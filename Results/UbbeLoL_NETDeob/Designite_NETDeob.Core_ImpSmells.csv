Implementation smell,Namespace,Class,File,Method,Description
Long Method,NETDeob.Core.Deobfuscators.Generic,Renamer,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Renamer.cs,RenameMembers,The method has 141 lines of code.
Long Method,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The method has 638 lines of code.
Long Method,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The method has 114 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 453 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 160 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The method has 125 lines of code.
Long Method,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The method has 130 lines of code.
Long Method,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The method has 172 lines of code.
Complex Method,NETDeob.Core.Deobfuscators.Generic,Renamer,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Renamer.cs,RenameMembers,Cyclomatic complexity of the method is 31
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 15
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 21
Complex Method,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,Cyclomatic complexity of the method is 10
Complex Method,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,Cyclomatic complexity of the method is 12
Complex Method,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,Cyclomatic complexity of the method is 10
Complex Method,NETDeob.Core.Deobfuscators.Obsolete.CodeWall.Tasks,StubDumper2,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StubDumper2.cs,Phase1,Cyclomatic complexity of the method is 8
Complex Method,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase2,Cyclomatic complexity of the method is 8
Complex Method,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase4,Cyclomatic complexity of the method is 14
Complex Method,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,DoAntiProxy,Cyclomatic complexity of the method is 9
Complex Method,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,Cyclomatic complexity of the method is 15
Complex Method,NETDeob.Core.Deobfuscators.Generic.Obsolete,MethodCleaner,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\MethodCleaner.cs,Phase2,Cyclomatic complexity of the method is 9
Long Parameter List,NETDeob.Core.Engine.Utils,Snapshot,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,Snapshot,The method has 5 parameters. Parameters: clonedStack' clonedLocals' currentInstruction' body' previous
Long Parameter List,SevenZip,ICoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The method has 6 parameters. Parameters: outBuf' outIndex' outLen' inBuf' inIndex' inLen
Long Parameter List,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The method has 6 parameters. Parameters: instr' instrList' stack' locals' markings' idx
Long Identifier,NETDeob.Core,DeobfuscatorOptions,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscator.cs,,The length of the parameter PreferPluginsOverBuiltinIdentifiers is 35.
Long Identifier,SevenZip.Compression.LZMA,Base,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,NETDeob.Core.Engine.Utils,Logger,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Logger.cs,VSLog,The length of the statement  "            if (Globals.DeobContext.Output == DeobfuscatorContext.OutputType.Subtle || Globals.DeobContext.Output == DeobfuscatorContext.OutputType.Verbose) " is 144.
Long Statement,NETDeob.Core.Engine.Utils,SignatureFinder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\SignatureFinder.cs,IsMatch,The length of the statement  "            if (mDef.Body.Instructions.Count <= (signature.StartIndex > 0 ? signature.StartIndex : -signature.StartIndex) + signature.Instructions.Count) " is 141.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 125.
Long Statement,NETDeob.Core.Deobfuscators.Manco.Tasks,CFlowCleaner,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\CFlowCleaner.cs,YieldBadBranches,The length of the statement  "                foreach (var fLoad in mDef.Body.Instructions.Where(i => i.OpCode == OpCodes.Ldsfld && (i.Operand as FieldReference).Resolve().DeclaringType == targetType)) " is 155.
Long Statement,NETDeob.Core.Deobfuscators.Manco.Tasks,CFlowCleaner,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\CFlowCleaner.cs,RemoveBranch,The length of the statement  "            mDef.Body.GetILProcessor().RemoveBlock(instr' instr.Next.Operand as Instruction); // load bool (ldsfld) -> branch target " is 120.
Long Statement,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The length of the statement  "            foreach (var mDef in from modDef in AsmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef) " is 140.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDump,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDump.cs,Phase1,The length of the statement  "                ctor.Body.Instructions.FirstOrDefault(i => i.OpCode == OpCodes.Call && IsBadMethod((i.Operand as MethodReference).Resolve())); " is 126.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDump,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDump.cs,IsBadMethod,The length of the statement  "            if (mDef.Body.Instructions[0].OpCode != OpCodes.Ldtoken && (mDef.Body.Instructions[0].Operand as TypeReference).Resolve() == mDef.DeclaringType) " is 144.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase3,The length of the statement  "                PT.InitProxyType(Params.ResolveFieldMD.MetadataToken.ToInt32()' Params.ResolveMethodMD.MetadataToken.ToInt32()' Params.asmReflection); " is 134.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase4,The length of the statement  "                    AsmDef.MainModule.Types[i].Methods[j].Name = String.Format("M_{0}_{1}"' j' AsmDef.MainModule.Types[i].Methods[j].ReturnType.Name); " is 130.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase4,The length of the statement  "                        AsmDef.MainModule.Types[i].Methods[j].Parameters[x].Name = String.Format("Arg_{0}_{1}"' x' AsmDef.MainModule.Types[i].Methods[j].Parameters[x].ParameterType.Name); " is 163.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,DoAntiProxy,The length of the statement  "                            MethodReference MR2 = AsmDef.MainModule.Import(Params.asmReflection.GetModules()[0].ResolveMethod(TokenOfOriginalCall2)); " is 121.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The length of the statement  "                    Int32 TokenOfCurrentInstruction = ((MethodDefinition)this.CCTor.Body.Instructions[(i * 2) + 1].Operand).MetadataToken.ToInt32(); " is 128.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The length of the statement  "                    this.arProxyTypeDelegate[i] = (TokenOfCurrentInstruction == TokenResolveField) ? ProxyTypeDelegate.NewObjectCall : ProxyTypeDelegate.DirectMethodCall; " is 150.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The length of the statement  "            using (var stream2 = new CryptoStream(new MemoryStream(buf)' new RijndaelManaged().CreateDecryptor(buf2' buf1)' CryptoStreamMode.Read)){ " is 136.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks.Common,WatermarkRemover,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\Common\WatermarkRemover.cs,Phase1,The length of the statement  "            MarkMember(AsmDef.MainModule.CustomAttributes.FirstOrDefault(attrib => attrib.AttributeType.Name == "ConfusedByAttribute")' AsmDef.MainModule); " is 143.
Long Statement,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The length of the statement  "                    markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return; " is 120.
Long Statement,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The length of the statement  "                    markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return; " is 120.
Long Statement,NETDeob.Core.Deobfuscators.Obfusasm,ObfusasmDeobfuscator,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\ObfusasmDeobfuscator.cs,CreateTaskQueue,The length of the statement  "            TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(false) { Methods = true' Fields = true' Properties = true' Parameters = true' Events = true' Delegates = true})); " is 166.
Long Statement,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,Phase1,The length of the statement  "            _staticKey = (cctor.Body.Instructions.FirstOrDefault(op => op.OpCode == OpCodes.Ldtoken).Operand as FieldReference).Resolve().InitialValue; " is 139.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,AssemblyDefinitionExt,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\AssemblyDefinition.cs,FindResource,The length of the statement  "            return (from modDef in asmDef.Modules from res in modDef.Resources where pred(res) select res as EmbeddedResource).FirstOrDefault(); " is 132.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,AssemblyDefinitionExt,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\AssemblyDefinition.cs,FindMethod,The length of the statement  "            return (from modDef in asmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef).FirstOrDefault(mDef => pred(mDef)); " is 163.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,MethodDefinitionExt,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\MethodDefinition.cs,HasDelegateReference,The length of the statement  "            return mDef.Body.Instructions.Where(instr => instr.OpCode == OpCodes.Newobj).FirstOrDefault(instr => instr.Operand == Delegate); " is 128.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,MiscExt,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\Misc.cs,IsNumeric,The length of the statement  "            return val is int || val is long || val is sbyte || val is short || val is ushort || val is ulong || val is uint || val is byte || val is double || val is decimal || val is float; " is 179.
Long Statement,NETDeob.Core.Misc,AssemblyUtils,C:\repos\UbbeLoL_NETDeob\NETDeob\Misc\AssemblyUtils.cs,FindMethodReferences,The length of the statement  "                foreach (var instr in mDef.Body.Instructions.Where(i => i.IsCall()).Where(instr => (instr.Operand as MethodReference).Resolve() == target)) " is 139.
Long Statement,NETDeob.Core.Unpackers.Mpress.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Mpress\Tasks\Unpacker.cs,Phase1,The length of the statement  "            _offset = (int)Convert.ChangeType(target.Body.Instructions.First(instr => instr.IsLdcI4WOperand()).Operand' typeof(Int32)); " is 123.
Long Statement,NETDeob.Core.Unpackers.Rpx.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Rpx\Tasks\Unpacker.cs,Phase2,The length of the statement  "                //                                                    Globals.DeobContext.InPath.LastIndexOf("\\"' StringComparison.Ordinal) + 1)))); " is 133.
Long Statement,NETDeob.Core.Unpackers.Rpx.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Rpx\Tasks\Unpacker.cs,GetResourceData,The length of the statement  "                    Logger.VSLog(string.Concat("Found compressed assembly; "' res.Name' " ("' (res as EmbeddedResource).GetResourceData().Length'") bytes...")); " is 140.
Long Statement,NETDeob.Misc.Structs__Enums___Interfaces,AssemblyWorker,C:\repos\UbbeLoL_NETDeob\NETDeob\Misc\Structs, Enums & Interfaces\Deobfuscation\AssemblyWorker.cs,Deobfuscate,The length of the statement  "            Logger.VSLog(string.Format("\n----------------------------\nSuccessfully deobfuscated assembly: {0} in {1} milliseconds"' AsmDef.Name.ToString().Split(''')[0]' (DateTime.Now - _startTime).Milliseconds)); " is 203.
Complex Conditional,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The conditional expression  "mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7"  is complex.
Complex Conditional,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The conditional expression  "mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2"  is complex.
Virtual Method Call from Constructor,NETDeob.Misc.Structs__Enums___Interfaces,AssemblyWorker,C:\repos\UbbeLoL_NETDeob\NETDeob\Misc\Structs, Enums & Interfaces\Deobfuscation\AssemblyWorker.cs,AssemblyWorker,The constructor "AssemblyWorker" calls a virtual method "CreateTaskQueue".
Empty Catch Block,NETDeob.Core.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver2,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ProxyResolver2.cs,ResolveMethod,The method has an empty catch block.
Empty Catch Block,NETDeob.Core.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver2,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ProxyResolver2.cs,ResolveMethod,The method has an empty catch block.
Empty Catch Block,NETDeob.Core.Deobfuscators.Generic,MetadataFixer,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\MetadataFixer.cs,AnalyzeTypeDefs,The method has an empty catch block.
Magic Number,NETDeob.Core.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver2,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ProxyResolver2.cs,Phase1,The following statement contains a magic number: Logger.VSLog("Located proxy resolver method at " + resolver.Name.Truncate(10));
Magic Number,NETDeob.Core.Deobfuscators.Generic,MetadataFixer,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\MetadataFixer.cs,AnalyzeResources,The following statement contains a magic number: foreach (var res in AsmDef.MainModule.Resources)              {                  var resStream = (res as EmbeddedResource).GetResourceStream();                  if (resStream.Length != 0 && res.Name.Length <= 1000) continue;                    Console.WriteLine("Found invalid resource...");                  yield return res;              }
Magic Number,NETDeob.Core.Deobfuscators.Generic,MetadataFixer,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\MetadataFixer.cs,AnalyzeTypeDefs,The following statement contains a magic number: foreach (var typeDef in AsmDef.MainModule.Types)              {                  try                  {                      foreach (var gParam in typeDef.GenericParameters)                          if (gParam.Attributes == (GenericParameterAttributes)0xffff)                              MarkMember(gParam);                  }                  catch {}                    if (typeDef.Name.Length >= 1000)                      yield return typeDef;              }
Magic Number,NETDeob.Core.Deobfuscators.Generic,GenericDecryptionContext,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\GenericStringDecryptor.cs,FetchParameters,The following statement contains a magic number: var st = new StackTracer(Source.Body' 1000);
Magic Number,NETDeob.Core.Deobfuscators.Generic,AssemblyStripper,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\AssemblyStripper.cs,RemoveMembers,The following statement contains a magic number: try              {                  foreach (var member in Globals.DeobContext.MarkedMembers)                  {                      switch (member.Type)                      {                          case DeobfuscatorContext.MemberType.Type:                              Logger.VLog("[Remove(Type)] " + (member.Member as TypeDefinition).Name.Truncate(10));                              AsmDef.MainModule.Types.Remove(member.Member as TypeDefinition);                              break;                            case DeobfuscatorContext.MemberType.Method:                              Logger.VLog("[Remove(Method)] " + (member.Member as MethodDefinition).Name);                              (member.Member as MethodDefinition).DeclaringType.Methods.Remove(                                  member.Member as MethodDefinition);                              break;                            case DeobfuscatorContext.MemberType.Field:                              Logger.VLog("[Remove(Field)] " + (member.Member as FieldDefinition).Name);                              (member.Member as FieldDefinition).DeclaringType.Fields.Remove(                                  member.Member as FieldDefinition);                              break;                            case DeobfuscatorContext.MemberType.Property:                              Logger.VLog("[Remove(Property)] " + (member.Member as PropertyDefinition).Name);                              (member.Member as PropertyDefinition).DeclaringType.Properties.Remove(                                  member.Member as PropertyDefinition);                              break;                            case DeobfuscatorContext.MemberType.Resource:                              Logger.VLog("[Remove(Resource)] " +                                          ((member.Member as EmbeddedResource).Name.Truncate(10)));                              AsmDef.MainModule.Resources.Remove(member.Member as EmbeddedResource);                              break;                            case DeobfuscatorContext.MemberType.Attribute:                              Logger.VLog("[Remove(Attribute)] " + (member.Member as CustomAttribute).AttributeType.Name);                              (member.ParentMember as ModuleDefinition).CustomAttributes.Remove(                                  member.Member as CustomAttribute);                              break;                            case DeobfuscatorContext.MemberType.Instruction:                              Logger.VLog("[Remove(Instruction)] " + (member.Member as Instruction).OpCode);                              (member.ParentMember as MethodDefinition).Body.Instructions.Remove(                                  member.Member as Instruction);                              break;                            case DeobfuscatorContext.MemberType.AssemblyReference:                              Logger.VLog("[Remove(AssemblyReference)] " + (member.Member as AssemblyNameReference).MetadataToken.ToInt32());                              AsmDef.MainModule.AssemblyReferences.Remove(member.Member as AssemblyNameReference);                              break;                      }                        tmp = member;                  }              }              catch (Exception e)              {                  if (tmp == null)                      return true;                    ThrowPhaseError("Failed to clean up member!"' 0' false);              }
Magic Number,NETDeob.Core.Deobfuscators.Generic,AssemblyStripper,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\AssemblyStripper.cs,RemoveMembers,The following statement contains a magic number: try              {                  foreach (var member in Globals.DeobContext.MarkedMembers)                  {                      switch (member.Type)                      {                          case DeobfuscatorContext.MemberType.Type:                              Logger.VLog("[Remove(Type)] " + (member.Member as TypeDefinition).Name.Truncate(10));                              AsmDef.MainModule.Types.Remove(member.Member as TypeDefinition);                              break;                            case DeobfuscatorContext.MemberType.Method:                              Logger.VLog("[Remove(Method)] " + (member.Member as MethodDefinition).Name);                              (member.Member as MethodDefinition).DeclaringType.Methods.Remove(                                  member.Member as MethodDefinition);                              break;                            case DeobfuscatorContext.MemberType.Field:                              Logger.VLog("[Remove(Field)] " + (member.Member as FieldDefinition).Name);                              (member.Member as FieldDefinition).DeclaringType.Fields.Remove(                                  member.Member as FieldDefinition);                              break;                            case DeobfuscatorContext.MemberType.Property:                              Logger.VLog("[Remove(Property)] " + (member.Member as PropertyDefinition).Name);                              (member.Member as PropertyDefinition).DeclaringType.Properties.Remove(                                  member.Member as PropertyDefinition);                              break;                            case DeobfuscatorContext.MemberType.Resource:                              Logger.VLog("[Remove(Resource)] " +                                          ((member.Member as EmbeddedResource).Name.Truncate(10)));                              AsmDef.MainModule.Resources.Remove(member.Member as EmbeddedResource);                              break;                            case DeobfuscatorContext.MemberType.Attribute:                              Logger.VLog("[Remove(Attribute)] " + (member.Member as CustomAttribute).AttributeType.Name);                              (member.ParentMember as ModuleDefinition).CustomAttributes.Remove(                                  member.Member as CustomAttribute);                              break;                            case DeobfuscatorContext.MemberType.Instruction:                              Logger.VLog("[Remove(Instruction)] " + (member.Member as Instruction).OpCode);                              (member.ParentMember as MethodDefinition).Body.Instructions.Remove(                                  member.Member as Instruction);                              break;                            case DeobfuscatorContext.MemberType.AssemblyReference:                              Logger.VLog("[Remove(AssemblyReference)] " + (member.Member as AssemblyNameReference).MetadataToken.ToInt32());                              AsmDef.MainModule.AssemblyReferences.Remove(member.Member as AssemblyNameReference);                              break;                      }                        tmp = member;                  }              }              catch (Exception e)              {                  if (tmp == null)                      return true;                    ThrowPhaseError("Failed to clean up member!"' 0' false);              }
Magic Number,NETDeob.Core.Engine.Utils,BugReporter,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Bugster.cs,DoRequest,The following statement contains a magic number: request.Timeout = 10 * 1000;
Magic Number,NETDeob.Core.Engine.Utils,BugReporter,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Bugster.cs,DoRequest,The following statement contains a magic number: request.Timeout = 10 * 1000;
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: foreach (var mDef in asmDef.FindMethods(m => m.HasBody))              {                  if (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_0();                  }                    if(mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_1();                  }              }
Magic Number,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: foreach (var mDef in asmDef.FindMethods(m => m.HasBody))              {                  if (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_0();                  }                    if(mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_1();                  }              }
Magic Number,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: foreach (var mDef in asmDef.FindMethods(m => m.HasBody))              {                  if (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_0();                  }                    if(mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_1();                  }              }
Magic Number,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: foreach (var mDef in asmDef.FindMethods(m => m.HasBody))              {                  if (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_0();                  }                    if(mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_1();                  }              }
Magic Number,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: foreach (var mDef in asmDef.FindMethods(m => m.HasBody))              {                  if (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_0();                  }                    if(mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_1();                  }              }
Magic Number,NETDeob.Core.Engine.Utils,Identifier,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: foreach (var mDef in asmDef.FindMethods(m => m.HasBody))              {                  if (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_0();                  }                    if(mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2)                  {                      found = true;                      return new Signatures.HurpFuscatorSignature1_1();                  }              }
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)  			{  				m_DictionarySize = dictionarySize;  				m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);  				uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));  				m_OutWindow.Create(blockSize);  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)  			{  				// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  					// while(nowPos64 < next)  				{  					uint posState = (uint)nowPos64 & m_PosStateMask;  					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  					{  						byte b;  						byte prevByte = m_OutWindow.GetByte(0);  						if (!state.IsCharState())  							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'  								(uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));  						else  							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);  						m_OutWindow.PutByte(b);  						state.UpdateChar();  						nowPos64++;  					}  					else  					{  						uint len;  						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)  						{  							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)  							{  								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  								{  									state.UpdateShortRep();  									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));  									nowPos64++;  									continue;  								}  							}  							else  							{  								UInt32 distance;  								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)  								{  									distance = rep1;  								}  								else  								{  									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)  										distance = rep2;  									else  									{  										distance = rep3;  										rep3 = rep2;  									}  									rep2 = rep1;  								}  								rep1 = rep0;  								rep0 = distance;  							}  							len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;  							state.UpdateRep();  						}  						else  						{  							rep3 = rep2;  							rep2 = rep1;  							rep1 = rep0;  							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);  							state.UpdateMatch();  							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);  							if (posSlot >= Base.kStartPosModelIndex)  							{  								int numDirectBits = (int)((posSlot >> 1) - 1);  								rep0 = ((2 | (posSlot & 1)) << numDirectBits);  								if (posSlot < Base.kEndPosModelIndex)  									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'  											rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  								else  								{  									rep0 += (m_RangeDecoder.DecodeDirectBits(  										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);  								}  							}  							else  								rep0 = posSlot;  						}  						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)  						{  							if (rep0 == 0xFFFFFFFF)  								break;  							throw new DataErrorException();  						}  						m_OutWindow.CopyBlock(rep0' len);  						nowPos64 += len;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,LiteralDecoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)  			{  				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  				for (UInt32 j = 0; j < k; j++' c++)  					g_FastPos[c] = slotFast;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  				return g_FastPos[pos];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)  			{  				lenRes = _matchDistances[numDistancePairs - 2];  				if (lenRes == _numFastBytes)  					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'  						Base.kMatchMaxLen - lenRes);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)  			{  				price = _isRepG0[state.Index].GetPrice0();  				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  			}  			else  			{  				price = _isRepG0[state.Index].GetPrice1();  				if (repIndex == 1)  					price += _isRepG1[state.Index].GetPrice0();  				else  				{  					price += _isRepG1[state.Index].GetPrice1();  					price += _isRepG2[state.Index].GetPrice(repIndex - 2);  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)  			{  				backRes = 0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if(lenEnd < 2)  			{  				backRes = _optimum[1].BackPrev;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  				_optimum[len--].Price = kIfinityPrice;  			while (len >= 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++)  			{   				UInt32 posSlot = GetPosSlot(i);  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders'   					baseVal - posSlot - 1' footerBits' i - baseVal);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,LiteralEncoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						m_Encoders[context].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: if (matchMode)  					{  						for (; i >= 0; i--)  						{  							uint matchBit = (uint)(matchByte >> i) & 1;  							uint bit = (uint)(symbol >> i) & 1;  							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);  							context = (context << 1) | bit;  							if (matchBit != bit)  							{  								i--;  								break;  							}  						}  					}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  				throw new Exception();
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				ShiftLow();
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)  			{  				Range >>= 1;  				if (((v >> i) & 1) == 1)  					Low += Range;  				if (Range < kTopValue)  				{  					Range <<= 8;  					ShiftLow();  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  				Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue)  			{  				encoder.Range <<= 8;  				encoder.ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_U4,The following statement contains a magic number: return (_n_ ^= 1) != 0 ? (uint)(_p_[_i_] & 0xF) : (uint)(_p_[_i_++] >> 4);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_) != 0 ? ((_p_[_i_] >> 4) | (_p_[_i_ + 1] << 4)) : _p_[_i_]));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_) != 0 ? ((_p_[_i_] >> 4) | (_p_[_i_ + 1] << 4)) : _p_[_i_]));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_) != 0 ? ((_p_[_i_] >> 4) | ((ushort)(GET_LE16(_p_' _i_ + 1)) << 4)) : GET_LE16(_p_' _i_));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_) != 0 ? ((_p_[_i_] >> 4) | ((ushort)(GET_LE16(_p_' _i_ + 1)) << 4)) : GET_LE16(_p_' _i_));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib); )              {                  int bc;                  byte tag;                  tag = LZMAT_GET_U8(pbIn' inPos' cur_nib);                  inPos++;                  for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0) // gamma                      {                          uint r_pos' r_cnt' dist;                          //#define cflag r_cnt                          r_cnt = LZMAT_GET_LE16(pbIn' inPos' cur_nib);                          inPos++;                          if (outPos > MAX_LZMAT_SHORT_DIST1)                          {                              dist = r_cnt >> 2;                              switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }                          }                          else                          {                              dist = r_cnt >> 1;                              if ((r_cnt & 1) != 0)                              {                                  inPos += cur_nib;                                  dist = (dist & 0x7FF) + 0x81;                                  cur_nib ^= 1;                              }                              else                                  dist = (dist & 0x7F) + 1;                          }                          //#undef cflag                          r_cnt = LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib);                          if (r_cnt != 0xF)                          {                              r_cnt += 3;                          }                          else                          {                              if ((inPos + 1 + cur_nib) > cbIn)                                  return LzmatStatus.INTEGRITY_FAILURE + 2;                              r_cnt = LZMAT_GET_U8(pbIn' inPos' cur_nib);                              inPos++;                              if (r_cnt != 0xFF)                              {                                  r_cnt += LZMAT_DEFAULT_CNT;                              }                              else                              {                                  if ((inPos + 2 + cur_nib) > cbIn)                                      return LzmatStatus.INTEGRITY_FAILURE + 3;                                  r_cnt = (uint)(LZMAT_GET_LE16(pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);                                  inPos += 2;                                  if (r_cnt == LZMAT_2BYTE_CNT)                                  {                                      // copy chunk                                      if (cur_nib != 0)                                      {                                          r_cnt = ((uint)pbIn[inPos - 4] & 0xFC) << 5;                                          inPos++;                                          cur_nib = 0;                                      }                                      else                                      {                                          r_cnt = (uint)((GET_LE16(pbIn' inPos - 5) & 0xFC0) << 1);                                      }                                      r_cnt += (uint)((tag & 0x7F) + 4);                                      r_cnt <<= 1;                                      if ((outPos + (r_cnt << 2)) > cbOutBuf)                                          return LzmatStatus.BUFFER_TOO_SMALL;                                      while (r_cnt-- != 0 && outPos < cbOutBuf)                                      {                                          pbOut[outPos] = pbIn[inPos];                                          pbOut[outPos + 1] = pbIn[inPos + 1];                                          pbOut[outPos + 2] = pbIn[inPos + 2];                                          pbOut[outPos + 3] = pbIn[inPos + 3];                                          inPos += 4;                                          outPos += 4;                                      }                                      break;                                  }                              }                          }                          if (outPos < dist)                              return LzmatStatus.INTEGRITY_FAILURE + 4;                          if ((outPos + r_cnt) > cbOutBuf)                              return LzmatStatus.BUFFER_TOO_SMALL + 1;                          r_pos = outPos - dist;                          while (r_cnt-- != 0 && outPos < cbOutBuf)                              pbOut[outPos++] = pbOut[r_pos++];                      }                      else                      {                          pbOut[outPos++] = LZMAT_GET_U8(pbIn' inPos' cur_nib);                          inPos++;                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int srcIndex = 3;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: while (dstIndex < decompressedLen)              {                  int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);                  if (partLen < 0x800000)                  {                      Array.Copy(compressed' srcIndex' decompressed' dstIndex' partLen);                      srcIndex += partLen;                      dstIndex += partLen;                  }                  else                  {                      partLen &= 0x7FFFFF;                      int decompressedLen2 = lzmat_old(decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);                      if (decompressedLen2 == 0)                          return null;                      dstIndex += decompressedLen2;                      srcIndex += partLen;                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: while (dstIndex < decompressedLen)              {                  int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);                  if (partLen < 0x800000)                  {                      Array.Copy(compressed' srcIndex' decompressed' dstIndex' partLen);                      srcIndex += partLen;                      dstIndex += partLen;                  }                  else                  {                      partLen &= 0x7FFFFF;                      int decompressedLen2 = lzmat_old(decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);                      if (decompressedLen2 == 0)                          return null;                      dstIndex += decompressedLen2;                      srcIndex += partLen;                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen)              {                  byte tag = inBuf[inIndex + inPos++];                  for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1)                  {                      if ((tag & 0x80) != 0)                      {                          ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);                          inPos++;                          int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;                          if (outPosDispl == 0)                              outPosDispl = 0x1000;                          if (outPosDispl > outPos)                              return 0;                          if (r_cnt == 18)                          {                              if (inPos >= inLen)                                  return 0;                              r_cnt = inBuf[inIndex + inPos++] + 18;                          }                          if (r_cnt == 0x111)                          {                              if (inPos + 2 > inLen)                                  return 0;                              r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;                              inPos += 2;                          }                          int outPos2 = outPos - outPosDispl;                          while (r_cnt-- > 0 && outPos < outLen)                              outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];                      }                      else                          outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];                  }              }
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: var managed2 = new RijndaelManaged              {                  BlockSize = 256'                  Padding = PaddingMode.PKCS7              };
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: var destinationArray = new byte[8];
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: Array.Copy(provider2.ComputeHash(Encoding.ASCII.GetBytes((entry as HurpFuscatorEntry).Arg2))' 0'                         destinationArray' 0' 8);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,ProcessEntry,The following statement contains a magic number: MarkMember(_entry.BadInstructions[2]' _entry.Source);
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,CFlowCleaner,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\CFlowCleaner.cs,IsBoolInitializer,The following statement contains a magic number: if (cctor.Body.Instructions.Count >= 4)                  return false;
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,MancoContext,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,ToString,The following statement contains a magic number: return string.Format(@"[Decrypt] ""{0}"" -> ""{1}"""' OrigString.Truncate(10)' PlainText);
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,Phase1,The following statement contains a magic number: Logger.VSLog("Found decryptor method at " + _decryptor.Name.Truncate(5));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if (strAlgo == Algorithm.Plain)                  if (paramStr != string.Empty)                  {                      int num2;                      int length = (paramStr.Length/2) + (paramStr.Length%2);                      string str = paramStr.Substring(0' length);                      string str2 = paramStr.Substring(length);                      StringBuilder builder = new StringBuilder(paramStr.Length);                      char[] chArray = new char[str.Length];                      char[] chArray2 = new char[str2.Length];                      bool flag = (str.Length%2) == 0;                      for (num2 = 0; num2 < str.Length; num2 += 2)                      {                          chArray[num2/2] = str[num2];                          if ((num2 < (str.Length - 1)) || flag)                          {                              chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];                          }                      }                      flag = (str2.Length%2) == 0;                      for (num2 = 0; num2 < str2.Length; num2 += 2)                      {                          chArray2[num2/2] = str2[num2];                          if ((num2 < (str2.Length - 1)) || flag)                          {                              chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];                          }                      }                      flag = str.Length == str2.Length;                      for (num2 = 0; num2 < str.Length; num2++)                      {                          builder.Append(chArray[num2]);                          if ((num2 < (str.Length - 1)) || flag)                          {                              builder.Append(chArray2[num2]);                          }                      }                      return builder.ToString();                  }
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,CreateAlgo,The following statement contains a magic number: algorithm.IV = encoding.GetBytes(paramStr.Substring(0' (strAlgo == Algorithm.Rijndael ? 0x10 : 8)));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,CreateAlgo,The following statement contains a magic number: algorithm.Key = encoding.GetBytes(paramStr.Substring((strAlgo == Algorithm.Rijndael ? 0x10 : 8)));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,ExtractDecryptor,The following statement contains a magic number: var decryptor =                  mTarget.DeclaringType.Methods.FirstOrDefault(                      m => m.Parameters.Count == 4 && m.ReturnType.ToString().Contains("String"));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,ExtractDecryptor,The following statement contains a magic number: if (decryptor.Body.Variables.Count != 10)                  strAlgo = (Algorithm)mTarget.Body.Instructions.First(i => i.IsLdcI4()).GetLdcI4();              else                  strAlgo = Algorithm.Plain;
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,BaseIsDecryptor,The following statement contains a magic number: var decryptor =                  mTarget.DeclaringType.Methods.FirstOrDefault(                      m => m.Parameters.Count == 4 && m.ReturnType.ToString().Contains("String"));
Magic Number,NETDeob.Deobfuscators.CodeWall,CodeWallDeobfuscator,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\CodeWallDeobfuscator.cs,IsAssemblyEncrypted,The following statement contains a magic number: return target.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 5 &&                     target.Body.Instructions.GetOpCodeCount(OpCodes.Call) == 7;
Magic Number,NETDeob.Deobfuscators.CodeWall,CodeWallDeobfuscator,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\CodeWallDeobfuscator.cs,IsAssemblyEncrypted,The following statement contains a magic number: return target.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 5 &&                     target.Body.Instructions.GetOpCodeCount(OpCodes.Call) == 7;
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: foreach (var mDef in from modDef in AsmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef)              {                  var decryptors = (List<MethodDefinition>)PhaseParam;                   // //mDef.Body.SimplifyMacros();                    for (var i = 0; i < mDef.Body.Instructions.Count; i++)                  {                      if (mDef.Body.Instructions[i].OpCode == OpCodes.Call)                          if (decryptors.Contains(mDef.Body.Instructions[i].Operand))                          {                              var tmpEntry = new CodewallEntry                                                 {                                                     Instructions = new List<Instruction>()'                                                     DecryptionMethod =                                                         decryptors.First(                                                             method => method == mDef.Body.Instructions[i].Operand)                                                 };                                var decModifiers = FindDecryptionModifiers(tmpEntry.DecryptionMethod);                                tmpEntry.Modifier1 = decModifiers[0];                              tmpEntry.Modifier2 = decModifiers[1];                              tmpEntry.Modifier3 = decModifiers[2];                              tmpEntry.Key1 = (Int32)mDef.Body.Instructions[i].Previous.Previous.Previous.Operand;                              tmpEntry.Key2 = (Int32)mDef.Body.Instructions[i].Previous.Previous.Operand;                              tmpEntry.Key3 = (Int32)mDef.Body.Instructions[i].Previous.Operand;                                tmpEntry.SourceMethod = mDef;                                i -= 4;                                tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                                tmpEntry.InsertIndex = i;                                decryptedStrings.Add(tmpEntry);                                i += 4;                          }                  }                   // //mDef.Body.OptimizeMacros();              }
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: foreach (var mDef in from modDef in AsmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef)              {                  var decryptors = (List<MethodDefinition>)PhaseParam;                   // //mDef.Body.SimplifyMacros();                    for (var i = 0; i < mDef.Body.Instructions.Count; i++)                  {                      if (mDef.Body.Instructions[i].OpCode == OpCodes.Call)                          if (decryptors.Contains(mDef.Body.Instructions[i].Operand))                          {                              var tmpEntry = new CodewallEntry                                                 {                                                     Instructions = new List<Instruction>()'                                                     DecryptionMethod =                                                         decryptors.First(                                                             method => method == mDef.Body.Instructions[i].Operand)                                                 };                                var decModifiers = FindDecryptionModifiers(tmpEntry.DecryptionMethod);                                tmpEntry.Modifier1 = decModifiers[0];                              tmpEntry.Modifier2 = decModifiers[1];                              tmpEntry.Modifier3 = decModifiers[2];                              tmpEntry.Key1 = (Int32)mDef.Body.Instructions[i].Previous.Previous.Previous.Operand;                              tmpEntry.Key2 = (Int32)mDef.Body.Instructions[i].Previous.Previous.Operand;                              tmpEntry.Key3 = (Int32)mDef.Body.Instructions[i].Previous.Operand;                                tmpEntry.SourceMethod = mDef;                                i -= 4;                                tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                                tmpEntry.InsertIndex = i;                                decryptedStrings.Add(tmpEntry);                                i += 4;                          }                  }                   // //mDef.Body.OptimizeMacros();              }
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: foreach (var mDef in from modDef in AsmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef)              {                  var decryptors = (List<MethodDefinition>)PhaseParam;                   // //mDef.Body.SimplifyMacros();                    for (var i = 0; i < mDef.Body.Instructions.Count; i++)                  {                      if (mDef.Body.Instructions[i].OpCode == OpCodes.Call)                          if (decryptors.Contains(mDef.Body.Instructions[i].Operand))                          {                              var tmpEntry = new CodewallEntry                                                 {                                                     Instructions = new List<Instruction>()'                                                     DecryptionMethod =                                                         decryptors.First(                                                             method => method == mDef.Body.Instructions[i].Operand)                                                 };                                var decModifiers = FindDecryptionModifiers(tmpEntry.DecryptionMethod);                                tmpEntry.Modifier1 = decModifiers[0];                              tmpEntry.Modifier2 = decModifiers[1];                              tmpEntry.Modifier3 = decModifiers[2];                              tmpEntry.Key1 = (Int32)mDef.Body.Instructions[i].Previous.Previous.Previous.Operand;                              tmpEntry.Key2 = (Int32)mDef.Body.Instructions[i].Previous.Previous.Operand;                              tmpEntry.Key3 = (Int32)mDef.Body.Instructions[i].Previous.Operand;                                tmpEntry.SourceMethod = mDef;                                i -= 4;                                tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                              tmpEntry.Instructions.Add(mDef.Body.Instructions[++i]);                                tmpEntry.InsertIndex = i;                                decryptedStrings.Add(tmpEntry);                                i += 4;                          }                  }                   // //mDef.Body.OptimizeMacros();              }
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptors,The following statement contains a magic number: return                  AsmDef.FindMethods(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 6 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 3).ToList();
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptors,The following statement contains a magic number: return                  AsmDef.FindMethods(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 6 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 3).ToList();
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindStringResource,The following statement contains a magic number: while(count < body.Instructions.Count)              {                  if (body.Instructions[count].OpCode == OpCodes.Ldstr)                      if((body.Instructions[count].Operand as string).Length == 32)                          return body.Instructions[count].Operand as string;                  count++;              }
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptionModifiers,The following statement contains a magic number: var decModifiers = new int[3];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptionModifiers,The following statement contains a magic number: foreach (Instruction t in target.Body.Instructions)              {                  if (t.OpCode == OpCodes.Xor)                      tmp++;                    if (t.OpCode == OpCodes.Xor && tmp == 1)                      decModifiers[0] = (Int32)t.Previous.Operand;                    if (t.OpCode == OpCodes.Xor && tmp == 4)                      decModifiers[1] = (Int32)t.Previous.Operand;                    else if (t.OpCode == OpCodes.Xor && tmp == 5)                      decModifiers[2] = (Int32)t.Previous.Operand;              }
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptionModifiers,The following statement contains a magic number: foreach (Instruction t in target.Body.Instructions)              {                  if (t.OpCode == OpCodes.Xor)                      tmp++;                    if (t.OpCode == OpCodes.Xor && tmp == 1)                      decModifiers[0] = (Int32)t.Previous.Operand;                    if (t.OpCode == OpCodes.Xor && tmp == 4)                      decModifiers[1] = (Int32)t.Previous.Operand;                    else if (t.OpCode == OpCodes.Xor && tmp == 5)                      decModifiers[2] = (Int32)t.Previous.Operand;              }
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptionModifiers,The following statement contains a magic number: foreach (Instruction t in target.Body.Instructions)              {                  if (t.OpCode == OpCodes.Xor)                      tmp++;                    if (t.OpCode == OpCodes.Xor && tmp == 1)                      decModifiers[0] = (Int32)t.Previous.Operand;                    if (t.OpCode == OpCodes.Xor && tmp == 4)                      decModifiers[1] = (Int32)t.Previous.Operand;                    else if (t.OpCode == OpCodes.Xor && tmp == 5)                      decModifiers[2] = (Int32)t.Previous.Operand;              }
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: var key3 = decKey[2] ^ decModifiers[2];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: var key3 = decKey[2] ^ decModifiers[2];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if(publicKeyToken.Length == 8)                  key2 ^= BitConverter.ToInt32(publicKeyToken' 0) ^ BitConverter.ToInt32(publicKeyToken' 4);              else                  key2 ^= decModifiers[1];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: if(publicKeyToken.Length == 8)                  key2 ^= BitConverter.ToInt32(publicKeyToken' 0) ^ BitConverter.ToInt32(publicKeyToken' 4);              else                  key2 ^= decModifiers[1];
Magic Number,NETDeob.Core.Deobfuscators.Obsolete.CodeWall.Tasks,StubDumper2,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StubDumper2.cs,Phase1,The following statement contains a magic number: foreach(var instr in target.Body.Instructions)                  if (instr.OpCode == OpCodes.Call)                  {                      target = instr.Operand as MethodDefinition;                        if (target == null)                          continue;                        if (target.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 6 &&                          target.Body.Instructions.GetOpCodeCount(OpCodes.Call) == 5)                          break;                  }
Magic Number,NETDeob.Core.Deobfuscators.Obsolete.CodeWall.Tasks,StubDumper2,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StubDumper2.cs,Phase1,The following statement contains a magic number: foreach(var instr in target.Body.Instructions)                  if (instr.OpCode == OpCodes.Call)                  {                      target = instr.Operand as MethodDefinition;                        if (target == null)                          continue;                        if (target.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 6 &&                          target.Body.Instructions.GetOpCodeCount(OpCodes.Call) == 5)                          break;                  }
Magic Number,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following statement contains a magic number: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Magic Number,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following statement contains a magic number: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Magic Number,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following statement contains a magic number: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Magic Number,NETDeob.Deobfuscators.Confuser.Obsolete,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ConstantsDecryptor.cs,IsDecryptor,The following statement contains a magic number: if(mDef.HasParameters)                      if(mDef.Parameters.Count == 2)                          if (mDef.Parameters[0].ParameterType.Name == "UInt32" && mDef.Parameters[1].ParameterType.Name == "UInt64")                          {                              return true;                          }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDebug,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDebug.cs,Phase1,The following statement contains a magic number: if (ctorBody.Body.Instructions.Count == 2)                  MarkMember(ctorBody);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDump,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDump.cs,IsBadMethod,The following statement contains a magic number: if (mDef.Body.Variables.Count != 44)                  return false;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,BaseIsDecryptor,The following statement contains a magic number: if (mDef.Body.Variables.Count != 20)                  return false;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers = new int[4];
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[0] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 3);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[1] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 4);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[2] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 5);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[2] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 5);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[3] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 12);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[3] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 12);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: uint num5 = (uint)Modifiers[2];
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));                  uint num7 = (num3 & 255) % 64;                  if ((num7 >= 0) && (num7 < 16))                  {                      num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);                      num5 ^= ((num3 * i) + 1) % 16;                      num3 += (num4 | num5) ^ (uint)Modifiers[3];                  }                  else if ((num7 >= 16) && (num7 < 32))                  {                      num4 ^= ((num3 & 16711935) << 8) ^ (((num3 & 16776960) >> 8) | (~num3 & 65535));                      num5 += (num3 * i) % 32;                      num3 |= (num4 + ~num5) & (uint)Modifiers[3];                  }                  else if ((num7 >= 32) && (num7 < 48))                  {                      num4 += ((num3 & 255) | ((num3 & 16711680) >> 16)) + (~num3 & 255);                      num5 -= ~(num3 + num7) % 48;                      num3 ^= (num4 % num5) | (uint)Modifiers[3];                  }                  else if ((num7 >= 48) && (num7 < 64))                  {                      num4 ^= (((num3 & 16711680) >> 16) | ~(num3 & 255)) * (~num3 & 16711680);                      num5 += (num3 ^ (i - 1)) % num7;                      num3 -= ~(num4 ^ num5) + (uint)Modifiers[3];                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(new MemoryStream(_rawData)))              {                  reader.BaseStream.Seek(key' SeekOrigin.Begin);                    reader.ReadByte();                  var bytes = reader.ReadBytes(reader.ReadInt32());                    var random = new Random(Modifiers[3] ^ ((int)key));                  var buffer3 = new byte[bytes.Length];                    random.NextBytes(buffer3);                    BitArray array = new BitArray(bytes);                  array.Xor(new BitArray(buffer3));                  array.CopyTo(bytes' 0);                    entry.PlainText = Encoding.UTF8.GetString(bytes);              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,ProcessEntry,The following statement contains a magic number: ilProc.InsertAfter(badInstructions[2]' ilProc.Create(OpCodes.Ldstr' entry.PlainText));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,ConstructEntries,The following statement contains a magic number: foreach (var mDef in AsmDef.FindMethods(m => true).Where(mDef => !BaseIsDecryptor(mDef)))              {                  if (!mDef.HasBody)                      continue;                    for (var i = 0; i < mDef.Body.Instructions.Count; i++)                  {                      var instr = mDef.Body.Instructions[i];                        if (instr.Previous == null)                          continue;                        if (instr.OpCode != OpCodes.Call || instr.Previous.OpCode != OpCodes.Ldc_I4 ||                          !BaseIsDecryptor((instr.Operand as MethodReference).Resolve())) continue;                        var entry = new Confuser1_7Entry                      {                          Id = (int)instr.Previous.Operand'                          Caller = mDef'                          MDToken = mDef.MetadataToken.ToUInt32()'                          BadInstructions = mDef.Body.Instructions.GetInstructionBlock(i - 1' 3)'                      };                        yield return entry;                  }              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,GetTokenForMethodDecode,The following statement contains a magic number: CT = (array2[0] == 13) ? FunctionCallType.Callvirt : FunctionCallType.Call;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,ProxyType,The following statement contains a magic number: iNumberOfMembers = (CCTor.Body.Instructions.Count - 1) / 2;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The following statement contains a magic number: for (int i = 0; i < iNumberOfMembers; i++)                  {                      this.arFields[i] = (FieldDefinition)this.CCTor.Body.Instructions[i * 2].Operand;                      this.arFieldReflection[i] = asmReflection.GetModules()[0].ResolveField(arFields[i].MetadataToken.ToInt32());                  }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The following statement contains a magic number: for (int i = 0; i < iNumberOfMembers; i++)                  {                      Int32 TokenOfCurrentInstruction = ((MethodDefinition)this.CCTor.Body.Instructions[(i * 2) + 1].Operand).MetadataToken.ToInt32();                        this.arProxyTypeDelegate[i] = (TokenOfCurrentInstruction == TokenResolveField) ? ProxyTypeDelegate.NewObjectCall : ProxyTypeDelegate.DirectMethodCall;                  }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ResourceDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ResourceDecryptor.cs,Phase2,The following statement contains a magic number: var modifier = resolver.Body.Instructions.GetOperandAt<dynamic>(instr => instr.IsLdcI4()' 6);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ResourceDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ResourceDecryptor.cs,Phase2,The following statement contains a magic number: using(var br = new BinaryReader(new DeflateStream(streamRes' CompressionMode.Decompress)))              {                  byte[] buffer = br.ReadBytes(br.ReadInt32());                  byte[] buffer2 = new byte[buffer.Length / 2];                    for (int i = 0; i < buffer.Length; i += 2)                      buffer2[i / 2] = (byte)(((buffer[i + 1] ^ modifier) * modifier) + (buffer[i] ^ modifier));                    using(var br2 = new BinaryReader(new DeflateStream(new MemoryStream(buffer2)' CompressionMode.Decompress)))                      PhaseParam = Assembly.Load(br2.ReadBytes(br2.ReadInt32()));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ResourceDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ResourceDecryptor.cs,Phase2,The following statement contains a magic number: using(var br = new BinaryReader(new DeflateStream(streamRes' CompressionMode.Decompress)))              {                  byte[] buffer = br.ReadBytes(br.ReadInt32());                  byte[] buffer2 = new byte[buffer.Length / 2];                    for (int i = 0; i < buffer.Length; i += 2)                      buffer2[i / 2] = (byte)(((buffer[i + 1] ^ modifier) * modifier) + (buffer[i] ^ modifier));                    using(var br2 = new BinaryReader(new DeflateStream(new MemoryStream(buffer2)' CompressionMode.Decompress)))                      PhaseParam = Assembly.Load(br2.ReadBytes(br2.ReadInt32()));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ResourceDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ResourceDecryptor.cs,Phase2,The following statement contains a magic number: using(var br = new BinaryReader(new DeflateStream(streamRes' CompressionMode.Decompress)))              {                  byte[] buffer = br.ReadBytes(br.ReadInt32());                  byte[] buffer2 = new byte[buffer.Length / 2];                    for (int i = 0; i < buffer.Length; i += 2)                      buffer2[i / 2] = (byte)(((buffer[i + 1] ^ modifier) * modifier) + (buffer[i] ^ modifier));                    using(var br2 = new BinaryReader(new DeflateStream(new MemoryStream(buffer2)' CompressionMode.Decompress)))                      PhaseParam = Assembly.Load(br2.ReadBytes(br2.ReadInt32()));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,StackUnderflowCleaner,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\StackUnderflowRemover.cs,Phase1,The following statement contains a magic number: foreach (var mDef in AsmDef.FindMethods(m => true))              {                  if (!mDef.HasBody)                      continue;                    if (mDef.Body.Instructions[0].OpCode != OpCodes.Br_S)                      continue;                    if ((mDef.Body.Instructions[0].Operand as Instruction) == mDef.Body.Instructions[3])                      for (var i = 0; i < 3; i++)                          MarkMember(mDef.Body.Instructions[i]' mDef);              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,StackUnderflowCleaner,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\StackUnderflowRemover.cs,Phase1,The following statement contains a magic number: foreach (var mDef in AsmDef.FindMethods(m => true))              {                  if (!mDef.HasBody)                      continue;                    if (mDef.Body.Instructions[0].OpCode != OpCodes.Br_S)                      continue;                    if ((mDef.Body.Instructions[0].Operand as Instruction) == mDef.Body.Instructions[3])                      for (var i = 0; i < 3; i++)                          MarkMember(mDef.Body.Instructions[i]' mDef);              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: for (var i = 0; i < buf2.Length; i += 4){                  buf2[i] = (byte)(buf2[i] ^ (36 & 255));                  buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));                  buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));                  buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: using (var stream2 = new CryptoStream(new MemoryStream(buf)' new RijndaelManaged().CreateDecryptor(buf2' buf1)' CryptoStreamMode.Read)){                    var buffer4 = new byte[4];                  stream2.Read(buffer4' 0' 4);                    var dst = new byte[BitConverter.ToUInt32(buffer4' 0)];                  Logger.VSLog(string.Format("Decompressed and decrypted resource' raw size: {0} bytes..."' dst.Length));                    var buffer6 = new byte[4096];                  var length = buffer6.Length;                                   for (var j = 0; length == buffer6.Length; j += length){                      length = stream2.Read(buffer6' 0' buffer6.Length);                      Buffer.BlockCopy(buffer6' 0' dst' j' length);                  }                    finalBuf = dst;              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: using (var stream2 = new CryptoStream(new MemoryStream(buf)' new RijndaelManaged().CreateDecryptor(buf2' buf1)' CryptoStreamMode.Read)){                    var buffer4 = new byte[4];                  stream2.Read(buffer4' 0' 4);                    var dst = new byte[BitConverter.ToUInt32(buffer4' 0)];                  Logger.VSLog(string.Format("Decompressed and decrypted resource' raw size: {0} bytes..."' dst.Length));                    var buffer6 = new byte[4096];                  var length = buffer6.Length;                                   for (var j = 0; length == buffer6.Length; j += length){                      length = stream2.Read(buffer6' 0' buffer6.Length);                      Buffer.BlockCopy(buffer6' 0' dst' j' length);                  }                    finalBuf = dst;              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: using (var stream2 = new CryptoStream(new MemoryStream(buf)' new RijndaelManaged().CreateDecryptor(buf2' buf1)' CryptoStreamMode.Read)){                    var buffer4 = new byte[4];                  stream2.Read(buffer4' 0' 4);                    var dst = new byte[BitConverter.ToUInt32(buffer4' 0)];                  Logger.VSLog(string.Format("Decompressed and decrypted resource' raw size: {0} bytes..."' dst.Length));                    var buffer6 = new byte[4096];                  var length = buffer6.Length;                                   for (var j = 0; length == buffer6.Length; j += length){                      length = stream2.Read(buffer6' 0' buffer6.Length);                      Buffer.BlockCopy(buffer6' 0' dst' j' length);                  }                    finalBuf = dst;              }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following statement contains a magic number: foreach(var marking in markings)              {                  for(var i = 0;i < instrList.Count;i++)                  {                      if(marking.Key.Key == i)                      {                          for (var x = 0; x < marking.Key.Value +1; x++)                              instrList.RemoveAt(marking.Key.Key -2);                            switch(marking.Value.OpCode.Code)                          {                              case Code.Ldc_I4:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I4' (int)marking.Value.Value));                                  break;                                case Code.Ldc_I8:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I8' (long)marking.Value.Value));                                  break;                          }                            break;                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following statement contains a magic number: foreach(var marking in markings)              {                  for(var i = 0;i < instrList.Count;i++)                  {                      if(marking.Key.Key == i)                      {                          for (var x = 0; x < marking.Key.Value +1; x++)                              instrList.RemoveAt(marking.Key.Key -2);                            switch(marking.Value.OpCode.Code)                          {                              case Code.Ldc_I4:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I4' (int)marking.Value.Value));                                  break;                                case Code.Ldc_I8:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I8' (long)marking.Value.Value));                                  break;                          }                            break;                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following statement contains a magic number: foreach(var marking in markings)              {                  for(var i = 0;i < instrList.Count;i++)                  {                      if(marking.Key.Key == i)                      {                          for (var x = 0; x < marking.Key.Value +1; x++)                              instrList.RemoveAt(marking.Key.Key -2);                            switch(marking.Value.OpCode.Code)                          {                              case Code.Ldc_I4:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I4' (int)marking.Value.Value));                                  break;                                case Code.Ldc_I8:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I8' (long)marking.Value.Value));                                  break;                          }                            break;                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The following statement contains a magic number: switch(instr.OpCode.Code)              {                  case Code.Ldc_I4:                      stack.Push((int) Convert.ChangeType(instr.Operand' typeof (int)));                      break;                    case Code.Ldc_I4_S:                      stack.Push((sbyte)Convert.ChangeType(instr.Operand' typeof(sbyte)));                      break;                    case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      stack.Push(Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]));                      break;                    case Code.Ldc_I4_M1:                      stack.Push(-1);                      break;                    case Code.Ldc_I8:                      stack.Push((long) Convert.ChangeType(instr.Operand' typeof (long)));                      break;                    case Code.Ldc_R4:                      stack.Push((float) Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Ldc_R8:                      stack.Push((double)Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Stloc:                  case Code.Stloc_S:                      PopToLocal(ref locals' ref stack' instr);                      break;                    case Code.Stloc_0:                  case Code.Stloc_1:                  case Code.Stloc_2:                  case Code.Stloc_3:                      PopToLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Ldloc:                  case Code.Ldloc_S:                      PushFromLocal(ref locals' ref stack' instr);                      break;                    case Code.Ldloc_0:                  case Code.Ldloc_1:                  case Code.Ldloc_2:                  case Code.Ldloc_3:                      PushFromLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Add:                  case Code.Add_Ovf:                  case Code.Add_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Addition' ref markings' ref idx);                      break;                    case Code.Sub:                  case Code.Sub_Ovf:                  case Code.Sub_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Subtraction' ref markings' ref idx);                      break;                    case Code.Mul:                  case Code.Mul_Ovf:                  case Code.Mul_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Multiplication' ref markings' ref idx);                      break;                    case Code.Div:                  case Code.Div_Un:                      PerformArithmetic(ref stack' Operator.Divide' ref markings' ref idx);                      break;                    case Code.Shl:                      PerformArithmetic(ref stack' Operator.ShiftLeft' ref markings' ref idx);                      break;                    case Code.Shr:                  case Code.Shr_Un:                      PerformArithmetic(ref stack' Operator.ShiftRight' ref markings' ref idx);                      break;                    case Code.Rem:                  case Code.Rem_Un:                      PerformArithmetic(ref stack' Operator.Mod' ref markings' ref idx);                      break;                      // We still need to follow control flow to not fuck up stack                  case Code.Br:                  case Code.Br_S:                  case Code.Leave:                  case Code.Leave_S:                      idx = (instr.Operand as Instruction).GetInstructionIndex(instrList);                      break;                    case Code.Conv_I1:                      //stack.Push((sbyte) stack.Pop());                      break;                    case Code.Conv_I2:                      //stack.Push((short) stack.Pop());                      break;                    case Code.Conv_I4:                      //stack.Push((int) stack.Pop());                      break;                    case Code.Conv_I8:                      //stack.Push((long) (stack.Pop() is UnknownValue ? 0 : );                      break;                    case Code.Call:                  case Code.Calli:                  case Code.Callvirt:                      EmulateCall(ref stack' instr);                      break;                    case Code.Ldtoken:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldsfld:                      stack.Push(new UnknownValue());                      break;                    case Code.Stsfld:                      stack.Pop();                      break;                    case Code.Dup:                      stack.Push(stack.Peek());                      break;                    case Code.Clt:                  case Code.Clt_Un:                  case Code.Bgt:                  case Code.Bgt_S:                  case Code.Bgt_Un:                  case Code.Bgt_Un_S:                  case Code.Bge:                  case Code.Bge_S:                  case Code.Bge_Un:                  case Code.Bge_Un_S:                  case Code.Blt:                  case Code.Blt_S:                  case Code.Blt_Un:                  case Code.Blt_Un_S:                  case Code.Bne_Un:                  case Code.Bne_Un_S:                  case Code.Beq:                  case Code.Beq_S:                      PerformComparison(ref stack' instr' ref idx' instrList);                      break;                    case Code.Box:                      stack.Push((object) stack.Pop());                      break;                    case Code.Stobj:                      stack.Pop();                      stack.Pop();                      break;                    case Code.Ldelem_Any:                  case Code.Ldelem_I:                  case Code.Ldelem_I1:                  case Code.Ldelem_I2:                  case Code.Ldelem_I4:                  case Code.Ldelem_I8:                  case Code.Ldelem_R4:                  case Code.Ldelem_R8:                  case Code.Ldelem_Ref:                  case Code.Ldelem_U1:                  case Code.Ldelem_U2:                  case Code.Ldelem_U4:                      stack.Pop();                      stack.Pop();                      stack.Push(new UnknownValue());                      break;                    case Code.Ldlen:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldnull:                      stack.Push(null);                      break;                    case Code.Newobj:                      stack.Push(new UnknownValue());                      break;              }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: if (IsIlNumeric(val1) && IsIlNumeric(val2))              {                  switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }                    var val = stack.Peek();                    if (val == 0){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});return;                  }                  if (val == 1){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});return;                  }                  if (val == 2){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return;                  }                  if (val == 3){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});return;                  }                  if (val == 4){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null}); return;                  }                  if (val == 5){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null}); return;                  }                  if (val == 6){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null}); return;                  }                  if (val == 7){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});return;                  }                  if (val == 8){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return;                  }                    if (val is float){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val}); return;                  }                  if (val is double){                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val }); return;                  }                    if (val >= sbyte.MinValue && val <= sbyte.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });                  else if(val >= short.MinValue && val <= int.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4' Value = val });                  else if (val >= long.MinValue && val <= long.MaxValue)                      markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I8' Value = val });              }              else                  stack.Push(new UnknownValue());
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete,MethodCleaner,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\MethodCleaner.cs,Phase2,The following statement contains a magic number: foreach (var entry in blockList)              {                  var blocks = entry.Value;                  var mDef = entry.Key;                  var cleanBody = new List<Instruction>();                  var tmpBlock = blocks.Find(block => block.StartIndex == 0);                  Instruction instr;                    while (tmpBlock.NextBlock != null)                  {                      //mDef.Body.SimplifyMacros();                      instr = mDef.Body.Instructions[tmpBlock.StartIndex];                        while (mDef.Body.Instructions.IndexOf(instr.Next) <= tmpBlock.EndIndex)                      {                          cleanBody.Add(instr);                          instr = instr.Next;                            if (instr == null)                              break;                            if(cleanBody.Count >= 10000)                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Internal block error!"                                               };                              return false;                          }                      }                        tmpBlock = tmpBlock.NextBlock;                  }                    instr = mDef.Body.Instructions[tmpBlock.StartIndex];                    while (mDef.Body.Instructions.IndexOf(instr.Next) <= tmpBlock.EndIndex)                  {                      cleanBody.Add(instr);                      instr = instr.Next;                        if (instr == null)                          break;                  }                    if (cleanBody[cleanBody.Count -1].OpCode != OpCodes.Ret)                      cleanBody.Add(mDef.Body.GetILProcessor().Create(OpCodes.Ret));                    CleanJumps(ref cleanBody);                    finalList.Add(mDef' cleanBody);              }
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,IsBadType,The following statement contains a magic number: if (cctor.Body.Instructions.GetOpCodeCount(OpCodes.Newarr) != 2)                  return false;
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,IsBadType,The following statement contains a magic number: if (!typeDef.IsSealed || typeDef.Fields.Count != 3)                  return false;
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: foreach (var mDef in AsmDef.FindMethods(m => m.HasBody))              {                  for (var i = 0; i < mDef.Body.Instructions.Count; i++)                  {                      var instr = mDef.Body.Instructions[i];                      MethodDefinition tmpTarget;                        if (instr.OpCode == OpCodes.Call &&                          (tmpTarget = (instr.Operand as MethodReference).Resolve()).DeclaringType == param as TypeDefinition)                      {                          if (!IsStringProxy(tmpTarget))                              continue;                            var decEntry = new ObfusasmEntry                          {                              Key =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 2).GetLdcI4()'                              Key1 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 3).GetLdcI4()'                              Key2 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 4).GetLdcI4()'                             // TargetProxy = tmpTarget                          };                            decEntry.InsertTargets.Add(new Tuple<Instruction' MethodDefinition>(instr.Next' mDef));                          MarkMember(instr' mDef);                            yield return decEntry;                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: foreach (var mDef in AsmDef.FindMethods(m => m.HasBody))              {                  for (var i = 0; i < mDef.Body.Instructions.Count; i++)                  {                      var instr = mDef.Body.Instructions[i];                      MethodDefinition tmpTarget;                        if (instr.OpCode == OpCodes.Call &&                          (tmpTarget = (instr.Operand as MethodReference).Resolve()).DeclaringType == param as TypeDefinition)                      {                          if (!IsStringProxy(tmpTarget))                              continue;                            var decEntry = new ObfusasmEntry                          {                              Key =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 2).GetLdcI4()'                              Key1 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 3).GetLdcI4()'                              Key2 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 4).GetLdcI4()'                             // TargetProxy = tmpTarget                          };                            decEntry.InsertTargets.Add(new Tuple<Instruction' MethodDefinition>(instr.Next' mDef));                          MarkMember(instr' mDef);                            yield return decEntry;                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: foreach (var mDef in AsmDef.FindMethods(m => m.HasBody))              {                  for (var i = 0; i < mDef.Body.Instructions.Count; i++)                  {                      var instr = mDef.Body.Instructions[i];                      MethodDefinition tmpTarget;                        if (instr.OpCode == OpCodes.Call &&                          (tmpTarget = (instr.Operand as MethodReference).Resolve()).DeclaringType == param as TypeDefinition)                      {                          if (!IsStringProxy(tmpTarget))                              continue;                            var decEntry = new ObfusasmEntry                          {                              Key =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 2).GetLdcI4()'                              Key1 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 3).GetLdcI4()'                              Key2 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 4).GetLdcI4()'                             // TargetProxy = tmpTarget                          };                            decEntry.InsertTargets.Add(new Tuple<Instruction' MethodDefinition>(instr.Next' mDef));                          MarkMember(instr' mDef);                            yield return decEntry;                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,Phase1,The following statement contains a magic number: var target =                  AsmDef.FindMethod(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 4 &&                       mDef.Body.Variables.Count == 10 &&                      mDef.Parameters.Count == 1 &&                      mDef.Parameters[0].ParameterType.ToString().Contains("Int32"));
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,Phase1,The following statement contains a magic number: var target =                  AsmDef.FindMethod(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 4 &&                       mDef.Body.Variables.Count == 10 &&                      mDef.Parameters.Count == 1 &&                      mDef.Parameters[0].ParameterType.ToString().Contains("Int32"));
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  fs.Seek(-48L' SeekOrigin.End);                    byte[] buf1 = new byte[16]' buf2 = null;                  var i = 0;                    while (i < 16)                  {                      buf2 = buf1;                      i += fs.Read(buf1' i' 16 - i);                  }                    Buffer.BlockCopy(buf2' 0' _decMod = new uint[4]' 0' 16);              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  fs.Seek(-48L' SeekOrigin.End);                    byte[] buf1 = new byte[16]' buf2 = null;                  var i = 0;                    while (i < 16)                  {                      buf2 = buf1;                      i += fs.Read(buf1' i' 16 - i);                  }                    Buffer.BlockCopy(buf2' 0' _decMod = new uint[4]' 0' 16);              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  fs.Seek(-48L' SeekOrigin.End);                    byte[] buf1 = new byte[16]' buf2 = null;                  var i = 0;                    while (i < 16)                  {                      buf2 = buf1;                      i += fs.Read(buf1' i' 16 - i);                  }                    Buffer.BlockCopy(buf2' 0' _decMod = new uint[4]' 0' 16);              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  fs.Seek(-48L' SeekOrigin.End);                    byte[] buf1 = new byte[16]' buf2 = null;                  var i = 0;                    while (i < 16)                  {                      buf2 = buf1;                      i += fs.Read(buf1' i' 16 - i);                  }                    Buffer.BlockCopy(buf2' 0' _decMod = new uint[4]' 0' 16);              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  fs.Seek(-48L' SeekOrigin.End);                    byte[] buf1 = new byte[16]' buf2 = null;                  var i = 0;                    while (i < 16)                  {                      buf2 = buf1;                      i += fs.Read(buf1' i' 16 - i);                  }                    Buffer.BlockCopy(buf2' 0' _decMod = new uint[4]' 0' 16);              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: using (var fs = new FileStream(Globals.DeobContext.InPath' FileMode.Open' FileAccess.Read))              {                  using (var br = new BinaryReader(fs))                  {                      if (rEntry.Key == 61 + 1)                          rEntry.Key = 62;                        uint[] numArray = null;                      uint[] numArray2 = null;                        fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);                        byte[] outData = null;                      var x = 0;                        while (x < (numArray ?? new uint[1337]).Length)                      {                          uint num = 0;                            try                          {                              num = br.ReadUInt32();                          }                          catch (EndOfStreamException e)                          {                              break;                          }                          catch                          {                              PhaseError = new PhaseError                                               {                                                   Level = PhaseError.ErrorLevel.Minor'                                                   Message = "Message author!"                                               };                              continue;                          }                            var num2 = br.ReadUInt32();                          var num3 = 3337565984;                            var tmp = numArray2;                            for (var i = 32; i > 0; i--)                          {                              num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);                              num3 -= 2654435769;                              num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);                          }                            uint[] numArray4;                          if (tmp == null)                          {                              outData = new byte[num];                              numArray4 = numArray = new uint[num + 11/8*2 - 1];                          }                          else                          {                              numArray[x - 1] = num;                              numArray4 = numArray;                          }                            numArray4[x] = num2;                          x += 2;                            if (x < numArray.Length)                              numArray2 = numArray4;                            Buffer.BlockCopy(numArray4' 0' outData' 0' outData.Length);                          str = Encoding.UTF8.GetString(outData);                      }                  }              }
Magic Number,NETDeob.Core.Engine.Utils.Extensions,InstructionExt,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\Instruction.cs,GetLdcI4,The following statement contains a magic number: switch (instr.OpCode.Code)              {                  case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      return Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]); // Lazy :)                    case Code.Ldc_I4_M1:                      return -1;                    case Code.Ldc_I4:                  case Code.Ldc_I4_S:                      return (int)Convert.ChangeType(instr.Operand' typeof(int)); // No idea why I have to cast it this way                    default:                      throw new Exception("Internal invalid instruction!");              }
Magic Number,NETDeob.Core.Unpackers.Mpress.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Mpress\Tasks\Unpacker.cs,lf,The following statement contains a magic number: if ((num2 >= 2) && (num2 <= (length - 0x200)))              {                  input.Seek(num2' SeekOrigin.Begin);                  if (reader.ReadUInt32() == 0x4550)                  {                      ushort num4 = reader.ReadUInt16();                      if (num4 == 0x8664)                      {                          num2 += 0x144;                      }                      else                      {                          num2 += 0x15c;                      }                      input.Seek(num2' SeekOrigin.Begin);                      int num5 = reader.ReadInt32();                      if (num4 == 0x8664)                      {                          num2 -= 12;                          input.Seek(num2' SeekOrigin.Begin);                          num5 += reader.ReadInt32();                      }                      else                      {                          num5 += 0x10;                      }                      if ((num5 < length) && (num5 >= 0x300))                      {                          length -= num5;                          byte[] buffer = new byte[length];                          input.Seek(num5' SeekOrigin.Begin);                          input.Read(buffer' 0' length);                          input.Close();                            return buffer;                      }                  }              }
Magic Number,NETDeob.Core.Unpackers.Mpress.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Mpress\Tasks\Unpacker.cs,lf,The following statement contains a magic number: if ((num2 >= 2) && (num2 <= (length - 0x200)))              {                  input.Seek(num2' SeekOrigin.Begin);                  if (reader.ReadUInt32() == 0x4550)                  {                      ushort num4 = reader.ReadUInt16();                      if (num4 == 0x8664)                      {                          num2 += 0x144;                      }                      else                      {                          num2 += 0x15c;                      }                      input.Seek(num2' SeekOrigin.Begin);                      int num5 = reader.ReadInt32();                      if (num4 == 0x8664)                      {                          num2 -= 12;                          input.Seek(num2' SeekOrigin.Begin);                          num5 += reader.ReadInt32();                      }                      else                      {                          num5 += 0x10;                      }                      if ((num5 < length) && (num5 >= 0x300))                      {                          length -= num5;                          byte[] buffer = new byte[length];                          input.Seek(num5' SeekOrigin.Begin);                          input.Read(buffer' 0' length);                          input.Close();                            return buffer;                      }                  }              }
Magic Number,NETDeob.Core.Unpackers.Netz.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Netz\Tasks\Unpacker.cs,Phase1,The following statement contains a magic number: target = target.Body.Instructions.FirstOfOpCode((op => op == OpCodes.Call)' 3).Operand as MethodDefinition;
Magic Number,NETDeob.Deobfuscators.Phoenix_Protector,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Phoenix Protector\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: foreach (char c in str)                  chrArr[i] =                      char.ConvertFromUtf32((((byte) ((c >> 8) ^ i) << 8) | (byte) (c ^ (chrArr.Length - i++))))[0];
Magic Number,NETDeob.Deobfuscators.Phoenix_Protector,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Phoenix Protector\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: foreach (char c in str)                  chrArr[i] =                      char.ConvertFromUtf32((((byte) ((c >> 8) ^ i) << 8) | (byte) (c ^ (chrArr.Length - i++))))[0];
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: byte[] buffer = new byte[5];
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: if (inStream.Read(buffer' 0' 5) != 5)              {                  throw new Exception("Err");              }
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: if (inStream.Read(buffer' 0' 5) != 5)              {                  throw new Exception("Err");              }
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int num3 = inStream.ReadByte();                  if (num3 < 0)                  {                      throw new Exception("Err");                  }                  outSize |= ((byte)num3) << (8 * i);              }
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,C:\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int num3 = inStream.ReadByte();                  if (num3 < 0)                  {                      throw new Exception("Err");                  }                  outSize |= ((byte)num3) << (8 * i);              }
Missing Default,NETDeob.Core.Deobfuscators.Generic,AssemblyStripper,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\AssemblyStripper.cs,RemoveMembers,The following switch statement is missing a default case: switch (member.Type)                      {                          case DeobfuscatorContext.MemberType.Type:                              Logger.VLog("[Remove(Type)] " + (member.Member as TypeDefinition).Name.Truncate(10));                              AsmDef.MainModule.Types.Remove(member.Member as TypeDefinition);                              break;                            case DeobfuscatorContext.MemberType.Method:                              Logger.VLog("[Remove(Method)] " + (member.Member as MethodDefinition).Name);                              (member.Member as MethodDefinition).DeclaringType.Methods.Remove(                                  member.Member as MethodDefinition);                              break;                            case DeobfuscatorContext.MemberType.Field:                              Logger.VLog("[Remove(Field)] " + (member.Member as FieldDefinition).Name);                              (member.Member as FieldDefinition).DeclaringType.Fields.Remove(                                  member.Member as FieldDefinition);                              break;                            case DeobfuscatorContext.MemberType.Property:                              Logger.VLog("[Remove(Property)] " + (member.Member as PropertyDefinition).Name);                              (member.Member as PropertyDefinition).DeclaringType.Properties.Remove(                                  member.Member as PropertyDefinition);                              break;                            case DeobfuscatorContext.MemberType.Resource:                              Logger.VLog("[Remove(Resource)] " +                                          ((member.Member as EmbeddedResource).Name.Truncate(10)));                              AsmDef.MainModule.Resources.Remove(member.Member as EmbeddedResource);                              break;                            case DeobfuscatorContext.MemberType.Attribute:                              Logger.VLog("[Remove(Attribute)] " + (member.Member as CustomAttribute).AttributeType.Name);                              (member.ParentMember as ModuleDefinition).CustomAttributes.Remove(                                  member.Member as CustomAttribute);                              break;                            case DeobfuscatorContext.MemberType.Instruction:                              Logger.VLog("[Remove(Instruction)] " + (member.Member as Instruction).OpCode);                              (member.ParentMember as MethodDefinition).Body.Instructions.Remove(                                  member.Member as Instruction);                              break;                            case DeobfuscatorContext.MemberType.AssemblyReference:                              Logger.VLog("[Remove(AssemblyReference)] " + (member.Member as AssemblyNameReference).MetadataToken.ToInt32());                              AsmDef.MainModule.AssemblyReferences.Remove(member.Member as AssemblyNameReference);                              break;                      }
Missing Default,NETDeob.Core.Engine.Utils,StackTracer,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following switch statement is missing a default case: switch (instruction.OpCode.StackBehaviourPush)                  {                      case StackBehaviour.Push0:                      case StackBehaviour.Push1:                      case StackBehaviour.Pushi:                      case StackBehaviour.Pushi8:                      case StackBehaviour.Pushr4:                      case StackBehaviour.Pushr8:                      case StackBehaviour.Pushref:                          _stack.Push(new StackEntry(instruction' true' instruction.Operand));                          break;                      case StackBehaviour.Push1_push1:                          _stack.Push(new StackEntry(instruction' false));                          _stack.Push(new StackEntry(instruction' false));                          break;                  }
Missing Default,NETDeob.Core.Engine.Utils.Decompression,Lzmat,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following switch statement is missing a default case: switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }
Missing Default,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,GetAlgo,The following switch statement is missing a default case: switch (strAlgo)              {                  case Algorithm.DES:                      return new DESCryptoServiceProvider();                    case Algorithm.RC2:                      return new RC2CryptoServiceProvider();                    case Algorithm.Rijndael:                      return new RijndaelManaged();                    case Algorithm.TripleDES:                      return new TripleDESCryptoServiceProvider();              }
Missing Default,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptStrings,The following switch statement is missing a default case: switch (strAlgo)                      {                          case Algorithm.Plain:                              decryptedStr = DecryptString(curInstr.Operand as string' ""' strAlgo);                              outDict.Add(curInstr.Next.Next.Operand as FieldDefinition' decryptedStr);                              break;                            case Algorithm.RC2:                          case Algorithm.DES:                          case Algorithm.Rijndael:                          case Algorithm.TripleDES:                                decryptedStr = DecryptString(curInstr.Operand as string' key' strAlgo);                              outDict.Add(curInstr.Next.Next.Operand as FieldDefinition' decryptedStr);                                break;                      }
Missing Default,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following switch statement is missing a default case: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Missing Default,NETDeob.Core.Deobfuscators.Confuser.Obsolete.Utils,ExpressionScheme,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\Utils\DynamicEvaluator.cs,ExpressionScheme,The following switch statement is missing a default case: switch(instr.OpCode.Code)                      {                          case Code.Add:                              _parts.Add(new ExpOperator {Operator = Operator.Addition});                              break;                          case Code.Sub:                              _parts.Add(new ExpOperator { Operator = Operator.Subtraction });                              break;                          case Code.Mul:                              _parts.Add(new ExpOperator { Operator = Operator.Multiplication });                              break;                          case Code.Xor:                              _parts.Add(new ExpOperator { Operator = Operator.Xor });                              break;                      }
Missing Default,NETDeob.Core.Deobfuscators.Confuser.Obsolete.Utils,ExpressionScheme,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\Utils\DynamicEvaluator.cs,ParseInstructions,The following switch statement is missing a default case: switch (((ExpOperator)part).Operator)                      {                          case Operator.Addition:                              yield return new ExInstruction                                              {                                                  Code = System.Reflection.Emit.OpCodes.Add'                                                  Value = null                                              };                              break;                            case Operator.Multiplication:                              yield return new ExInstruction                              {                                  Code = System.Reflection.Emit.OpCodes.Mul'                                  Value = null                              };                              break;                            case Operator.Subtraction:                              yield return new ExInstruction                              {                                  Code = System.Reflection.Emit.OpCodes.Sub'                                  Value = null                              };                              break;                            case Operator.Xor:                              yield return new ExInstruction                              {                                  Code = System.Reflection.Emit.OpCodes.Xor'                                  Value = null                              };                              continue;                      }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following switch statement is missing a default case: switch(marking.Value.OpCode.Code)                          {                              case Code.Ldc_I4:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I4' (int)marking.Value.Value));                                  break;                                case Code.Ldc_I8:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I8' (long)marking.Value.Value));                                  break;                          }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The following switch statement is missing a default case: switch(instr.OpCode.Code)              {                  case Code.Ldc_I4:                      stack.Push((int) Convert.ChangeType(instr.Operand' typeof (int)));                      break;                    case Code.Ldc_I4_S:                      stack.Push((sbyte)Convert.ChangeType(instr.Operand' typeof(sbyte)));                      break;                    case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      stack.Push(Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]));                      break;                    case Code.Ldc_I4_M1:                      stack.Push(-1);                      break;                    case Code.Ldc_I8:                      stack.Push((long) Convert.ChangeType(instr.Operand' typeof (long)));                      break;                    case Code.Ldc_R4:                      stack.Push((float) Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Ldc_R8:                      stack.Push((double)Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Stloc:                  case Code.Stloc_S:                      PopToLocal(ref locals' ref stack' instr);                      break;                    case Code.Stloc_0:                  case Code.Stloc_1:                  case Code.Stloc_2:                  case Code.Stloc_3:                      PopToLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Ldloc:                  case Code.Ldloc_S:                      PushFromLocal(ref locals' ref stack' instr);                      break;                    case Code.Ldloc_0:                  case Code.Ldloc_1:                  case Code.Ldloc_2:                  case Code.Ldloc_3:                      PushFromLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Add:                  case Code.Add_Ovf:                  case Code.Add_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Addition' ref markings' ref idx);                      break;                    case Code.Sub:                  case Code.Sub_Ovf:                  case Code.Sub_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Subtraction' ref markings' ref idx);                      break;                    case Code.Mul:                  case Code.Mul_Ovf:                  case Code.Mul_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Multiplication' ref markings' ref idx);                      break;                    case Code.Div:                  case Code.Div_Un:                      PerformArithmetic(ref stack' Operator.Divide' ref markings' ref idx);                      break;                    case Code.Shl:                      PerformArithmetic(ref stack' Operator.ShiftLeft' ref markings' ref idx);                      break;                    case Code.Shr:                  case Code.Shr_Un:                      PerformArithmetic(ref stack' Operator.ShiftRight' ref markings' ref idx);                      break;                    case Code.Rem:                  case Code.Rem_Un:                      PerformArithmetic(ref stack' Operator.Mod' ref markings' ref idx);                      break;                      // We still need to follow control flow to not fuck up stack                  case Code.Br:                  case Code.Br_S:                  case Code.Leave:                  case Code.Leave_S:                      idx = (instr.Operand as Instruction).GetInstructionIndex(instrList);                      break;                    case Code.Conv_I1:                      //stack.Push((sbyte) stack.Pop());                      break;                    case Code.Conv_I2:                      //stack.Push((short) stack.Pop());                      break;                    case Code.Conv_I4:                      //stack.Push((int) stack.Pop());                      break;                    case Code.Conv_I8:                      //stack.Push((long) (stack.Pop() is UnknownValue ? 0 : );                      break;                    case Code.Call:                  case Code.Calli:                  case Code.Callvirt:                      EmulateCall(ref stack' instr);                      break;                    case Code.Ldtoken:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldsfld:                      stack.Push(new UnknownValue());                      break;                    case Code.Stsfld:                      stack.Pop();                      break;                    case Code.Dup:                      stack.Push(stack.Peek());                      break;                    case Code.Clt:                  case Code.Clt_Un:                  case Code.Bgt:                  case Code.Bgt_S:                  case Code.Bgt_Un:                  case Code.Bgt_Un_S:                  case Code.Bge:                  case Code.Bge_S:                  case Code.Bge_Un:                  case Code.Bge_Un_S:                  case Code.Blt:                  case Code.Blt_S:                  case Code.Blt_Un:                  case Code.Blt_Un_S:                  case Code.Bne_Un:                  case Code.Bne_Un_S:                  case Code.Beq:                  case Code.Beq_S:                      PerformComparison(ref stack' instr' ref idx' instrList);                      break;                    case Code.Box:                      stack.Push((object) stack.Pop());                      break;                    case Code.Stobj:                      stack.Pop();                      stack.Pop();                      break;                    case Code.Ldelem_Any:                  case Code.Ldelem_I:                  case Code.Ldelem_I1:                  case Code.Ldelem_I2:                  case Code.Ldelem_I4:                  case Code.Ldelem_I8:                  case Code.Ldelem_R4:                  case Code.Ldelem_R8:                  case Code.Ldelem_Ref:                  case Code.Ldelem_U1:                  case Code.Ldelem_U2:                  case Code.Ldelem_U4:                      stack.Pop();                      stack.Pop();                      stack.Push(new UnknownValue());                      break;                    case Code.Ldlen:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldnull:                      stack.Push(null);                      break;                    case Code.Newobj:                      stack.Push(new UnknownValue());                      break;              }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformComparison,The following switch statement is missing a default case: switch(instr.OpCode.Code)              {                  case Code.Clt:                  case Code.Clt_Un:                      stack.Push(val1 < val2 ? 1 : 0);                      break;                    case Code.Blt:                  case Code.Blt_S:                  case Code.Blt_Un:                  case Code.Blt_Un_S:                      idx = (val1 < val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Bgt:                  case Code.Bgt_S:                  case Code.Bgt_Un:                  case Code.Bgt_Un_S:                      idx = (val1 > val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Bge:                  case Code.Bge_S:                  case Code.Bge_Un:                  case Code.Bge_Un_S:                      idx = (val1 >= val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Beq:                  case Code.Beq_S:                      idx = (val1 == val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Bne_Un:                  case Code.Bne_Un_S:                      idx = (val1 != val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;              }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,C:\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following switch statement is missing a default case: switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }
Missing Default,NETDeob.Core.Engine.Utils.Extensions,TypeDefinitionExt,C:\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\TypeDefinition.cs,GetAllReferences,The following switch statement is missing a default case: switch (instr.OpCode.Code)                      {                          case Code.Ldsfld:                          case Code.Ldsflda:                              if ((instr.Operand as FieldReference).Resolve().DeclaringType == typeDef)                                  if ((TopParentType<MethodDefinition>(mDef) != typeDef))                                      yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                            case Code.Stobj:                          case Code.Ldobj:                          case Code.Castclass:                          case Code.Isinst:                          case Code.Unbox:                          case Code.Box:                          case Code.Newarr:                          case Code.Ldelem_I1:                          case Code.Ldelem_Any:                          case Code.Stelem_Any:                          case Code.Unbox_Any:                          case Code.Refanyval:                          case Code.Mkrefany:                          case Code.Initobj:                          case Code.Constrained:                          case Code.Sizeof:                              if ((instr.Operand as TypeReference).Resolve() == typeDef)                                  if ((TopParentType(mDef) != typeDef))                                      yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                            case Code.Ldtoken:                              if ((instr.Operand is TypeReference))                              {                                  if ((instr.Operand as TypeReference).Resolve() == typeDef)                                      if ((TopParentType(mDef) != typeDef))                                          yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                              }                              else if ((instr.Operand is FieldReference) || (instr.Operand is MethodReference))                                  if ((instr.Operand as dynamic).Resolve().DeclaringType == typeDef)                                      if ((TopParentType(mDef) != typeDef))                                          yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                            case Code.Call:                          case Code.Callvirt:                          case Code.Jmp:                          case Code.Newobj:                          case Code.Ldftn:                          case Code.Ldvirtftn:                              if (((instr.Operand as MethodReference).Resolve()).DeclaringType == typeDef)                                  if ((TopParentType(mDef) != typeDef))                                      yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                        }
