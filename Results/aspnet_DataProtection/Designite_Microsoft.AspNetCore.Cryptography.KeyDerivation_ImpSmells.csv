Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Microsoft.AspNetCore.Cryptography.KeyDerivation,KeyDerivation,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\KeyDerivation.cs,Pbkdf2,The method has 5 parameters. Parameters: password' salt' prf' iterationCount' numBytesRequested
Long Parameter List,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,IPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\IPbkdf2Provider.cs,DeriveKey,The method has 5 parameters. Parameters: password' salt' prf' iterationCount' numBytesRequested
Long Parameter List,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,ManagedPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\ManagedPbkdf2Provider.cs,DeriveKey,The method has 5 parameters. Parameters: password' salt' prf' iterationCount' numBytesRequested
Long Parameter List,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win7Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win7Pbkdf2Provider.cs,DeriveKey,The method has 5 parameters. Parameters: password' salt' prf' iterationCount' numBytesRequested
Long Parameter List,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKey,The method has 5 parameters. Parameters: password' salt' prf' iterationCount' numBytesRequested
Long Parameter List,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKeyCore,The method has 7 parameters. Parameters: pbkdf2KeyHandle' hashAlgorithm' pbSalt' cbSalt' iterCount' pbDerivedBytes' cbDerivedBytes
Long Statement,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win7Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win7Pbkdf2Provider.cs,DeriveKey,The length of the statement  "            byte dummy; // CLR doesn't like pinning zero-length buffers' so this provides a valid memory address when working with zero-length buffers " is 138.
Long Statement,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win7Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win7Pbkdf2Provider.cs,DeriveKey,The length of the statement  "            fixed (byte* pbHeapAllocatedPasswordBuffer = (cbPasswordBuffer > Constants.MAX_STACKALLOC_BYTES) ? new byte[cbPasswordBuffer] : null) " is 133.
Long Statement,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKey,The length of the statement  "                byte dummy; // CLR doesn't like pinning zero-length buffers' so this provides a valid memory address when working with zero-length buffers " is 138.
Long Statement,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKey,The length of the statement  "                        DeriveKeyCore(keyHandle' algorithmName' pbSalt' (uint)salt.Length' (ulong)iterationCount' pbRetVal' (uint)retVal.Length); " is 121.
Long Statement,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,PasswordToPbkdfKeyHandle,The length of the statement  "            byte dummy; // CLR doesn't like pinning zero-length buffers' so this provides a valid memory address when working with zero-length buffers " is 138.
Long Statement,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,PasswordToPbkdfKeyHandle,The length of the statement  "            fixed (byte* pbHeapAllocatedPasswordBuffer = (cbPasswordBuffer > Constants.MAX_STACKALLOC_BYTES) ? new byte[cbPasswordBuffer] : null) " is 133.
Long Statement,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,PasswordToPbkdfKeyHandleStep2,The length of the statement  "            const uint PBKDF2_MAX_KEYLENGTH_IN_BYTES = 2048; // GetSupportedKeyLengths() on a Win8 box; value should never be lowered in any future version of Windows " is 154.
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,ManagedPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\ManagedPbkdf2Provider.cs,DeriveKey,The following statement contains a magic number: using (var hashAlgorithm = PrfToManagedHmacAlgorithm(prf' password))              {                  for (uint blockIndex = 1; numBytesRemaining > 0; blockIndex++)                  {                      // write the block index out as big-endian                      saltWithBlockIndex[saltWithBlockIndex.Length - 4] = (byte)(blockIndex >> 24);                      saltWithBlockIndex[saltWithBlockIndex.Length - 3] = (byte)(blockIndex >> 16);                      saltWithBlockIndex[saltWithBlockIndex.Length - 2] = (byte)(blockIndex >> 8);                      saltWithBlockIndex[saltWithBlockIndex.Length - 1] = (byte)blockIndex;                        // U_1 = PRF(U_0) = PRF(Salt || block_index)                      // T_blockIndex = U_1                      byte[] U_iter = hashAlgorithm.ComputeHash(saltWithBlockIndex); // this is U_1                      byte[] T_blockIndex = U_iter;                        for (int iter = 1; iter < iterationCount; iter++)                      {                          U_iter = hashAlgorithm.ComputeHash(U_iter);                          XorBuffers(src: U_iter' dest: T_blockIndex);                          // At this point' the 'U_iter' variable actually contains U_{iter+1} (due to indexing differences).                      }                        // At this point' we're done iterating on this block' so copy the transformed block into retVal.                      int numBytesToCopy = Math.Min(numBytesRemaining' T_blockIndex.Length);                      Buffer.BlockCopy(T_blockIndex' 0' retVal' numBytesWritten' numBytesToCopy);                      numBytesWritten += numBytesToCopy;                      numBytesRemaining -= numBytesToCopy;                  }              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,ManagedPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\ManagedPbkdf2Provider.cs,DeriveKey,The following statement contains a magic number: using (var hashAlgorithm = PrfToManagedHmacAlgorithm(prf' password))              {                  for (uint blockIndex = 1; numBytesRemaining > 0; blockIndex++)                  {                      // write the block index out as big-endian                      saltWithBlockIndex[saltWithBlockIndex.Length - 4] = (byte)(blockIndex >> 24);                      saltWithBlockIndex[saltWithBlockIndex.Length - 3] = (byte)(blockIndex >> 16);                      saltWithBlockIndex[saltWithBlockIndex.Length - 2] = (byte)(blockIndex >> 8);                      saltWithBlockIndex[saltWithBlockIndex.Length - 1] = (byte)blockIndex;                        // U_1 = PRF(U_0) = PRF(Salt || block_index)                      // T_blockIndex = U_1                      byte[] U_iter = hashAlgorithm.ComputeHash(saltWithBlockIndex); // this is U_1                      byte[] T_blockIndex = U_iter;                        for (int iter = 1; iter < iterationCount; iter++)                      {                          U_iter = hashAlgorithm.ComputeHash(U_iter);                          XorBuffers(src: U_iter' dest: T_blockIndex);                          // At this point' the 'U_iter' variable actually contains U_{iter+1} (due to indexing differences).                      }                        // At this point' we're done iterating on this block' so copy the transformed block into retVal.                      int numBytesToCopy = Math.Min(numBytesRemaining' T_blockIndex.Length);                      Buffer.BlockCopy(T_blockIndex' 0' retVal' numBytesWritten' numBytesToCopy);                      numBytesWritten += numBytesToCopy;                      numBytesRemaining -= numBytesToCopy;                  }              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,ManagedPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\ManagedPbkdf2Provider.cs,DeriveKey,The following statement contains a magic number: using (var hashAlgorithm = PrfToManagedHmacAlgorithm(prf' password))              {                  for (uint blockIndex = 1; numBytesRemaining > 0; blockIndex++)                  {                      // write the block index out as big-endian                      saltWithBlockIndex[saltWithBlockIndex.Length - 4] = (byte)(blockIndex >> 24);                      saltWithBlockIndex[saltWithBlockIndex.Length - 3] = (byte)(blockIndex >> 16);                      saltWithBlockIndex[saltWithBlockIndex.Length - 2] = (byte)(blockIndex >> 8);                      saltWithBlockIndex[saltWithBlockIndex.Length - 1] = (byte)blockIndex;                        // U_1 = PRF(U_0) = PRF(Salt || block_index)                      // T_blockIndex = U_1                      byte[] U_iter = hashAlgorithm.ComputeHash(saltWithBlockIndex); // this is U_1                      byte[] T_blockIndex = U_iter;                        for (int iter = 1; iter < iterationCount; iter++)                      {                          U_iter = hashAlgorithm.ComputeHash(U_iter);                          XorBuffers(src: U_iter' dest: T_blockIndex);                          // At this point' the 'U_iter' variable actually contains U_{iter+1} (due to indexing differences).                      }                        // At this point' we're done iterating on this block' so copy the transformed block into retVal.                      int numBytesToCopy = Math.Min(numBytesRemaining' T_blockIndex.Length);                      Buffer.BlockCopy(T_blockIndex' 0' retVal' numBytesWritten' numBytesToCopy);                      numBytesWritten += numBytesToCopy;                      numBytesRemaining -= numBytesToCopy;                  }              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,ManagedPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\ManagedPbkdf2Provider.cs,DeriveKey,The following statement contains a magic number: using (var hashAlgorithm = PrfToManagedHmacAlgorithm(prf' password))              {                  for (uint blockIndex = 1; numBytesRemaining > 0; blockIndex++)                  {                      // write the block index out as big-endian                      saltWithBlockIndex[saltWithBlockIndex.Length - 4] = (byte)(blockIndex >> 24);                      saltWithBlockIndex[saltWithBlockIndex.Length - 3] = (byte)(blockIndex >> 16);                      saltWithBlockIndex[saltWithBlockIndex.Length - 2] = (byte)(blockIndex >> 8);                      saltWithBlockIndex[saltWithBlockIndex.Length - 1] = (byte)blockIndex;                        // U_1 = PRF(U_0) = PRF(Salt || block_index)                      // T_blockIndex = U_1                      byte[] U_iter = hashAlgorithm.ComputeHash(saltWithBlockIndex); // this is U_1                      byte[] T_blockIndex = U_iter;                        for (int iter = 1; iter < iterationCount; iter++)                      {                          U_iter = hashAlgorithm.ComputeHash(U_iter);                          XorBuffers(src: U_iter' dest: T_blockIndex);                          // At this point' the 'U_iter' variable actually contains U_{iter+1} (due to indexing differences).                      }                        // At this point' we're done iterating on this block' so copy the transformed block into retVal.                      int numBytesToCopy = Math.Min(numBytesRemaining' T_blockIndex.Length);                      Buffer.BlockCopy(T_blockIndex' 0' retVal' numBytesWritten' numBytesToCopy);                      numBytesWritten += numBytesToCopy;                      numBytesRemaining -= numBytesToCopy;                  }              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,ManagedPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\ManagedPbkdf2Provider.cs,DeriveKey,The following statement contains a magic number: using (var hashAlgorithm = PrfToManagedHmacAlgorithm(prf' password))              {                  for (uint blockIndex = 1; numBytesRemaining > 0; blockIndex++)                  {                      // write the block index out as big-endian                      saltWithBlockIndex[saltWithBlockIndex.Length - 4] = (byte)(blockIndex >> 24);                      saltWithBlockIndex[saltWithBlockIndex.Length - 3] = (byte)(blockIndex >> 16);                      saltWithBlockIndex[saltWithBlockIndex.Length - 2] = (byte)(blockIndex >> 8);                      saltWithBlockIndex[saltWithBlockIndex.Length - 1] = (byte)blockIndex;                        // U_1 = PRF(U_0) = PRF(Salt || block_index)                      // T_blockIndex = U_1                      byte[] U_iter = hashAlgorithm.ComputeHash(saltWithBlockIndex); // this is U_1                      byte[] T_blockIndex = U_iter;                        for (int iter = 1; iter < iterationCount; iter++)                      {                          U_iter = hashAlgorithm.ComputeHash(U_iter);                          XorBuffers(src: U_iter' dest: T_blockIndex);                          // At this point' the 'U_iter' variable actually contains U_{iter+1} (due to indexing differences).                      }                        // At this point' we're done iterating on this block' so copy the transformed block into retVal.                      int numBytesToCopy = Math.Min(numBytesRemaining' T_blockIndex.Length);                      Buffer.BlockCopy(T_blockIndex' 0' retVal' numBytesWritten' numBytesToCopy);                      numBytesWritten += numBytesToCopy;                      numBytesRemaining -= numBytesToCopy;                  }              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,ManagedPbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\ManagedPbkdf2Provider.cs,DeriveKey,The following statement contains a magic number: using (var hashAlgorithm = PrfToManagedHmacAlgorithm(prf' password))              {                  for (uint blockIndex = 1; numBytesRemaining > 0; blockIndex++)                  {                      // write the block index out as big-endian                      saltWithBlockIndex[saltWithBlockIndex.Length - 4] = (byte)(blockIndex >> 24);                      saltWithBlockIndex[saltWithBlockIndex.Length - 3] = (byte)(blockIndex >> 16);                      saltWithBlockIndex[saltWithBlockIndex.Length - 2] = (byte)(blockIndex >> 8);                      saltWithBlockIndex[saltWithBlockIndex.Length - 1] = (byte)blockIndex;                        // U_1 = PRF(U_0) = PRF(Salt || block_index)                      // T_blockIndex = U_1                      byte[] U_iter = hashAlgorithm.ComputeHash(saltWithBlockIndex); // this is U_1                      byte[] T_blockIndex = U_iter;                        for (int iter = 1; iter < iterationCount; iter++)                      {                          U_iter = hashAlgorithm.ComputeHash(U_iter);                          XorBuffers(src: U_iter' dest: T_blockIndex);                          // At this point' the 'U_iter' variable actually contains U_{iter+1} (due to indexing differences).                      }                        // At this point' we're done iterating on this block' so copy the transformed block into retVal.                      int numBytesToCopy = Math.Min(numBytesRemaining' T_blockIndex.Length);                      Buffer.BlockCopy(T_blockIndex' 0' retVal' numBytesWritten' numBytesToCopy);                      numBytesWritten += numBytesToCopy;                      numBytesRemaining -= numBytesToCopy;                  }              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,PasswordToPbkdfKeyHandleStep2,The following statement contains a magic number: const uint PBKDF2_MAX_KEYLENGTH_IN_BYTES = 2048;
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKeyCore,The following statement contains a magic number: BCryptBuffer* pBuffers = stackalloc BCryptBuffer[3];
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKeyCore,The following statement contains a magic number: fixed (char* pszHashAlgorithm = hashAlgorithm)              {                  pBuffers[2].BufferType = BCryptKeyDerivationBufferType.KDF_HASH_ALGORITHM;                  pBuffers[2].pvBuffer = (IntPtr)pszHashAlgorithm;                  pBuffers[2].cbBuffer = GetTotalByteLengthIncludingNullTerminator(hashAlgorithm);                    // Add the header which points to the buffers                  BCryptBufferDesc bufferDesc = default(BCryptBufferDesc);                  BCryptBufferDesc.Initialize(ref bufferDesc);                  bufferDesc.cBuffers = 3;                  bufferDesc.pBuffers = pBuffers;                    // Finally' import the KDK into the KDF algorithm' then invoke the KDF                  uint numBytesDerived;                  int ntstatus = UnsafeNativeMethods.BCryptKeyDerivation(                          hKey: pbkdf2KeyHandle'                          pParameterList: &bufferDesc'                          pbDerivedKey: pbDerivedBytes'                          cbDerivedKey: cbDerivedBytes'                          pcbResult: out numBytesDerived'                          dwFlags: 0);                  UnsafeNativeMethods.ThrowExceptionForBCryptStatus(ntstatus);                    // Final sanity checks before returning control to caller.                  CryptoUtil.Assert(numBytesDerived == cbDerivedBytes' "numBytesDerived == cbDerivedBytes");              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKeyCore,The following statement contains a magic number: fixed (char* pszHashAlgorithm = hashAlgorithm)              {                  pBuffers[2].BufferType = BCryptKeyDerivationBufferType.KDF_HASH_ALGORITHM;                  pBuffers[2].pvBuffer = (IntPtr)pszHashAlgorithm;                  pBuffers[2].cbBuffer = GetTotalByteLengthIncludingNullTerminator(hashAlgorithm);                    // Add the header which points to the buffers                  BCryptBufferDesc bufferDesc = default(BCryptBufferDesc);                  BCryptBufferDesc.Initialize(ref bufferDesc);                  bufferDesc.cBuffers = 3;                  bufferDesc.pBuffers = pBuffers;                    // Finally' import the KDK into the KDF algorithm' then invoke the KDF                  uint numBytesDerived;                  int ntstatus = UnsafeNativeMethods.BCryptKeyDerivation(                          hKey: pbkdf2KeyHandle'                          pParameterList: &bufferDesc'                          pbDerivedKey: pbDerivedBytes'                          cbDerivedKey: cbDerivedBytes'                          pcbResult: out numBytesDerived'                          dwFlags: 0);                  UnsafeNativeMethods.ThrowExceptionForBCryptStatus(ntstatus);                    // Final sanity checks before returning control to caller.                  CryptoUtil.Assert(numBytesDerived == cbDerivedBytes' "numBytesDerived == cbDerivedBytes");              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKeyCore,The following statement contains a magic number: fixed (char* pszHashAlgorithm = hashAlgorithm)              {                  pBuffers[2].BufferType = BCryptKeyDerivationBufferType.KDF_HASH_ALGORITHM;                  pBuffers[2].pvBuffer = (IntPtr)pszHashAlgorithm;                  pBuffers[2].cbBuffer = GetTotalByteLengthIncludingNullTerminator(hashAlgorithm);                    // Add the header which points to the buffers                  BCryptBufferDesc bufferDesc = default(BCryptBufferDesc);                  BCryptBufferDesc.Initialize(ref bufferDesc);                  bufferDesc.cBuffers = 3;                  bufferDesc.pBuffers = pBuffers;                    // Finally' import the KDK into the KDF algorithm' then invoke the KDF                  uint numBytesDerived;                  int ntstatus = UnsafeNativeMethods.BCryptKeyDerivation(                          hKey: pbkdf2KeyHandle'                          pParameterList: &bufferDesc'                          pbDerivedKey: pbDerivedBytes'                          cbDerivedKey: cbDerivedBytes'                          pcbResult: out numBytesDerived'                          dwFlags: 0);                  UnsafeNativeMethods.ThrowExceptionForBCryptStatus(ntstatus);                    // Final sanity checks before returning control to caller.                  CryptoUtil.Assert(numBytesDerived == cbDerivedBytes' "numBytesDerived == cbDerivedBytes");              }
Magic Number,Microsoft.AspNetCore.Cryptography.KeyDerivation.PBKDF2,Win8Pbkdf2Provider,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.Cryptography.KeyDerivation\PBKDF2\Win8Pbkdf2Provider.cs,DeriveKeyCore,The following statement contains a magic number: fixed (char* pszHashAlgorithm = hashAlgorithm)              {                  pBuffers[2].BufferType = BCryptKeyDerivationBufferType.KDF_HASH_ALGORITHM;                  pBuffers[2].pvBuffer = (IntPtr)pszHashAlgorithm;                  pBuffers[2].cbBuffer = GetTotalByteLengthIncludingNullTerminator(hashAlgorithm);                    // Add the header which points to the buffers                  BCryptBufferDesc bufferDesc = default(BCryptBufferDesc);                  BCryptBufferDesc.Initialize(ref bufferDesc);                  bufferDesc.cBuffers = 3;                  bufferDesc.pBuffers = pBuffers;                    // Finally' import the KDK into the KDF algorithm' then invoke the KDF                  uint numBytesDerived;                  int ntstatus = UnsafeNativeMethods.BCryptKeyDerivation(                          hKey: pbkdf2KeyHandle'                          pParameterList: &bufferDesc'                          pbDerivedKey: pbDerivedBytes'                          cbDerivedKey: cbDerivedBytes'                          pcbResult: out numBytesDerived'                          dwFlags: 0);                  UnsafeNativeMethods.ThrowExceptionForBCryptStatus(ntstatus);                    // Final sanity checks before returning control to caller.                  CryptoUtil.Assert(numBytesDerived == cbDerivedBytes' "numBytesDerived == cbDerivedBytes");              }
