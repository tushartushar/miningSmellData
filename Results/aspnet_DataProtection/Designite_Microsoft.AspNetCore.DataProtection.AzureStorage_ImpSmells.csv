Implementation smell,Namespace,Class,File,Method,Description
Empty Catch Block,Microsoft.AspNetCore.DataProtection.AzureStorage,AzureBlobXmlRepository,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.DataProtection.AzureStorage\AzureBlobXmlRepository.cs,GetLatestDataAsync,The method has an empty catch block.
Magic Number,Microsoft.AspNetCore.DataProtection.AzureStorage,AzureBlobXmlRepository,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.DataProtection.AzureStorage\AzureBlobXmlRepository.cs,GetLatestDataAsync,The following statement contains a magic number: try              {                  using (var memoryStream = new MemoryStream())                  {                      await blobRef.DownloadToStreamAsync(                          target: memoryStream'                          accessCondition: accessCondition'                          options: null'                          operationContext: null);                        // At this point' our original cache either didn't exist or was outdated.                      // We'll update it now and return the updated value;                        latestCachedData = new BlobData()                      {                          BlobContents = memoryStream.ToArray()'                          ETag = blobRef.Properties.ETag                      };                    }                  Volatile.Write(ref _cachedBlobData' latestCachedData);              }              catch (StorageException ex) when (ex.RequestInformation.HttpStatusCode == 304)              {                  // 304 Not Modified                  // Thrown when we already have the latest cached data.                  // This isn't an error; we'll return our cached copy of the data.              }              catch (StorageException ex) when (ex.RequestInformation.HttpStatusCode == 404)              {                  // 404 Not Found                  // Thrown when no file exists in storage.                  // This isn't an error; we'll delete our cached copy of data.                    latestCachedData = null;                  Volatile.Write(ref _cachedBlobData' latestCachedData);              }
Magic Number,Microsoft.AspNetCore.DataProtection.AzureStorage,AzureBlobXmlRepository,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.DataProtection.AzureStorage\AzureBlobXmlRepository.cs,GetLatestDataAsync,The following statement contains a magic number: try              {                  using (var memoryStream = new MemoryStream())                  {                      await blobRef.DownloadToStreamAsync(                          target: memoryStream'                          accessCondition: accessCondition'                          options: null'                          operationContext: null);                        // At this point' our original cache either didn't exist or was outdated.                      // We'll update it now and return the updated value;                        latestCachedData = new BlobData()                      {                          BlobContents = memoryStream.ToArray()'                          ETag = blobRef.Properties.ETag                      };                    }                  Volatile.Write(ref _cachedBlobData' latestCachedData);              }              catch (StorageException ex) when (ex.RequestInformation.HttpStatusCode == 304)              {                  // 304 Not Modified                  // Thrown when we already have the latest cached data.                  // This isn't an error; we'll return our cached copy of the data.              }              catch (StorageException ex) when (ex.RequestInformation.HttpStatusCode == 404)              {                  // 404 Not Found                  // Thrown when no file exists in storage.                  // This isn't an error; we'll delete our cached copy of data.                    latestCachedData = null;                  Volatile.Write(ref _cachedBlobData' latestCachedData);              }
Magic Number,Microsoft.AspNetCore.DataProtection.AzureStorage,AzureBlobXmlRepository,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.DataProtection.AzureStorage\AzureBlobXmlRepository.cs,GetRandomizedBackoffPeriod,The following statement contains a magic number: var multiplier = 0.8 + (_random.NextDouble() * 0.2);
Magic Number,Microsoft.AspNetCore.DataProtection.AzureStorage,AzureBlobXmlRepository,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.DataProtection.AzureStorage\AzureBlobXmlRepository.cs,GetRandomizedBackoffPeriod,The following statement contains a magic number: var multiplier = 0.8 + (_random.NextDouble() * 0.2);
Magic Number,Microsoft.AspNetCore.DataProtection.AzureStorage,AzureBlobXmlRepository,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.DataProtection.AzureStorage\AzureBlobXmlRepository.cs,StoreElementAsync,The following statement contains a magic number: for (var i = 0; i < ConflictMaxRetries; i++)              {                  if (i > 1)                  {                      // If multiple conflicts occurred' wait a small period of time before retrying                      // the operation so that other writers can make forward progress.                      await Task.Delay(GetRandomizedBackoffPeriod());                  }                    if (i > 0)                  {                      // If at least one conflict occurred' make sure we have an up-to-date                      // view of the blob contents.                      await GetLatestDataAsync(blobRef);                  }                    // Merge the new element into the document. If no document exists'                  // create a new default document and inject this element into it.                    var latestData = Volatile.Read(ref _cachedBlobData);                  var doc = (latestData != null)                      ? CreateDocumentFromBlob(latestData.BlobContents)                      : new XDocument(new XElement(RepositoryElementName));                  doc.Root.Add(element);                    // Turn this document back into a byte[].                    var serializedDoc = new MemoryStream();                  doc.Save(serializedDoc' SaveOptions.DisableFormatting);                    // Generate the appropriate precondition header based on whether or not                  // we believe data already exists in storage.                    AccessCondition accessCondition;                  if (latestData != null)                  {                      accessCondition = AccessCondition.GenerateIfMatchCondition(blobRef.Properties.ETag);                  }                  else                  {                      accessCondition = AccessCondition.GenerateIfNotExistsCondition();                      blobRef.Properties.ContentType = "application/xml; charset=utf-8"; // set content type on first write                  }                    try                  {                      // Send the request up to the server.                        var serializedDocAsByteArray = serializedDoc.ToArray();                        await blobRef.UploadFromByteArrayAsync(                          buffer: serializedDocAsByteArray'                          index: 0'                          count: serializedDocAsByteArray.Length'                          accessCondition: accessCondition'                          options: null'                          operationContext: null);                        // If we got this far' success!                      // We can update the cached view of the remote contents.                        Volatile.Write(ref _cachedBlobData' new BlobData()                      {                          BlobContents = serializedDocAsByteArray'                          ETag = blobRef.Properties.ETag // was updated by Upload routine                      });                        return;                  }                  catch (StorageException ex)                      when (ex.RequestInformation.HttpStatusCode == 409 || ex.RequestInformation.HttpStatusCode == 412)                  {                      // 409 Conflict                      // This error is rare but can be thrown in very special circumstances'                      // such as if the blob in the process of being created. We treat it                      // as equivalent to 412 for the purposes of retry logic.                        // 412 Precondition Failed                      // We'll get this error if another writer updated the repository and we                      // have an outdated view of its contents. If this occurs' we'll just                      // refresh our view of the remote contents and try again up to the max                      // retry limit.                        lastError = ExceptionDispatchInfo.Capture(ex);                  }              }
Magic Number,Microsoft.AspNetCore.DataProtection.AzureStorage,AzureBlobXmlRepository,C:\repos\aspnet_DataProtection\src\Microsoft.AspNetCore.DataProtection.AzureStorage\AzureBlobXmlRepository.cs,StoreElementAsync,The following statement contains a magic number: for (var i = 0; i < ConflictMaxRetries; i++)              {                  if (i > 1)                  {                      // If multiple conflicts occurred' wait a small period of time before retrying                      // the operation so that other writers can make forward progress.                      await Task.Delay(GetRandomizedBackoffPeriod());                  }                    if (i > 0)                  {                      // If at least one conflict occurred' make sure we have an up-to-date                      // view of the blob contents.                      await GetLatestDataAsync(blobRef);                  }                    // Merge the new element into the document. If no document exists'                  // create a new default document and inject this element into it.                    var latestData = Volatile.Read(ref _cachedBlobData);                  var doc = (latestData != null)                      ? CreateDocumentFromBlob(latestData.BlobContents)                      : new XDocument(new XElement(RepositoryElementName));                  doc.Root.Add(element);                    // Turn this document back into a byte[].                    var serializedDoc = new MemoryStream();                  doc.Save(serializedDoc' SaveOptions.DisableFormatting);                    // Generate the appropriate precondition header based on whether or not                  // we believe data already exists in storage.                    AccessCondition accessCondition;                  if (latestData != null)                  {                      accessCondition = AccessCondition.GenerateIfMatchCondition(blobRef.Properties.ETag);                  }                  else                  {                      accessCondition = AccessCondition.GenerateIfNotExistsCondition();                      blobRef.Properties.ContentType = "application/xml; charset=utf-8"; // set content type on first write                  }                    try                  {                      // Send the request up to the server.                        var serializedDocAsByteArray = serializedDoc.ToArray();                        await blobRef.UploadFromByteArrayAsync(                          buffer: serializedDocAsByteArray'                          index: 0'                          count: serializedDocAsByteArray.Length'                          accessCondition: accessCondition'                          options: null'                          operationContext: null);                        // If we got this far' success!                      // We can update the cached view of the remote contents.                        Volatile.Write(ref _cachedBlobData' new BlobData()                      {                          BlobContents = serializedDocAsByteArray'                          ETag = blobRef.Properties.ETag // was updated by Upload routine                      });                        return;                  }                  catch (StorageException ex)                      when (ex.RequestInformation.HttpStatusCode == 409 || ex.RequestInformation.HttpStatusCode == 412)                  {                      // 409 Conflict                      // This error is rare but can be thrown in very special circumstances'                      // such as if the blob in the process of being created. We treat it                      // as equivalent to 412 for the purposes of retry logic.                        // 412 Precondition Failed                      // We'll get this error if another writer updated the repository and we                      // have an outdated view of its contents. If this occurs' we'll just                      // refresh our view of the remote contents and try again up to the max                      // retry limit.                        lastError = ExceptionDispatchInfo.Capture(ex);                  }              }
