Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The method has 113 lines of code.
Complex Method,Mathos,Matrix,C:\repos\MathosProject_Mathos-Project\Mathos\Matrix.cs,RREF,Cyclomatic complexity of the method is 12
Complex Method,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,Cyclomatic complexity of the method is 9
Long Parameter List,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,SystemOfTwoEquations,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The method has 5 parameters. Parameters: function' lowerLimit' upperLimit' integrationAlgorithm' numberOfIntervals
Long Parameter List,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The method has 6 parameters. Parameters: sideA' sideB' sideC' angleA' angleB' angleC
Long Parameter List,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,FibMatrix,The method has 5 parameters. Parameters: n' i' h' j' k
Long Parameter List,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,RemainingBalanceOfAnnuity,The method has 5 parameters. Parameters: originalValue' payment' ratePerPeriod' numberOfPeriods' round
Long Statement,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBig,The length of the statement  "                newArr[j - i] = numArr[j];//C# is not my first language so if there is a one line code for this please replace it with this " is 123.
Long Statement,Mathos.Arithmetic,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,Sqrt,The length of the statement  "                //decimal y = Math.Sign(number.imaginaryPart) * (decimal)Math.Sqrt((Math.Sqrt((double)sumofPowers) - (double)number.realPart) / 2); " is 131.
Long Statement,ComplexNumbers,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,Sqrt,The length of the statement  "                //decimal y = Math.Sign(number.imaginaryPart) * (decimal)Math.Sqrt((Math.Sqrt((double)sumofPowers) - (double)number.realPart) / 2); " is 131.
Long Statement,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The length of the statement  "            if (Convert.ToDouble(minutes) < 10 && Convert.ToDouble(minutes) >= 0) //if minutes are less than then then before value of minutes add zero " is 139.
Long Statement,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The length of the statement  "            if (Convert.ToDouble(stringSeconds) < 10 && Convert.ToDouble(stringSeconds) >= 0) //if seconds are less than then then before value of seconds add zero " is 151.
Long Statement,Mathos.Geometry.Shapes,Trapezoid,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Trapezoid.cs,Equals,The length of the statement  "            return (other != null) && (Math.Abs(_baseOne - other._baseOne) < 1) && (Math.Abs(_baseTwo - other._baseTwo) < 1) && (Math.Abs(_height - other._height) < 1); " is 156.
Long Statement,Mathos.Geometry.Shapes,Trapezoid,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Trapezoid.cs,Equals,The length of the statement  "            return (other != null) && (Math.Abs(_baseOne - other._baseOne) < 1) && (Math.Abs(_baseTwo - other._baseTwo) < 1) && (Math.Abs(_height - other._height) < 1); " is 156.
Long Statement,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Equals,The length of the statement  "            return other != null && (Math.Abs(_sideA - other._sideA) < 1 && Math.Abs(_sideB - other._sideB) < 1) && Math.Abs(_sideC - other._sideC) < 1 && Math.Abs(_angleA - other._angleA) < 1 && Math.Abs(_angleB - other._angleB) < 1 && Math.Abs(_angleC - other._angleC) < 1; " is 263.
Long Statement,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Equals,The length of the statement  "            return other != null && (Math.Abs(_sideA - other._sideA) < 1 && Math.Abs(_sideB - other._sideB) < 1) && Math.Abs(_sideC - other._sideC) < 1 && Math.Abs(_angleA - other._angleA) < 1 && Math.Abs(_angleB - other._angleB) < 1 && Math.Abs(_angleC - other._angleC) < 1; " is 263.
Long Statement,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,GetHashCode,The length of the statement  "            return SideA.GetHashCode() ^ SideB.GetHashCode() ^ SideC.GetHashCode() ^ AngleA.GetHashCode() ^ AngleB.GetHashCode() ^ AngleC.GetHashCode(); " is 140.
Long Statement,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The length of the statement  "                    var zero = uncertaintySigFig-temp.ToString(CultureInfo.InvariantCulture).Length; // unsure about this step' although it is good when avoiding cases like 0.001500 (the extra zeroes at the end) " is 191.
Long Statement,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The length of the statement  "                value = Convert.ToDecimal(string.Format("{{0:F" + (uncertainty.ToString(CultureInfo.InvariantCulture).Length-2) + "}}"' value - decimal.Floor(value))) + decimal.Floor(value) ; " is 175.
Long Statement,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The length of the statement  "                        var num = 1 / PowD(10' uncertainty.ToString(CultureInfo.InvariantCulture).Length - 2) * 0.1M; // important that y is an uint. " is 125.
Long Statement,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The length of the statement  "                value = Convert.ToDecimal( Convert.ToDouble(string.Format("{{0:G" + (decimal.Floor(value).ToString(CultureInfo.InvariantCulture).Length- uncertainty.ToString(CultureInfo.InvariantCulture).Length+1) + "}}"' decimal.Floor( value))));//Decimal.Round(Decimal.Floor(value)' uncertaintySigFig); " is 288.
Long Statement,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,NetPresentValue,The length of the statement  "            var netPresentValue = initialInvestment*-1 + cashFlow.Select((t' i) => t/DecimalPower(1 + rateOfReturn/100' i + 1)).Sum(temp => round ? Math.Round(temp' 2) : temp); " is 164.
Long Statement,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,PresentValueOfAnnuity,The length of the statement  "            var presentValueOfAnnuity = periodicPayment * ((1 - DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods * -1)) / (ratePerPeriod / 100)); " is 138.
Long Statement,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,FutureValueOfAnnuity,The length of the statement  "            var futureValueOfAnnuity = periodicPayment * ((DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods) - 1) / (ratePerPeriod / 100)); " is 132.
Long Statement,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,AnnuityPaymentPresentValue,The length of the statement  "            var annuityPayment = presentValue * ratePerPeriod / 100 / (1 - DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods * -1)); " is 124.
Long Statement,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,RemainingBalanceOfAnnuity,The length of the statement  "            var remaining = FutureValue(originalValue' ratePerPeriod' numberOfPeriods' false) - FutureValueOfAnnuity(payment' ratePerPeriod' numberOfPeriods' false); " is 153.
Long Statement,TwoDimensional,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,Distance,The length of the statement  "                    return Convert.ToDecimal(Math.Sqrt(Math.Pow((double)coordinateA.X.ToDecimal() - (double)coordinateB.X.ToDecimal()' 2) + Math.Pow((double)coordinateA.Y.ToDecimal() - (double)coordinateB.Y.ToDecimal()' 2))); " is 205.
Long Statement,Mathos.Geometry,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,Distance,The length of the statement  "                    return Convert.ToDecimal(Math.Sqrt(Math.Pow((double)coordinateA.X.ToDecimal() - (double)coordinateB.X.ToDecimal()' 2) + Math.Pow((double)coordinateA.Y.ToDecimal() - (double)coordinateB.Y.ToDecimal()' 2))); " is 205.
Complex Conditional,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The conditional expression  "Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1"  is complex.
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquation,The following statement contains a magic number: var discriminant = Math.Pow(b' 2) - 4 * a * c;
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquation,The following statement contains a magic number: var discriminant = Math.Pow(b' 2) - 4 * a * c;
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquation,The following statement contains a magic number: var q = -(b + Math.Sign(b) * ComplexArithmetic.Sqrt(discriminant)) / 2;
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquationEx,The following statement contains a magic number: var discriminant = Math.Pow(b' 2) - 4 * a * c;
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquationEx,The following statement contains a magic number: var discriminant = Math.Pow(b' 2) - 4 * a * c;
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquationEx,The following statement contains a magic number: var q = -(b + Math.Sign(b) * ComplexArithmetic.Sqrt(discriminant)) / 2;
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquation,The following statement contains a magic number: var discriminant = b * b - 4 * a * c;
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquation,The following statement contains a magic number: var x1 = (b * -1 + Complex.Sqrt(discriminant)) / (2 * a);
Magic Number,Mathos,EquationSolver,C:\repos\MathosProject_Mathos-Project\Mathos\Algebra.cs,QuadraticEquation,The following statement contains a magic number: var x2 = (b * -1 - Complex.Sqrt(discriminant)) / (2 * a);
Magic Number,Mathos,Fraction,C:\repos\MathosProject_Mathos-Project\Mathos\Fraction.cs,GetHashCode,The following statement contains a magic number: return unchecked (_denominator.GetHashCode() * 397) ^ Numerator.GetHashCode();
Magic Number,Mathos,Fraction,C:\repos\MathosProject_Mathos-Project\Mathos\Fraction.cs,FromSternBrocotSystem,The following statement contains a magic number: for (var i = matArray.Length - 2; i >= 0; i--)                  matArray[i] *= matArray[i + 1];
Magic Number,Mathos,Fraction,C:\repos\MathosProject_Mathos-Project\Mathos\Fraction.cs,ToSternBrocotSystem,The following statement contains a magic number: if (continious)              {                  var integerPart = Convert.ToInt64(decimal.Floor(realNumber));                  //long fractionalPart = Convert.ToInt64(realNumber - decimal.Floor(realNumber));                  var fractionalPart =                      Convert.ToInt64(                          realNumber.ToString(CultureInfo.InvariantCulture)                                    .Substring(                                        realNumber.ToString(CultureInfo.InvariantCulture)                                                  .IndexOf("."' StringComparison.Ordinal) + 1));                    output =                  (integerPart +                   new Fraction(fractionalPart'                       Convert.ToInt64(Math.Pow(10' fractionalPart.ToString(CultureInfo.InvariantCulture).Length)) -                       1)).ToSternBrocotSystem();              }              else              {                  for (var i = 0; i < iterations; i++)                  {                      if (realNumber < 1)                      {                          output += "L";                          realNumber = realNumber / (1 - realNumber);                      }                      else                      {                          output += "R";                          realNumber = realNumber - 1;                      }                  }              }
Magic Number,Mathos,Matrix,C:\repos\MathosProject_Mathos-Project\Mathos\Matrix.cs,Determinant,The following statement contains a magic number: if (colNum == 2)                  detNum = this[0][0] * this[1][1] - this[0][1] * this[1][0];              else              {                  for (var i = 0; i < colNum; i++)                  {                      var x = new Matrix(this' 0' i);                        detNum += this[0][i] * x.Determinant() * (int)Math.Pow(-1' i);                  }              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBig,The following statement contains a magic number: const int maxsize = 6000;
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBig,The following statement contains a magic number: for (count = 2; count <= n; count++)            //calculates the large number resulting from the factorial operation              {                  while (i > 0)                  {                      var total = numArr[i] * count + rem;    //rem use to save remainder of division(Carry Number).                                                rem = 0;                                                if (total > 9)                      {                          numArr[i] = total % 10;                          rem = total / 10;                      }                      else                          numArr[i] = total;                        i--;                  }                    rem = 0;                  i = maxsize - 1;              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBig,The following statement contains a magic number: for (count = 2; count <= n; count++)            //calculates the large number resulting from the factorial operation              {                  while (i > 0)                  {                      var total = numArr[i] * count + rem;    //rem use to save remainder of division(Carry Number).                                                rem = 0;                                                if (total > 9)                      {                          numArr[i] = total % 10;                          rem = total / 10;                      }                      else                          numArr[i] = total;                        i--;                  }                    rem = 0;                  i = maxsize - 1;              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBig,The following statement contains a magic number: for (count = 2; count <= n; count++)            //calculates the large number resulting from the factorial operation              {                  while (i > 0)                  {                      var total = numArr[i] * count + rem;    //rem use to save remainder of division(Carry Number).                                                rem = 0;                                                if (total > 9)                      {                          numArr[i] = total % 10;                          rem = total / 10;                      }                      else                          numArr[i] = total;                        i--;                  }                    rem = 0;                  i = maxsize - 1;              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBig,The following statement contains a magic number: for (count = 2; count <= n; count++)            //calculates the large number resulting from the factorial operation              {                  while (i > 0)                  {                      var total = numArr[i] * count + rem;    //rem use to save remainder of division(Carry Number).                                                rem = 0;                                                if (total > 9)                      {                          numArr[i] = total % 10;                          rem = total / 10;                      }                      else                          numArr[i] = total;                        i--;                  }                    rem = 0;                  i = maxsize - 1;              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBigInteger,The following statement contains a magic number: var start = 2;
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBigInteger,The following statement contains a magic number: if (n%2 == 0)                  start = 1;
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBigInteger,The following statement contains a magic number: for (BigInteger i = start; i < n; i = i + 2)              {                  var j = i * (i + 1);                      while (j % 2 == 0)                  {                      numTwo++;                      j >>= 1;                  }                    fact *= j;              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,FactorialBigInteger,The following statement contains a magic number: for (BigInteger i = start; i < n; i = i + 2)              {                  var j = i * (i + 1);                      while (j % 2 == 0)                  {                      numTwo++;                      j >>= 1;                  }                    fact *= j;              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,Factors,The following statement contains a magic number: for (long i = 2; i <= max; i++)              {                  if (num%i != 0)                      continue;                                        if (Check.IsPrime(i))                      yield return i;                  else                  {                      var tmpI = i;                        foreach (var factor in Factors(i).Where(factor => Check.IsPrime(tmpI)))                          yield return i;                  }              }
Magic Number,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,IntPower,The following statement contains a magic number: var n = 15;
Magic Number,Mathos.Arithmetic.Numbers,Check,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Check.cs,IsOdd,The following statement contains a magic number: if (num < 0)                  return num % 2 != 0;
Magic Number,Mathos.Arithmetic.Numbers,Check,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Check.cs,IsPrime,The following statement contains a magic number: if (num % 2 == 0) //even numbers>2 are not prime (2 is included in the common prime numbers)                  return false;
Magic Number,Mathos.Arithmetic.Numbers,Check,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Check.cs,IsPrime,The following statement contains a magic number: for (long i = 2; i <= sqrtNum; i++)              {                  if (num%i == 0)                      return false; // not a prime              }
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,RootOf,The following statement contains a magic number: var newPhase = phase / n + Math.PI * 2 * (index - 1) / n;
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,Sqrt,The following statement contains a magic number: if (Math.Abs(x - y) > 0)              {                  double r;                    if (xAbs >= yAbs)                  {                      r = y / x;                      w = Math.Sqrt(xAbs) *                          Math.Sqrt(                          (1 + Math.Sqrt(1 + r * r))                          / 2);                  }                  else                  {                      r = x / y;                      w = Math.Sqrt(yAbs) *                          Math.Sqrt(                          (Math.Abs(r) + Math.Sqrt(1 + r * r))                          / 2);                  }              }
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,Sqrt,The following statement contains a magic number: if (Math.Abs(x - y) > 0)              {                  double r;                    if (xAbs >= yAbs)                  {                      r = y / x;                      w = Math.Sqrt(xAbs) *                          Math.Sqrt(                          (1 + Math.Sqrt(1 + r * r))                          / 2);                  }                  else                  {                      r = x / y;                      w = Math.Sqrt(yAbs) *                          Math.Sqrt(                          (Math.Abs(r) + Math.Sqrt(1 + r * r))                          / 2);                  }              }
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,Sqrt,The following statement contains a magic number: if (x >= 0)                  return new Complex(w' y/(2*w));
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,Sqrt,The following statement contains a magic number: return y >= 0 ? new Complex(yAbs/(2*w)' w) : new Complex(yAbs/(2*w)' -w);
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,Sqrt,The following statement contains a magic number: return y >= 0 ? new Complex(yAbs/(2*w)' w) : new Complex(yAbs/(2*w)' -w);
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,FromString,The following statement contains a magic number: if ((outStr.Length == 1) && !isImaginaryPart || outStr.Length > 2)                  double.TryParse(outStr[0]' out realPart);
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,Modulus,The following statement contains a magic number: return Math.Abs(c.Real) >= Math.Abs(c.Imaginary)                  ? Math.Abs(c.Real)*Math.Sqrt(1 + Math.Pow(c.Imaginary/c.Real' 2))                  : Math.Abs(c.Imaginary)*Math.Sqrt(1 + Math.Pow(c.Real/c.Imaginary' 2));
Magic Number,Mathos.Arithmetic,ComplexArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexArithmetic.cs,Modulus,The following statement contains a magic number: return Math.Abs(c.Real) >= Math.Abs(c.Imaginary)                  ? Math.Abs(c.Real)*Math.Sqrt(1 + Math.Pow(c.Imaginary/c.Real' 2))                  : Math.Abs(c.Imaginary)*Math.Sqrt(1 + Math.Pow(c.Real/c.Imaginary' 2));
Magic Number,Mathos.Arithmetic,ComplexNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,ComplexNumber,The following statement contains a magic number: if ((outStr.Length == 1) && !isImaginaryPart || outStr.Length > 2)                  {                      Double.TryParse(outStr[0]' out _realPart);                  }
Magic Number,Mathos.Arithmetic,ComplexNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      return (_realPart.GetHashCode() * 397) ^ _imaginaryPart.GetHashCode();                  }
Magic Number,Mathos.Arithmetic,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,LogOfAbs,The following statement contains a magic number: return Math.Log(max) + 0.5 * Elementary.LogOfOnePlusX(u * u);
Magic Number,Mathos.Arithmetic,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,Sqrt,The following statement contains a magic number: return ComplexNumber.FromPolar(Math.Sqrt(number.Modulus)'                      number.Argument / 2);
Magic Number,Mathos.Arithmetic,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,Roots,The following statement contains a magic number: var delta = 2 * Math.PI / n;
Magic Number,Mathos.Arithmetic,DecimalArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\DecimalArithmetic.cs,Ln,The following statement contains a magic number: if ((x < 1) || ((-x < 1) && (x <0)))              {                  for (var i = 1; i < degreeOfTaylorPolynomial; i++)                  {                      decimal vec = i % 2 == 1 ? 1 : -1;                        vec *= Pow(x - 1' i) / i;                      val += vec;                  }              }              else              {                  for (var i = 1; i < degreeOfTaylorPolynomial; i++)                      val += decimal.Divide(1' i)*Pow((x - 1)/x' i);              }
Magic Number,Mathos.Arithmetic,DoubleArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\DoubleArithmetic.cs,Hypotenuse,The following statement contains a magic number: if (Math.Abs(min - max) < 1)                  return max * 2.0;
Magic Number,Mathos.Arithmetic,IntegerArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\IntegerArithmetic.cs,Sqrt,The following statement contains a magic number: var bit = 1 << 14;
Magic Number,Mathos.Arithmetic,IntegerArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\IntegerArithmetic.cs,Sqrt,The following statement contains a magic number: while (bit > number)                  bit >>= 2;
Magic Number,Mathos.Arithmetic,IntegerArithmetic,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\IntegerArithmetic.cs,Sqrt,The following statement contains a magic number: while (bit != 0)              {                  if (number >= res + bit)                  {                      number -= res + bit;                      res = (res >> 1) + bit;                  }                  else                      res >>= 1;                    bit >>= 2;              }
Magic Number,ComplexNumbers,ComplexNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,ComplexNumber,The following statement contains a magic number: if ((outStr.Length == 1) && !isImaginaryPart || outStr.Length > 2)                  {                      Double.TryParse(outStr[0]' out _realPart);                  }
Magic Number,ComplexNumbers,ComplexNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      return (_realPart.GetHashCode() * 397) ^ _imaginaryPart.GetHashCode();                  }
Magic Number,ComplexNumbers,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,LogOfAbs,The following statement contains a magic number: return Math.Log(max) + 0.5 * Elementary.LogOfOnePlusX(u * u);
Magic Number,ComplexNumbers,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,Sqrt,The following statement contains a magic number: return ComplexNumber.FromPolar(Math.Sqrt(number.Modulus)'                      number.Argument / 2);
Magic Number,ComplexNumbers,ComplexOperation,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\ComplexNumber.cs,Roots,The following statement contains a magic number: var delta = 2 * Math.PI / n;
Magic Number,Mathos.Calculus,DifferentialCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\DifferentialCalculus.cs,FirstDerivative,The following statement contains a magic number: return (function(xPoint + h) - function(xPoint - h))/(2*h);
Magic Number,Mathos.Calculus,DifferentialCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\DifferentialCalculus.cs,SecondDerivative,The following statement contains a magic number: return (function(xPoint + h) - 2*function(xPoint) + function(xPoint - h))/decimal.Multiply(h' h);
Magic Number,Mathos.Calculus,DifferentialCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\DifferentialCalculus.cs,SecondDerivative,The following statement contains a magic number: return (function(points) - 2*value1 + value2)/decimal.Multiply(h' h);
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,LogOfAbs,The following statement contains a magic number: return Math.Log(max) + 0.5 * LogOfOnePlusX(u * u);
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,LogOfOnePlusX,The following statement contains a magic number: if (z > 0.75)                  return Math.Log(y);
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,LogOfOnePlusX,The following statement contains a magic number: if (z > 1e-4)                  return x*Math.Log(y)/(y - 1.0);
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,LogOfOnePlusX,The following statement contains a magic number: if (z > 1e-16)                  return (-0.5*x + 1.0)*x;
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,LogOfOnePlusX,The following statement contains a magic number: if (z > 1e-16)                  return (-0.5*x + 1.0)*x;
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,ExpOfXMinusOne,The following statement contains a magic number: if (z > 1e-5)                  return Math.Exp(x) - 1.0;
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,ExpOfXMinusOne,The following statement contains a magic number: if (z > 1e-16)                  return x + 0.5*x*x;
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,ExpOfXMinusOne,The following statement contains a magic number: if (z > 1e-16)                  return x + 0.5*x*x;
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,TimesTwoTo,The following statement contains a magic number: return x * DoubleArithmetic.PowInt(2.0' n);
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,Decompose,The following statement contains a magic number: while (Math.Abs(f) >= 1.0)              {                  ei++;                  f /= 2;              }
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,Decompose,The following statement contains a magic number: while (Math.Abs(f) < 0.5)              {                  ei--;                  f *= 2.0;              }
Magic Number,Mathos.Calculus,Elementary,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\Elementary.Complex.cs,Decompose,The following statement contains a magic number: while (Math.Abs(f) < 0.5)              {                  ei--;                  f *= 2.0;              }
Magic Number,Mathos.Calculus,FiniteCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\FiniteCalculus.cs,GetExpressionForNthTerm,The following statement contains a magic number: for (var i = 0; i < coefficients.Length; i++)              {                  coefficients[i] = Math.Round(coefficients[i]' round);                    if (Math.Abs(coefficients[i]) > 0 && i < coefficients.Length - 1)                  {                      if (Math.Abs(coefficients[i] - 1) > 1 || Math.Abs(coefficients[i] - 1) < 1)                          expr += coefficients[i].ToString(CultureInfo.InvariantCulture) + variable;                      else                          expr += variable;                        if (i < coefficients.Length - 2)                          expr += "^" + (coefficients.Length - i - 1);                  }                  else                  {                      if (Math.Abs(coefficients[i]) > 0)                          expr += coefficients[i].ToString(CultureInfo.InvariantCulture);                  }                    if (i >= coefficients.Length - 1)                      continue;                    coefficients[i + 1] = Math.Round(coefficients[i + 1]' round);                    if (coefficients[i + 1] > 0)                      expr += "+";              }
Magic Number,Mathos.Calculus,FiniteCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\FiniteCalculus.cs,GetDifference,The following statement contains a magic number: var evenStart = (term + degree)%2 == 0;
Magic Number,Mathos.Calculus,FiniteCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\FiniteCalculus.cs,GetDifference,The following statement contains a magic number: for (var i = term + degree; j <= degree; i--)              {                  result += Pascal(degree' j)*sequence[i]*(evenStart ? (i%2 == 0 ? 1 : -1) : (i%2 == 0 ? -1 : 1));                  j++;              }
Magic Number,Mathos.Calculus,FiniteCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\FiniteCalculus.cs,GetDifference,The following statement contains a magic number: for (var i = term + degree; j <= degree; i--)              {                  result += Pascal(degree' j)*sequence[i]*(evenStart ? (i%2 == 0 ? 1 : -1) : (i%2 == 0 ? -1 : 1));                  j++;              }
Magic Number,Mathos.Calculus,FiniteCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\FiniteCalculus.cs,GetNextTerm,The following statement contains a magic number: var evenStart = (term + constantIndex - 1)%2 == 0;
Magic Number,Mathos.Calculus,FiniteCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\FiniteCalculus.cs,GetNextTerm,The following statement contains a magic number: for (var i = term + constantIndex - 1; j <= constantIndex - 1; i--)              {                  result += Pascal(constantIndex - 1' j)*sequence[i]*                            (evenStart ? (i%2 == 0 ? 1 : -1) : (i%2 == 0 ? -1 : 1));                  j++;              }
Magic Number,Mathos.Calculus,FiniteCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\FiniteCalculus.cs,GetNextTerm,The following statement contains a magic number: for (var i = term + constantIndex - 1; j <= constantIndex - 1; i--)              {                  result += Pascal(constantIndex - 1' j)*sequence[i]*                            (evenStart ? (i%2 == 0 ? 1 : -1) : (i%2 == 0 ? -1 : 1));                  j++;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Calculus,IntegralCalculus,C:\repos\MathosProject_Mathos-Project\Mathos\Calculus\IntegralCalculus.cs,Integrate,The following statement contains a magic number: switch (integrationAlgorithm)              {                  case IntegrationAlgorithm.RectangleMethod:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        for (var i = 0; i < numberOfIntervals; i++)                          sum += function(lowerLimit + sizeOfInterval*i)*sizeOfInterval;                        return sum;                  }                  case IntegrationAlgorithm.TrapezoidalRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit) + function(upperLimit);                        for (var i = 1; i < numberOfIntervals; i++)                          sum += 2*function(lowerLimit + i*sizeOfInterval);                        return sum*sizeOfInterval/2;                  }                  case IntegrationAlgorithm.SimpsonsRule:                  {                      var sizeOfInterval = (upperLimit - lowerLimit)/numberOfIntervals;                        sum = function(lowerLimit);                        for (var i = 1; i < numberOfIntervals; i += 2)                          sum += 4*function(lowerLimit + sizeOfInterval*i);                        for (var i = 2; i < numberOfIntervals - 1; i += 2)                          sum += 2*function(lowerLimit + sizeOfInterval*i);                        sum += function(upperLimit);                        return sum*sizeOfInterval/3;                  }                  default:                      return 0;              }
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,AngleToDecimalAngle,The following statement contains a magic number: var minutes = Math.Truncate((angle - degrees) * 100);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,AngleToDecimalAngle,The following statement contains a magic number: var decimalMinutes = minutes / 60;
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,AngleToDecimalAngle,The following statement contains a magic number: var seconds = Math.Round((angle * 100 - Math.Truncate(angle * 100)) * 100' 0);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,AngleToDecimalAngle,The following statement contains a magic number: var seconds = Math.Round((angle * 100 - Math.Truncate(angle * 100)) * 100' 0);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,AngleToDecimalAngle,The following statement contains a magic number: var seconds = Math.Round((angle * 100 - Math.Truncate(angle * 100)) * 100' 0);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,AngleToDecimalAngle,The following statement contains a magic number: var decimalSeconds = seconds / 3600;
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The following statement contains a magic number: var minutes = Math.Truncate(decimalMinutesAndSeconds * 60);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The following statement contains a magic number: var seconds = Math.Round((decimalMinutesAndSeconds * 60 - minutes) * 60' 0);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The following statement contains a magic number: var seconds = Math.Round((decimalMinutesAndSeconds * 60 - minutes) * 60' 0);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The following statement contains a magic number: if (Convert.ToDouble(minutes) < 10 && Convert.ToDouble(minutes) >= 0) //if minutes are less than then then before value of minutes add zero                  stringMinutes = "0" + stringMinutes;
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The following statement contains a magic number: if (Convert.ToDouble(stringSeconds) < 10 && Convert.ToDouble(stringSeconds) >= 0) //if seconds are less than then then before value of seconds add zero                  stringSeconds = "0" + stringSeconds;
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,DecimalAngleToAngle,The following statement contains a magic number: angle = Math.Round(Convert.ToDouble(ugaoB)' 4);
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,AngleToRadians,The following statement contains a magic number: return angle * Math.PI / 180;
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,RadiansToDecimalAngle,The following statement contains a magic number: return radians * 180 / Math.PI;
Magic Number,Mathos.Converter,AngleConverter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\AngleConverter.cs,RadiansToAngle,The following statement contains a magic number: radians = radians * 180 / Math.PI;
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Converter,The following statement contains a magic number: UnitConversions = new Dictionary<Enum' double>              {                  // Angle Conversions                  {Angle.Degree' 57.295779513082323}'                  {Angle.Gradian' 63.661977236758133}'                  {Angle.Radian' 1}'                    // Length Conversions                  {Length.Centimeter' 100}'                  {Length.Foot' 3.28084}'                  {Length.Inch' 39.3701}'                  {Length.Kilometer' 0.001}'                  {Length.Meter' 1}'                  {Length.Millimeter' 1000}'                  {Length.Mile' 0.000621371}'                  {Length.NauticalMile' 0.000539957}'                  {Length.Yard' 1.09361}'                    // Speed Conversions                  {Speed.FeetPerSecond' 3.28084}'                  {Speed.KilometersPerHour' 3.6}'                  {Speed.Knot' 1.94384}'                  {Speed.MetersPerSecond' 1}'                  {Speed.MilesPerHour' 2.23694}'                    // Mass Conversions                  {Mass.Gram' 1000}'                  {Mass.Kilogram' 1}'                  {Mass.LongTon' 0.000984207}'                  {Mass.MetricTon' 0.001}'                  {Mass.Milligram' 1000000}'                  {Mass.Ounce' 35.274}'                  {Mass.Pound' 2.20462}'                  {Mass.ShortTon' 0.00110231}'                  {Mass.Stone' 0.157473}'                    // Volume Conversions                  {Volume.CubicFoot' 0.0353147}'                  {Volume.CubicInch' 61.0237}'                  {Volume.CubicMeter' 0.001}'                  {Volume.CupUs' 4.22675}'                  {Volume.GallonImp' 0.219969}'                  {Volume.GallonUs' 0.264172}'                  {Volume.Liter' 1}'                  {Volume.Milliliter' 1000}'                  {Volume.OzImp' 35.1951}'                  {Volume.OzUs' 33.814}'                  {Volume.PintImp' 1.75975}'                  {Volume.PintUs' 2.11338}'                  {Volume.QuartImp' 0.879877}'                  {Volume.QuartUs' 1.05669}'                  {Volume.TablespoonImp' 56.3121}'                  {Volume.TablespoonUs' 67.628}'                  {Volume.TeaspoonImp' 168.936}'                  {Volume.TeaspoonUs' 202.884}'                    // Area Conversion                  {Area.SquareKilometer' 0.000001}'                  {Area.Hectare' 0.0001}'                  {Area.SquareMile' 0.0000003861}'                  {Area.SquareMeter' 1}'                  {Area.Acre' 0.000247105}'                  {Area.SquareYard' 1.19599}'                  {Area.SquareFoot' 10.7639}'                  {Area.SquareInch' 1550}'                    // Pressure Conversion                  {Pressure.Pascal' 1}'                  {Pressure.Hectopascal' 100}'                  {Pressure.Kilopascal' 1000}'                  {Pressure.Bar' 0.00001}'                  {Pressure.At' 0.0000101971621298}'                  {Pressure.Atm' 0.00000986923267}'                  {Pressure.Psi' 0.000145037738}'                  {Pressure.MmHg' 0.00750061683}'                    // Power Conversion                  {Power.Milliwatt' 1000}'                  {Power.Watt' 1}'                  {Power.Kilowatt' 0.001}'                  {Power.Megawatt' 0.000001}'                  {Power.JoulesMin' 60}'                  {Power.MetricHp' 0.001359621617303904}'                  {Power.MechanicalHp' 0.001341022071853089}'                  {Power.ElectricalHp' 0.001340482573726541}'                  {Power.FtLbMin' 44.2537289566362}'                  {Power.FtLbSec' 0.73756214927727}'                  {Power.KgfMeterSec' 0.101971621}'                  {Power.KgfMeterMin' 6.11829728}'                    //Temperature Conversions                  {Temperature.DegreeC' 1}' // we have to refer to TemperatureConverter                  {Temperature.DegreeK' 274.15}'                  {Temperature.DegreeF' 33.8}              };
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Encode,The following statement contains a magic number: if (toBase < 2 || toBase > 36)                  throw new ArgumentOutOfRangeException("toBase"' "Value must be between 2 and 36");
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Encode,The following statement contains a magic number: if (toBase < 2 || toBase > 36)                  throw new ArgumentOutOfRangeException("toBase"' "Value must be between 2 and 36");
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Decode,The following statement contains a magic number: if (fromBase < 2 || fromBase > 36)                  throw new ArgumentOutOfRangeException("fromBase"' "Value must be between 2 and 36");
Magic Number,Mathos.Converter,Converter,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\Converter.cs,Decode,The following statement contains a magic number: if (fromBase < 2 || fromBase > 36)                  throw new ArgumentOutOfRangeException("fromBase"' "Value must be between 2 and 36");
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeC && (Temperature) unit == Temperature.DegreeK)                  return conversionInfo.Value + 273.15;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeC && (Temperature) unit == Temperature.DegreeF)                  return conversionInfo.Value*9/5 + 32;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeC && (Temperature) unit == Temperature.DegreeF)                  return conversionInfo.Value*9/5 + 32;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeC && (Temperature) unit == Temperature.DegreeF)                  return conversionInfo.Value*9/5 + 32;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeF && (Temperature) unit == Temperature.DegreeC)                  return (conversionInfo.Value - 32)*5/9;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeF && (Temperature) unit == Temperature.DegreeC)                  return (conversionInfo.Value - 32)*5/9;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeF && (Temperature) unit == Temperature.DegreeC)                  return (conversionInfo.Value - 32)*5/9;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeF && (Temperature) unit == Temperature.DegreeK)                  return (conversionInfo.Value - 32)*5/9 + 273.15;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeF && (Temperature) unit == Temperature.DegreeK)                  return (conversionInfo.Value - 32)*5/9 + 273.15;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeF && (Temperature) unit == Temperature.DegreeK)                  return (conversionInfo.Value - 32)*5/9 + 273.15;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeF && (Temperature) unit == Temperature.DegreeK)                  return (conversionInfo.Value - 32)*5/9 + 273.15;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeK && (Temperature) unit == Temperature.DegreeF)                  return (conversionInfo.Value - 273.15)*9/5 + 32;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeK && (Temperature) unit == Temperature.DegreeF)                  return (conversionInfo.Value - 273.15)*9/5 + 32;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeK && (Temperature) unit == Temperature.DegreeF)                  return (conversionInfo.Value - 273.15)*9/5 + 32;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeK && (Temperature) unit == Temperature.DegreeF)                  return (conversionInfo.Value - 273.15)*9/5 + 32;
Magic Number,Mathos.Converter,TemperatureConversion,C:\repos\MathosProject_Mathos-Project\Mathos\Converter\TemperatureConverter.cs,ConvertTemperature,The following statement contains a magic number: if ((Temperature) conversionInfo.Unit == Temperature.DegreeK && (Temperature) unit == Temperature.DegreeC)                  return conversionInfo.Value - 273.15;
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: _angleC = 90;
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: _angleA = _angleB - 90;
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: _angleC = 90;
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: _angleA = _angleB - 90;
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.Geometry.Shapes,Triangle,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\Shapes\Triangle.cs,Triangle,The following statement contains a magic number: while (Math.Abs(_sideA) < 1 || Math.Abs(_sideB) < 1 || Math.Abs(_sideC) < 1 || Math.Abs(_angleA) < 1 ||                     Math.Abs(_angleB) < 1 || Math.Abs(_angleC) < 1)              {                  c++;                    if (Math.Abs(_angleA) < 1)                  {                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(B)/b)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleB + _angleC)                          : _angleA;                      //in case of two known angles third angle = (180-sum of two angles)                      _angleA = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleA;                      //in case of SSA (two sides and an angle is known )A=Sin_inverse(a*sin(C)/c)                      _angleA = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*Math.Asin(_sideA*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleA;                      //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                      _angleA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideC*_sideC - _sideA*_sideA)/                                      (2.0*_sideB*_sideC))                          : _angleA; //in case of SSS (all sides are known) A=Cos_inverse((b^2 + c^2 - a^2)/2bc)                  }                  if (Math.Abs(_angleB) < 1) //similar to angleA                  {                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0                          ? 180 - (_angleA + _angleC)                          : _angleB;                      _angleB = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleB;                      _angleB = Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideB) > 0                          ? 180/Math.PI*Math.Asin(_sideB*Math.Sin(Math.PI/180*_angleC)/_sideC)                          : _angleB;                      _angleB = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideC*_sideC + _sideA*_sideA - _sideB*_sideB)/                                      (2.0*_sideC*_sideA))                          : _angleB;                  }                  if (Math.Abs(_angleC) < 1) //similar to angleA                  {                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0                          ? 180 - (_angleA + _angleB)                          : _angleC;                      _angleC = Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleA)/_sideA)                          : _angleC;                      _angleC = Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0                          ? 180/Math.PI*Math.Asin(_sideC*Math.Sin(Math.PI/180*_angleB)/_sideB)                          : _angleC;                      _angleC = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_sideA) > 0                          ? 180/Math.PI*                            Math.Acos((_sideB*_sideB + _sideA*_sideA - _sideC*_sideC)/                                      (2.0*_sideB*_sideA))                          : _angleC;                  }                  if (Math.Abs(_sideA) < 1)                  {                      //in case of AAS (two angles and a side) a=sin(A)*(b/sin(B))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideA;                      //in case of AAS (two angles and a side) a=sin(A)*(c/sin(C))                      _sideA = Math.Abs(_angleA) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleA)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideA;                      //in case of SSA (two sides and an angle) a=sqrt(b^2 + c^2 - 2*b*c*cos(A))                      _sideA = Math.Abs(_sideB) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleA) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideC*_sideC -                                      2.0*_sideB*_sideC*Math.Cos(Math.PI/180*_angleA))                          : _sideA;                  }                  if (Math.Abs(_sideB) < 1) //similar to sideA                  {                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleC) > 0 && Math.Abs(_sideC) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideC/Math.Sin(Math.PI/180*_angleC))                          : _sideB;                      _sideB = Math.Abs(_angleB) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleB)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideB;                      _sideB = Math.Abs(_sideA) > 0 && Math.Abs(_sideC) > 0 && Math.Abs(_angleB) > 0                          ? Math.Sqrt(_sideA*_sideA + _sideC*_sideC -                                      2.0*_sideA*_sideC*Math.Cos(Math.PI/180*_angleB))                          : _sideB;                  }                  if (Math.Abs(_sideC) < 1) //similar to side A                  {                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleB) > 0 && Math.Abs(_sideB) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideB/Math.Sin(Math.PI/180*_angleB))                          : _sideC;                      _sideC = Math.Abs(_angleC) > 0 && Math.Abs(_angleA) > 0 && Math.Abs(_sideA) > 0                          ? Math.Sin(Math.PI/180*_angleC)*(_sideA/Math.Sin(Math.PI/180*_angleA))                          : _sideC;                      _sideC = Math.Abs(_sideB) > 0 && Math.Abs(_sideA) > 0 && Math.Abs(_angleC) > 0                          ? Math.Sqrt(_sideB*_sideB + _sideA*_sideA -                                      2.0*_sideB*_sideA*Math.Cos(Math.PI/180*_angleC))                          : _sideC;                  }                    if (c == 3) //did not get time to test out if while loop is required here or to find the optimum c                      throw new InvalidTriangleException("Given information do not form a triangle");              }
Magic Number,Mathos.PreCalculus,ArithmeticSequence,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\ArithmeticSequence.cs,Sum,The following statement contains a magic number: var tmpLeft = (double) n/2;
Magic Number,Mathos.PreCalculus,ArithmeticSequence,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\ArithmeticSequence.cs,Sum,The following statement contains a magic number: return tmpLeft * (2 * InitialTerm + (n - 1) * CommonDifference);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,NTerm,The following statement contains a magic number: var k = 2;
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,BinetFormula,The following statement contains a magic number: return (Math.Pow((1 + Math.Sqrt(5)) / 2' n) - Math.Pow((1 - Math.Sqrt(5)) / 2' n)) / Math.Sqrt(5);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,BinetFormula,The following statement contains a magic number: return (Math.Pow((1 + Math.Sqrt(5)) / 2' n) - Math.Pow((1 - Math.Sqrt(5)) / 2' n)) / Math.Sqrt(5);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,BinetFormula,The following statement contains a magic number: return (Math.Pow((1 + Math.Sqrt(5)) / 2' n) - Math.Pow((1 - Math.Sqrt(5)) / 2' n)) / Math.Sqrt(5);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,BinetFormula,The following statement contains a magic number: return (Math.Pow((1 + Math.Sqrt(5)) / 2' n) - Math.Pow((1 - Math.Sqrt(5)) / 2' n)) / Math.Sqrt(5);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,BinetFormula,The following statement contains a magic number: return (Math.Pow((1 + Math.Sqrt(5)) / 2' n) - Math.Pow((1 - Math.Sqrt(5)) / 2' n)) / Math.Sqrt(5);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,Index,The following statement contains a magic number: var n = Math.Log(f*Math.Sqrt(5) + 0.5' phi);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,Index,The following statement contains a magic number: var n = Math.Log(f*Math.Sqrt(5) + 0.5' phi);
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,FibMatrix,The following statement contains a magic number: while (n > 0)              {                  int t;                    if (n % 2 == 1)                  {                      t = j * h;                      j = i * h + j * k + t;                      i = i * k + t;                  }                    t = h * h;                  h = 2 * k * h + t;                  k = k * k + t;                  n = n / 2;              }
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,FibMatrix,The following statement contains a magic number: while (n > 0)              {                  int t;                    if (n % 2 == 1)                  {                      t = j * h;                      j = i * h + j * k + t;                      i = i * k + t;                  }                    t = h * h;                  h = 2 * k * h + t;                  k = k * k + t;                  n = n / 2;              }
Magic Number,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,FibMatrix,The following statement contains a magic number: while (n > 0)              {                  int t;                    if (n % 2 == 1)                  {                      t = j * h;                      j = i * h + j * k + t;                      i = i * k + t;                  }                    t = h * h;                  h = 2 * k * h + t;                  k = k * k + t;                  n = n / 2;              }
Magic Number,Mathos.SpecialFunctions,GammaRelated,C:\repos\MathosProject_Mathos-Project\Mathos\SpecialFunctions\Gamma.cs,LogOfGamma,The following statement contains a magic number: if (x < 0.5)                  return LogPi - Math.Log(Math.Sin(Math.PI * x)) - LogOfGamma(1D - x);
Magic Number,Mathos.Statistics,DiceSimulator,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\DiceSimulator.cs,Roll,The following statement contains a magic number: Math.DivRem(_rnd.Next()' 6' out int nResult);
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,Median,The following statement contains a magic number: if (0 != listLength%2)                  return listSorted[(listLength + 1)/2 - 1];
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,Median,The following statement contains a magic number: if (0 != listLength%2)                  return listSorted[(listLength + 1)/2 - 1];
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,Median,The following statement contains a magic number: var leftMedian = listSorted[listLength / 2 - 1];
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,Median,The following statement contains a magic number: var rightMedian = listSorted[listLength / 2];
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,Median,The following statement contains a magic number: return (leftMedian + rightMedian) / 2;
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,RootMeanSquare,The following statement contains a magic number: try              {                  double listCount = list.Count;                  var listOfSquares = list.Select(d => Math.Pow((double) d' 2)).ToList();                    return (decimal)Math.Sqrt(1 / listCount * listOfSquares.Sum());              }              catch              {                  return 0;              }
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,Percentile,The following statement contains a magic number: var rank = (int)Math.Round(p * list.Count + 0.5' 0' MidpointRounding.AwayFromZero);
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,LowerQuartile,The following statement contains a magic number: return Percentile(list' 0.25);
Magic Number,Mathos.Statistics,StatisticalProcedures,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistics.cs,UpperQuartile,The following statement contains a magic number: return Percentile(list' 0.75);
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,UncertainNumber,The following statement contains a magic number: switch (uncertaintyType)              {                  case UncertaintyType.AbsoluteUncertainty:                      Value = value;                      Uncertainty = uncertainty;                      break;                  case UncertaintyType.RelativeUncertainty:                      Value = value;                      Uncertainty = uncertainty / 100 * value;                      break;              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,CustomFunction,The following statement contains a magic number: using (var reader = new System.IO.StringReader(tsv))              {                  string line;                  var final = new List<UncertainNumber>();                                    while ((line = reader.ReadLine()) != null)                  {                      var a = line.Split((char)9);                      var temp = new UncertainNumber[a.Length/2];                        for (var i = 0; i < a.Length; i += 2)                          temp[i] = new UncertainNumber(Convert.ToDecimal(a[i])' Convert.ToDecimal(a[i + 1]));                        final.Add(CustomFunction(function'temp));                  }                    return final.ToArray();              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,CustomFunction,The following statement contains a magic number: using (var reader = new System.IO.StringReader(tsv))              {                  string line;                  var final = new List<UncertainNumber>();                                    while ((line = reader.ReadLine()) != null)                  {                      var a = line.Split((char)9);                      var temp = new UncertainNumber[a.Length/2];                        for (var i = 0; i < a.Length; i += 2)                          temp[i] = new UncertainNumber(Convert.ToDecimal(a[i])' Convert.ToDecimal(a[i + 1]));                        final.Add(CustomFunction(function'temp));                  }                    return final.ToArray();              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,CustomFunction,The following statement contains a magic number: using (var reader = new System.IO.StringReader(tsv))              {                  string line;                  var final = new List<UncertainNumber>();                                    while ((line = reader.ReadLine()) != null)                  {                      var a = line.Split((char)9);                      var temp = new UncertainNumber[a.Length/2];                        for (var i = 0; i < a.Length; i += 2)                          temp[i] = new UncertainNumber(Convert.ToDecimal(a[i])' Convert.ToDecimal(a[i + 1]));                        final.Add(CustomFunction(function'temp));                  }                    return final.ToArray();              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The following statement contains a magic number: if(uncertainty < 1)              {                  if (uncertaintySigFig > 2)                  {                      var temp = Convert.ToDecimal( uncertainty.ToString(CultureInfo.InvariantCulture).Replace("."' "")) ;                      var zero = uncertaintySigFig-temp.ToString(CultureInfo.InvariantCulture).Length; // unsure about this step' although it is good when avoiding cases like 0.001500 (the extra zeroes at the end)                      var num = PowD(10' zero);                                            uncertainty = decimal.Ceiling(uncertainty * num) / (num * 1.0M);                  }                    value = Convert.ToDecimal(string.Format("{{0:F" + (uncertainty.ToString(CultureInfo.InvariantCulture).Length-2) + "}}"' value - decimal.Floor(value))) + decimal.Floor(value) ;              }              else              {                  if (uncertaintySigFig > 1)                  {                      uncertainty = decimal.Floor(uncertainty);                        if (uncertainty.ToString(CultureInfo.InvariantCulture).Length > 1)                      {                          var num = 1 / PowD(10' uncertainty.ToString(CultureInfo.InvariantCulture).Length - 2) * 0.1M; // important that y is an uint.                                                    uncertainty = decimal.Ceiling(uncertainty * num) / num;                      }                  }                    value = Convert.ToDecimal( Convert.ToDouble(string.Format("{{0:G" + (decimal.Floor(value).ToString(CultureInfo.InvariantCulture).Length- uncertainty.ToString(CultureInfo.InvariantCulture).Length+1) + "}}"' decimal.Floor( value))));//Decimal.Round(Decimal.Floor(value)' uncertaintySigFig);              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The following statement contains a magic number: if(uncertainty < 1)              {                  if (uncertaintySigFig > 2)                  {                      var temp = Convert.ToDecimal( uncertainty.ToString(CultureInfo.InvariantCulture).Replace("."' "")) ;                      var zero = uncertaintySigFig-temp.ToString(CultureInfo.InvariantCulture).Length; // unsure about this step' although it is good when avoiding cases like 0.001500 (the extra zeroes at the end)                      var num = PowD(10' zero);                                            uncertainty = decimal.Ceiling(uncertainty * num) / (num * 1.0M);                  }                    value = Convert.ToDecimal(string.Format("{{0:F" + (uncertainty.ToString(CultureInfo.InvariantCulture).Length-2) + "}}"' value - decimal.Floor(value))) + decimal.Floor(value) ;              }              else              {                  if (uncertaintySigFig > 1)                  {                      uncertainty = decimal.Floor(uncertainty);                        if (uncertainty.ToString(CultureInfo.InvariantCulture).Length > 1)                      {                          var num = 1 / PowD(10' uncertainty.ToString(CultureInfo.InvariantCulture).Length - 2) * 0.1M; // important that y is an uint.                                                    uncertainty = decimal.Ceiling(uncertainty * num) / num;                      }                  }                    value = Convert.ToDecimal( Convert.ToDouble(string.Format("{{0:G" + (decimal.Floor(value).ToString(CultureInfo.InvariantCulture).Length- uncertainty.ToString(CultureInfo.InvariantCulture).Length+1) + "}}"' decimal.Floor( value))));//Decimal.Round(Decimal.Floor(value)' uncertaintySigFig);              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The following statement contains a magic number: if(uncertainty < 1)              {                  if (uncertaintySigFig > 2)                  {                      var temp = Convert.ToDecimal( uncertainty.ToString(CultureInfo.InvariantCulture).Replace("."' "")) ;                      var zero = uncertaintySigFig-temp.ToString(CultureInfo.InvariantCulture).Length; // unsure about this step' although it is good when avoiding cases like 0.001500 (the extra zeroes at the end)                      var num = PowD(10' zero);                                            uncertainty = decimal.Ceiling(uncertainty * num) / (num * 1.0M);                  }                    value = Convert.ToDecimal(string.Format("{{0:F" + (uncertainty.ToString(CultureInfo.InvariantCulture).Length-2) + "}}"' value - decimal.Floor(value))) + decimal.Floor(value) ;              }              else              {                  if (uncertaintySigFig > 1)                  {                      uncertainty = decimal.Floor(uncertainty);                        if (uncertainty.ToString(CultureInfo.InvariantCulture).Length > 1)                      {                          var num = 1 / PowD(10' uncertainty.ToString(CultureInfo.InvariantCulture).Length - 2) * 0.1M; // important that y is an uint.                                                    uncertainty = decimal.Ceiling(uncertainty * num) / num;                      }                  }                    value = Convert.ToDecimal( Convert.ToDouble(string.Format("{{0:G" + (decimal.Floor(value).ToString(CultureInfo.InvariantCulture).Length- uncertainty.ToString(CultureInfo.InvariantCulture).Length+1) + "}}"' decimal.Floor( value))));//Decimal.Round(Decimal.Floor(value)' uncertaintySigFig);              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The following statement contains a magic number: if(uncertainty < 1)              {                  if (uncertaintySigFig > 2)                  {                      var temp = Convert.ToDecimal( uncertainty.ToString(CultureInfo.InvariantCulture).Replace("."' "")) ;                      var zero = uncertaintySigFig-temp.ToString(CultureInfo.InvariantCulture).Length; // unsure about this step' although it is good when avoiding cases like 0.001500 (the extra zeroes at the end)                      var num = PowD(10' zero);                                            uncertainty = decimal.Ceiling(uncertainty * num) / (num * 1.0M);                  }                    value = Convert.ToDecimal(string.Format("{{0:F" + (uncertainty.ToString(CultureInfo.InvariantCulture).Length-2) + "}}"' value - decimal.Floor(value))) + decimal.Floor(value) ;              }              else              {                  if (uncertaintySigFig > 1)                  {                      uncertainty = decimal.Floor(uncertainty);                        if (uncertainty.ToString(CultureInfo.InvariantCulture).Length > 1)                      {                          var num = 1 / PowD(10' uncertainty.ToString(CultureInfo.InvariantCulture).Length - 2) * 0.1M; // important that y is an uint.                                                    uncertainty = decimal.Ceiling(uncertainty * num) / num;                      }                  }                    value = Convert.ToDecimal( Convert.ToDouble(string.Format("{{0:G" + (decimal.Floor(value).ToString(CultureInfo.InvariantCulture).Length- uncertainty.ToString(CultureInfo.InvariantCulture).Length+1) + "}}"' decimal.Floor( value))));//Decimal.Round(Decimal.Floor(value)' uncertaintySigFig);              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,AutoFormat,The following statement contains a magic number: if(uncertainty < 1)              {                  if (uncertaintySigFig > 2)                  {                      var temp = Convert.ToDecimal( uncertainty.ToString(CultureInfo.InvariantCulture).Replace("."' "")) ;                      var zero = uncertaintySigFig-temp.ToString(CultureInfo.InvariantCulture).Length; // unsure about this step' although it is good when avoiding cases like 0.001500 (the extra zeroes at the end)                      var num = PowD(10' zero);                                            uncertainty = decimal.Ceiling(uncertainty * num) / (num * 1.0M);                  }                    value = Convert.ToDecimal(string.Format("{{0:F" + (uncertainty.ToString(CultureInfo.InvariantCulture).Length-2) + "}}"' value - decimal.Floor(value))) + decimal.Floor(value) ;              }              else              {                  if (uncertaintySigFig > 1)                  {                      uncertainty = decimal.Floor(uncertainty);                        if (uncertainty.ToString(CultureInfo.InvariantCulture).Length > 1)                      {                          var num = 1 / PowD(10' uncertainty.ToString(CultureInfo.InvariantCulture).Length - 2) * 0.1M; // important that y is an uint.                                                    uncertainty = decimal.Ceiling(uncertainty * num) / num;                      }                  }                    value = Convert.ToDecimal( Convert.ToDouble(string.Format("{{0:G" + (decimal.Floor(value).ToString(CultureInfo.InvariantCulture).Length- uncertainty.ToString(CultureInfo.InvariantCulture).Length+1) + "}}"' decimal.Floor( value))));//Decimal.Round(Decimal.Floor(value)' uncertaintySigFig);              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,GetSignificantDigitCount,The following statement contains a magic number: if ((value >= 1M) || (value <= -1M))              {                  var highPart = bits[2];                  var middlePart = bits[1];                  var lowPart = bits[0];                  var num = new decimal(lowPart' middlePart' highPart' false' 0);                  var exponent = (int)Math.Ceiling(Math.Log10((double)num));                    return exponent;              }              else              {                  var scalePart = bits[3];                    // Accoring to MSDN' the exponent is represented by                  // bits 16-23 (the 2nd word):                  // http://msdn.microsoft.com/en-us/library/system.decimal.getbits.aspx                  var exponent = (scalePart & 0x00FF0000) >> 16;                    return exponent + 1;              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,GetSignificantDigitCount,The following statement contains a magic number: if ((value >= 1M) || (value <= -1M))              {                  var highPart = bits[2];                  var middlePart = bits[1];                  var lowPart = bits[0];                  var num = new decimal(lowPart' middlePart' highPart' false' 0);                  var exponent = (int)Math.Ceiling(Math.Log10((double)num));                    return exponent;              }              else              {                  var scalePart = bits[3];                    // Accoring to MSDN' the exponent is represented by                  // bits 16-23 (the 2nd word):                  // http://msdn.microsoft.com/en-us/library/system.decimal.getbits.aspx                  var exponent = (scalePart & 0x00FF0000) >> 16;                    return exponent + 1;              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,GetSignificantDigitCount,The following statement contains a magic number: if ((value >= 1M) || (value <= -1M))              {                  var highPart = bits[2];                  var middlePart = bits[1];                  var lowPart = bits[0];                  var num = new decimal(lowPart' middlePart' highPart' false' 0);                  var exponent = (int)Math.Ceiling(Math.Log10((double)num));                    return exponent;              }              else              {                  var scalePart = bits[3];                    // Accoring to MSDN' the exponent is represented by                  // bits 16-23 (the 2nd word):                  // http://msdn.microsoft.com/en-us/library/system.decimal.getbits.aspx                  var exponent = (scalePart & 0x00FF0000) >> 16;                    return exponent + 1;              }
Magic Number,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (Value.GetHashCode() * 397) ^ Uncertainty.GetHashCode();              }
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,FutureValue,The following statement contains a magic number: var futureValue = presentValue * DecimalPower(1 + rateOfReturn / 100' numberOfPeriods);
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,FutureValue,The following statement contains a magic number: return round ? Math.Round(futureValue' 2) : futureValue;
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,PresentValue,The following statement contains a magic number: var presentValue = futureValue / DecimalPower(1 + rateOfReturn / 100' numberOfPeriods);
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,PresentValue,The following statement contains a magic number: return round ? Math.Round(presentValue' 2) : presentValue;
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,NetPresentValue,The following statement contains a magic number: var netPresentValue = initialInvestment*-1 + cashFlow.Select((t' i) => t/DecimalPower(1 + rateOfReturn/100' i + 1)).Sum(temp => round ? Math.Round(temp' 2) : temp);
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,NetPresentValue,The following statement contains a magic number: var netPresentValue = initialInvestment*-1 + cashFlow.Select((t' i) => t/DecimalPower(1 + rateOfReturn/100' i + 1)).Sum(temp => round ? Math.Round(temp' 2) : temp);
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,NetPresentValue,The following statement contains a magic number: return round ? Math.Round(netPresentValue' 2) : netPresentValue;
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,PresentValueOfAnnuity,The following statement contains a magic number: var presentValueOfAnnuity = periodicPayment * ((1 - DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods * -1)) / (ratePerPeriod / 100));
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,PresentValueOfAnnuity,The following statement contains a magic number: var presentValueOfAnnuity = periodicPayment * ((1 - DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods * -1)) / (ratePerPeriod / 100));
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,PresentValueOfAnnuity,The following statement contains a magic number: return round ? Math.Round(presentValueOfAnnuity' 2) : presentValueOfAnnuity;
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,FutureValueOfAnnuity,The following statement contains a magic number: var futureValueOfAnnuity = periodicPayment * ((DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods) - 1) / (ratePerPeriod / 100));
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,FutureValueOfAnnuity,The following statement contains a magic number: var futureValueOfAnnuity = periodicPayment * ((DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods) - 1) / (ratePerPeriod / 100));
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,FutureValueOfAnnuity,The following statement contains a magic number: return round ? Math.Round(futureValueOfAnnuity' 2) : futureValueOfAnnuity;
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,AnnuityPaymentPresentValue,The following statement contains a magic number: var annuityPayment = presentValue * ratePerPeriod / 100 / (1 - DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods * -1));
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,AnnuityPaymentPresentValue,The following statement contains a magic number: var annuityPayment = presentValue * ratePerPeriod / 100 / (1 - DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods * -1));
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,AnnuityPaymentPresentValue,The following statement contains a magic number: return round ? Math.Round(annuityPayment' 2) : annuityPayment;
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,AnnuityPaymentFutureValue,The following statement contains a magic number: var annuityPayment = futureValue * ratePerPeriod / 100 / (DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods) - 1);
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,AnnuityPaymentFutureValue,The following statement contains a magic number: var annuityPayment = futureValue * ratePerPeriod / 100 / (DecimalPower(1 + ratePerPeriod / 100' numberOfPeriods) - 1);
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,AnnuityPaymentFutureValue,The following statement contains a magic number: return round ? Math.Round(annuityPayment' 2) : annuityPayment;
Magic Number,Mathos.Finance,Finance,C:\repos\MathosProject_Mathos-Project\Mathos\Finance\Finance.cs,RemainingBalanceOfAnnuity,The following statement contains a magic number: return round ? Math.Round(remaining' 2) : remaining;
Magic Number,TwoDimensional,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,Distance,The following statement contains a magic number: try                  {                      return Convert.ToDecimal(Math.Sqrt(Math.Pow((double)coordinateA.X.ToDecimal() - (double)coordinateB.X.ToDecimal()' 2) + Math.Pow((double)coordinateA.Y.ToDecimal() - (double)coordinateB.Y.ToDecimal()' 2)));                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the distance."' e);                  }
Magic Number,TwoDimensional,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,Distance,The following statement contains a magic number: try                  {                      return Convert.ToDecimal(Math.Sqrt(Math.Pow((double)coordinateA.X.ToDecimal() - (double)coordinateB.X.ToDecimal()' 2) + Math.Pow((double)coordinateA.Y.ToDecimal() - (double)coordinateB.Y.ToDecimal()' 2)));                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the distance."' e);                  }
Magic Number,TwoDimensional,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,MidPoint,The following statement contains a magic number: try                  {                      return new Coordinate((coordinateA.X + coordinateB.X) / 2'                                            (coordinateA.Y + coordinateB.Y) / 2);                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the MidPoint"' e);                  }
Magic Number,TwoDimensional,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,MidPoint,The following statement contains a magic number: try                  {                      return new Coordinate((coordinateA.X + coordinateB.X) / 2'                                            (coordinateA.Y + coordinateB.Y) / 2);                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the MidPoint"' e);                  }
Magic Number,Mathos.Geometry,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,Distance,The following statement contains a magic number: try                  {                      return Convert.ToDecimal(Math.Sqrt(Math.Pow((double)coordinateA.X.ToDecimal() - (double)coordinateB.X.ToDecimal()' 2) + Math.Pow((double)coordinateA.Y.ToDecimal() - (double)coordinateB.Y.ToDecimal()' 2)));                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the distance."' e);                  }
Magic Number,Mathos.Geometry,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,Distance,The following statement contains a magic number: try                  {                      return Convert.ToDecimal(Math.Sqrt(Math.Pow((double)coordinateA.X.ToDecimal() - (double)coordinateB.X.ToDecimal()' 2) + Math.Pow((double)coordinateA.Y.ToDecimal() - (double)coordinateB.Y.ToDecimal()' 2)));                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the distance."' e);                  }
Magic Number,Mathos.Geometry,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,MidPoint,The following statement contains a magic number: try                  {                      return new Coordinate((coordinateA.X + coordinateB.X) / 2'                                            (coordinateA.Y + coordinateB.Y) / 2);                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the MidPoint"' e);                  }
Magic Number,Mathos.Geometry,Calculate,C:\repos\MathosProject_Mathos-Project\Mathos\Geometry\CoordinateGeometry.cs,MidPoint,The following statement contains a magic number: try                  {                      return new Coordinate((coordinateA.X + coordinateB.X) / 2'                                            (coordinateA.Y + coordinateB.Y) / 2);                  }                  catch (Exception e)                  {                      throw new ArgumentException("Error when calculating the MidPoint"' e);                  }
Magic Number,Mathos.Statistics.Statistical_Distributions,BinomialDistribution,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistical Distributions\BinomialDistribution.cs,Skewness,The following statement contains a magic number: return (decimal)((1 - 2 * probabilityOfSuccess) / Math.Sqrt((double)Variance(numberOfTrials' probabilityOfSuccess)));
Magic Number,Mathos.Statistics.Statistical_Distributions,BinomialDistribution,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistical Distributions\BinomialDistribution.cs,ExcessKurtosis,The following statement contains a magic number: return (1 - 6 * variance / numberOfTrials) / variance;
Magic Number,Mathos.Statistics.Statistical_Distributions,PoissonDistribution,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Statistical Distributions\PoissonDistribution.cs,Skewness,The following statement contains a magic number: return (decimal)Math.Pow(poissonParameter' -.5);
Magic Number,Mathos.Syntax,SyntaxExtensions,C:\repos\MathosProject_Mathos-Project\Mathos\SyntaxExtensions.cs,IsEven,The following statement contains a magic number: return num % 2 == 0;
Magic Number,Mathos.Syntax,SyntaxExtensions,C:\repos\MathosProject_Mathos-Project\Mathos\SyntaxExtensions.cs,IsEven,The following statement contains a magic number: return num % 2 == 0;
Magic Number,Mathos.Syntax,SyntaxExtensions,C:\repos\MathosProject_Mathos-Project\Mathos\SyntaxExtensions.cs,IsEven,The following statement contains a magic number: return num % 2 == 0;
Magic Number,Mathos.Syntax,SyntaxExtensions,C:\repos\MathosProject_Mathos-Project\Mathos\SyntaxExtensions.cs,IsEven,The following statement contains a magic number: return num % 2 == 0;
Missing Default,Mathos,Fraction,C:\repos\MathosProject_Mathos-Project\Mathos\Fraction.cs,FromSternBrocotSystem,The following switch statement is missing a default case: switch (letter)                  {                      case 'L':                          matArray[j] = new Matrix(new Vector(1' 1)' new Vector(0' 1));                            break;                      case 'R':                          matArray[j] = new Matrix(new Vector(1' 0)' new Vector(1' 1));                            break;                  }
Missing Default,Mathos.Arithmetic.Numbers,Get,C:\repos\MathosProject_Mathos-Project\Mathos\Arithmetic\Numbers\Get.cs,IntPower,The following switch statement is missing a default case: switch (power)              {                  case 0:                      return 1;                  case 1:                      return x;              }
Missing Default,Mathos.PreCalculus,Fibonacci,C:\repos\MathosProject_Mathos-Project\Mathos\PreCalculus\Fibonacci.cs,NTerm,The following switch statement is missing a default case: switch (n)              {                  case 0:                      return InitialTerm;                  case 1:                      return FirstTerm;              }
Missing Default,Mathos.Statistics,UncertainNumber,C:\repos\MathosProject_Mathos-Project\Mathos\Statistics\Uncertainty.cs,UncertainNumber,The following switch statement is missing a default case: switch (uncertaintyType)              {                  case UncertaintyType.AbsoluteUncertainty:                      Value = value;                      Uncertainty = uncertainty;                      break;                  case UncertaintyType.RelativeUncertainty:                      Value = value;                      Uncertainty = uncertainty / 100 * value;                      break;              }
