Implementation smell,Namespace,Class,File,Method,Description
Complex Method,TinCan,MusicNote,C:\repos\artl93_tincan\src\MusicNote.cs,GetNoteRatio,Cyclomatic complexity of the method is 15
Long Parameter List,TinCan,SequencerTrack,C:\repos\artl93_tincan\src\SequencerTrack.cs,PlayEvents,The method has 5 parameters.
Long Parameter List,TinCan,SequencerTrack,C:\repos\artl93_tincan\src\SequencerTrack.cs,PlayEventsInSubFrame,The method has 5 parameters.
Long Statement,TinCan,Sequencer,C:\repos\artl93_tincan\src\Sequencer.cs,UpdatePosition,The length of the statement  "		var frameSampleOffset = (int)Math.Round (EventLocation.GetBeatsSpan (_end' startEventPosition' BeatsPerMeasure) * _samplesPerBeat' 0); " is 134.
Long Statement,TinCan,SequencerTrack,C:\repos\artl93_tincan\src\SequencerTrack.cs,PlayEvents,The length of the statement  "		int subFrameOffset = (int)Math.Round (EventLocation.GetBeatsSpan (_end' startSpan' _beatsPerMeasure) * samplesPerBeat' 0); " is 122.
Long Statement,TinCan,SequencerTrack,C:\repos\artl93_tincan\src\SequencerTrack.cs,PlayEventsInSubFrame,The length of the statement  "		info.sampleOffset = (int)Math.Round (EventLocation.GetBeatsSpan (noteStartLocation' startSpan' _beatsPerMeasure) * samplesPerBeat' 0) + sampleOffset; " is 149.
Magic Number,TinCan,AudioEngine,C:\repos\artl93_tincan\src\AudioEngine.cs,_soundEngine_BufferNeeded,The following statement contains a magic number: if (this._soundEngine.PendingBufferCount < 2) {  	Debug.WriteLine ("Buffers left: {0}"' _soundEngine.PendingBufferCount);  	SubmitAudioToBuffer ();  	// catchup  }  
Magic Number,TinCan,AudioEngine,C:\repos\artl93_tincan\src\AudioEngine.cs,RenderTempToOutput,The following statement contains a magic number: for (int i = 0; i < _countOfShortsInFrame; i++) {  	short value = (short)(_internalSoundBuffer [i]);  	var byte1 = (byte)(value);  	var byte2 = (byte)(value >> 8);  	_soundbuffers [_offset + i * 2] = byte1;  	_soundbuffers [_offset + (i * 2) + 1] = byte2;  }  
Magic Number,TinCan,AudioEngine,C:\repos\artl93_tincan\src\AudioEngine.cs,RenderTempToOutput,The following statement contains a magic number: for (int i = 0; i < _countOfShortsInFrame; i++) {  	short value = (short)(_internalSoundBuffer [i]);  	var byte1 = (byte)(value);  	var byte2 = (byte)(value >> 8);  	_soundbuffers [_offset + i * 2] = byte1;  	_soundbuffers [_offset + (i * 2) + 1] = byte2;  }  
Magic Number,TinCan,AudioEngine,C:\repos\artl93_tincan\src\AudioEngine.cs,RenderTempToOutput,The following statement contains a magic number: for (int i = 0; i < _countOfShortsInFrame; i++) {  	short value = (short)(_internalSoundBuffer [i]);  	var byte1 = (byte)(value);  	var byte2 = (byte)(value >> 8);  	_soundbuffers [_offset + i * 2] = byte1;  	_soundbuffers [_offset + (i * 2) + 1] = byte2;  }  
Magic Number,TinCan,AudioEngine,C:\repos\artl93_tincan\src\AudioEngine.cs,RenderTempToOutput,The following statement contains a magic number: _soundbuffers [_offset + i * 2] = byte1;  
Magic Number,TinCan,AudioEngine,C:\repos\artl93_tincan\src\AudioEngine.cs,RenderTempToOutput,The following statement contains a magic number: _soundbuffers [_offset + (i * 2) + 1] = byte2;  
Magic Number,TinCan,EventLocation,C:\repos\artl93_tincan\src\EventLocation.cs,AddBeats,The following statement contains a magic number: if (Beat >= beatsPerMeasure) {  	var newMeasures = Beat / 4;  	Beat = Beat % beatsPerMeasure;  	Measure += newMeasures;  }  
Magic Number,TinCan,EventLocation,C:\repos\artl93_tincan\src\EventLocation.cs,GetHashCode,The following statement contains a magic number: return (int)(hash * 20500);  
Magic Number,TinCan,EventLocation,C:\repos\artl93_tincan\src\EventLocation.cs,Parse,The following statement contains a magic number: newEvent.Div = Double.Parse (values [2]);  
Magic Number,TinCan,SampleFile,C:\repos\artl93_tincan\src\SampleFile.cs,ReadSubchunks,The following statement contains a magic number: if (reader.ReadInt32 () != 16)  	throw new FormatException ("Chunk size");  
Magic Number,TinCan,SampleFile,C:\repos\artl93_tincan\src\SampleFile.cs,ReadSubchunks,The following statement contains a magic number: if (byteRate != (sampleRate * channels * (bitsPerSample / 8)))  	throw new FormatException ("ByteRate checksum failed");  
Magic Number,TinCan,SampleFile,C:\repos\artl93_tincan\src\SampleFile.cs,ReadSubchunks,The following statement contains a magic number: if (blockAlign != (channels * (bitsPerSample / 8)))  	throw new FormatException ("BlockAlign checksum failed");  
Magic Number,TinCan,Sequencer,C:\repos\artl93_tincan\src\Sequencer.cs,SetTempo,The following statement contains a magic number: _samplesPerBeat = (_sampleRate * 60) / tempo;  
Magic Number,TinCan,SynthesizerInstrument,C:\repos\artl93_tincan\src\SynthesizerInstrument.cs,Play,The following statement contains a magic number: _generator.Frequency = 440.0 * ratio * octave;  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: switch (_waveform) {  case Waveform.Nothing:  	return 0;  case Waveform.Sine:  	return (short)(Math.Sin (2 * Math.PI * _position / samplesPerCycle) * short.MaxValue);  case Waveform.Square:  	return _position < samplesPerCycle ? short.MaxValue : short.MinValue;  case Waveform.Triangle:  	double tempPosition = _position + (samplesPerCycle / 4);  	if (tempPosition < (samplesPerCycle / 2))  		return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  	else  		return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  case Waveform.SawUp:  	return (short)((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue);  case Waveform.SawDown:  	return (short)(ushort.MaxValue - ((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue));  }  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: switch (_waveform) {  case Waveform.Nothing:  	return 0;  case Waveform.Sine:  	return (short)(Math.Sin (2 * Math.PI * _position / samplesPerCycle) * short.MaxValue);  case Waveform.Square:  	return _position < samplesPerCycle ? short.MaxValue : short.MinValue;  case Waveform.Triangle:  	double tempPosition = _position + (samplesPerCycle / 4);  	if (tempPosition < (samplesPerCycle / 2))  		return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  	else  		return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  case Waveform.SawUp:  	return (short)((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue);  case Waveform.SawDown:  	return (short)(ushort.MaxValue - ((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue));  }  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: switch (_waveform) {  case Waveform.Nothing:  	return 0;  case Waveform.Sine:  	return (short)(Math.Sin (2 * Math.PI * _position / samplesPerCycle) * short.MaxValue);  case Waveform.Square:  	return _position < samplesPerCycle ? short.MaxValue : short.MinValue;  case Waveform.Triangle:  	double tempPosition = _position + (samplesPerCycle / 4);  	if (tempPosition < (samplesPerCycle / 2))  		return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  	else  		return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  case Waveform.SawUp:  	return (short)((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue);  case Waveform.SawDown:  	return (short)(ushort.MaxValue - ((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue));  }  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: switch (_waveform) {  case Waveform.Nothing:  	return 0;  case Waveform.Sine:  	return (short)(Math.Sin (2 * Math.PI * _position / samplesPerCycle) * short.MaxValue);  case Waveform.Square:  	return _position < samplesPerCycle ? short.MaxValue : short.MinValue;  case Waveform.Triangle:  	double tempPosition = _position + (samplesPerCycle / 4);  	if (tempPosition < (samplesPerCycle / 2))  		return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  	else  		return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  case Waveform.SawUp:  	return (short)((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue);  case Waveform.SawDown:  	return (short)(ushort.MaxValue - ((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue));  }  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: switch (_waveform) {  case Waveform.Nothing:  	return 0;  case Waveform.Sine:  	return (short)(Math.Sin (2 * Math.PI * _position / samplesPerCycle) * short.MaxValue);  case Waveform.Square:  	return _position < samplesPerCycle ? short.MaxValue : short.MinValue;  case Waveform.Triangle:  	double tempPosition = _position + (samplesPerCycle / 4);  	if (tempPosition < (samplesPerCycle / 2))  		return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  	else  		return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  case Waveform.SawUp:  	return (short)((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue);  case Waveform.SawDown:  	return (short)(ushort.MaxValue - ((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue));  }  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: return (short)(Math.Sin (2 * Math.PI * _position / samplesPerCycle) * short.MaxValue);  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: if (tempPosition < (samplesPerCycle / 2))  	return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  else  	return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: if (tempPosition < (samplesPerCycle / 2))  	return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  else  	return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: if (tempPosition < (samplesPerCycle / 2))  	return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  else  	return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  
Magic Number,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following statement contains a magic number: return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  
Missing Default,TinCan,WaveformGenerator,C:\repos\artl93_tincan\src\WaveformGenerator.cs,GetPCMValue,The following switch statement is missing a default case: switch (_waveform) {  case Waveform.Nothing:  	return 0;  case Waveform.Sine:  	return (short)(Math.Sin (2 * Math.PI * _position / samplesPerCycle) * short.MaxValue);  case Waveform.Square:  	return _position < samplesPerCycle ? short.MaxValue : short.MinValue;  case Waveform.Triangle:  	double tempPosition = _position + (samplesPerCycle / 4);  	if (tempPosition < (samplesPerCycle / 2))  		return (short)((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue);  	else  		return (short)(ushort.MaxValue - ((ushort)(tempPosition / (samplesPerCycle / 2)) * ushort.MaxValue));  case Waveform.SawUp:  	return (short)((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue);  case Waveform.SawDown:  	return (short)(ushort.MaxValue - ((ushort)(_position / (samplesPerCycle)) * ushort.MaxValue));  }  
