Implementation smell,Namespace,Class,File,Method,Description
Long Method,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,SyncDirectory,The method has 163 lines of code.
Complex Method,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,ServerLog,Cyclomatic complexity of the method is 10
Complex Method,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,SyncDirectory,Cyclomatic complexity of the method is 40
Complex Method,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,CheckArgs,Cyclomatic complexity of the method is 34
Long Statement,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,SyncDirectory,The length of the statement  "				ClientLog (String.Format ("File {0} {1}"' lRemoteItem.FileName' lNeedSync ? "requires synchronization." : "doesn't require synchronization.")); " is 143.
Long Statement,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,SyncDirectory,The length of the statement  "				ClientLog (String.Format ("File {0} {1}"' lName' lNeedSync ? "requires synchronization." : "doesn't require synchronization.")); " is 128.
Long Statement,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,CheckArgs,The length of the statement  "		Console.WriteLine ("  Usage: FtpSync directory user:pass@server/remote [-local] [-remote] [-nodelete] [-passive] [-l] [-r]"); " is 125.
Magic Number,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,Sync,The following statement contains a magic number: try {  	fFtpClient = new FtpClient ();  	fFtpClient.HostName = fServer;  	fFtpClient.UserName = fUserName;  	fFtpClient.Password = fPassword;  	fFtpClient.Passive = fPassiveMode;  	fFtpClient.Port = 21;  	fFtpClient.OnLog += ServerLog;  	fFtpClient.OnTransferProgress += Ftp_OnTransferProgress;  	ClientLog ("Connecting to " + fServer);  	fFtpClient.Open ();  	try {  		fFtpClient.Login ();  		SyncDirectory (fLocalDirectory' "/" + fServerDirectory);  	}  	finally {  		ClientLog ("Disconnecting");  		fFtpClient.Quit ();  		fFtpClient.Close ();  	}  }  catch (Exception ex) {  	ClientLog (String.Format ("Error syncing directory ({0})"' ex.Message));  	if (ex.StackTrace != null && fDoShowFtpClientLog) {  		ClientLog (ex.StackTrace);  	}  }  
Magic Number,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,Sync,The following statement contains a magic number: fFtpClient.Port = 21;  
Magic Number,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,CheckArgs,The following statement contains a magic number: for (int i = 2; i < lCount; i++) {  	switch (args [i].ToLower ()) {  	case "-local":  		fSyncMode = SyncMode.Local;  		break;  	case "-remote":  		fSyncMode = SyncMode.Remote;  		break;  	case "-nodelete":  		fDoNotDeleteMissingItems = true;  		break;  	case "-passive":  		fPassiveMode = true;  		break;  	case "-r":  		fRecursiveSync = true;  		break;  	case "-l":  		fDoShowFtpClientLog = true;  		break;  	case "-help":  		lBadParam = true;  		break;  	case "/help":  		lBadParam = true;  		break;  	default:  		Console.WriteLine ("Invalid command line paramter \"" + args [i] + "\"");  		Console.WriteLine ("");  		lBadParam = true;  		break;  	}  }  
Missing Default,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,ServerLog,The following switch statement is missing a default case: switch (ea.Direction) {  case RemObjects.InternetPack.Events.TransferDirection.Receive:  	lIcon = "<";  	break;  case RemObjects.InternetPack.Events.TransferDirection.Send:  	lIcon = ">";  	break;  case RemObjects.InternetPack.Events.TransferDirection.None:  	lIcon = "!";  	break;  }  
Missing Default,FtpSync,FtpSyncWorker,C:\repos\remobjects_internetpack\Samples\C#\FTP Sync\FtpSyncWorker.cs,SyncDirectory,The following switch statement is missing a default case: switch (fSyncMode) {  #region Local Synchronization. Master: ftp; slave: local;  case SyncMode.Local:  	#region Folders synchronization  	foreach (String lName in lRemoteFolders.Keys) {  		ClientLog (String.Format ("Synchronizing folder '{0}'..."' lName));  		String lLocalItemName = Path.Combine (aLocalDirectory' lName);  		if (!Directory.Exists (lLocalItemName))  			Directory.CreateDirectory (lLocalItemName);  		SyncDirectory (lLocalItemName' lName);  		ClientLog (String.Format ("Folder '{0}' has been synchronized"' lName));  		lLocalFolders.Remove (lName);  	}  	#region Delete local folders that doesn't exists on FTP  	if (!fDoNotDeleteMissingItems) {  		foreach (DirectoryInfo toDelete in lLocalFolders.Values) {  			toDelete.Delete (true);  			//delete recursive  		}  		lLocalFolders.Clear ();  	}  	#endregion  	#endregion  	#region Files synchronization  	foreach (String lName in lRemoteFiles.Keys) {  		FtpListingItem lRemoteItem = lRemoteFiles [lName];  		Boolean lNeedSync = true;  		if (lLocalFiles.ContainsKey (lName)) {  			FileInfo lLocalItem = lLocalFiles [lName];  			lNeedSync = ((lLocalItem.Length != lRemoteItem.Size) || (lLocalItem.LastWriteTime != lRemoteItem.FileDate));  		}  		ClientLog (String.Format ("File {0} {1}"' lRemoteItem.FileName' lNeedSync ? "requires synchronization." : "doesn't require synchronization."));  		if (lNeedSync) {  			ClientLog (String.Format ("Downloading {0}..."' lRemoteItem.FileName));  			using (Stream lStream = File.Open (Path.Combine (aLocalDirectory' lName)' FileMode.Create)) {  				fFtpClient.Retrieve (lRemoteItem' lStream);  				lStream.Close ();  				File.SetLastWriteTime (lRemoteItem.FileName' lRemoteItem.FileDate);  			}  			ClientLog (String.Format ("File {0} has been downloaded."' lRemoteItem.FileName));  		}  		lLocalFiles.Remove (lName);  	}  	#region Delete local files that doesn't exists on FTP  	if (!fDoNotDeleteMissingItems) {  		foreach (FileInfo toDelete in lLocalFiles.Values) {  			toDelete.Delete ();  		}  		lLocalFiles.Clear ();  	}  	#endregion  	#endregion  	break;  #endregion  #region Remote Synchronization.	Master: local; slave: ftp;  case SyncMode.Remote:  	#region Folders Synchronization.  	foreach (String lName in lLocalFolders.Keys) {  		ClientLog (String.Format ("Synchronizing folder '{0}'..."' lName));  		String lLocalItemName = Path.Combine (aLocalDirectory' lName);  		if (!lRemoteFolders.ContainsKey (lName))  			fFtpClient.MakeDirectory (lName);  		SyncDirectory (lLocalItemName' lName);  		ClientLog (String.Format ("Folder '{0}' has been synchronized"' lName));  		lRemoteFolders.Remove (lName);  	}  	#region Delete FTP folders that doesn't exists locally  	if (!fDoNotDeleteMissingItems) {  		foreach (FtpListingItem toDelete in lRemoteFolders.Values) {  			fFtpClient.RemoveDirectory (toDelete.FileName);  		}  		lRemoteFolders.Clear ();  	}  	#endregion  	#endregion  	#region Files Synchronization.  	foreach (String lName in lLocalFiles.Keys) {  		String lLocalItemName = Path.Combine (aLocalDirectory' lName);  		Boolean lNeedSync = true;  		if (lRemoteFiles.ContainsKey (lName)) {  			FileInfo lLocalItem = new FileInfo (lLocalItemName);  			FtpListingItem lRemoteItem = lRemoteFiles [lName];  			lNeedSync = ((lLocalItem.Length != lRemoteItem.Size) || (lLocalItem.LastWriteTime != lRemoteItem.FileDate));  		}  		ClientLog (String.Format ("File {0} {1}"' lName' lNeedSync ? "requires synchronization." : "doesn't require synchronization."));  		if (lNeedSync) {  			ClientLog (String.Format ("Uploading {0}..."' lName));  			if (File.Exists (lLocalItemName))  				using (FileStream fs = new FileStream (lLocalItemName' FileMode.Open' FileAccess.Read)) {  					fFtpClient.Store (lName' fs);  				}  			ClientLog (String.Format ("File {0} has been uploaded."' lName));  		}  		lRemoteFiles.Remove (lName);  	}  	#region Delete FTP files that doesn't exist locally  	if (!fDoNotDeleteMissingItems) {  		foreach (FtpListingItem toDelete in lRemoteFiles.Values) {  			fFtpClient.Delete (toDelete.FileName);  		}  		lRemoteFiles.Clear ();  	}  	#endregion  	#endregion  	break;  #endregion  }  
