Implementation smell,Namespace,Class,File,Method,Description
Long Method,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The method has 246 lines of code.
Long Method,sones.Networking.HTTP,URLParser,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\URLParser.cs,GetCallback,The method has 142 lines of code.
Long Method,sones.Networking.HTTP,HTTPHeader,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHeader.cs,HTTPHeader,The method has 177 lines of code.
Long Method,sones.Library.Threading,SmartThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\SmartThreadPool.cs,ProcessQueuedItems,The method has 144 lines of code.
Long Method,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The method has 106 lines of code.
Complex Method,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ParseInterface,Cyclomatic complexity of the method is 13
Complex Method,sones.Networking.HTTP,HTTPHeader,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHeader.cs,HTTPHeader,Cyclomatic complexity of the method is 11
Complex Method,sones.Library.Threading,SmartThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\SmartThreadPool.cs,Shutdown,Cyclomatic complexity of the method is 9
Complex Method,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,Cyclomatic complexity of the method is 8
Complex Method,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,Parse,Cyclomatic complexity of the method is 10
Long Parameter List,sones.Networking.HTTP,HTTPServer<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPServer.cs,HTTPServer,The method has 5 parameters. Parameters: myIPAddress' myPort' myInstance' myTimeout' myAutoStart
Long Parameter List,sones.Networking.HTTP,URLParser,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\URLParser.cs,AddNode,The method has 6 parameters. Parameters: urlNodes' urlParts' methodInfo' url' posInUrl' needsExplicitAuthentication
Long Parameter List,sones.Networking.HTTP,URLParser,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\URLParser.cs,GetCallback,The method has 5 parameters. Parameters: urlNodes' urlParts' parameters' url' posInUrl
Long Parameter List,sones.Library.Threading,IWorkItemsGroup,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters. Parameters: callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority
Long Parameter List,sones.Library.Threading,IWorkItemsGroup,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters. Parameters: action' arg1' arg2' arg3' arg4
Long Parameter List,sones.Library.Threading,IWorkItemsGroup,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters. Parameters: func' arg1' arg2' arg3' arg4
Long Parameter List,sones.Library.Threading,WorkItemFactory,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' workItemPriority
Long Parameter List,sones.Library.Threading,WorkItemFactory,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters. Parameters: workItemsGroup' wigStartInfo' workItemInfo' callback' state
Long Parameter List,sones.Library.Threading,WorkItemFactory,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback
Long Parameter List,sones.Library.Threading,WorkItemFactory,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 6 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback' workItemPriority
Long Parameter List,sones.Library.Threading,WorkItemFactory,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 6 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute
Long Parameter List,sones.Library.Threading,WorkItemFactory,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 7 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority
Long Parameter List,sones.Library.Threading,AWorkItemsGroupBase,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters. Parameters: callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority
Long Parameter List,sones.Library.Threading,AWorkItemsGroupBase,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters. Parameters: action' arg1' arg2' arg3' arg4
Long Parameter List,sones.Library.Threading,AWorkItemsGroupBase,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters. Parameters: func' arg1' arg2' arg3' arg4
Long Identifier,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ParseInterface,The length of the parameter _GlobalNeedsExplicitAuthentication is 34.
Long Identifier,sones.Library.Threading,CallerThreadContext,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\CallerThreadContext.cs,,The length of the parameter getLogicalCallContextMethodInfo is 31.
Long Identifier,sones.Library.Threading,CallerThreadContext,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\CallerThreadContext.cs,,The length of the parameter setLogicalCallContextMethodInfo is 31.
Long Identifier,sones.Library.Threading,SmartThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\SmartThreadPool.cs,ProcessQueuedItems,The length of the parameter bInUseWorkerThreadsWasIncremented is 33.
Long Identifier,sones.Library.Threading,SmartThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\SmartThreadPool.cs,,The length of the parameter DefaultPostExecuteWorkItemCallback is 34.
Long Identifier,sones.Library.Threading,SmartThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\SmartThreadPool.cs,,The length of the parameter DefaultPerformanceCounterInstanceName is 37.
Long Identifier,sones.Library.Threading,STPInstancePerformanceCounters,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\STPPerformanceCounter.cs,,The length of the parameter _stpInstanceNullPerformanceCounter is 34.
Long Statement,sones.Networking.HTTP,AcceptType,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\AcceptType.cs,Equals,The length of the statement  "            else if (_ContentType.GetMediaSubType() == "*" && _ContentType.GetMediaType().Equals((obj as AcceptType).ContentType.GetMediaType())) " is 133.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,GetStream,The length of the statement  "                    var sslStream = new SslStream(myTcpClient.GetStream()' false' HTTPSecurity.RemoteCertificateValidationCallback' HTTPSecurity.LocalCertificateSelectionCallback); " is 160.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,GetStream,The length of the statement  "                    var sslStream = new SslStream(myTcpClient.GetStream()' false' HTTPSecurity.RemoteCertificateValidationCallback' HTTPSecurity.LocalCertificateSelectionCallback' HTTPSecurity.EncryptionPolicy); " is 191.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,GetStream,The length of the statement  "                     sslStream.AuthenticateAsServer(HTTPSecurity.ServerCertificate' HTTPSecurity.UseClientCertificate' SslProtocols.Default' false); " is 127.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                        Debug.WriteLine(string.Format("{0} Retrieved a request to resource {1} from {2}"' DateTime.Now.TimeOfDay' requestHeader.Destination' requestHeader.Headers["SENDER"])' "HttpHandler"); " is 182.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                        Debug.WriteLine(string.Format("{0} Retrieved a request to resource {1}"' DateTime.Now.TimeOfDay' requestHeader.Destination)' "HttpHandler"); " is 140.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                            var parsedCallback = _Parser.GetCallback(_HTTPWebContext.RequestHeader.RawUrl' _HTTPWebContext.RequestHeader.HttpMethodString); " is 127.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                                responseBodyBytes = Encoding.UTF8.GetBytes("Could not find a valid handler for url: " + _HTTPWebContext.RequestHeader.RawUrl); " is 126.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                                if (HTTPSecurity != null && !(parsedCallback.Item1.NeedsExplicitAuthentication.HasValue && !parsedCallback.Item1.NeedsExplicitAuthentication.Value)) " is 148.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                                            responseHeader = new HTTPHeader() { HttpStatusCode = HTTPStatusCodes.InternalServerError' ContentLength = responseBodyBytes.ULongLength() }; " is 140.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                                else if (parsedCallback.Item1.NeedsExplicitAuthentication.HasValue && parsedCallback.Item1.NeedsExplicitAuthentication.Value) " is 125.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                                    responseHeader = new HTTPHeader() { HttpStatusCode = HTTPStatusCodes.InternalServerError' ContentLength = responseBodyBytes.ULongLength() }; " is 140.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                            responseBodyBytes = _CustomErrorPage.GetCustomErrorPage(responseHeader.HttpStatusCode' _HTTPWebContext.RequestHeader' _HTTPWebContext.RequestBody' _LastException); " is 163.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                            _StringBuilder.Append("    <title>").Append((Int32)responseHeader.HttpStatusCode).Append(" ").Append(HTTPHeader.HttpStatusCodeToSimpleString(responseHeader.HttpStatusCode)).AppendLine("</title>"); " is 196.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The length of the statement  "                            _StringBuilder.Append("    <h1>Error ").Append((Int32)responseHeader.HttpStatusCode).Append(" - ").Append(HTTPHeader.HttpStatusCodeToSimpleString(responseHeader.HttpStatusCode)).AppendLine("</h1>"); " is 198.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,InvokeURL,The length of the statement  "            //var parsedCallback = _Parser.GetCallback(httpWebContext.RequestHeader.RawUrl' httpWebContext.RequestHeader.HttpMethodString); " is 127.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,InvokeURL,The length of the statement  "                myResponseBodyBytes = Encoding.UTF8.GetBytes("Could not find a valid handler for url: " + myHTTPContext.RequestHeader.RawUrl); " is 126.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,InvokeURL,The length of the statement  "                myHTTPContext.ResponseHeader = new HTTPHeader() { HttpStatusCode = HTTPStatusCodes.NotFound' ContentType = new System.Net.Mime.ContentType("text/plain")' ContentLength = myResponseBodyBytes.ULongLength() }; " is 206.
Long Statement,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,InvokeURL,The length of the statement  "                if (!myHTTPContext.StreamDataAvailable) // The user did not write into the stream itself - we will add header and the invocation result " is 135.
Long Statement,sones.Networking.HTTP,URLParser,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\URLParser.cs,AddNode,The length of the statement  "            if (val.StartsWith("{") && val.EndsWith("}")) // something like /{....} or .{....} or ?{.....} will be changed to /{} .{} ?{}  " is 125.
Long Statement,sones.Networking.HTTP,URLParser,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\URLParser.cs,GetCallback,The length of the statement  "            var urlParts = url.Split(_Separators); // skip the first one because this is all in front of the first "/" and this is odd " is 122.
Long Statement,sones.Networking.HTTP,URLParser,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\URLParser.cs,GetCallback,The length of the statement  "            else if (curUrlNode.Callback == null && !curUrlNode.ChildNodes.IsNullOrEmpty() && curUrlNode.ChildNodes.ContainsKey("{}")) " is 122.
Long Statement,sones.Networking.HTTP,URLParser,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\URLParser.cs,GetCallback,The length of the statement  "            else if (curUrlNode.Callback == null && !curUrlNode.ChildNodes.IsNullOrEmpty() && !curUrlNode.ChildNodes.ContainsKey("{}")) " is 123.
Long Statement,sones.Networking.HTTP,HTTPHeader,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHeader.cs,HttpStatusCodeToString,The length of the statement  "                    return "HTTP/1.1 401 " + HttpStatusCodeToSimpleString(myHTTPStatusCode) + Environment.NewLine + "WWW-Authenticate: Basic realm=\"Intern\""; " is 139.
Long Statement,sones.Library.Threading,CallerThreadContext,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\CallerThreadContext.cs,Capture,The length of the statement  "				callerThreadContext._callContext = (LogicalCallContext)getLogicalCallContextMethodInfo.Invoke(Thread.CurrentThread' null); " is 122.
Long Statement,sones.Library.Threading,SmartThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\SmartThreadPool.cs,ValidateWorkItemsGroupWaitForIdle,The length of the statement  "				throw new NotSupportedException("WaitForIdle cannot be called from a thread on its SmartThreadPool' it causes a deadlock"); " is 123.
Long Statement,sones.Library.Threading,SmartThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\SmartThreadPool.cs,ValidateWorkItemsGroupWaitForIdleImpl,The length of the statement  "				throw new NotSupportedException("WaitForIdle cannot be called from a thread on its SmartThreadPool' it causes a deadlock"); " is 123.
Long Statement,sones.Library.Threading,AWorkItemsGroupBase,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "            WorkItem workItem = WorkItemFactory.CreateWorkItem(this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' workItemPriority); " is 135.
Long Statement,sones.Library.Threading,AWorkItemsGroupBase,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "            WorkItem workItem = WorkItemFactory.CreateWorkItem(this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute); " is 136.
Long Statement,sones.Library.Threading,AWorkItemsGroupBase,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "            WorkItem workItem = WorkItemFactory.CreateWorkItem(this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority); " is 154.
Long Statement,sones.Library.Threading,GraphThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\ThreadPool\ThreadPool.cs,QueueWorkItem,The length of the statement  "              //  + _ThreadEntries.Count + " FreeWorkers: " + _FreeWorkers + " CurThreads: " + _ParallelThreadWorkers.Count + " T:" + DateTime.Now.Ticks); " is 140.
Long Statement,sones.Library.Threading,GraphThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\ThreadPool\ThreadPool.cs,QueueWorkItem,The length of the statement  "                //System.Diagnostics.Debug.WriteLine("[GraphThreadPool] Spawn New Thread: BusyWorkers: " + _BusyWorkers + " in Queue: " + _ThreadEntries.Count + " FreeWorkers: " + _FreeWorkers); " is 178.
Long Statement,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The length of the statement  "            while (BytesRead > 0 && FirstBytesList.Count < (Int32.MaxValue - ReadBuffer.Length) && (BytesRead == ReadBuffer.Length)); " is 121.
Long Statement,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The length of the statement  "            while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10)) " is 175.
Long Statement,sones.Networking.TCPSocket,TCPSocketListener<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\TCPSocketListener.cs,StartTcpSocketConnection,The length of the statement  "                while (tcpSocketConnection.ConnectionEstablished() && tcpSocketConnection.KeepAlive && tcpSocketConnection.TcpClientConnection.Connected && !_Stopped) " is 150.
Long Statement,sones.Networking.TCPSocket,TCPSocketListener<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\TCPSocketListener.cs,StartTcpSocketConnection,The length of the statement  "                    //Console.WriteLine("(" + _TcpSocketConnections.IndexOf(TcpSocketConnection) + ") TcpSocketConnection.KeepAlive: " + TcpSocketConnection.KeepAlive); " is 148.
Long Statement,sones.Networking.TCPSocket,TCPSocketListener<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\TCPSocketListener.cs,ToString,The length of the statement  "            return String.Concat("ConnectedClients: " + ConnectedClients.ToString().PadLeft(3)' " IsRunning:"' IsRunning' " StopRequested: "' StopRequested); " is 145.
Long Statement,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,Parse,The length of the statement  "                //As required by the Telnet protocol' any occurrence of 255 in the subnegotiation must be doubled to distinguish it from the IAC character (which has a value of 255) " is 165.
Long Statement,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,Parse,The length of the statement  "                            //As required by the Telnet protocol' any occurrence of 255 in the subnegotiation must be doubled to distinguish it from the IAC character (which has a value of 255) " is 165.
Long Statement,sones.Networking.UDPSocket,UDPSocketMulticast<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\UDPSocket\UDPSocketMulticast.cs,Run,The length of the statement  "                    GraphThreadPool.QueueWorkItem(new GraphThreadPool.ThreadPoolEntry(new ParameterizedThreadStart(((AUDPSocketConnection)TServerLogic).DataReceived)' totalRecievedBytes)); " is 168.
Long Statement,sones.Networking.UDPSocket,UDPSocketMulticast<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\UDPSocket\UDPSocketMulticast.cs,Run,The length of the statement  "                    //SmartThreadPool.QueueWorkItem(new Action<Object>(((AUDPSocketConnection)TServerLogic).DataReceived)' totalRecievedBytes); " is 123.
Long Statement,sones.Networking.UDPSocket,UDPSocketMulticast<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\UDPSocket\UDPSocketMulticast.cs,Send,The length of the statement  "                throw new Exception("Message (" + mySendData.Length + "b) is bigger than the maximum message size of " + MAX_UDPBUFFER_SIZE + "b"); " is 131.
Long Statement,sones.Networking.UDPSocket,UDPSocketMulticast<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\UDPSocket\UDPSocketMulticast.cs,Send,The length of the statement  "            //Console.WriteLine(Environment.NewLine + "NotificationBridge Sent: " + message.NotificationType.Name + " " + bytesToSend.Length + "bytes from dispatcher " + _Dispatcher.Uuid + " - I'm dispatcher " + Dispatcher.Uuid); " is 217.
Complex Conditional,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,WaitForStreamDataAvailable,The conditional expression  "!StopRequested && TcpClientConnection.Connected                      && !stream.DataAvailable                      && ((Timeout == System.Threading.Timeout.Infinite) || (DateTime.Now.Subtract(Start).TotalMilliseconds < Timeout))"  is complex.
Complex Conditional,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The conditional expression  "(CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10)"  is complex.
Complex Conditional,sones.Networking.TCPSocket,TCPSocketListener<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\TCPSocketListener.cs,StartTcpSocketConnection,The conditional expression  "tcpSocketConnection.ConnectionEstablished() && tcpSocketConnection.KeepAlive && tcpSocketConnection.TcpClientConnection.Connected && !_Stopped"  is complex.
Complex Conditional,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The conditional expression  "(b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126)"  is complex.
Complex Conditional,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The conditional expression  "b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68"  is complex.
Empty Catch Block,sones.Networking.HTTP,AcceptType,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\AcceptType.cs,AcceptType,The method has an empty catch block.
Empty Catch Block,sones.Networking.HTTP,AcceptType,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\AcceptType.cs,AcceptType,The method has an empty catch block.
Empty Catch Block,sones.Networking.HTTP,HTTPHeader,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHeader.cs,HTTPHeader,The method has an empty catch block.
Empty Catch Block,sones.Library.Threading,WorkItem,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItem.cs,FireWorkItemCompleted,The method has an empty catch block.
Empty Catch Block,sones.Library.Threading,WorkItem,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItem.cs,FireWorkItemStarted,The method has an empty catch block.
Empty Catch Block,sones.Library.Threading,WorkItemsGroup,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItemsGroup.cs,FireOnIdleImpl,The method has an empty catch block.
Magic Number,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The following statement contains a magic number: using (var _DataStream = GetStream(TcpClientConnection))              {                    try                  {                      #region Wait until new StreamData is available (returns true)' timeout or server shutdown                        if (!WaitForStreamDataAvailable())                          return false;                        #endregion                        #region Get header & body                        HTTPHeader requestHeader = null;                      Byte[] requestBody = null;                      Byte[] responseBodyBytes = new byte[0];                      Byte[] responseHeaderBytes = null;                      HTTPContext _HTTPWebContext = null;                      Exception _LastException = null;                      var _HeaderErrors = GetHeaderAndBody(_DataStream' out requestHeader' out requestBody);    #if DEBUG                      if (requestHeader.Destination == null)                          return false;                      if (requestHeader.Headers.AllKeys.Contains("SENDER"))                          Debug.WriteLine(string.Format("{0} Retrieved a request to resource {1} from {2}"' DateTime.Now.TimeOfDay' requestHeader.Destination' requestHeader.Headers["SENDER"])' "HttpHandler");                      else                          Debug.WriteLine(string.Format("{0} Retrieved a request to resource {1}"' DateTime.Now.TimeOfDay' requestHeader.Destination)' "HttpHandler");  #endif                      if (requestHeader == null || requestBody == null)                          return false;                        #endregion                        #region Trace                        //System.Diagnostics.Trace.WriteLine("-------------------request started-------------------");                      //System.Diagnostics.Trace.Indent();                      //System.Diagnostics.Trace.WriteLine("requestHeader:");                      //System.Diagnostics.Trace.Indent();                      //System.Diagnostics.Trace.WriteLine(requestHeader.PlainHeader);                      //System.Diagnostics.Trace.Unindent();                      //System.Diagnostics.Trace.WriteLine("requestBody:");                      //System.Diagnostics.Trace.Indent();                      //System.Diagnostics.Trace.WriteLine(Encoding.UTF8.GetString(requestBody));                      //System.Diagnostics.Trace.Unindent();                      //System.Diagnostics.Trace.Unindent();                      //System.Diagnostics.Trace.WriteLine("-----------------------------------------------------");                        #endregion                        #region Check if a error occurred during header processing...                        HTTPHeader responseHeader = null;                        if (requestHeader.HttpStatusCode != HTTPStatusCodes.OK)                      {                            responseHeader = new HTTPHeader()                          {                              HttpStatusCode = requestHeader.HttpStatusCode'                          };                            _HTTPWebContext = new HTTPContext(requestHeader' requestBody' responseHeader' _DataStream);                          HTTPServer.HTTPContext = _HTTPWebContext;                        }                        #endregion                        #region ... or process request and create a response header                        else                      {                            responseHeader = new HTTPHeader()                          {                              HttpStatusCode = HTTPStatusCodes.OK'                              ContentType = new ContentType("text/html")                          };                            #region Create and set HTTPContext                            _HTTPWebContext = new HTTPContext(requestHeader' requestBody' responseHeader' _DataStream);                          HTTPServer.HTTPContext = _HTTPWebContext;                            #endregion                            // Process request                          try                          {                                // Get Callback                              var parsedCallback = _Parser.GetCallback(_HTTPWebContext.RequestHeader.RawUrl' _HTTPWebContext.RequestHeader.HttpMethodString);                                #region Check callback...                                if (parsedCallback == null || parsedCallback.Item1 == null)                              {                                    Debug.WriteLine("Could not find a valid handler for url: " + _HTTPWebContext.RequestHeader.RawUrl);                                  responseBodyBytes = Encoding.UTF8.GetBytes("Could not find a valid handler for url: " + _HTTPWebContext.RequestHeader.RawUrl);                                    _HTTPWebContext.ResponseHeader = new HTTPHeader()                                  {                                      HttpStatusCode = HTTPStatusCodes.NotFound'                                      ContentType = new ContentType("text/plain")'                                      ContentLength = responseBodyBytes.ULongLength()                                  };                                    responseHeaderBytes = _HTTPWebContext.ResponseHeader.ToBytes();                                }                                #endregion                                #region ...check authentication and invoke method callback                                else                              {                                    var authenticated = false;                                    #region Check HTTPSecurity                                    // the server switched on authentication AND the method does not explicit allow not authentication                                  if (HTTPSecurity != null && !(parsedCallback.Item1.NeedsExplicitAuthentication.HasValue && !parsedCallback.Item1.NeedsExplicitAuthentication.Value))                                  {                                        #region Authentication                                        //in this case the client is already been authenticated by his certificate                                      if (HTTPSecurity.CredentialType == HttpClientCredentialType.Certificate)                                      {                                          authenticated = true;                                      }                                        if (HTTPSecurity.CredentialType == HttpClientCredentialType.Basic)                                      {                                            if (requestHeader.Authorization == null)                                          {                                                #region No authorisation info was sent                                                responseHeader = GetAuthenticationRequiredHeader();                                              responseHeaderBytes = responseHeader.ToBytes();                                                #endregion                                            }                                          else if (!Authorize(_HTTPWebContext.RequestHeader.Authorization))                                          {                                                #region Authorization failed                                                responseHeader = GetAuthenticationRequiredHeader();                                              responseHeaderBytes = responseHeader.ToBytes();                                                #endregion                                            }                                          else                                          {                                              authenticated = true;                                          }                                        }                                      else                                      {                                          if (HTTPSecurity.CredentialType != HttpClientCredentialType.Certificate)                                          {                                              responseBodyBytes = Encoding.UTF8.GetBytes("Authentication other than Basic or Certificate currently not provided");                                              responseHeader = new HTTPHeader() { HttpStatusCode = HTTPStatusCodes.InternalServerError' ContentLength = responseBodyBytes.ULongLength() };                                              responseHeaderBytes = responseHeader.ToBytes();                                                Debug.WriteLine("------------------------------------------------------------");                                              Debug.WriteLine("!!!Authentication other than Basic or Certificate currently not provided!!!");                                          }                                      }                                        #endregion                                    }                                    else if (parsedCallback.Item1.NeedsExplicitAuthentication.HasValue && parsedCallback.Item1.NeedsExplicitAuthentication.Value)                                  {                                        #region The server does not have authentication but the Interface explicitly needs authentication                                        responseBodyBytes = Encoding.UTF8.GetBytes("Authentication not provided from server");                                      responseHeader = new HTTPHeader() { HttpStatusCode = HTTPStatusCodes.InternalServerError' ContentLength = responseBodyBytes.ULongLength() };                                      responseHeaderBytes = responseHeader.ToBytes();                                        #endregion                                        Debug.WriteLine("---------------------------------------------");                                      Debug.WriteLine("!!!Authentication not provided from server!!!");                                    }                                  else                                      authenticated = true;                                    #endregion                                    if (authenticated)                                      InvokeURL(parsedCallback' _HTTPWebContext' ref responseHeaderBytes' ref responseBodyBytes);                                }                                #endregion                            }                            #region Handle exceptions occurred during request processing                            catch (Exception ex)                          {                                Debug.WriteLine(ex.ToString());                                responseBodyBytes = Encoding.UTF8.GetBytes(ex.ToString());                                responseHeader = new HTTPHeader()                              {                                  HttpStatusCode = HTTPStatusCodes.InternalServerError'                                  ContentType = new ContentType("text/plain")'                                  ContentLength = responseBodyBytes.ULongLength()                              };                                responseHeaderBytes = responseHeader.ToBytes();                                ExceptionThrowed(this' ex);                                _LastException = ex;                            }                            #endregion                        }                        #endregion                          #region Handle errors...                        if ((Int32)responseHeader.HttpStatusCode >= 400 && (Int32)responseHeader.HttpStatusCode <= 599)                      {                            #region Handle custom error pages...                            var _CustomErrorPage = _Instance as ICustomErrorPageHandler;                            if (_CustomErrorPage != null)                          {                              responseBodyBytes = _CustomErrorPage.GetCustomErrorPage(responseHeader.HttpStatusCode' _HTTPWebContext.RequestHeader' _HTTPWebContext.RequestBody' _LastException);                              responseHeader.ContentLength = responseBodyBytes.ULongLength();                              responseHeaderBytes = responseHeader.ToBytes();                          }                            #endregion                            #region ...or generate a generic errorpage!                            else                          {                                var _StringBuilder = new StringBuilder();                                _StringBuilder.AppendLine("<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">");                              _StringBuilder.AppendLine("<html>");                              _StringBuilder.AppendLine("  <head>");                              _StringBuilder.Append("    <title>").Append((Int32)responseHeader.HttpStatusCode).Append(" ").Append(HTTPHeader.HttpStatusCodeToSimpleString(responseHeader.HttpStatusCode)).AppendLine("</title>");                              _StringBuilder.AppendLine("  </head>");                              _StringBuilder.AppendLine("  <body>");                              _StringBuilder.Append("    <h1>Error ").Append((Int32)responseHeader.HttpStatusCode).Append(" - ").Append(HTTPHeader.HttpStatusCodeToSimpleString(responseHeader.HttpStatusCode)).AppendLine("</h1>");                              _StringBuilder.AppendLine("    Your client sent a request which led to an error!<br />");                              _StringBuilder.AppendLine("  </body>");                              _StringBuilder.AppendLine("</html>");                              _StringBuilder.AppendLine();                                responseBodyBytes = Encoding.UTF8.GetBytes(_StringBuilder.ToString());                              responseHeader.ContentLength = responseBodyBytes.ULongLength();                              responseHeaderBytes = responseHeader.ToBytes();                            }                            #endregion                        }                        #endregion                        #region Send Response                        // Remove HttpWebContext                      HTTPServer.HTTPContext = null;                        if (!_HTTPWebContext.StreamDataAvailable)                      {                            // The user did not write into the stream itself - we will add header and the invocation result                          var BytesToSend = new Byte[responseBodyBytes.Length + responseHeaderBytes.Length];                          Array.Copy(responseHeaderBytes' BytesToSend' responseHeaderBytes.Length);                          Array.Copy(responseBodyBytes' 0' BytesToSend' responseHeaderBytes.Length' responseBodyBytes.Length);                            _DataStream.Write(BytesToSend' 0' BytesToSend.Length);                        }                        #endregion                  }                  finally                  {                      if (_DataStream != null)                      {                          _DataStream.Close();                      }                      if (TcpClientConnection != null)                      {                          TcpClientConnection.Close();                      }                  }              }
Magic Number,sones.Networking.HTTP,HttpHandler<T>,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHandler.cs,ConnectionEstablished,The following statement contains a magic number: using (var _DataStream = GetStream(TcpClientConnection))              {                    try                  {                      #region Wait until new StreamData is available (returns true)' timeout or server shutdown                        if (!WaitForStreamDataAvailable())                          return false;                        #endregion                        #region Get header & body                        HTTPHeader requestHeader = null;                      Byte[] requestBody = null;                      Byte[] responseBodyBytes = new byte[0];                      Byte[] responseHeaderBytes = null;                      HTTPContext _HTTPWebContext = null;                      Exception _LastException = null;                      var _HeaderErrors = GetHeaderAndBody(_DataStream' out requestHeader' out requestBody);    #if DEBUG                      if (requestHeader.Destination == null)                          return false;                      if (requestHeader.Headers.AllKeys.Contains("SENDER"))                          Debug.WriteLine(string.Format("{0} Retrieved a request to resource {1} from {2}"' DateTime.Now.TimeOfDay' requestHeader.Destination' requestHeader.Headers["SENDER"])' "HttpHandler");                      else                          Debug.WriteLine(string.Format("{0} Retrieved a request to resource {1}"' DateTime.Now.TimeOfDay' requestHeader.Destination)' "HttpHandler");  #endif                      if (requestHeader == null || requestBody == null)                          return false;                        #endregion                        #region Trace                        //System.Diagnostics.Trace.WriteLine("-------------------request started-------------------");                      //System.Diagnostics.Trace.Indent();                      //System.Diagnostics.Trace.WriteLine("requestHeader:");                      //System.Diagnostics.Trace.Indent();                      //System.Diagnostics.Trace.WriteLine(requestHeader.PlainHeader);                      //System.Diagnostics.Trace.Unindent();                      //System.Diagnostics.Trace.WriteLine("requestBody:");                      //System.Diagnostics.Trace.Indent();                      //System.Diagnostics.Trace.WriteLine(Encoding.UTF8.GetString(requestBody));                      //System.Diagnostics.Trace.Unindent();                      //System.Diagnostics.Trace.Unindent();                      //System.Diagnostics.Trace.WriteLine("-----------------------------------------------------");                        #endregion                        #region Check if a error occurred during header processing...                        HTTPHeader responseHeader = null;                        if (requestHeader.HttpStatusCode != HTTPStatusCodes.OK)                      {                            responseHeader = new HTTPHeader()                          {                              HttpStatusCode = requestHeader.HttpStatusCode'                          };                            _HTTPWebContext = new HTTPContext(requestHeader' requestBody' responseHeader' _DataStream);                          HTTPServer.HTTPContext = _HTTPWebContext;                        }                        #endregion                        #region ... or process request and create a response header                        else                      {                            responseHeader = new HTTPHeader()                          {                              HttpStatusCode = HTTPStatusCodes.OK'                              ContentType = new ContentType("text/html")                          };                            #region Create and set HTTPContext                            _HTTPWebContext = new HTTPContext(requestHeader' requestBody' responseHeader' _DataStream);                          HTTPServer.HTTPContext = _HTTPWebContext;                            #endregion                            // Process request                          try                          {                                // Get Callback                              var parsedCallback = _Parser.GetCallback(_HTTPWebContext.RequestHeader.RawUrl' _HTTPWebContext.RequestHeader.HttpMethodString);                                #region Check callback...                                if (parsedCallback == null || parsedCallback.Item1 == null)                              {                                    Debug.WriteLine("Could not find a valid handler for url: " + _HTTPWebContext.RequestHeader.RawUrl);                                  responseBodyBytes = Encoding.UTF8.GetBytes("Could not find a valid handler for url: " + _HTTPWebContext.RequestHeader.RawUrl);                                    _HTTPWebContext.ResponseHeader = new HTTPHeader()                                  {                                      HttpStatusCode = HTTPStatusCodes.NotFound'                                      ContentType = new ContentType("text/plain")'                                      ContentLength = responseBodyBytes.ULongLength()                                  };                                    responseHeaderBytes = _HTTPWebContext.ResponseHeader.ToBytes();                                }                                #endregion                                #region ...check authentication and invoke method callback                                else                              {                                    var authenticated = false;                                    #region Check HTTPSecurity                                    // the server switched on authentication AND the method does not explicit allow not authentication                                  if (HTTPSecurity != null && !(parsedCallback.Item1.NeedsExplicitAuthentication.HasValue && !parsedCallback.Item1.NeedsExplicitAuthentication.Value))                                  {                                        #region Authentication                                        //in this case the client is already been authenticated by his certificate                                      if (HTTPSecurity.CredentialType == HttpClientCredentialType.Certificate)                                      {                                          authenticated = true;                                      }                                        if (HTTPSecurity.CredentialType == HttpClientCredentialType.Basic)                                      {                                            if (requestHeader.Authorization == null)                                          {                                                #region No authorisation info was sent                                                responseHeader = GetAuthenticationRequiredHeader();                                              responseHeaderBytes = responseHeader.ToBytes();                                                #endregion                                            }                                          else if (!Authorize(_HTTPWebContext.RequestHeader.Authorization))                                          {                                                #region Authorization failed                                                responseHeader = GetAuthenticationRequiredHeader();                                              responseHeaderBytes = responseHeader.ToBytes();                                                #endregion                                            }                                          else                                          {                                              authenticated = true;                                          }                                        }                                      else                                      {                                          if (HTTPSecurity.CredentialType != HttpClientCredentialType.Certificate)                                          {                                              responseBodyBytes = Encoding.UTF8.GetBytes("Authentication other than Basic or Certificate currently not provided");                                              responseHeader = new HTTPHeader() { HttpStatusCode = HTTPStatusCodes.InternalServerError' ContentLength = responseBodyBytes.ULongLength() };                                              responseHeaderBytes = responseHeader.ToBytes();                                                Debug.WriteLine("------------------------------------------------------------");                                              Debug.WriteLine("!!!Authentication other than Basic or Certificate currently not provided!!!");                                          }                                      }                                        #endregion                                    }                                    else if (parsedCallback.Item1.NeedsExplicitAuthentication.HasValue && parsedCallback.Item1.NeedsExplicitAuthentication.Value)                                  {                                        #region The server does not have authentication but the Interface explicitly needs authentication                                        responseBodyBytes = Encoding.UTF8.GetBytes("Authentication not provided from server");                                      responseHeader = new HTTPHeader() { HttpStatusCode = HTTPStatusCodes.InternalServerError' ContentLength = responseBodyBytes.ULongLength() };                                      responseHeaderBytes = responseHeader.ToBytes();                                        #endregion                                        Debug.WriteLine("---------------------------------------------");                                      Debug.WriteLine("!!!Authentication not provided from server!!!");                                    }                                  else                                      authenticated = true;                                    #endregion                                    if (authenticated)                                      InvokeURL(parsedCallback' _HTTPWebContext' ref responseHeaderBytes' ref responseBodyBytes);                                }                                #endregion                            }                            #region Handle exceptions occurred during request processing                            catch (Exception ex)                          {                                Debug.WriteLine(ex.ToString());                                responseBodyBytes = Encoding.UTF8.GetBytes(ex.ToString());                                responseHeader = new HTTPHeader()                              {                                  HttpStatusCode = HTTPStatusCodes.InternalServerError'                                  ContentType = new ContentType("text/plain")'                                  ContentLength = responseBodyBytes.ULongLength()                              };                                responseHeaderBytes = responseHeader.ToBytes();                                ExceptionThrowed(this' ex);                                _LastException = ex;                            }                            #endregion                        }                        #endregion                          #region Handle errors...                        if ((Int32)responseHeader.HttpStatusCode >= 400 && (Int32)responseHeader.HttpStatusCode <= 599)                      {                            #region Handle custom error pages...                            var _CustomErrorPage = _Instance as ICustomErrorPageHandler;                            if (_CustomErrorPage != null)                          {                              responseBodyBytes = _CustomErrorPage.GetCustomErrorPage(responseHeader.HttpStatusCode' _HTTPWebContext.RequestHeader' _HTTPWebContext.RequestBody' _LastException);                              responseHeader.ContentLength = responseBodyBytes.ULongLength();                              responseHeaderBytes = responseHeader.ToBytes();                          }                            #endregion                            #region ...or generate a generic errorpage!                            else                          {                                var _StringBuilder = new StringBuilder();                                _StringBuilder.AppendLine("<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">");                              _StringBuilder.AppendLine("<html>");                              _StringBuilder.AppendLine("  <head>");                              _StringBuilder.Append("    <title>").Append((Int32)responseHeader.HttpStatusCode).Append(" ").Append(HTTPHeader.HttpStatusCodeToSimpleString(responseHeader.HttpStatusCode)).AppendLine("</title>");                              _StringBuilder.AppendLine("  </head>");                              _StringBuilder.AppendLine("  <body>");                              _StringBuilder.Append("    <h1>Error ").Append((Int32)responseHeader.HttpStatusCode).Append(" - ").Append(HTTPHeader.HttpStatusCodeToSimpleString(responseHeader.HttpStatusCode)).AppendLine("</h1>");                              _StringBuilder.AppendLine("    Your client sent a request which led to an error!<br />");                              _StringBuilder.AppendLine("  </body>");                              _StringBuilder.AppendLine("</html>");                              _StringBuilder.AppendLine();                                responseBodyBytes = Encoding.UTF8.GetBytes(_StringBuilder.ToString());                              responseHeader.ContentLength = responseBodyBytes.ULongLength();                              responseHeaderBytes = responseHeader.ToBytes();                            }                            #endregion                        }                        #endregion                        #region Send Response                        // Remove HttpWebContext                      HTTPServer.HTTPContext = null;                        if (!_HTTPWebContext.StreamDataAvailable)                      {                            // The user did not write into the stream itself - we will add header and the invocation result                          var BytesToSend = new Byte[responseBodyBytes.Length + responseHeaderBytes.Length];                          Array.Copy(responseHeaderBytes' BytesToSend' responseHeaderBytes.Length);                          Array.Copy(responseBodyBytes' 0' BytesToSend' responseHeaderBytes.Length' responseBodyBytes.Length);                            _DataStream.Write(BytesToSend' 0' BytesToSend.Length);                        }                        #endregion                  }                  finally                  {                      if (_DataStream != null)                      {                          _DataStream.Close();                      }                      if (TcpClientConnection != null)                      {                          TcpClientConnection.Close();                      }                  }              }
Magic Number,sones.Networking.HTTP,HTTPHeader,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHeader.cs,HTTPHeader,The following statement contains a magic number: if (HTTPMethodHeader.Length < 3)              {                  HttpStatusCode = HTTPStatusCodes.BadRequest;                  return;              }
Magic Number,sones.Networking.HTTP,HTTPHeader,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHeader.cs,HTTPHeader,The following statement contains a magic number: if (HTTPMethodHeader[0].StartsWith("HTTP"))              {                                  Protocol        = HTTPMethodHeader[0];                  ProtocolArray   = Protocol.Split(_SlashSeperator);                  ProtocolName    = ProtocolArray[0].ToLower();                  ProtocolVersion = new Version(ProtocolArray[1]);                  HttpStatusCode  = (HTTPStatusCodes) Enum.Parse(typeof(HTTPStatusCodes)' HTTPMethodHeader[1]);              }                // This is a request              else              {                    if (!Enum.IsDefined(typeof(HTTPMethods)' HTTPMethodHeader[0]))                  {                      //HttpStatusCode = HTTPStatusCodes.NotImplemented;                      HttpMethod       = HTTPMethods.UNKNOWN;                      HttpMethodString = HTTPMethodHeader[0];                      //return;                      //throw new Exception("Invalid HTTP Method " + HTTPMethodHeader[0]);                  }                  else                  {                      HttpMethod       = (HTTPMethods) Enum.Parse(typeof(HTTPMethods)' HTTPMethodHeader[0]);                      HttpMethodString = HTTPMethodHeader[0];                  }                    // Decode UTF-8 Hex encoding "%C3%B6" -> "φ" etc...                  Destination = RawUrl = HTTPMethodHeader[1];// HttpUtility.UrlDecode(HTTPMethodHeader[1]);                  //if (Destination.Length > 1 && Destination.EndsWith("/") && !Destination.Contains("/?"))                  //{                  //    RawUrl = HttpUtility.UrlDecode(HTTPMethodHeader[1]);//.TrimEnd(((String)"/").ToCharArray());                  //    if (RawUrl[RawUrl.Length-1] == '/')                  //    {                  //        RawUrl = RawUrl.Substring(0' RawUrl.Length - 1);                  //    }                  //    Destination = RawUrl;                  //}                    // Parse QueryString after '?' and maybe fix the Destination                  var _Questionmark = RawUrl.IndexOf('?');                  if (_Questionmark > -1)                  {                      Destination = RawUrl.Substring(0' _Questionmark);                      QueryString = HttpUtility.ParseQueryString(RawUrl.Substring(_Questionmark + 1));                  }                    //!svn/vcc/default                  var _Exclamationmark = RawUrl.IndexOf('!');                  if (_Exclamationmark > -1)                  {                      SVNParameters = RawUrl.Substring(_Exclamationmark + 1);                      Destination   = RawUrl.Substring(0' _Exclamationmark - 1);                      if (Destination == "") Destination = "/";                  }                    Protocol        = HTTPMethodHeader[2];                  ProtocolArray   = Protocol.Split(_SlashSeperator);                  ProtocolName    = ProtocolArray[0].ToLower();                  ProtocolVersion = new Version(ProtocolArray[1]);                    RawUrl = HTTPMethodHeader[1];                }
Magic Number,sones.Networking.HTTP,HTTPHeader,C:\repos\sones_sones\Library\Internal\Network\Networking\HttpWebServer\HTTPHeader.cs,ParseHttpStatus,The following statement contains a magic number: if (HTTPMethodHeader.Length < 3)              {                  return Result;              }
Magic Number,sones.Library.Threading,WorkItem,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: try              {                  try                  {                      result = _callback(_state);                  }                  catch (Exception e)                  {                      // Save the exception so we can rethrow it later                      exception = e;                  }                    // Remove the value of the execution thread' so it will not be possible to cancel the work item                  // since it is already completed.                  // Cancelling a work item that already completed may cause the abortion of the next work item!!!                  Thread executionThread = Interlocked.CompareExchange(ref _executingThread' null' _executingThread);                    if (null == executionThread)                  {                      // Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException                      Thread.Sleep(60*1000);                        // If after 1 minute this thread was not aborted then let it continue working.                  }              }              // We must treat the ThreadAbortException or else it will be stored in the exception variable              catch (ThreadAbortException tae)              {                  // Check if the work item was cancelled                  if ((String)tae.ExceptionState == "Cancel")                  {  #if !(WindowsCE)                      Thread.ResetAbort();  #endif                  }              }
Magic Number,sones.Library.Threading,WorkItem,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: try              {                  try                  {                      result = _callback(_state);                  }                  catch (Exception e)                  {                      // Save the exception so we can rethrow it later                      exception = e;                  }                    // Remove the value of the execution thread' so it will not be possible to cancel the work item                  // since it is already completed.                  // Cancelling a work item that already completed may cause the abortion of the next work item!!!                  Thread executionThread = Interlocked.CompareExchange(ref _executingThread' null' _executingThread);                    if (null == executionThread)                  {                      // Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException                      Thread.Sleep(60*1000);                        // If after 1 minute this thread was not aborted then let it continue working.                  }              }              // We must treat the ThreadAbortException or else it will be stored in the exception variable              catch (ThreadAbortException tae)              {                  // Check if the work item was cancelled                  if ((String)tae.ExceptionState == "Cancel")                  {  #if !(WindowsCE)                      Thread.ResetAbort();  #endif                  }              }
Magic Number,sones.Library.Threading,WorkItem,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItem.cs,WaitAll,The following statement contains a magic number: if ((null == cancelWaitHandle) && (waitHandles.Length <= 64))  			{  				success = EventWaitHandle.WaitAll(waitHandles' millisecondsTimeout' exitContext);  			}  			else  			{  				success = true;  				int millisecondsLeft = millisecondsTimeout;                  DateTime start = TimestampNonce.Now;    				WaitHandle [] whs;  				if (null != cancelWaitHandle)  				{  					whs = new WaitHandle [] { null' cancelWaitHandle };  				}  				else  				{  					whs = new WaitHandle [] { null };  				}                    bool waitInfinitely = (Timeout.Infinite == millisecondsTimeout);  				// Iterate over the wait handles and wait for each one to complete.  				// We cannot use WaitHandle.WaitAll directly' because the cancelWaitHandle  				// won't affect it.  				// Each iteration we update the time left for the timeout.                  for (int i = 0; i < waitableResults.Length; ++i)  				{                      // WaitAny don't work with negative numbers                      if (!waitInfinitely && (millisecondsLeft < 0))                      {                          success = false;                          break;                      }    					whs[0] = waitHandles[i];  					int result = EventWaitHandle.WaitAny(whs' millisecondsLeft' exitContext);                      if ((result > 0) || (EventWaitHandle.WaitTimeout == result))  					{  						success = false;  						break;  					}    					if(!waitInfinitely)  					{                          // Update the time left to wait                          TimeSpan ts = TimestampNonce.Now - start;  						millisecondsLeft = millisecondsTimeout - (int)ts.TotalMilliseconds;  					}  				}  			}
Magic Number,sones.Library.Threading,GraphThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\ThreadPool\ThreadPool.cs,Worker,The following statement contains a magic number: while (!_Disposed)              {                    if (_SuspendNextFreeWorker)                  {                      lock (_SuspendNextFreeWorkerLock)                      {                          if (_SuspendNextFreeWorker)                          {                              _SuspendNextFreeWorker = false;                              Interlocked.Decrement(ref _WorkerThreads);                              break;                          }                      }                  }                    Interlocked.Increment(ref _FreeWorkers);                    lock (_WorkitemsQueue)                  {                        while (_WorkitemsQueue.Count == 0 && !_Disposed)                      {                          Monitor.Wait(_WorkitemsQueue' 50);                      }                        if (_Disposed) break;                        threadPoolEntry = _WorkitemsQueue.Dequeue();                      Interlocked.Decrement(ref _Workitems);                  }                    Interlocked.Decrement(ref _FreeWorkers);                  Interlocked.Increment(ref _BusyWorkers);                    try                  {                      threadPoolEntry.Value.Invoke();                  }                  catch (Exception ex)                  {                      if (OnWorkerThreadException != null)                          if (ex.InnerException != null)                              OnWorkerThreadException(this' ex.InnerException);                          else                              OnWorkerThreadException(this' ex);                  }                    Interlocked.Decrement(ref _BusyWorkers);                }
Magic Number,sones.Library.Threading,GraphThreadPool,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\ThreadPool\ThreadPool.cs,Dispose,The following statement contains a magic number: lock (_WorkitemsQueue)              {                  while (!_Disposed)                  {                      if (_WorkitemsQueue.Count == 0)                          _Disposed = true;                      else                          Monitor.Wait(_WorkitemsQueue' 50); // wait for changed on _ThreadTargets                  }              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: var ReadBuffer = new Byte[16 * 1024];
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: var ReadBuffer = new Byte[16 * 1024];
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: Int32 CurPos = 4;
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10))              {                  CurPos++;              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10))              {                  CurPos++;              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10))              {                  CurPos++;              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10))              {                  CurPos++;              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10))              {                  CurPos++;              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10))              {                  CurPos++;              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetHeaderAndBody,The following statement contains a magic number: while ((CurPos < FirstBytes.Length) && !(FirstBytes[CurPos - 4] == 13 && FirstBytes[CurPos - 3] == 10 && FirstBytesList[CurPos - 2] == 13 && FirstBytesList[CurPos - 1] == 10))              {                  CurPos++;              }
Magic Number,sones.Networking.TCPSocket,ATCPSocketConnection,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\ATCPSocketConnection.cs,GetAllAvailableData,The following statement contains a magic number: Byte[] ReadBuffer = new Byte[1024];
Magic Number,sones.Networking.TCPSocket,TCPSocketListener<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\TCPSocketListener.cs,StartListener,The following statement contains a magic number: _TcpListener.Start(10000);
Magic Number,sones.Networking.TCPSocket,TCPSocketListener<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\TCPSocket\TCPSocketListener.cs,ToString,The following statement contains a magic number: return String.Concat("ConnectedClients: " + ConnectedClients.ToString().PadLeft(3)' " IsRunning:"' IsRunning' " StopRequested: "' StopRequested);
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,TelnetParser,The following statement contains a magic number: _LocalOptions = new BitArray(256' false);
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,TelnetParser,The following statement contains a magic number: _RemoteOptions = new BitArray(256' false);
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following statement contains a magic number: if (OnKeyReceived != null)              {                    Byte[] bytesToSend = null;                  //Console.Write("[TelnetParser_OnDataReceived] DataLength: " + myEventArgs.Data.Length + "Key: ");                  Int32 i=0;                  while (i < myData.Length)                  {                      ConsoleKeyInfo? keyInfo = null;                      Byte b = myData[i++];                      //Write((char)b + " = " + b.ToString() + "' ");                        #region Parse bytes and create ConsoleKeyInfo                        // Special key' e.g.: ! " # $ %                      if ((b >= 32 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96) || (b >= 123 && b <= 126))                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)0' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // numbers                      else if (b >= 48 && b <= 57)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char a-z                      else if (b >= 65 && b <= 90)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)b' false' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // char A-Z                      else if (b >= 97 && b <= 122)                      {                          keyInfo = new ConsoleKeyInfo((char)b' (ConsoleKey)(b - 32)' true' false' false);                          bytesToSend = new Byte[1];                          bytesToSend[0] = b;                      }                        // Arrows                      else if (b == 27 && (i + 1 < myData.Length) && myData[i] == 91 && myData[i + 1] >= 65 && myData[i + 1] <= 68)                      {                          b = myData[i + 1];                          switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }                          i += 2;                      }                        // TAB                      else if (b == 9)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Tab' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // ESC                      else if (b == 27)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Escape' false' false' false);                          bytesToSend = new Byte[3] { 27' 91' 50 };                      }                        // Delete (Entf)                      else if (b == 127)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Delete' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Backspace                      else if (b == 8)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Backspace' false' false' false);                          bytesToSend = new Byte[1] { b };                      }                        // Enter                      else if (b == (Byte)ASCIIControlCodes.CR)                      {                          keyInfo = new ConsoleKeyInfo((char)b' ConsoleKey.Enter' false' false' false);                          if (myData[i] == 0) i++;                      }                        #endregion                        if (keyInfo.HasValue)                      {                            TelnetKeyEventArgs args = new TelnetKeyEventArgs();                          args.KeyInfo = keyInfo.Value;                          OnKeyReceived(this' args);                                            }                  }                }
Magic Number,sones.Networking.UDPSocket,UDPSocketMulticast<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\UDPSocket\UDPSocketMulticast.cs,StartListener,The following statement contains a magic number: if (Int32.Parse(parts[0]) < 224 || Int32.Parse(parts[0]) > 239)                  throw new Exception("Invalid multicast IP Address");
Magic Number,sones.Networking.UDPSocket,UDPSocketMulticast<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\UDPSocket\UDPSocketMulticast.cs,StartListener,The following statement contains a magic number: if (Int32.Parse(parts[0]) < 224 || Int32.Parse(parts[0]) > 239)                  throw new Exception("Invalid multicast IP Address");
Magic Number,sones.Networking.UDPSocket,UDPSocketMulticast<TServerLogic>,C:\repos\sones_sones\Library\Internal\Network\Networking\UDPSocket\UDPSocketMulticast.cs,StartListener,The following statement contains a magic number: if (_Port < 0 || _Port > 65535)                  throw new Exception(_Port + " is not a valid port (must between 0 and )");
Missing Default,sones.Library.Threading,WorkItem,C:\repos\sones_sones\Library\Internal\Network\Networking\Multithreading\SmartThreadPool\WorkItem.cs,Cancel,The following switch statement is missing a default case: switch(GetWorkItemState())  				{  					case WorkItemState.Canceled:  						//Debug.WriteLine("Work item already canceled");  						success =  true;                          break;  					case WorkItemState.Completed:                          //Debug.WriteLine("Work item cannot be canceled");                          break;                      case WorkItemState.InProgress:                          if (abortExecution)                          {                              Thread executionThread = Interlocked.CompareExchange(ref _executingThread' null' _executingThread);                              if (null != executionThread)                              {                                  executionThread.Abort("Cancel");                                  success = true;                                  signalComplete = true;                              }                          }                          else                          {                              success = true;                              signalComplete = true;                          }                          break;  					case WorkItemState.InQueue:  						// Signal to the wait for completion that the work  						// item has been completed (canceled). There is no  						// reason to wait for it to get out of the queue                          signalComplete = true;  						//Debug.WriteLine("Work item canceled");  						success = true;                          break;  				}
Missing Default,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleTelnetOption,The following switch statement is missing a default case: switch (myTelnetSymbol.Command)              {                  case TelnetCommands.Will:                      HandleTelnetWillOption(myTelnetSymbol);                      break;                  case TelnetCommands.Wont:                      HandleTelnetWontOption(myTelnetSymbol);                      break;                  case TelnetCommands.Do:                      HandleTelnetDoOption(myTelnetSymbol);                      break;                  case TelnetCommands.Dont:                      HandleTelnetDontOption(myTelnetSymbol);                      break;              }
Missing Default,sones.Networking.Telnet,TelnetParser,C:\repos\sones_sones\Library\Internal\Network\Networking\Telnet\TelnetParser.cs,HandleKeys,The following switch statement is missing a default case: switch (b)                          {                              case 65:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.UpArrow' false' false' false);                                  break;                              case 66:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.DownArrow' false' false' false);                                  break;                              case 67:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.RightArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                              case 68:                                  keyInfo = new ConsoleKeyInfo((char)0' ConsoleKey.LeftArrow' false' false' false);                                  bytesToSend = new Byte[3];                                  Array.Copy(myData' i - 1' bytesToSend' 0' 3);                                  break;                          }
