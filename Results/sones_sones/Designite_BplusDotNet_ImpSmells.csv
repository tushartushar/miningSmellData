Implementation smell,Namespace,Class,File,Method,Description
Long Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Delete,The method has 134 lines of code.
Long Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The method has 107 lines of code.
Long Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,InsertLeaf,The method has 109 lines of code.
Long Method,BplusDotNet,LinkedFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\LinkedFile.cs,checkStructure,The method has 109 lines of code.
Complex Method,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Recover,Cyclomatic complexity of the method is 11
Complex Method,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,toHtml,Cyclomatic complexity of the method is 8
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SanityCheck,Cyclomatic complexity of the method is 19
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Delete,Cyclomatic complexity of the method is 15
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,Cyclomatic complexity of the method is 12
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,MergeLeaves,Cyclomatic complexity of the method is 9
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,DeleteLeaf,Cyclomatic complexity of the method is 8
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Insert,Cyclomatic complexity of the method is 8
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,InsertLeaf,Cyclomatic complexity of the method is 10
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Load,Cyclomatic complexity of the method is 8
Complex Method,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Dump,Cyclomatic complexity of the method is 8
Complex Method,BplusDotNet,LinkedFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\LinkedFile.cs,checkStructure,Cyclomatic complexity of the method is 20
Long Parameter List,BplusDotNet,BplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTree.cs,Initialize,The method has 6 parameters. Parameters: treefileName' blockfileName' KeyLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,BplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTree.cs,Initialize,The method has 6 parameters. Parameters: treefile' blockfile' KeyLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,BplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeBytes.cs,Initialize,The method has 6 parameters. Parameters: treefileName' blockfileName' KeyLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,BplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeBytes.cs,Initialize,The method has 6 parameters. Parameters: treefile' blockfile' KeyLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,BplusTreeLong,The method has 5 parameters. Parameters: fromfile' NodeSize' KeyLength' StartSeek' CultureId
Long Parameter List,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,InitializeInStream,The method has 5 parameters. Parameters: fromfile' KeyLength' NodeSize' CultureId' StartSeek
Long Parameter List,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The method has 5 parameters. Parameters: left' KeyBetween' right' rightLeastKey' DeleteRight
Long Parameter List,BplusDotNet,hBplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTree.cs,Initialize,The method has 6 parameters. Parameters: treefileName' blockfileName' PrefixLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,hBplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTree.cs,Initialize,The method has 6 parameters. Parameters: treefile' blockfile' PrefixLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,hBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTreeBytes.cs,Initialize,The method has 6 parameters. Parameters: treefileName' blockfileName' PrefixLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,hBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTreeBytes.cs,Initialize,The method has 6 parameters. Parameters: treefile' blockfile' PrefixLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,LinkedFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\LinkedFile.cs,SetBuffer,The method has 6 parameters. Parameters: buffernumber' type' thebuffer' start' length' NextBufferNumber
Long Parameter List,BplusDotNet,xBplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\xBplusTree.cs,Initialize,The method has 6 parameters. Parameters: treefileName' blockfileName' PrefixLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,xBplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\xBplusTree.cs,Initialize,The method has 6 parameters. Parameters: treefile' blockfile' PrefixLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,xBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\xBplusTreeBytes.cs,Initialize,The method has 6 parameters. Parameters: treefileName' blockfileName' PrefixLength' CultureId' nodesize' buffersize
Long Parameter List,BplusDotNet,xBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\xBplusTreeBytes.cs,Initialize,The method has 6 parameters. Parameters: treefile' blockfile' PrefixLength' CultureId' nodesize' buffersize
Long Statement,BplusDotNet,BplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTree.cs,Initialize,The length of the statement  "			BplusTreeBytes tree = BplusTreeBytes.Initialize(treefileName' blockfileName' KeyLength' CultureId' nodesize' buffersize); " is 121.
Long Statement,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,TestRebuffer,The length of the statement  "				throw new BplusTreeException("didn't get back buffernumber "+this.Size+" got "+this.ChildBufferNumbers[this.Size]+" not "+Ns[this.Size]); " is 137.
Long Statement,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,DumpToFreshBuffer,The length of the statement  "			//System.Diagnostics.Debug.WriteLine("\r\n<br> dumping "+this.indexInParent+" from "+oldbuffernumber+" to "+freshBufferNumber); " is 127.
Long Statement,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The length of the statement  "			//System.Diagnostics.Debug.WriteLine("\r\n<br> merging "+right.myBufferNumber+" ("+KeyBetween+") "+left.myBufferNumber); " is 120.
Long Statement,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,InsertLeaf,The length of the statement  "				if (this.ChildKeys[insertposition]==null || this.owner.Compare(this.ChildKeys[insertposition]' key)==0) // this.ChildKeys[insertposition].Equals(key) " is 149.
Long Statement,BplusDotNet,hBplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTree.cs,Initialize,The length of the statement  "			hBplusTreeBytes tree = hBplusTreeBytes.Initialize(treefileName' blockfileName' PrefixLength' CultureId' nodesize' buffersize); " is 126.
Long Statement,BplusDotNet,LinkedFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\LinkedFile.cs,InitializeLinkedFileInStream,The length of the statement  "			result.buffers = BufferFile.InitializeBufferFileInStream(fromfile' buffersize+BUFFEROVERHEAD' StartSeek+result.headersize); " is 123.
Long Statement,BplusDotNet,xBplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\xBplusTree.cs,Initialize,The length of the statement  "			xBplusTreeBytes tree = xBplusTreeBytes.Initialize(treefileName' blockfileName' PrefixLength' CultureId' nodesize' buffersize); " is 126.
Virtual Method Call from Constructor,BplusDotNet,BplusTree,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTree.cs,BplusTree,The constructor "BplusTree" calls a virtual method "checkTree".
Magic Number,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SanityCheck,The following statement contains a magic number: if (this.NodeSize<2)   			{  				throw new BplusTreeException("node size must be larger than 2");  			}
Magic Number,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SanityCheck,The following statement contains a magic number: if (this.KeyLength<5)   			{  				throw new BplusTreeException("Key length must be larger than 5");  			}
Magic Number,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SetupFromExistingStream,The following statement contains a magic number: BplusTreeLong result = new BplusTreeLong(fromfile' 7' 100' StartSeek' dummyId);
Magic Number,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SetupFromExistingStream,The following statement contains a magic number: BplusTreeLong result = new BplusTreeLong(fromfile' 7' 100' StartSeek' dummyId);
Magic Number,BplusDotNet,BplusTreeLong,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SetFootPrintLimit,The following statement contains a magic number: if (limit<5)   			{  				throw new BplusTreeException("foot print limit less than 5 is too small");  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SerializationCheck,The following statement contains a magic number: A.ChildBufferNumbers[this.Size] = 7;
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SerializationCheck,The following statement contains a magic number: A.ChildBufferNumbers[this.Size] = -9097;
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,SanityCheck,The following statement contains a magic number: if (this.parent!=null)   			{  				if (this.parent.isLeaf)   				{  					throw new BplusTreeException("parent is leaf");  				}  				this.parent.MaterializeNodeAtIndex(this.indexInParent);  				if (this.parent.MaterializedChildNodes[this.indexInParent]!=this)   				{  					throw new BplusTreeException("incorrect index in parent");  				}  				// since not at root there should be at least size/2 keys  				int limit = this.Size/2;  				if (this.isLeaf)   				{  					limit--;  				}  				for (int i=0; i<limit; i++)   				{  					if (this.ChildKeys[i]==null)   					{  						throw new BplusTreeException("null child in first half");  					}  				}  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Destroy,The following statement contains a magic number: this.Size = -100;
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Destroy,The following statement contains a magic number: this.indexInParent = -100;
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Delete,The following statement contains a magic number: if (delresult!=null && this.owner.Compare(delresult' key)==0) // delresult.Equals(key)  			{  				if (this.Size>3)   				{  					throw new BplusTreeException("assertion error: delete returned delete key for too large node size: "+this.Size);  				}  				// junk this leaf and shift everything over  				if (deleteposition==0)   				{  					result = this.ChildKeys[deleteposition];  				}   				else if (deleteposition==this.Size)   				{  					this.ChildKeys[deleteposition-1] = null;  				}  				else  				{  					this.ChildKeys[deleteposition-1] = this.ChildKeys[deleteposition];  				}  				if (result!=null && this.owner.Compare(result' key)==0) // result.Equals(key)  				{  					// I'm not sure this ever happens  					this.MaterializeNodeAtIndex(1);  					result = this.MaterializedChildNodes[1].LeastKey();  				}  				DeleteChild.Free();  				for (int i=deleteposition; i<this.Size-1; i++)   				{  					this.ChildKeys[i] = this.ChildKeys[i+1];  					this.MaterializedChildNodes[i] = this.MaterializedChildNodes[i+1];  					this.ChildBufferNumbers[i] = this.ChildBufferNumbers[i+1];  				}  				this.ChildKeys[this.Size-1] = null;  				if (deleteposition<this.Size)   				{  					this.MaterializedChildNodes[this.Size-1] = this.MaterializedChildNodes[this.Size];  					this.ChildBufferNumbers[this.Size-1] = this.ChildBufferNumbers[this.Size];  				}  				this.MaterializedChildNodes[this.Size] = null;  				this.ChildBufferNumbers[this.Size] = BplusTreeLong.NULLBUFFERNUMBER;  				MergeMe = (this.SizeInUse()<this.Size/2);  				this.reParentAllChildren();  				return result;  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Delete,The following statement contains a magic number: if (delresult!=null && this.owner.Compare(delresult' key)==0) // delresult.Equals(key)  			{  				if (this.Size>3)   				{  					throw new BplusTreeException("assertion error: delete returned delete key for too large node size: "+this.Size);  				}  				// junk this leaf and shift everything over  				if (deleteposition==0)   				{  					result = this.ChildKeys[deleteposition];  				}   				else if (deleteposition==this.Size)   				{  					this.ChildKeys[deleteposition-1] = null;  				}  				else  				{  					this.ChildKeys[deleteposition-1] = this.ChildKeys[deleteposition];  				}  				if (result!=null && this.owner.Compare(result' key)==0) // result.Equals(key)  				{  					// I'm not sure this ever happens  					this.MaterializeNodeAtIndex(1);  					result = this.MaterializedChildNodes[1].LeastKey();  				}  				DeleteChild.Free();  				for (int i=deleteposition; i<this.Size-1; i++)   				{  					this.ChildKeys[i] = this.ChildKeys[i+1];  					this.MaterializedChildNodes[i] = this.MaterializedChildNodes[i+1];  					this.ChildBufferNumbers[i] = this.ChildBufferNumbers[i+1];  				}  				this.ChildKeys[this.Size-1] = null;  				if (deleteposition<this.Size)   				{  					this.MaterializedChildNodes[this.Size-1] = this.MaterializedChildNodes[this.Size];  					this.ChildBufferNumbers[this.Size-1] = this.ChildBufferNumbers[this.Size];  				}  				this.MaterializedChildNodes[this.Size] = null;  				this.ChildBufferNumbers[this.Size] = BplusTreeLong.NULLBUFFERNUMBER;  				MergeMe = (this.SizeInUse()<this.Size/2);  				this.reParentAllChildren();  				return result;  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Delete,The following statement contains a magic number: if (MergeKid)   			{  				int leftindex' rightindex;  				BplusNode leftNode;  				BplusNode rightNode;  				string keyBetween;  				if (deleteposition==0)   				{  					// merge with next  					leftindex = deleteposition;  					rightindex = deleteposition+1;  					leftNode = DeleteChild;  					//keyBetween = this.ChildKeys[deleteposition];  					rightNode = this.MaterializeNodeAtIndex(rightindex);  				}   				else   				{  					// merge with previous  					leftindex = deleteposition-1;  					rightindex = deleteposition;  					leftNode = this.MaterializeNodeAtIndex(leftindex);  					//keyBetween = this.ChildKeys[deleteBufferNumber-1];  					rightNode = DeleteChild;  				}  				keyBetween = this.ChildKeys[leftindex];  				string rightLeastKey;  				bool DeleteRight;  				Merge(leftNode' keyBetween' rightNode' out rightLeastKey' out DeleteRight);  				// delete the right node if needed.  				if (DeleteRight)   				{  					for (int i=rightindex; i<this.Size; i++)   					{  						this.ChildKeys[i-1] = this.ChildKeys[i];  						this.ChildBufferNumbers[i] = this.ChildBufferNumbers[i+1];  						this.MaterializedChildNodes[i] = this.MaterializedChildNodes[i+1];  					}  					this.ChildKeys[this.Size-1] = null;  					this.MaterializedChildNodes[this.Size] = null;  					this.ChildBufferNumbers[this.Size] = BplusTreeLong.NULLBUFFERNUMBER;  					this.reParentAllChildren();  					rightNode.Free();  					// does this node need merging?  					if (this.SizeInUse()<this.Size/2)   					{  						MergeMe = true;  					}  				}   				else   				{  					// update the key entry  					this.ChildKeys[rightindex-1] = rightLeastKey;  				}  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The following statement contains a magic number: string[] allkeys = new string[left.Size*2+1];
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The following statement contains a magic number: long[] allseeks = new long[left.Size*2+2];
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The following statement contains a magic number: long[] allseeks = new long[left.Size*2+2];
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The following statement contains a magic number: BplusNode[] allMaterialized = new BplusNode[left.Size*2+2];
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The following statement contains a magic number: BplusNode[] allMaterialized = new BplusNode[left.Size*2+2];
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Merge,The following statement contains a magic number: int leftcontent = index/2;
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,MergeLeaves,The following statement contains a magic number: string[] allkeys = new string[left.Size*2];
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,MergeLeaves,The following statement contains a magic number: long[] allseeks = new long[left.Size*2];
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,MergeLeaves,The following statement contains a magic number: int rightcontent = index/2;
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,DeleteLeaf,The following statement contains a magic number: if (this.SizeInUse()<this.Size/2)  			{  				MergeMe = true;  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Insert,The following statement contains a magic number: if (childSplit!=null)   			{  				// insert the child  				this.Soil(); // redundant -- a child will have a change so this node will need to be copied  				int newChildPosition = insertposition+1;  				bool dosplit = false;  				// if there is no free space we must do a split  				if (this.ChildBufferNumbers[this.Size]!=BplusTreeLong.NULLBUFFERNUMBER)   				{  					dosplit = true;  					this.PrepareForSplit();  				}  				// bubble over the current values to make space for new child  				for (int i=this.ChildKeys.Length-2; i>=newChildPosition-1; i--)   				{  					int i1 = i+1;  					int i2 = i1+1;  					this.ChildKeys[i1] = this.ChildKeys[i];  					this.ChildBufferNumbers[i2] = this.ChildBufferNumbers[i1];  					BplusNode childNode = this.MaterializedChildNodes[i2] = this.MaterializedChildNodes[i1];  				}  				// record the new child  				this.ChildKeys[newChildPosition-1] = childSplitString;  				//this.MaterializedChildNodes[newChildPosition] = childSplit;  				//this.ChildBufferNumbers[newChildPosition] = childSplit.myBufferNumber;  				childSplit.Reparent(this' newChildPosition);  				// split' if needed  				if (dosplit)   				{  					int splitpoint = this.MaterializedChildNodes.Length/2-1;  					splitString = this.ChildKeys[splitpoint];  					splitNode = new BplusNode(this.owner' this.parent' -1' this.isLeaf);  					// make copy of expanded node structure  					BplusNode[] materialized = this.MaterializedChildNodes;  					long[] buffernumbers = this.ChildBufferNumbers;  					string[] keys = this.ChildKeys;  					// repair the expanded node  					this.ChildKeys = new string[this.Size];  					this.MaterializedChildNodes = new BplusNode[this.Size+1];  					this.ChildBufferNumbers = new long[this.Size+1];  					this.Clear();  					Array.Copy(materialized' 0' this.MaterializedChildNodes' 0' splitpoint+1);  					Array.Copy(buffernumbers' 0' this.ChildBufferNumbers' 0' splitpoint+1);  					Array.Copy(keys' 0' this.ChildKeys' 0' splitpoint);  					// initialize the new node  					splitNode.Clear(); // redundant.  					int remainingKeys = this.Size-splitpoint;  					Array.Copy(materialized' splitpoint+1' splitNode.MaterializedChildNodes' 0' remainingKeys+1);  					Array.Copy(buffernumbers' splitpoint+1' splitNode.ChildBufferNumbers' 0' remainingKeys+1);  					Array.Copy(keys' splitpoint+1' splitNode.ChildKeys' 0' remainingKeys);  					// fix pointers in materialized children of splitnode  					splitNode.reParentAllChildren();  					// store the new node  					splitNode.DumpToFreshBuffer();  					splitNode.CheckIfTerminal();  					splitNode.Soil();  					this.CheckIfTerminal();  				}  				// fix pointers in children  				this.reParentAllChildren();  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,Insert,The following statement contains a magic number: if (childSplit!=null)   			{  				// insert the child  				this.Soil(); // redundant -- a child will have a change so this node will need to be copied  				int newChildPosition = insertposition+1;  				bool dosplit = false;  				// if there is no free space we must do a split  				if (this.ChildBufferNumbers[this.Size]!=BplusTreeLong.NULLBUFFERNUMBER)   				{  					dosplit = true;  					this.PrepareForSplit();  				}  				// bubble over the current values to make space for new child  				for (int i=this.ChildKeys.Length-2; i>=newChildPosition-1; i--)   				{  					int i1 = i+1;  					int i2 = i1+1;  					this.ChildKeys[i1] = this.ChildKeys[i];  					this.ChildBufferNumbers[i2] = this.ChildBufferNumbers[i1];  					BplusNode childNode = this.MaterializedChildNodes[i2] = this.MaterializedChildNodes[i1];  				}  				// record the new child  				this.ChildKeys[newChildPosition-1] = childSplitString;  				//this.MaterializedChildNodes[newChildPosition] = childSplit;  				//this.ChildBufferNumbers[newChildPosition] = childSplit.myBufferNumber;  				childSplit.Reparent(this' newChildPosition);  				// split' if needed  				if (dosplit)   				{  					int splitpoint = this.MaterializedChildNodes.Length/2-1;  					splitString = this.ChildKeys[splitpoint];  					splitNode = new BplusNode(this.owner' this.parent' -1' this.isLeaf);  					// make copy of expanded node structure  					BplusNode[] materialized = this.MaterializedChildNodes;  					long[] buffernumbers = this.ChildBufferNumbers;  					string[] keys = this.ChildKeys;  					// repair the expanded node  					this.ChildKeys = new string[this.Size];  					this.MaterializedChildNodes = new BplusNode[this.Size+1];  					this.ChildBufferNumbers = new long[this.Size+1];  					this.Clear();  					Array.Copy(materialized' 0' this.MaterializedChildNodes' 0' splitpoint+1);  					Array.Copy(buffernumbers' 0' this.ChildBufferNumbers' 0' splitpoint+1);  					Array.Copy(keys' 0' this.ChildKeys' 0' splitpoint);  					// initialize the new node  					splitNode.Clear(); // redundant.  					int remainingKeys = this.Size-splitpoint;  					Array.Copy(materialized' splitpoint+1' splitNode.MaterializedChildNodes' 0' remainingKeys+1);  					Array.Copy(buffernumbers' splitpoint+1' splitNode.ChildBufferNumbers' 0' remainingKeys+1);  					Array.Copy(keys' splitpoint+1' splitNode.ChildKeys' 0' remainingKeys);  					// fix pointers in materialized children of splitnode  					splitNode.reParentAllChildren();  					// store the new node  					splitNode.DumpToFreshBuffer();  					splitNode.CheckIfTerminal();  					splitNode.Soil();  					this.CheckIfTerminal();  				}  				// fix pointers in children  				this.reParentAllChildren();  			}
Magic Number,BplusDotNet,BplusNode,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BplusTreeLong.cs,InsertLeaf,The following statement contains a magic number: if (dosplit)   			{  				int splitpoint = this.ChildKeys.Length/2;  				int splitlength = this.ChildKeys.Length - splitpoint;  				splitNode = new BplusNode(this.owner' this.parent' -1' this.isLeaf);  				// copy the split info into the splitNode  				Array.Copy(this.ChildBufferNumbers' splitpoint' splitNode.ChildBufferNumbers' 0' splitlength);  				Array.Copy(this.ChildKeys' splitpoint' splitNode.ChildKeys' 0' splitlength);  				Array.Copy(this.MaterializedChildNodes' splitpoint' splitNode.MaterializedChildNodes' 0' splitlength);  				splitString = splitNode.ChildKeys[0];  				// archive the new node  				splitNode.DumpToFreshBuffer();  				// store the node data temporarily  				long[] buffernumbers = this.ChildBufferNumbers;  				string[] keys = this.ChildKeys;  				BplusNode[] nodes = this.MaterializedChildNodes;  				// repair current node' copy in the other part of the split  				this.ChildBufferNumbers = new long[this.Size+1];  				this.ChildKeys = new string[this.Size];  				this.MaterializedChildNodes = new BplusNode[this.Size+1];  				Array.Copy(buffernumbers' 0' this.ChildBufferNumbers' 0' splitpoint);  				Array.Copy(keys' 0' this.ChildKeys' 0' splitpoint);  				Array.Copy(nodes' 0' this.MaterializedChildNodes' 0' splitpoint);  				for (int i=splitpoint; i<this.ChildKeys.Length; i++)   				{  					this.ChildKeys[i] = null;  					this.ChildBufferNumbers[i] = BplusTreeLong.NULLBUFFERNUMBER;  					this.MaterializedChildNodes[i] = null;  				}  				// store the new node  				//splitNode.DumpToFreshBuffer();  				this.owner.RecordTerminalNode(splitNode);  				splitNode.Soil();  			}
Magic Number,BplusDotNet,BufferFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BufferFile.cs,SetupFromExistingStream,The following statement contains a magic number: BufferFile result = new BufferFile(fromfile' 100' StartSeek);
Magic Number,BplusDotNet,BufferFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BufferFile.cs,Store,The following statement contains a magic number: for (int i=0; i<limit; i++)   			{  				byte thebyte = (byte) (TheInt & 0xff);  				ToArray[atIndex+i] = thebyte;  				TheInt = TheInt>>8;  			}
Magic Number,BplusDotNet,BufferFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BufferFile.cs,Store,The following statement contains a magic number: for (int i=0; i<limit; i++)   			{  				byte thebyte = (byte) (TheInt & 0xff);  				ToArray[atIndex+i] = thebyte;  				TheInt = TheInt>>8;  			}
Magic Number,BplusDotNet,BufferFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BufferFile.cs,Retrieve,The following statement contains a magic number: for (int i=0; i<limit; i++)   			{  				byte thebyte = ToArray[atIndex+limit-i-1];  				result = result << 8;  				result = result | thebyte;  			}
Magic Number,BplusDotNet,BufferFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BufferFile.cs,Store,The following statement contains a magic number: for (int i=0; i<limit; i++)   			{  				byte thebyte = (byte) (TheLong & 0xff);  				ToArray[atIndex+i] = thebyte;  				TheLong = TheLong>>8;  			}
Magic Number,BplusDotNet,BufferFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BufferFile.cs,RetrieveLong,The following statement contains a magic number: for (int i=0; i<limit; i++)   			{  				byte thebyte = ToArray[atIndex+limit-i-1];  				result = result << 8;  				result = result | thebyte;  			}
Magic Number,BplusDotNet,BufferFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\BufferFile.cs,RetrieveShort,The following statement contains a magic number: for (int i=0; i<limit; i++)   			{  				byte thebyte = ToArray[atIndex+limit-i-1];  				result = (result << 8);  				result = result | thebyte;  			}
Magic Number,BplusDotNet,hBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTreeBytes.cs,PrefixForByteCount,The following statement contains a magic number: for (int i=0; i<maxbytecount; i++)   			{  				int r = digest[i % digest.Length];  				if (r>127)   				{  					r = 256-r;  				}  				if (r<0)   				{  					r = -r;  				}  				//Console.WriteLine(" before "+i+" "+r);  				r = r%79 + 40; // printable ascii  				//Console.WriteLine(" "+i+" "+r);  				resultbytes[i] = (byte)r;  			}
Magic Number,BplusDotNet,hBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTreeBytes.cs,PrefixForByteCount,The following statement contains a magic number: for (int i=0; i<maxbytecount; i++)   			{  				int r = digest[i % digest.Length];  				if (r>127)   				{  					r = 256-r;  				}  				if (r<0)   				{  					r = -r;  				}  				//Console.WriteLine(" before "+i+" "+r);  				r = r%79 + 40; // printable ascii  				//Console.WriteLine(" "+i+" "+r);  				resultbytes[i] = (byte)r;  			}
Magic Number,BplusDotNet,hBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTreeBytes.cs,PrefixForByteCount,The following statement contains a magic number: for (int i=0; i<maxbytecount; i++)   			{  				int r = digest[i % digest.Length];  				if (r>127)   				{  					r = 256-r;  				}  				if (r<0)   				{  					r = -r;  				}  				//Console.WriteLine(" before "+i+" "+r);  				r = r%79 + 40; // printable ascii  				//Console.WriteLine(" "+i+" "+r);  				resultbytes[i] = (byte)r;  			}
Magic Number,BplusDotNet,hBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\hBplusTreeBytes.cs,PrefixForByteCount,The following statement contains a magic number: for (int i=0; i<maxbytecount; i++)   			{  				int r = digest[i % digest.Length];  				if (r>127)   				{  					r = 256-r;  				}  				if (r<0)   				{  					r = -r;  				}  				//Console.WriteLine(" before "+i+" "+r);  				r = r%79 + 40; // printable ascii  				//Console.WriteLine(" "+i+" "+r);  				resultbytes[i] = (byte)r;  			}
Magic Number,BplusDotNet,LinkedFile,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\LinkedFile.cs,SetupFromExistingStream,The following statement contains a magic number: LinkedFile result = new LinkedFile(100' StartSeek);
Magic Number,BplusDotNet,xBplusTreeBytes,C:\repos\sones_sones\Library\External\BplusDotNet\BplusDotNet\xBplusTreeBytes.cs,xBplusTreeBytes,The following statement contains a magic number: if (prefixLength<3)   			{  				throw new BplusTreeException("prefix cannot be smaller than 3 :: "+prefixLength);   			}
