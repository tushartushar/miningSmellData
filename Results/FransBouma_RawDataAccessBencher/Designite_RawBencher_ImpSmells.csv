Implementation smell,Namespace,Class,File,Method,Description
Long Method,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The method has 201 lines of code.
Long Method,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Insert,The method has 142 lines of code.
Long Method,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetFactory,The method has 182 lines of code.
Complex Method,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ProfileBenchers,Cyclomatic complexity of the method is 11
Complex Method,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunBencher,Cyclomatic complexity of the method is 13
Complex Method,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,Cyclomatic complexity of the method is 36
Complex Method,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetAutoMapper,Cyclomatic complexity of the method is 9
Complex Method,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,PocoData,Cyclomatic complexity of the method is 9
Complex Method,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetFactory,Cyclomatic complexity of the method is 9
Long Parameter List,RawBencher.Benchers,BencherBase<T>,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\BencherBase.cs,BencherBase,The method has 5 parameters. Parameters: salesOrderIdRetriever' usesChangeTracking' usesCaching' supportsEagerLoading' supportsAsync
Long Parameter List,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,All,The method has 5 parameters. Parameters: where' orderBy' limit' columns' args
Long Parameter List,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,Paged,The method has 6 parameters. Parameters: where' orderBy' columns' pageSize' currentPage' args
Long Parameter List,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,Paged,The method has 8 parameters. Parameters: sql' primaryKey' where' orderBy' columns' pageSize' currentPage' args
Long Parameter List,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,BuildPagedResult,The method has 8 parameters. Parameters: sql' primaryKeyField' where' orderBy' columns' pageSize' currentPage' args
Long Parameter List,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,BuildPageQueries,The method has 6 parameters. Parameters: skip' take' sql' args' sqlCount' sqlPage
Long Parameter List,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,FindSplitPoint,The method has 5 parameters. Parameters: typeThis' typeNext' sql' r' pos
Long Parameter List,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Update,The method has 5 parameters. Parameters: tableName' primaryKeyName' poco' primaryKeyValue' columns
Long Parameter List,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetFactory,The method has 6 parameters. Parameters: sql' connString' ForceDateTimesToUtc' firstColumn' countColumns' r
Long Identifier,RawBencher.Benchers,BencherBase<T>,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\BencherBase.cs,,The length of the parameter _asyncEagerLoadBenchmarkResults is 31.
Long Statement,RawBencher.Benchers,BencherBase<T>,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\BencherBase.cs,VerifyGraphElement,The length of the statement  "			return resultContainer.NumberOfRowsFetchedPerType.Count == 2 && resultContainer.NumberOfRowsFetchedPerType.All(kvp=>kvp.Value > 0); " is 131.
Long Statement,RawBencher.Benchers,ChainCompiledBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\ChainCompiledBencher.cs,FetchIndividual,The length of the statement  "            return DataSource.From("[Sales].[SalesOrderHeader]"' new { SalesOrderId = key }).Compile().ToObject<SalesOrderHeader>().Execute(); " is 130.
Long Statement,RawBencher.Benchers,ChainBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\ChainBencher.cs,FetchIndividual,The length of the statement  "            return DataSource.From("[Sales].[SalesOrderHeader]"' new { SalesOrderId = key }).ToObject<SalesOrderHeader>().Execute(); " is 120.
Long Statement,RawBencher.Benchers,RawDbDataReaderBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\RawDbDataReaderBencher.cs,MaterializeSet,The length of the statement  "				// optimization: call cancel first' this will greatly reduce the time it takes to Close the datareader as we're not interested in " is 129.
Long Statement,RawBencher.Benchers,OrmLiteBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\OrmLiteBencher.cs,FetchIndividual,The length of the statement  "				toReturn = con.SqlList<SalesOrderHeader>(this.CommandText + " WHERE SalesOrderId=@p"' new { p = key }).FirstOrDefault(); " is 120.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new HandCodedBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 126.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new HandCodedBencherUsingBoxing() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 137.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new RawDbDataReaderBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 132.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new NPocoBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 122.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new DapperBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 123.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "            RegisteredBenchers.Add(new ChainBencher() { CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString }); " is 124.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "            RegisteredBenchers.Add(new ChainCompiledBencher() { CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString }); " is 132.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new PetaPocoBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 125.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new PetaPocoFastBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 129.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new OrmLiteBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 124.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			RegisteredBenchers.Add(new DataTableBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}); " is 126.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,Run,The length of the statement  "			// Uncomment the line below if you want to profile a bencher. Specify the bencher instance and follow the guides on the screen. " is 127.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,DisplayHeader,The length of the statement  "			Console.WriteLine("| Client OS                      : {0} ({1}bit)"' Environment.OSVersion' Environment.Is64BitOperatingSystem ? "64" : "32"); " is 142.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ProfileBenchers,The length of the statement  "				Console.WriteLine("Running set benchmark for bencher '{0}' before profiling to warm up constructs"' b.CreateFrameworkName()); " is 125.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ProfileBenchers,The length of the statement  "						Console.WriteLine("Running set benchmark for profile for bencher: {0}. Change tracking: {1}"' b.CreateFrameworkName()' b.UsesChangeTracking); " is 141.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ProfileBenchers,The length of the statement  "						Console.WriteLine("Running individual fetch benchmark for profile for bencher: {0}. Change tracking: {1}"' b.CreateFrameworkName()' b.UsesChangeTracking); " is 154.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ProfileBenchers,The length of the statement  "						Console.WriteLine("Running eager load fetch benchmark for profile for bencher: {0}. Change tracking: {1}"' b.CreateFrameworkName()' b.UsesChangeTracking); " is 154.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ProfileBenchers,The length of the statement  "						Console.WriteLine("Running async eager load fetch benchmark for profile for bencher: {0}. Change tracking: {1}"' b.CreateFrameworkName()' b.UsesChangeTracking); " is 160.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,InitConnectionString,The length of the statement  "				ConnectionString = string.IsNullOrEmpty(connectionStringFromConfig.ConnectionString) ? ConnectionString : connectionStringFromConfig.ConnectionString; " is 150.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,FetchKeysForIndividualFetches,The length of the statement  "				KeysForIndividualFetches = conn.Query<int>("select top {=count} SalesOrderId from AdventureWorks.Sales.SalesOrderHeader order by SalesOrderNumber"' " is 147.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunMemoryAnalysisForBencher,The length of the statement  "					// sleep is to avoid hammering the network layer on the target server. If the target server is a VM' it might stall once or twice " is 129.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunMemoryAnalysisForBencher,The length of the statement  "					// during benching' which is not what we want at it can skew the results a lot. In a very short time' a lot of queries are executed " is 131.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunMemoryAnalysisForBencher,The length of the statement  "					// on the target server (LoopAmount * IndividualKeysAmount)' which will hurt performance on VMs with very fast frameworks in some " is 129.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunBencher,The length of the statement  "						// sleep is to avoid hammering the network layer on the target server. If the target server is a VM' it might stall once or twice " is 129.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunBencher,The length of the statement  "						// during benching' which is not what we want at it can skew the results a lot. In a very short time' a lot of queries are executed " is 131.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunBencher,The length of the statement  "						// on the target server (LoopAmount * IndividualKeysAmount)' which will hurt performance on VMs with very fast frameworks in some " is 129.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,WarmupDB,The length of the statement  "			IBencher dbWarmer = new DataTableBencher() {CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString}; " is 122.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,DisplayBencherInfo,The length of the statement  "			Console.WriteLine("{0}. Change tracking: {1}. Caching: {2}."' bencher.CreateFrameworkName()' bencher.UsesChangeTracking' bencher.UsesCaching); " is 142.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportSetResult,The length of the statement  "			Console.WriteLine("[{0:HH:mm:ss}] # of elements fetched: {1}.\tFetch took: {2:N2}ms.\tEnumerating result took: {3:N2}ms."' DateTime.Now' result.TotalNumberOfRowsFetched'  " is 169.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportIndividualResult,The length of the statement  "			Console.WriteLine("[{0:HH:mm:ss}] # of elements fetched individually: {1}.\tTotal time: {2:N2}ms.\tTime per element: {3:N2}ms"' DateTime.Now' KeysForIndividualFetches.Count'  " is 173.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportEagerLoadResult,The length of the statement  "			Console.WriteLine("[{0:HH:mm:ss}] # of elements fetched: {1} ({2}).\tFetch took: {3:N2}ms."' DateTime.Now' result.TotalNumberOfRowsFetched'  " is 139.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportEagerLoadResult,The length of the statement  "							  string.Join(" + "' result.NumberOfRowsFetchedPerType.Select(kvp => kvp.Value).ToArray())' result.FetchTimeInMilliseconds); " is 122.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportMemoryUsageSetResult,The length of the statement  "			Console.WriteLine("[{0:HH:mm:ss}] # of elements fetched: {1}.\tFetch took: {2:N2}ms.\tAllocated bytes: {3}."' DateTime.Now' result.TotalNumberOfRowsFetched'  " is 156.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportMemoryUsageIndividualResult,The length of the statement  "			Console.WriteLine("[{0:HH:mm:ss}] # of elements fetched individually: {1}.\tTotal time: {2:N2}ms.\tAllocated bytes per element: {3}."' DateTime.Now' KeysForIndividualFetches.Count'  " is 180.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportMemoryUsageEagerLoadResult,The length of the statement  "			Console.WriteLine("[{0:HH:mm:ss}] # of elements fetched: {1} ({2}).\tFetch took: {3:N2}ms. Allocated bytes: {3}."' DateTime.Now' result.TotalNumberOfRowsFetched'  " is 161.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportMemoryUsageEagerLoadResult,The length of the statement  "							  string.Join(" + "' result.NumberOfRowsFetchedPerType.Select(kvp => kvp.Value).ToArray())' result.NumberOfBytesAllocated); " is 121.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				var benchersToList = RegisteredBenchers.Where(b => !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList(); " is 130.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean' " is 153.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'  " is 147.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList(); " is 125.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean' " is 153.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'  " is 147.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				var benchersToList = RegisteredBenchers.Where(b => !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList(); " is 137.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "					Console.WriteLine("\nNon-change tracking individual fetches ({0} elements' {1} runs)' no caching"' IndividualKeysAmount' LoopAmount); " is 133.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount' " is 177.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'  " is 154.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList(); " is 132.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "					Console.WriteLine("\nChange tracking individual fetches ({0} elements' {1} runs)' no caching"' IndividualKeysAmount' LoopAmount); " is 129.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount' " is 177.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'  " is 154.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				var benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList(); " is 162.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "					Console.WriteLine("Non-change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount); " is 144.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD); " is 159.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'  " is 153.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList(); " is 157.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "					Console.WriteLine("\nChange tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount); " is 142.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD); " is 159.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'  " is 153.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.SupportsAsync && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList(); " is 176.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "					Console.WriteLine("\nAsync change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount); " is 148.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.AsyncEagerLoadFetchMean' bencher.AsyncEagerLoadFetchSD); " is 169.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryAsyncEagerLoadBenchmarks / 1024'  " is 158.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				var benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList(); " is 128.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean' " is 153.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'  " is 147.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "				var benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList(); " is 135.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "					Console.WriteLine("\nChange tracking individual fetches ({0} elements' {1} runs)' caching"' IndividualKeysAmount' LoopAmount); " is 126.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount' " is 177.
Long Statement,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The length of the statement  "						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'  " is 154.
Long Statement,RawBencher,Program,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Program.cs,InitConnectionString,The length of the statement  "				ConnectionString = string.IsNullOrEmpty(connectionStringFromConfig.ConnectionString) ? ConnectionString : connectionStringFromConfig.ConnectionString; " is 150.
Long Statement,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,Paged,The length of the statement  "			return BuildPagedResult(where: where' orderBy: orderBy' columns: columns' pageSize: pageSize' currentPage: currentPage' args: args); " is 132.
Long Statement,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,BuildPagedResult,The length of the statement  "				query = string.Format("SELECT {0} FROM (SELECT ROW_NUMBER() OVER (ORDER BY {1}) AS Row' {0} FROM ({2}) AS PagedTable {3}) AS Paged "' columns' orderBy' sql' where); " is 164.
Long Statement,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,BuildPagedResult,The length of the statement  "				query = string.Format("SELECT {0} FROM (SELECT ROW_NUMBER() OVER (ORDER BY {1}) AS Row' {0} FROM {2} {3}) AS Paged "' columns' orderBy' TableName' where); " is 154.
Long Statement,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,KeyValues,The length of the statement  "				throw new InvalidOperationException("There's no DescriptorField set - do this in your constructor to describe the text value you want to see"); " is 143.
Long Statement,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,CreateUpdateWhereCommand,The length of the statement  "				stub = where.Trim().StartsWith("where"' StringComparison.OrdinalIgnoreCase) ? "UPDATE {0} SET {1} " : "UPDATE {0} SET {1} WHERE "; " is 130.
Long Statement,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,TryInvokeMember,The length of the statement  "				throw new InvalidOperationException("Please use named arguments for this type of query - the column name' orderby' columns' etc"); " is 130.
Long Statement,RawBencher.BenchmarkDotNet,BenchmarkDotNetController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\BenchmarkDotNet\BenchmarkDotNetController.cs,FetchSet_HandCodedBencherUsingBoxing,The length of the statement  "			var bencher = new HandCodedBencherUsingBoxing() { CommandText = SqlSelectCommandText' ConnectionStringToUse = ConnectionString }; " is 129.
Long Statement,RawBencher.BenchmarkDotNet,BenchmarkDotNetController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\BenchmarkDotNet\BenchmarkDotNetController.cs,FetchKeysForIndividualFetches,The length of the statement  "				KeysForIndividualFetches = conn.Query<int>("select top {=count} SalesOrderId from AdventureWorks.Sales.SalesOrderHeader order by SalesOrderNumber"' " is 147.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,CommonConstruct,The length of the statement  "			else if (_providerName.IndexOf("SqlServerCe"' StringComparison.InvariantCultureIgnoreCase) >= 0) _dbType = DBType.SqlServerCE; " is 126.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,CommonConstruct,The length of the statement  "			else if (_providerName.IndexOf("Npgsql"' StringComparison.InvariantCultureIgnoreCase) >= 0) _dbType = DBType.PostgreSQL; " is 120.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,CommonConstruct,The length of the statement  "			if (_dbType == DBType.MySql && _connectionString != null && _connectionString.IndexOf("Allow User Variables=true") >= 0) " is 120.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,ProcessParams,The length of the statement  "						throw new ArgumentOutOfRangeException(string.Format("Parameter '@{0}' specified but only {1} parameters supplied (in `{2}`)"' paramIndex' args_src.Length' _sql)); " is 162.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,ProcessParams,The length of the statement  "						throw new ArgumentException(string.Format("Parameter '@{0}' specified but none of the passed arguments have a property with this name (in '{1}')"' param' _sql)); " is 161.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,SplitSqlForPaging,The length of the statement  "				sqlCount = sql.Substring(0' g.Index) + "COUNT(" + m.Groups[1].ToString().Trim() + ") " + sql.Substring(g.Index + g.Length); " is 123.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,BuildPageQueries,The length of the statement  "				sqlPage = string.Format("SELECT * FROM (SELECT ROW_NUMBER() OVER ({0}) peta_rn' {1}) peta_paged WHERE peta_rn>@{2} AND peta_rn<=@{3}"' " is 134.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Query,The length of the statement  "					var factory = pd.GetFactory(cmd.CommandText' _sharedConnection.ConnectionString' ForceDateTimesToUtc' 0' r.FieldCount' r) as Func<IDataReader' T>; " is 146.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetAutoMapper,The length of the statement  "							throw new InvalidOperationException(string.Format("Can't auto join {0} as {1} has more than one property of type {0}"' types[i]' types[j])); " is 140.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,FindSplitPoint,The length of the statement  "				return PocoData.ForType(typeThis).GetFactory(sql' _sharedConnection.ConnectionString' ForceDateTimesToUtc' pos' r.FieldCount - pos' r); " is 135.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,FindSplitPoint,The length of the statement  "				if (usedColumns.ContainsKey(fieldName) || (!pdThis.Columns.ContainsKey(fieldName) && pdNext.Columns.ContainsKey(fieldName))) " is 124.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,FindSplitPoint,The length of the statement  "					return pdThis.GetFactory(sql' _sharedConnection.ConnectionString' ForceDateTimesToUtc' firstColumn' pos - firstColumn' r); " is 122.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,FindSplitPoint,The length of the statement  "			throw new InvalidOperationException(string.Format("Couldn't find split point between {0} and {1}"' typeThis' typeNext)); " is 120.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,CreateMultiPocoFactory,The length of the statement  "			var m = new DynamicMethod("petapoco_multipoco_factory"' typeof(TRet)' new Type[] { typeof(MultiPocoFactory)' typeof(IDataReader)' typeof(object) }' typeof(MultiPocoFactory)); " is 174.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,CreateMultiPocoFactory,The length of the statement  "			il.Emit(OpCodes.Callvirt' Expression.GetFuncType(types.Concat(new Type[] { typeof(TRet) }).ToArray()).GetMethod("Invoke")); " is 123.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,CreateMultiPocoFactory,The length of the statement  "			return (Func<IDataReader' object' TRet>)m.CreateDelegate(typeof(Func<IDataReader' object' TRet>)' new MultiPocoFactory() { m_Delegates = dels }); " is 145.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Exists,The length of the statement  "			return FirstOrDefault<T>(string.Format("WHERE {0}=@0"' EscapeSqlIdentifier(PocoData.ForType(typeof(T)).TableInfo.PrimaryKey))' primaryKey) != null; " is 147.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Single,The length of the statement  "			return Single<T>(string.Format("WHERE {0}=@0"' EscapeSqlIdentifier(PocoData.ForType(typeof(T)).TableInfo.PrimaryKey))' primaryKey); " is 131.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,SingleOrDefault,The length of the statement  "			return SingleOrDefault<T>(string.Format("WHERE {0}=@0"' EscapeSqlIdentifier(PocoData.ForType(typeof(T)).TableInfo.PrimaryKey))' primaryKey); " is 140.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Delete,The length of the statement  "			var sql = string.Format("DELETE FROM {0} WHERE {1}=@0"' EscapeTableName(tableName)' EscapeSqlIdentifier(primaryKeyName)); " is 121.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,IsNew,The length of the statement  "					throw new ArgumentException(string.Format("The object doesn't have a property matching the primary key column name '{0}'"' primaryKeyName)); " is 140.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,IsNew,The length of the statement  "				throw new InvalidOperationException("IsNew() and Save() are only supported on tables with auto-increment/identity primary key columns"); " is 136.
Long Statement,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,FormatCommand,The length of the statement  "			return FormatCommand(cmd.CommandText' (from IDataParameter parameter in cmd.Parameters select parameter.Value).ToArray()); " is 122.
Long Statement,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetFactory,The length of the statement  "					var m = new DynamicMethod("petapoco_factory_" + PocoFactories.Count.ToString()' type' new Type[] { typeof(IDataReader) }' true); " is 128.
Long Statement,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetFactory,The length of the statement  "							il.Emit(OpCodes.Newobj' type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new Type[0]' null)); " is 140.
Long Statement,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetFactory,The length of the statement  "							var fnOnLoaded = RecurseInheritedTypes<MethodInfo>(type' (x) => x.GetMethod("OnLoaded"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new Type[0]' null)); " is 184.
Long Statement,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetConverter,The length of the statement  "				if (forceDateTimesToUtc && converter == null && srcType == typeof(DateTime) && (dstType == typeof(DateTime) || dstType == typeof(DateTime?))) " is 141.
Complex Conditional,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetFactory,The conditional expression  "valuegetter != null  											&& valuegetter.ReturnType == srcType  											&& (valuegetter.ReturnType == dstType || valuegetter.ReturnType == Nullable.GetUnderlyingType(dstType))"  is complex.
Complex Conditional,PetaPoco,PocoData,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,GetConverter,The conditional expression  "forceDateTimesToUtc && converter == null && srcType == typeof(DateTime) && (dstType == typeof(DateTime) || dstType == typeof(DateTime?))"  is complex.
Magic Number,RawBencher.Benchers,BencherBase<T>,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\BencherBase.cs,VerifyGraphElement,The following statement contains a magic number: return resultContainer.NumberOfRowsFetchedPerType.Count == 2 && resultContainer.NumberOfRowsFetchedPerType.All(kvp=>kvp.Value > 0);
Magic Number,RawBencher.Benchers,EntityFrameworkCoreNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkCoreNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var ctx = new AWDataContext(this.ConnectionStringToUse))  			{  				return (from soh in ctx.SalesOrderHeaders  						where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  						select soh)  							.Include(x => x.SalesOrderDetails)  							.Include(x => x.Customer)  							.ToList();  			}
Magic Number,RawBencher.Benchers,EntityFrameworkCoreNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkCoreNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var ctx = new AWDataContext(this.ConnectionStringToUse))  			{  				return (from soh in ctx.SalesOrderHeaders  						where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  						select soh)  							.Include(x => x.SalesOrderDetails)  							.Include(x => x.Customer)  							.ToList();  			}
Magic Number,RawBencher.Benchers,EntityFrameworkCoreNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkCoreNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: using(var ctx = new AWDataContext(this.ConnectionStringToUse))  			{  				return await (from soh in ctx.SalesOrderHeaders  							  where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  							  select soh)  					.Include(x=>x.SalesOrderDetails)  					.Include(x=>x.Customer)  					.ToListAsync();  			}
Magic Number,RawBencher.Benchers,EntityFrameworkCoreNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkCoreNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: using(var ctx = new AWDataContext(this.ConnectionStringToUse))  			{  				return await (from soh in ctx.SalesOrderHeaders  							  where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  							  select soh)  					.Include(x=>x.SalesOrderDetails)  					.Include(x=>x.Customer)  					.ToListAsync();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencherUsingBoxing,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencherUsingBoxing.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				object[] values = new object[26];  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					reader.GetValues(values);  					soh.SalesOrderId = (int)values[0];  					soh.RevisionNumber = (byte)values[1];  					soh.OrderDate = (DateTime)values[2];  					soh.DueDate = (DateTime)values[3];  					if(values[4]!=DBNull.Value)  					{  						soh.ShipDate = (DateTime?)values[4];  					}  					soh.Status = (byte)values[5];  					soh.OnlineOrderFlag = (bool)values[6];  					soh.SalesOrderNumber = (string)values[7];  					if(values[8] != DBNull.Value)  					{  						soh.PurchaseOrderNumber = (string)values[8];  					}  					if(values[9] != DBNull.Value)  					{  						soh.AccountNumber = (string)values[9];  					}  					soh.CustomerID = (int)values[10];  					if(values[11] != DBNull.Value)  					{  						soh.SalesPersonID = (int?)values[11];  					}  					if(values[12] != DBNull.Value)  					{  						soh.TerritoryID = (int?)values[12];  					}  					soh.BillToAddressID = (int)values[13];  					soh.ShipToAddressID = (int)values[14];  					soh.ShipMethodID = (int)values[15];  					if(values[16] != DBNull.Value)  					{  						soh.CreditCardID = (int?)values[16];  					}  					if(values[17] != DBNull.Value)  					{  						soh.CreditCardApprovalCode = (string)values[17];  					}  					if(values[18] != DBNull.Value)  					{  						soh.CurrencyRateID = (int?)values[18];  					}  					soh.SubTotal = (decimal)values[19];  					soh.TaxAmt = (decimal)values[20];  					soh.Freight = (decimal)values[21];  					soh.TotalDue = (decimal)values[22];  					if(values[23] != DBNull.Value)  					{  						soh.Comment = (string)values[23];  					}  					soh.Rowguid = (Guid)values[24];  					soh.ModifiedDate = (DateTime)values[25];  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,RawDbDataReaderBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\RawDbDataReaderBencher.cs,MaterializeSet,The following statement contains a magic number: var headers = new List<object[]>(31000);
Magic Number,RawBencher.Benchers,NHibernateNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\NHibernateNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var session = SessionManager.OpenSession())  			{  				return session.Query<NH.Bencher.EntityClasses.SalesOrderHeader>()  					.Where(soh => soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000)  					.Fetch(x => x.Customer)  					.Fetch(x => x.SalesOrderDetails)  					.ToList();  			}
Magic Number,RawBencher.Benchers,NHibernateNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\NHibernateNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var session = SessionManager.OpenSession())  			{  				return session.Query<NH.Bencher.EntityClasses.SalesOrderHeader>()  					.Where(soh => soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000)  					.Fetch(x => x.Customer)  					.Fetch(x => x.SalesOrderDetails)  					.ToList();  			}
Magic Number,RawBencher.Benchers,NHibernateNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\NHibernateNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: using(var session = SessionManager.OpenSession())  			{  				return await session.Query<NH.Bencher.EntityClasses.SalesOrderHeader>()  							  .Where(soh => soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000)  							  .Fetch(x => x.Customer)  							  .Fetch(x => x.SalesOrderDetails)  							  .ToListAsync();  			}
Magic Number,RawBencher.Benchers,NHibernateNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\NHibernateNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: using(var session = SessionManager.OpenSession())  			{  				return await session.Query<NH.Bencher.EntityClasses.SalesOrderHeader>()  							  .Where(soh => soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000)  							  .Fetch(x => x.Customer)  							  .Fetch(x => x.SalesOrderDetails)  							  .ToListAsync();  			}
Magic Number,RawBencher.Benchers,LinqToSqlNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LinqToSqlNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var ctx = new L2SBencherDataContext())  			{  				var loadOptions = new DataLoadOptions();  				loadOptions.LoadWith<L2S.Bencher.EntityClasses.SalesOrderHeader>(soh=>soh.SalesOrderDetails);  				loadOptions.LoadWith<L2S.Bencher.EntityClasses.SalesOrderHeader>(soh=>soh.Customer);  				ctx.LoadOptions = loadOptions;  				return (from soh in ctx.SalesOrderHeaders  						where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  						select soh).ToList();  			}
Magic Number,RawBencher.Benchers,LinqToSqlNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LinqToSqlNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var ctx = new L2SBencherDataContext())  			{  				var loadOptions = new DataLoadOptions();  				loadOptions.LoadWith<L2S.Bencher.EntityClasses.SalesOrderHeader>(soh=>soh.SalesOrderDetails);  				loadOptions.LoadWith<L2S.Bencher.EntityClasses.SalesOrderHeader>(soh=>soh.Customer);  				ctx.LoadOptions = loadOptions;  				return (from soh in ctx.SalesOrderHeaders  						where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  						select soh).ToList();  			}
Magic Number,RawBencher.Benchers,EntityFrameworkNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var ctx = new AWDataContext())  			{  				return (from soh in ctx.SalesOrderHeaders  					   where soh.SalesOrderId > 50000 && soh.SalesOrderId <=51000  					   select soh)  							.Include(x=>x.SalesOrderDetails)  							.Include(x=>x.Customer)  							.ToList();  			}
Magic Number,RawBencher.Benchers,EntityFrameworkNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkNormalBencher.cs,FetchGraph,The following statement contains a magic number: using(var ctx = new AWDataContext())  			{  				return (from soh in ctx.SalesOrderHeaders  					   where soh.SalesOrderId > 50000 && soh.SalesOrderId <=51000  					   select soh)  							.Include(x=>x.SalesOrderDetails)  							.Include(x=>x.Customer)  							.ToList();  			}
Magic Number,RawBencher.Benchers,EntityFrameworkNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: using(var ctx = new AWDataContext())  			{  				return await (from soh in ctx.SalesOrderHeaders  							  where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  							  select soh)  					.Include(x=>x.SalesOrderDetails)  					.Include(x=>x.Customer)  					.ToListAsync();  			}
Magic Number,RawBencher.Benchers,EntityFrameworkNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\EntityFrameworkNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: using(var ctx = new AWDataContext())  			{  				return await (from soh in ctx.SalesOrderHeaders  							  where soh.SalesOrderId > 50000 && soh.SalesOrderId <= 51000  							  select soh)  					.Include(x=>x.SalesOrderDetails)  					.Include(x=>x.Customer)  					.ToListAsync();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,HandCodedBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\HandCodedBencher.cs,MaterializeSet,The following statement contains a magic number: using(var con = new SqlConnection(this.ConnectionStringToUse))  			{  				toExecute.Connection = con;  				con.Open();  				var reader = toExecute.ExecuteReader();  				while(reader.Read())  				{  					var soh = new SalesOrderHeader();  					// using IsDBNull(ordinal) is slow' however it allows the usage of the typed Get<type>(ordinal) methods. This avoids  					// boxing / unboxing of the value again' which enhances performance more than IsDBNull can slow it down.   					soh.SalesOrderId = reader.GetInt32(0);  					soh.RevisionNumber = reader.GetByte(1);  					soh.OrderDate = reader.GetDateTime(2);  					soh.DueDate = reader.GetDateTime(3);  					if(!reader.IsDBNull(4))  					{  						soh.ShipDate = reader.GetDateTime(4);  					}  					soh.Status = reader.GetByte(5);  					soh.OnlineOrderFlag = reader.GetBoolean(6);  					soh.SalesOrderNumber = reader.GetString(7);  					if(!reader.IsDBNull(8))  					{  						soh.PurchaseOrderNumber =  reader.GetString(8);  					}  					if(!reader.IsDBNull(9))  					{  						soh.AccountNumber = reader.GetString(9);  					}  					soh.CustomerID = reader.GetInt32(10);  					if(!reader.IsDBNull(11))  					{  						soh.SalesPersonID = reader.GetInt32(11);  					}  					if(!reader.IsDBNull(12))  					{  						soh.TerritoryID = reader.GetInt32(12);  					}  					soh.BillToAddressID = reader.GetInt32(13);  					soh.ShipToAddressID = reader.GetInt32(14);  					soh.ShipMethodID = reader.GetInt32(15);  					if(!reader.IsDBNull(16))  					{  						soh.CreditCardID = reader.GetInt32(16);  					}  					if(!reader.IsDBNull(17))  					{  						soh.CreditCardApprovalCode = reader.GetString(17);  					}  					if(!reader.IsDBNull(18))  					{  						soh.CurrencyRateID = reader.GetInt32(18);  					}  					soh.SubTotal = reader.GetDecimal(19);  					soh.TaxAmt = reader.GetDecimal(20);  					soh.Freight = reader.GetDecimal(21);  					soh.TotalDue = reader.GetDecimal(22);  					if(!reader.IsDBNull(23))  					{  						soh.Comment = reader.GetString(23);  					}  					soh.Rowguid = reader.GetGuid(24);  					soh.ModifiedDate = reader.GetDateTime(25);  					headers.Add(soh);  				}  				reader.Close();  				reader.Dispose();  				con.Close();  			}
Magic Number,RawBencher.Benchers,LLBLGenProResultsetCachingBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LLBLGenProResultsetCachingBencher.cs,FetchIndividual,The following statement contains a magic number: var q = qf.SalesOrderHeader  							.Where(SalesOrderHeaderFields.SalesOrderId == key)  							.CacheResultset(10);
Magic Number,RawBencher.Benchers,LLBLGenProResultsetCachingBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LLBLGenProResultsetCachingBencher.cs,FetchSet,The following statement contains a magic number: var q = qf.SalesOrderHeader  						.CacheResultset(10);
Magic Number,RawBencher.Benchers,LLBLGenProNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LLBLGenProNormalBencher.cs,FetchGraph,The following statement contains a magic number: var q = qf.SalesOrderHeader  								.Where((SalesOrderHeaderFields.SalesOrderId > 50000).And(SalesOrderHeaderFields.SalesOrderId <= 51000))  								.WithPath(SalesOrderHeaderEntity.PrefetchPathSalesOrderDetails' SalesOrderHeaderEntity.PrefetchPathCustomer);
Magic Number,RawBencher.Benchers,LLBLGenProNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LLBLGenProNormalBencher.cs,FetchGraph,The following statement contains a magic number: var q = qf.SalesOrderHeader  								.Where((SalesOrderHeaderFields.SalesOrderId > 50000).And(SalesOrderHeaderFields.SalesOrderId <= 51000))  								.WithPath(SalesOrderHeaderEntity.PrefetchPathSalesOrderDetails' SalesOrderHeaderEntity.PrefetchPathCustomer);
Magic Number,RawBencher.Benchers,LLBLGenProNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LLBLGenProNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: var q = qf.SalesOrderHeader  								.Where((SalesOrderHeaderFields.SalesOrderId > 50000).And(SalesOrderHeaderFields.SalesOrderId <= 51000))  								.WithPath(SalesOrderHeaderEntity.PrefetchPathSalesOrderDetails' SalesOrderHeaderEntity.PrefetchPathCustomer);
Magic Number,RawBencher.Benchers,LLBLGenProNormalBencher,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Benchers\LLBLGenProNormalBencher.cs,FetchGraphAsync,The following statement contains a magic number: var q = qf.SalesOrderHeader  								.Where((SalesOrderHeaderFields.SalesOrderId > 50000).And(SalesOrderHeaderFields.SalesOrderId <= 51000))  								.WithPath(SalesOrderHeaderEntity.PrefetchPathSalesOrderDetails' SalesOrderHeaderEntity.PrefetchPathCustomer);
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunMemoryAnalysisForBencher,The following statement contains a magic number: if(PerformIndividualBenchMarks)  			{  				// individual benches  				Console.WriteLine("\nSingle element fetches");  				Console.WriteLine("-------------------------");  				result = bencher.PerformIndividualBenchMark(KeysForIndividualFetches' discardResults:true);  				OriginalController.ReportMemoryUsageIndividualResult(result);  				bencher.MemoryIndividualBenchmarks = result.NumberOfBytesAllocated;    				// avoid having the GC collect in the middle of a run.  				OriginalController.ForceGCCollect();    				if(ApplyAntiFloodForVMUsage)  				{  					// sleep is to avoid hammering the network layer on the target server. If the target server is a VM' it might stall once or twice  					// during benching' which is not what we want at it can skew the results a lot. In a very short time' a lot of queries are executed  					// on the target server (LoopAmount * IndividualKeysAmount)' which will hurt performance on VMs with very fast frameworks in some  					// cases in some runs (so more than 2 runs are slow).   #pragma warning disable CS0162  					Thread.Sleep(400);  #pragma warning restore CS0162  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,RunBencher,The following statement contains a magic number: if(PerformIndividualBenchMarks)  			{  				// individual benches  				Console.WriteLine("\nSingle element fetches");  				Console.WriteLine("-------------------------");  				for(int i = 0; i < LoopAmount; i++)  				{  					result = bencher.PerformIndividualBenchMark(KeysForIndividualFetches);  					OriginalController.ReportIndividualResult(result);    					// avoid having the GC collect in the middle of a run.  					OriginalController.ForceGCCollect();    					if(ApplyAntiFloodForVMUsage)  					{  						// sleep is to avoid hammering the network layer on the target server. If the target server is a VM' it might stall once or twice  						// during benching' which is not what we want at it can skew the results a lot. In a very short time' a lot of queries are executed  						// on the target server (LoopAmount * IndividualKeysAmount)' which will hurt performance on VMs with very fast frameworks in some  						// cases in some runs (so more than 2 runs are slow).   #pragma warning disable CS0162  						Thread.Sleep(400);  #pragma warning restore CS0162  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformSetBenchmarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("Non-change tracking fetches' set fetches ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean'  										  bencher.SetFetchSD' bencher.EnumerationMean' bencher.EnumerationSD);  					}  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemorySetBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'   										  bencher.MemorySetBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking fetches' set fetches ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean'  										  bencher.SetFetchSD' bencher.EnumerationMean' bencher.EnumerationSD);  					}  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemorySetBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'   										  bencher.MemorySetBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformSetBenchmarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("Non-change tracking fetches' set fetches ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean'  										  bencher.SetFetchSD' bencher.EnumerationMean' bencher.EnumerationSD);  					}  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemorySetBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'   										  bencher.MemorySetBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking fetches' set fetches ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean'  										  bencher.SetFetchSD' bencher.EnumerationMean' bencher.EnumerationSD);  					}  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemorySetBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'   										  bencher.MemorySetBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformIndividualBenchMarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nNon-change tracking individual fetches ({0} elements' {1} runs)' no caching"' IndividualKeysAmount' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount'  										  bencher.IndividualFetchSD / IndividualKeysAmount);  					}  					  					Console.WriteLine("\nMemory usage' per individual element");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryIndividualBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'   										  bencher.MemoryIndividualBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking individual fetches ({0} elements' {1} runs)' no caching"' IndividualKeysAmount' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount'  										  bencher.IndividualFetchSD / IndividualKeysAmount);  					}  										  					Console.WriteLine("\nMemory usage' per individual element");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryIndividualBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'   										  bencher.MemoryIndividualBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformIndividualBenchMarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nNon-change tracking individual fetches ({0} elements' {1} runs)' no caching"' IndividualKeysAmount' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount'  										  bencher.IndividualFetchSD / IndividualKeysAmount);  					}  					  					Console.WriteLine("\nMemory usage' per individual element");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryIndividualBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'   										  bencher.MemoryIndividualBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking individual fetches ({0} elements' {1} runs)' no caching"' IndividualKeysAmount' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount'  										  bencher.IndividualFetchSD / IndividualKeysAmount);  					}  										  					Console.WriteLine("\nMemory usage' per individual element");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryIndividualBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'   										  bencher.MemoryIndividualBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformEagerLoadBenchmarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("Non-change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD);  					}  									  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'   										  bencher.MemoryEagerLoadBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD);  					}  									  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'   										  bencher.MemoryEagerLoadBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.SupportsAsync && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nAsync change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.AsyncEagerLoadFetchMean' bencher.AsyncEagerLoadFetchSD);  					}  														  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryAsyncEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryAsyncEagerLoadBenchmarks / 1024'   										  bencher.MemoryAsyncEagerLoadBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformEagerLoadBenchmarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("Non-change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD);  					}  									  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'   										  bencher.MemoryEagerLoadBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD);  					}  									  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'   										  bencher.MemoryEagerLoadBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.SupportsAsync && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nAsync change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.AsyncEagerLoadFetchMean' bencher.AsyncEagerLoadFetchSD);  					}  														  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryAsyncEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryAsyncEagerLoadBenchmarks / 1024'   										  bencher.MemoryAsyncEagerLoadBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformEagerLoadBenchmarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && !b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("Non-change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD);  					}  									  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'   										  bencher.MemoryEagerLoadBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.EagerLoadFetchMean' bencher.EagerLoadFetchSD);  					}  									  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryEagerLoadBenchmarks / 1024'   										  bencher.MemoryEagerLoadBenchmarks);  					}  				}  				benchersToList = RegisteredBenchers.Where(b => b.SupportsEagerLoading && b.SupportsAsync && b.UsesChangeTracking && !b.UsesCaching).OrderBy(b => b.EagerLoadFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nAsync change tracking fetches' eager load fetches' 3-node split graph' 1000 root elements ({0} runs)' no caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)"' bencher.CreateFrameworkName()' bencher.AsyncEagerLoadFetchMean' bencher.AsyncEagerLoadFetchSD);  					}  														  					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryAsyncEagerLoadBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryAsyncEagerLoadBenchmarks / 1024'   										  bencher.MemoryAsyncEagerLoadBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformSetBenchmarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && b.UsesCaching).OrderBy(b => b.SetFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking fetches' set fetches ({0} runs)' caching"' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms)\tEnum: {3:N2}ms ({4:N2}ms)"' bencher.CreateFrameworkName()' bencher.SetFetchMean'  										  bencher.SetFetchSD' bencher.EnumerationMean' bencher.EnumerationSD);  					}    					Console.WriteLine("\nMemory usage' per iteration");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemorySetBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemorySetBenchmarks / 1024'   										  bencher.MemorySetBenchmarks);  					}  				}  			}
Magic Number,RawBencher,OriginalController,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\OriginalController.cs,ReportResultStatistics,The following statement contains a magic number: if(PerformIndividualBenchMarks)  			{  				var benchersToList = RegisteredBenchers.Where(b => b.UsesChangeTracking && b.UsesCaching).OrderBy(b => b.IndividualFetchMean).ToList();  				if(benchersToList.Count > 0)  				{  					Console.WriteLine("\nChange tracking individual fetches ({0} elements' {1} runs)' caching"' IndividualKeysAmount' LoopAmount);  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList)  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:N2}ms ({2:N2}ms) per individual fetch"' bencher.CreateFrameworkName()' bencher.IndividualFetchMean / IndividualKeysAmount'  										  bencher.IndividualFetchSD / IndividualKeysAmount);  					}  					  					Console.WriteLine("\nMemory usage' per individual element");  					Console.WriteLine("------------------------------------------------------------------------------");  					foreach(var bencher in benchersToList.OrderBy(b=>b.MemoryIndividualBenchmarks))  					{  						Console.WriteLine("{0'-" + longestNameLength + "} : {1:0'0} KB ({2:0'0} bytes)"' bencher.CreateFrameworkName()' bencher.MemoryIndividualBenchmarks / 1024'   										  bencher.MemoryIndividualBenchmarks);  					}  				}  			}
Magic Number,VanillaMassive,ObjectExtensions,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,AddParam,The following statement contains a magic number: if(item == null)  			{  				p.Value = DBNull.Value;  			}  			else  			{  				if(item.GetType() == typeof(Guid))  				{  					p.Value = item.ToString();  					p.DbType = DbType.String;  					p.Size = 4000;  				}  				else if(item.GetType() == typeof(ExpandoObject))  				{  					var d = (IDictionary<string' object>)item;  					p.Value = d.Values.FirstOrDefault();  				}  				else  				{  					p.Value = item;  				}  				if(item.GetType() == typeof(string))  					p.Size = ((string)item).Length > 4000 ? -1 : 4000;  			}
Magic Number,VanillaMassive,ObjectExtensions,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,AddParam,The following statement contains a magic number: if(item == null)  			{  				p.Value = DBNull.Value;  			}  			else  			{  				if(item.GetType() == typeof(Guid))  				{  					p.Value = item.ToString();  					p.DbType = DbType.String;  					p.Size = 4000;  				}  				else if(item.GetType() == typeof(ExpandoObject))  				{  					var d = (IDictionary<string' object>)item;  					p.Value = d.Values.FirstOrDefault();  				}  				else  				{  					p.Value = item;  				}  				if(item.GetType() == typeof(string))  					p.Size = ((string)item).Length > 4000 ? -1 : 4000;  			}
Magic Number,VanillaMassive,ObjectExtensions,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,AddParam,The following statement contains a magic number: if(item == null)  			{  				p.Value = DBNull.Value;  			}  			else  			{  				if(item.GetType() == typeof(Guid))  				{  					p.Value = item.ToString();  					p.DbType = DbType.String;  					p.Size = 4000;  				}  				else if(item.GetType() == typeof(ExpandoObject))  				{  					var d = (IDictionary<string' object>)item;  					p.Value = d.Values.FirstOrDefault();  				}  				else  				{  					p.Value = item;  				}  				if(item.GetType() == typeof(string))  					p.Size = ((string)item).Length > 4000 ? -1 : 4000;  			}
Magic Number,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,CreateUpdateCommand,The following statement contains a magic number: if(counter > 0)  			{  				//add the key  				result.AddParam(key);  				//strip the last commas  				var keys = sbKeys.ToString().Substring(0' sbKeys.Length - 4);  				result.CommandText = string.Format(stub' TableName' keys' PrimaryKeyField' counter);  			}  			else throw new InvalidOperationException("No parsable object was sent in - could not divine any name/value pairs");
Magic Number,VanillaMassive,DynamicModel,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\Massive.cs,CreateUpdateWhereCommand,The following statement contains a magic number: if(counter > 0)  			{  				//strip the last commas  				var keys = sbKeys.ToString().Substring(0' sbKeys.Length - 4);  				result.CommandText = string.Format(stub' TableName' keys);  			}  			else throw new InvalidOperationException("No parsable object was sent in - could not divine any name/value pairs");
Magic Number,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Database,The following statement contains a magic number: _sharedConnectionDepth = 2;
Magic Number,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,AddParam,The following statement contains a magic number: if (item == null)  			{  				p.Value = DBNull.Value;  			}  			else  			{  				var t = item.GetType();  				if (t.IsEnum)		// PostgreSQL .NET driver wont cast enum to int  				{  					p.Value = (int)item;  				}  				else if (t == typeof(Guid))  				{  					p.Value = item.ToString();  					p.DbType = DbType.String;  					p.Size = 40;  				}  				else if (t == typeof(string))  				{  					p.Size = Math.Max((item as string).Length + 1' 4000);		// Help query plan caching by using common size  					p.Value = item;  				}  				else if (t == typeof(AnsiString))  				{  					// Thanks @DataChomp for pointing out the SQL Server indexing performance hit of using wrong string type on varchar  					p.Size = Math.Max((item as AnsiString).Value.Length + 1' 4000);  					p.Value = (item as AnsiString).Value;  					p.DbType = DbType.AnsiString;  				}  				else if (t == typeof(bool) && _dbType != DBType.PostgreSQL)  				{  					p.Value = ((bool)item) ? 1 : 0;  				}  				else if (item.GetType().Name == "SqlGeography") //SqlGeography is a CLR Type  				{  					p.GetType().GetProperty("UdtTypeName").SetValue(p' "geography"' null); //geography is the equivalent SQL Server Type  					p.Value = item;  				}    				else if (item.GetType().Name == "SqlGeometry") //SqlGeometry is a CLR Type  				{  					p.GetType().GetProperty("UdtTypeName").SetValue(p' "geometry"' null); //geography is the equivalent SQL Server Type  					p.Value = item;  				}  				else  				{  					p.Value = item;  				}  			}
Magic Number,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,AddParam,The following statement contains a magic number: if (item == null)  			{  				p.Value = DBNull.Value;  			}  			else  			{  				var t = item.GetType();  				if (t.IsEnum)		// PostgreSQL .NET driver wont cast enum to int  				{  					p.Value = (int)item;  				}  				else if (t == typeof(Guid))  				{  					p.Value = item.ToString();  					p.DbType = DbType.String;  					p.Size = 40;  				}  				else if (t == typeof(string))  				{  					p.Size = Math.Max((item as string).Length + 1' 4000);		// Help query plan caching by using common size  					p.Value = item;  				}  				else if (t == typeof(AnsiString))  				{  					// Thanks @DataChomp for pointing out the SQL Server indexing performance hit of using wrong string type on varchar  					p.Size = Math.Max((item as AnsiString).Value.Length + 1' 4000);  					p.Value = (item as AnsiString).Value;  					p.DbType = DbType.AnsiString;  				}  				else if (t == typeof(bool) && _dbType != DBType.PostgreSQL)  				{  					p.Value = ((bool)item) ? 1 : 0;  				}  				else if (item.GetType().Name == "SqlGeography") //SqlGeography is a CLR Type  				{  					p.GetType().GetProperty("UdtTypeName").SetValue(p' "geography"' null); //geography is the equivalent SQL Server Type  					p.Value = item;  				}    				else if (item.GetType().Name == "SqlGeometry") //SqlGeometry is a CLR Type  				{  					p.GetType().GetProperty("UdtTypeName").SetValue(p' "geometry"' null); //geography is the equivalent SQL Server Type  					p.Value = item;  				}  				else  				{  					p.Value = item;  				}  			}
Magic Number,PetaPoco,Database,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,AddParam,The following statement contains a magic number: if (item == null)  			{  				p.Value = DBNull.Value;  			}  			else  			{  				var t = item.GetType();  				if (t.IsEnum)		// PostgreSQL .NET driver wont cast enum to int  				{  					p.Value = (int)item;  				}  				else if (t == typeof(Guid))  				{  					p.Value = item.ToString();  					p.DbType = DbType.String;  					p.Size = 40;  				}  				else if (t == typeof(string))  				{  					p.Size = Math.Max((item as string).Length + 1' 4000);		// Help query plan caching by using common size  					p.Value = item;  				}  				else if (t == typeof(AnsiString))  				{  					// Thanks @DataChomp for pointing out the SQL Server indexing performance hit of using wrong string type on varchar  					p.Size = Math.Max((item as AnsiString).Value.Length + 1' 4000);  					p.Value = (item as AnsiString).Value;  					p.DbType = DbType.AnsiString;  				}  				else if (t == typeof(bool) && _dbType != DBType.PostgreSQL)  				{  					p.Value = ((bool)item) ? 1 : 0;  				}  				else if (item.GetType().Name == "SqlGeography") //SqlGeography is a CLR Type  				{  					p.GetType().GetProperty("UdtTypeName").SetValue(p' "geography"' null); //geography is the equivalent SQL Server Type  					p.Value = item;  				}    				else if (item.GetType().Name == "SqlGeometry") //SqlGeometry is a CLR Type  				{  					p.GetType().GetProperty("UdtTypeName").SetValue(p' "geometry"' null); //geography is the equivalent SQL Server Type  					p.Value = item;  				}  				else  				{  					p.Value = item;  				}  			}
Magic Number,PetaPoco,Sql,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Build,The following statement contains a magic number: if (!String.IsNullOrEmpty(_sql))  			{  				// Add SQL to the string  				if (sb.Length > 0)  				{  					sb.Append("\n");  				}    				var sql = Database.ProcessParams(_sql' _args' args);    				if (Is(lhs' "WHERE ") && Is(this' "WHERE "))  					sql = "AND " + sql.Substring(6);  				if (Is(lhs' "ORDER BY ") && Is(this' "ORDER BY "))  					sql = "' " + sql.Substring(9);    				sb.Append(sql);  			}
Magic Number,PetaPoco,Sql,C:\repos\FransBouma_RawDataAccessBencher\RawBencher\PetaPoco.cs,Build,The following statement contains a magic number: if (!String.IsNullOrEmpty(_sql))  			{  				// Add SQL to the string  				if (sb.Length > 0)  				{  					sb.Append("\n");  				}    				var sql = Database.ProcessParams(_sql' _args' args);    				if (Is(lhs' "WHERE ") && Is(this' "WHERE "))  					sql = "AND " + sql.Substring(6);  				if (Is(lhs' "ORDER BY ") && Is(this' "ORDER BY "))  					sql = "' " + sql.Substring(9);    				sb.Append(sql);  			}
