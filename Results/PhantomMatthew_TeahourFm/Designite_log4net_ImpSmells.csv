Implementation smell,Namespace,Class,File,Method,Description
Long Method,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The method has 120 lines of code.
Long Method,log4net.Appender,SmtpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\SmtpAppender.cs,SendEmail,The method has 126 lines of code.
Long Method,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The method has 103 lines of code.
Long Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The method has 182 lines of code.
Complex Method,log4net.Appender,AdoNetAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AdoNetAppender.cs,SendBuffer,Cyclomatic complexity of the method is 10
Complex Method,log4net.Appender,AdoNetAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AdoNetAppender.cs,InitializeDatabaseCommand,Cyclomatic complexity of the method is 9
Complex Method,log4net.Appender,AppenderSkeleton,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AppenderSkeleton.cs,FilterEvent,Cyclomatic complexity of the method is 9
Complex Method,log4net.Appender,BufferingAppenderSkeleton,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\BufferingAppenderSkeleton.cs,Append,Cyclomatic complexity of the method is 10
Complex Method,log4net.Appender,EventLogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\EventLogAppender.cs,ActivateOptions,Cyclomatic complexity of the method is 12
Complex Method,log4net.Appender,EventLogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\EventLogAppender.cs,Append,Cyclomatic complexity of the method is 15
Complex Method,log4net.Appender,LocalSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\LocalSyslogAppender.cs,GetSeverity,Cyclomatic complexity of the method is 8
Complex Method,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,Cyclomatic complexity of the method is 8
Complex Method,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,GetSeverity,Cyclomatic complexity of the method is 8
Complex Method,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,InitializeFromOneFile,Cyclomatic complexity of the method is 11
Complex Method,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,ActivateOptions,Cyclomatic complexity of the method is 9
Complex Method,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,DeleteFile,Cyclomatic complexity of the method is 8
Complex Method,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,RollOverRenameFiles,Cyclomatic complexity of the method is 10
Complex Method,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,Cyclomatic complexity of the method is 40
Complex Method,log4net.Appender,SmtpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\SmtpAppender.cs,SendEmail,Cyclomatic complexity of the method is 9
Complex Method,log4net.Appender,SmtpPickupDirAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\SmtpPickupDirAppender.cs,SendBuffer,Cyclomatic complexity of the method is 10
Complex Method,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,Cyclomatic complexity of the method is 10
Complex Method,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,Cyclomatic complexity of the method is 10
Complex Method,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromUri,Cyclomatic complexity of the method is 14
Complex Method,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,Cyclomatic complexity of the method is 10
Complex Method,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,Cyclomatic complexity of the method is 17
Complex Method,log4net.Core,LocationInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LocationInfo.cs,LocationInfo,Cyclomatic complexity of the method is 12
Complex Method,log4net.Core,LoggerManager,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LoggerManager.cs,LoggerManager,Cyclomatic complexity of the method is 8
Complex Method,log4net.Core,LoggingEvent,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LoggingEvent.cs,FixVolatileData,Cyclomatic complexity of the method is 11
Complex Method,log4net.Filter,PropertyFilter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Filter\PropertyFilter.cs,Decide,Cyclomatic complexity of the method is 10
Complex Method,log4net.Filter,StringMatchFilter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Filter\StringMatchFilter.cs,Decide,Cyclomatic complexity of the method is 9
Complex Method,log4net.Layout,XmlLayout,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayout.cs,FormatXml,Cyclomatic complexity of the method is 10
Complex Method,log4net.Layout,XmlLayoutSchemaLog4j,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayoutSchemaLog4j.cs,FormatXml,Cyclomatic complexity of the method is 11
Complex Method,log4net.Layout.Pattern,ExceptionPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\ExceptionPatternConverter.cs,Convert,Cyclomatic complexity of the method is 19
Complex Method,log4net.ObjectRenderer,DefaultRenderer,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\ObjectRenderer\DefaultRenderer.cs,RenderObject,Cyclomatic complexity of the method is 9
Complex Method,log4net.Repository.Hierarchy,Logger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Logger.cs,CallAppenders,Cyclomatic complexity of the method is 8
Complex Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,Cyclomatic complexity of the method is 20
Complex Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseAppender,Cyclomatic complexity of the method is 8
Complex Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,Cyclomatic complexity of the method is 30
Complex Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,Cyclomatic complexity of the method is 12
Complex Method,log4net.Util,AppenderAttachedImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\AppenderAttachedImpl.cs,AppendLoopOnAppenders,Cyclomatic complexity of the method is 8
Complex Method,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,Cyclomatic complexity of the method is 18
Complex Method,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,GetTypeFromString,Cyclomatic complexity of the method is 8
Long Parameter List,log4net.Appender,NetSendAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\NetSendAppender.cs,NetMessageBufferSend,The method has 5 parameters.
Long Parameter List,log4net.Core,LoggingEvent,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LoggingEvent.cs,LoggingEvent,The method has 6 parameters.
Long Parameter List,log4net.Util,ILogExtensions,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\ILogExtensions.cs,DebugFormatExt,The method has 5 parameters.
Long Parameter List,log4net.Util,ILogExtensions,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\ILogExtensions.cs,InfoFormatExt,The method has 5 parameters.
Long Parameter List,log4net.Util,ILogExtensions,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\ILogExtensions.cs,WarnFormatExt,The method has 5 parameters.
Long Parameter List,log4net.Util,ILogExtensions,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\ILogExtensions.cs,ErrorFormatExt,The method has 5 parameters.
Long Parameter List,log4net.Util,ILogExtensions,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\ILogExtensions.cs,FatalFormatExt,The method has 5 parameters.
Long Parameter List,log4net.Util,NativeError,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\NativeError.cs,FormatMessage,The method has 7 parameters.
Long Parameter List,log4net.Util,WindowsSecurityContext,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\WindowsSecurityContext.cs,LogonUser,The method has 6 parameters.
Long Identifier,log4net.Core,ILogger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\ILogger.cs,Log,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LocationInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LocationInfo.cs,LocationInfo,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LoggingEvent,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LoggingEvent.cs,LoggingEvent,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LoggingEvent,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LoggingEvent.cs,LoggingEvent,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LoggingEvent,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LoggingEvent.cs,LoggingEvent,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Repository.Hierarchy,Logger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Logger.cs,Log,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Repository.Hierarchy,Logger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Logger.cs,ForcedLog,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the parameter parsedObjectConversionTargetType is 32.
Long Identifier,log4net.Util,NativeError,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\NativeError.cs,GetErrorMessage,The length of the parameter FORMAT_MESSAGE_ALLOCATE_BUFFER is 30.
Long Identifier,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,SystemInfo,The length of the parameter notAvailableTextAppSettingsKey is 30.
Long Statement,log4net.Appender,AdoNetAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AdoNetAppender.cs,SendBuffer,The length of the statement  "		LogLog.Debug (declaringType' "Attempting to reconnect to database. Current Connection State: " + ((m_dbConnection == null) ? SystemInfo.NullText : m_dbConnection.State.ToString ())); " is 182.
Long Statement,log4net.Appender,AdoNetAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AdoNetAppender.cs,ResolveConnectionString,The length of the statement  "	connectionStringContext = "Unable to resolve connection string from ConnectionString' ConnectionStrings' or AppSettings."; " is 122.
Long Statement,log4net.Appender,AdoNetAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AdoNetAppender.cs,InitializeDatabaseConnection,The length of the statement  "		ErrorHandler.Error ("Could not open database connection [" + resolvedConnectionString + "]. Connection string context [" + connectionStringContext + "]."' e); " is 158.
Long Statement,log4net.Appender,AppenderCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AppenderCollection.cs,Remove,The length of the statement  "		throw new System.ArgumentException ("Cannot remove the specified item because it was not found in the specified Collection."); " is 126.
Long Statement,log4net.Appender,AppenderCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AppenderCollection.cs,ValidateIndex,The length of the statement  "		throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException ("i"' (object)i' "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values."); " is 248.
Long Statement,log4net.Appender,BufferingAppenderSkeleton,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\BufferingAppenderSkeleton.cs,Append,The length of the statement  "		if ((!m_lossy) || (m_evaluator != null && m_evaluator.IsTriggeringEvent (loggingEvent)) || (m_lossyEvaluator != null && m_lossyEvaluator.IsTriggeringEvent (loggingEvent))) { " is 173.
Long Statement,log4net.Appender,EventLogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\EventLogAppender.cs,ActivateOptions,The length of the statement  "			LogLog.Debug (declaringType' "Changing event source [" + m_applicationName + "] from log [" + currentLogName + "] to log [" + m_logName + "]"); " is 143.
Long Statement,log4net.Appender,EventLogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\EventLogAppender.cs,ActivateOptions,The length of the statement  "		ErrorHandler.Error ("Caught a SecurityException trying to access the EventLog.  Most likely the event source " + m_applicationName + " doesn't exist and must be created by a local administrator.  Will disable EventLogAppender." + "  See http://logging.apache.org/log4net/release/faq.html#trouble-EventLog"' ex); " is 311.
Long Statement,log4net.Appender,NetSendAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\NetSendAppender.cs,Append,The length of the statement  "		int returnValue = NetMessageBufferSend (this.Server' this.Recipient' this.Sender' renderedLoggingEvent' renderedLoggingEvent.Length * Marshal.SystemDefaultCharSize); " is 165.
Long Statement,log4net.Appender,NetSendAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\NetSendAppender.cs,Append,The length of the statement  "		ErrorHandler.Error (nativeError.ToString () + " (Params: Server=" + this.Server + "' Recipient=" + this.Recipient + "' Sender=" + this.Sender + ")"); " is 149.
Long Statement,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The length of the statement  "		ErrorHandler.Error ("Unable to send logging event to remote syslog " + this.RemoteAddress.ToString () + " on port " + this.RemotePort + "."' e' ErrorCode.WriteFailure); " is 168.
Long Statement,log4net.Appender,RemotingAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemotingAppender.cs,SendBuffer,The length of the statement  "		ErrorHandler.Error ("RemotingAppender [" + Name + "] failed to ThreadPool.QueueUserWorkItem logging events in SendBuffer."); " is 124.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,OpenFile,The length of the statement  "					LogLog.Error (declaringType' "RollingFileAppender: INTERNAL ERROR. Append is False but OutputFile [" + fileName + "] already exists."); " is 135.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,GetNextOutputFileName,The length of the statement  "			fileName = CombinePath (fileName' m_now.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 121.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,RollOverIfDateBoundaryCrossing,The length of the statement  "			LogLog.Debug (declaringType' "[" + last.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo) + "] vs. [" + m_now.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo) + "]"); " is 227.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,RollOverIfDateBoundaryCrossing,The length of the statement  "			if (!(last.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo).Equals (m_now.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)))) { " is 189.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,RollOverIfDateBoundaryCrossing,The length of the statement  "				m_scheduledFilename = CombinePath (m_baseFileName' last.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 137.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,ExistingInit,The length of the statement  "				LogLog.Debug (declaringType' "Output file [" + fileName + "] already exists. MaxSizeRollBackups is 0; cannot roll. Overwriting existing file."); " is 144.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,ExistingInit,The length of the statement  "				LogLog.Debug (declaringType' "Output file [" + fileName + "] already exists. Not appending to file. Rolling existing file out of the way."); " is 140.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,ComputeCheckPeriod,The length of the statement  "		string r1 = NextCheckDate (s_date1970' (RollPoint)i).ToString (datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo); " is 131.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,ActivateOptions,The length of the statement  "		m_scheduledFilename = CombinePath (File' m_now.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 128.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,RollOverTime,The length of the statement  "	m_scheduledFilename = CombinePath (File' m_now.ToString (m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 128.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,RollFile,The length of the statement  "			ErrorHandler.Error ("Exception while rolling file [" + fromFile + "] -> [" + toFile + "]"' moveEx' ErrorCode.GenericFailure); " is 125.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,DeleteFile,The length of the statement  "			LogLog.Debug (declaringType' "Exception while moving file to be deleted [" + fileName + "] -> [" + tempFileName + "]"' moveEx); " is 127.
Long Statement,log4net.Appender,SmtpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\SmtpAppender.cs,SendEmail,The length of the statement  "			// 'ReplyTo is obsoleted for this type.  Please use ReplyToList instead which can accept multiple addresses. http://go.microsoft.com/fwlink/?linkid=14202' " is 154.
Long Statement,log4net.Appender,SmtpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\SmtpAppender.cs,SendEmail,The length of the statement  "					ErrorHandler.Error("SmtpAppender: Authentication and server Port are only supported when running on the MS .NET 1.1 framework"' missingMethodException);" is 152.
Long Statement,log4net.Appender,SmtpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\SmtpAppender.cs,SendEmail,The length of the statement  "					ErrorHandler.Error("SmtpAppender: Authentication is only supported on the MS .NET 1.1 or MS .NET 2.0 builds of log4net");" is 121.
Long Statement,log4net.Appender,UdpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\UdpAppender.cs,ActivateOptions,The length of the statement  "		throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException ("this.RemotePort"' (object)this.RemotePort' "The RemotePort is less than " + IPEndPoint.MinPort.ToString (NumberFormatInfo.InvariantInfo) + " or greater than " + IPEndPoint.MaxPort.ToString (NumberFormatInfo.InvariantInfo) + "."); " is 295.
Long Statement,log4net.Appender,UdpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\UdpAppender.cs,ActivateOptions,The length of the statement  "		throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException ("this.LocalPort"' (object)this.LocalPort' "The LocalPort is less than " + IPEndPoint.MinPort.ToString (NumberFormatInfo.InvariantInfo) + " or greater than " + IPEndPoint.MaxPort.ToString (NumberFormatInfo.InvariantInfo) + "."); " is 292.
Long Statement,log4net.Appender,UdpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\UdpAppender.cs,Append,The length of the statement  "		ErrorHandler.Error ("Unable to send logging event to remote host " + this.RemoteAddress.ToString () + " on port " + this.RemotePort + "."' ex' ErrorCode.WriteFailure); " is 167.
Long Statement,log4net.Appender,UdpAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\UdpAppender.cs,InitializeClientConnection,The length of the statement  "		ErrorHandler.Error ("Could not initialize the UdpClient connection on port " + this.LocalPort.ToString (NumberFormatInfo.InvariantInfo) + "."' ex' ErrorCode.GenericFailure); " is 173.
Long Statement,log4net.Config,BasicConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\BasicConfigurator.cs,InternalConfigure,The length of the statement  "		LogLog.Warn (declaringType' "BasicConfigurator: Repository [" + repository + "] does not support the BasicConfigurator"); " is 121.
Long Statement,log4net.Config,SecurityContextProviderAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\SecurityContextProviderAttribute.cs,Configure,The length of the statement  "		LogLog.Error (declaringType' "Attribute specified on assembly [" + sourceAssembly.FullName + "] with null ProviderType."); " is 122.
Long Statement,log4net.Config,SecurityContextProviderAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\SecurityContextProviderAttribute.cs,Configure,The length of the statement  "			LogLog.Error (declaringType' "Failed to create SecurityContextProvider instance of type [" + m_providerType.Name + "]."); " is 121.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "			LogLog.Error (declaringType' "Failed to find configuration section 'log4net' in the application's .config file. Check your .config file for the <log4net> and <configSections> elements. The configuration section should look like: <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler'log4net\" />"); " is 327.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "			string configSectionStr = "<section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler'" + Assembly.GetExecutingAssembly ().FullName + "\" />"; " is 166.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "			LogLog.Error (declaringType' "Failed to parse config file. Is the <configSections> specified as: " + configSectionStr' confEx); " is 127.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "				LogLog.Error (declaringType' "XML configuration contains [" + configNodeList.Count + "] <log4net> elements. Only one is allowed. Configuration Aborted."); " is 154.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigureAndWatch,The length of the statement  "	LogLog.Debug (declaringType' "configuring repository [" + repository.Name + "] using file [" + configFile + "] watching for file updates"); " is 139.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigureAndWatch,The length of the statement  "				ConfigureAndWatchHandler handler = (ConfigureAndWatchHandler)m_repositoryName2ConfigAndWatchHandler [configFile.FullName]; " is 122.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigureAndWatch,The length of the statement  "			LogLog.Error (declaringType' "Failed to initialize configuration file watcher for file [" + configFile.FullName + "]"' ex); " is 123.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "				LogLog.Error (declaringType' "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set."' ex); " is 221.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "				LogLog.Error (declaringType' "Exception getting ApplicationBaseDirectory. Must be able to resolve ApplicationBaseDirectory and AssemblyFileName when ConfigFileExtension property is set."' ex); " is 192.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "				fullPath2ConfigFile = Path.Combine (applicationBaseDirectory' SystemInfo.AssemblyFileName (sourceAssembly) + m_configFileExtension); " is 132.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "			LogLog.Warn (declaringType' "Exception getting ApplicationBaseDirectory. ConfigFile property path [" + m_configFile + "] will be treated as an absolute path."' ex); " is 164.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromUri,The length of the statement  "				LogLog.Error (declaringType' "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set."' ex); " is 221.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromUri,The length of the statement  "				LogLog.Error (declaringType' "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when the ConfigFile property are not set."' ex); " is 199.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromUri,The length of the statement  "			LogLog.Warn (declaringType' "Exception getting ApplicationBaseDirectory. ConfigFile property path [" + m_configFile + "] will be treated as an absolute URI."' ex); " is 163.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "			LogLog.Debug (declaringType' "Assembly [" + repositoryAssembly + "] using repository [" + actualRepositoryName + "] and repository type [" + actualRepositoryType + "]"); " is 169.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "						LogLog.Error (declaringType' "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes."' ex); " is 124.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "				LogLog.Debug (declaringType' "repository [" + actualRepositoryName + "] already exists' using repository type [" + rep.GetType ().FullName + "]"); " is 146.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "						LogLog.Error (declaringType' "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes."' ex); " is 124.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "					LogLog.Debug (declaringType' "Aliasing repository [" + repositoryName + "] to existing repository [" + aliasedRepository.Name + "]"); " is 133.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "					LogLog.Error (declaringType' "Failed to alias repository [" + repositoryName + "] to existing repository [" + aliasedRepository.Name + "]. Requested repository type [" + repositoryType.FullName + "] is not compatible with existing type [" + aliasedRepository.GetType ().FullName + "]"); " is 286.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,AliasRepository,The length of the statement  "				throw new InvalidOperationException ("Repository [" + repositoryAlias + "] is already aliased to repository [" + ((ILoggerRepository)m_alias2repositoryMap [repositoryAlias]).Name + "]. Aliases cannot be redefined."); " is 216.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,AliasRepository,The length of the statement  "				throw new InvalidOperationException ("Repository [" + repositoryAlias + "] already exists and cannot be aliased to repository [" + repositoryTarget.Name + "]."); " is 161.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "		LogLog.Debug (declaringType' "Assembly [" + assembly.FullName + "] Loaded From [" + SystemInfo.AssemblyLocationInfo (assembly) + "]"); " is 134.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "		object[] repositoryAttributes = Attribute.GetCustomAttributes (assembly' typeof(log4net.Config.RepositoryAttribute)' false); " is 124.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "				LogLog.Error (declaringType' "Assembly [" + assembly + "] has multiple log4net.Config.RepositoryAttribute assembly attributes. Only using first occurrence."); " is 158.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "						LogLog.Error (declaringType' "DefaultRepositorySelector: Repository Type [" + domAttr.RepositoryType + "] must implement the ILoggerRepository interface."); " is 156.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "	object[] configAttributes = Attribute.GetCustomAttributes (assembly' typeof(log4net.Config.ConfiguratorAttribute)' false); " is 122.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "				LogLog.Warn (declaringType' "Exception getting ApplicationBaseDirectory. appSettings log4net.Config path [" + repositoryConfigFile + "] will be treated as an absolute URI"' ex); " is 177.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "					LogLog.Error (declaringType' "DefaultRepositorySelector: Exception while parsing log4net.Config file physical path [" + repositoryConfigFilePath + "]"' ex); " is 156.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "					LogLog.Debug (declaringType' "Loading and watching configuration for default repository from AppSettings specified Config path [" + repositoryConfigFilePath + "]"); " is 164.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "					LogLog.Error (declaringType' "DefaultRepositorySelector: Exception calling XmlConfigurator.ConfigureAndWatch method with ConfigFilePath [" + repositoryConfigFilePath + "]"' ex); " is 177.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "					LogLog.Debug (declaringType' "Loading configuration for default repository from AppSettings specified Config URI [" + repositoryConfigUri.ToString () + "]"); " is 157.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "						LogLog.Error (declaringType' "Exception calling XmlConfigurator.Configure method with ConfigUri [" + repositoryConfigUri + "]"' ex); " is 132.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,LoadAliases,The length of the statement  "	object[] configAttributes = Attribute.GetCustomAttributes (assembly' typeof(log4net.Config.AliasRepositoryAttribute)' false); " is 125.
Long Statement,log4net.Core,LevelCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LevelCollection.cs,Remove,The length of the statement  "		throw new System.ArgumentException ("Cannot remove the specified item because it was not found in the specified Collection."); " is 126.
Long Statement,log4net.Core,LevelCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LevelCollection.cs,ValidateIndex,The length of the statement  "		throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException ("i"' (object)i' "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values."); " is 248.
Long Statement,log4net.Core,LevelMap,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LevelMap.cs,Add,The length of the statement  "		throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException ("name"' name' "Parameter: name' Value: [" + name + "] out of range. Level name must not be empty"); " is 164.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,DebugFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelDebug' new SystemStringFormat (CultureInfo.InvariantCulture' format' args)' null); " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,DebugFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelDebug' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,DebugFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelDebug' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,DebugFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelDebug' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,InfoFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelInfo' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,InfoFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelInfo' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,InfoFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelInfo' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,WarnFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelWarn' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,WarnFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelWarn' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,WarnFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelWarn' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,ErrorFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelError' new SystemStringFormat (CultureInfo.InvariantCulture' format' args)' null); " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,ErrorFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelError' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,ErrorFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelError' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,ErrorFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelError' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,FatalFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelFatal' new SystemStringFormat (CultureInfo.InvariantCulture' format' args)' null); " is 120.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,FatalFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelFatal' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,FatalFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelFatal' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Core,LogImpl,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LogImpl.cs,FatalFormat,The length of the statement  "		Logger.Log (ThisDeclaringType' m_levelFatal' new SystemStringFormat (CultureInfo.InvariantCulture' format' new object[] { " is 121.
Long Statement,log4net.Layout,PatternLayout,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\PatternLayout.cs,AddConverter,The length of the statement  "		throw new ArgumentException ("The converter type specified [" + converterInfo.Type + "] must be a subclass of log4net.Util.PatternConverter"' "converterInfo"); " is 159.
Long Statement,log4net.Layout,XmlLayout,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayout.cs,FormatXml,The length of the statement  "	writer.WriteAttributeString (ATTR_TIMESTAMP' XmlConvert.ToString (loggingEvent.TimeStamp' XmlDateTimeSerializationMode.Local)); " is 127.
Long Statement,log4net.Layout,XmlLayout,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayout.cs,FormatXml,The length of the statement  "			writer.WriteAttributeString (ATTR_NAME' Transform.MaskXmlInvalidCharacters ((string)entry.Key' this.InvalidCharReplacement)); " is 125.
Long Statement,log4net.Layout,XmlLayout,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayout.cs,FormatXml,The length of the statement  "				valueStr = Transform.MaskXmlInvalidCharacters (loggingEvent.Repository.RendererMap.FindAndRender (entry.Value)' this.InvalidCharReplacement); " is 141.
Long Statement,log4net.Layout,XmlLayoutSchemaLog4j,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayoutSchemaLog4j.cs,FormatXml,The length of the statement  "	if (loggingEvent.LookupProperty (LoggingEvent.HostNameProperty) != null && loggingEvent.LookupProperty ("log4jmachinename") == null) { " is 134.
Long Statement,log4net.Layout,XmlLayoutSchemaLog4j,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayoutSchemaLog4j.cs,FormatXml,The length of the statement  "	if (loggingEvent.LookupProperty ("log4japp") == null && loggingEvent.Domain != null && loggingEvent.Domain.Length > 0) { " is 120.
Long Statement,log4net.Layout,XmlLayoutSchemaLog4j,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayoutSchemaLog4j.cs,FormatXml,The length of the statement  "	if (loggingEvent.Identity != null && loggingEvent.Identity.Length > 0 && loggingEvent.LookupProperty (LoggingEvent.IdentityProperty) == null) { " is 143.
Long Statement,log4net.Layout,XmlLayoutSchemaLog4j,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\XmlLayoutSchemaLog4j.cs,FormatXml,The length of the statement  "	if (loggingEvent.UserName != null && loggingEvent.UserName.Length > 0 && loggingEvent.LookupProperty (LoggingEvent.UserNameProperty) == null) { " is 143.
Long Statement,log4net.Layout.Pattern,DatePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\DatePatternConverter.cs,ActivateOptions,The length of the statement  "	if (string.Compare (dateFormatStr' AbsoluteTimeDateFormatter.Iso8601TimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 148.
Long Statement,log4net.Layout.Pattern,DatePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\DatePatternConverter.cs,ActivateOptions,The length of the statement  "	else if (string.Compare (dateFormatStr' AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 154.
Long Statement,log4net.Layout.Pattern,DatePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\DatePatternConverter.cs,ActivateOptions,The length of the statement  "	else if (string.Compare (dateFormatStr' AbsoluteTimeDateFormatter.DateAndTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 153.
Long Statement,log4net.Layout.Pattern,RelativeTimePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\RelativeTimePatternConverter.cs,Convert,The length of the statement  "	writer.Write (TimeDifferenceInMillis (LoggingEvent.StartTime' loggingEvent.TimeStamp).ToString (System.Globalization.NumberFormatInfo.InvariantInfo)); " is 150.
Long Statement,log4net.Layout.Pattern,StackTracePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTracePatternConverter.cs,ActivateOptions,The length of the statement  "				LogLog.Error (declaringType' "StackTracePatternConverter: StackeFrameLevel option (" + optStr + ") isn't a positive integer."); " is 127.
Long Statement,log4net.Layout.Pattern,StackTracePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTracePatternConverter.cs,ActivateOptions,The length of the statement  "			LogLog.Error (declaringType' "StackTracePatternConverter: StackFrameLevel option \"" + optStr + "\" not a decimal integer."); " is 125.
Long Statement,log4net.ObjectRenderer,RendererMap,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\ObjectRenderer\RendererMap.cs,FindAndRender,The length of the statement  "				log4net.Util.LogLog.Error (declaringType' "Exception while rendering object of type [" + obj.GetType ().FullName + "]"' ex); " is 124.
Long Statement,log4net.Plugin,PluginCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Plugin\PluginCollection.cs,Remove,The length of the statement  "		throw new System.ArgumentException ("Cannot remove the specified item because it was not found in the specified Collection."); " is 126.
Long Statement,log4net.Plugin,PluginCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Plugin\PluginCollection.cs,ValidateIndex,The length of the statement  "		throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException ("i"' (object)i' "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values."); " is 248.
Long Statement,log4net.Repository.Hierarchy,Hierarchy,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Hierarchy.cs,AddLevel,The length of the statement  "			throw new InvalidOperationException ("Cannot redefine level [" + levelEntry.Name + "] because it is not defined in the LevelMap. To define the level supply the level value."); " is 175.
Long Statement,log4net.Repository.Hierarchy,Logger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Logger.cs,Log,The length of the statement  "			ForcedLog ((callerStackBoundaryDeclaringType != null) ? callerStackBoundaryDeclaringType : declaringType' level' message' exception); " is 133.
Long Statement,log4net.Repository.Hierarchy,Logger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Logger.cs,CallAppenders,The length of the statement  "		LogLog.Debug (declaringType' "No appenders could be found for logger [" + Name + "] repository [" + Repository.Name + "]"); " is 123.
Long Statement,log4net.Repository.Hierarchy,Logger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Logger.cs,ForcedLog,The length of the statement  "	CallAppenders (new LoggingEvent (callerStackBoundaryDeclaringType' this.Hierarchy' this.Name' level' message' exception)); " is 122.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,The length of the statement  "			configUpdateMode = (ConfigUpdateMode)OptionConverter.ConvertStringTo (typeof(ConfigUpdateMode)' configUpdateModeAttribute); " is 123.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,The length of the statement  "			LogLog.Error (declaringType' "Invalid " + CONFIG_UPDATE_MODE_ATTR + " attribute value [" + configUpdateModeAttribute + "]"); " is 124.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,The length of the statement  "			LogLog.Warn (declaringType' "Unable to set hierarchy threshold using value [" + thresholdStr + "] (with acceptable conversion types)"); " is 135.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseAppender,The length of the statement  "						LogLog.Error (declaringType' "Requesting attachment of appender named [" + refName + "] to appender named [" + appender.Name + "] which does not implement log4net.Core.IAppenderAttachable."); " is 191.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseAppender,The length of the statement  "		LogLog.Error (declaringType' "Could not create Appender [" + appenderName + "] of type [" + typeName + "]. Reported error follows."' ex); " is 137.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseRenderer,The length of the statement  "	LogLog.Debug (declaringType' "Rendering class [" + renderingClassName + "]' Rendered class [" + renderedClassName + "]."); " is 122.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseRenderer,The length of the statement  "	IObjectRenderer renderer = (IObjectRenderer)OptionConverter.InstantiateByClassName (renderingClassName' typeof(IObjectRenderer)' null); " is 135.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseLevel,The length of the statement  "			LogLog.Debug (declaringType' "Logger [" + loggerName + "] level set to [name=\"" + log.Level.Name + "\"'value=" + log.Level.Value + "]."); " is 138.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "	propInfo = targetType.GetProperty (name' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.IgnoreCase); " is 137.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "		LogLog.Error (declaringType' "XmlHierarchyConfigurator: Cannot find Property [" + name + "] to set object on [" + target.ToString () + "]"); " is 140.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "				LogLog.Debug (declaringType' "Security exception while trying to expand environment variables. Error Ignored. No Expansion."); " is 126.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "							LogLog.Error (declaringType' "subtype [" + subType.FullName + "] set on [" + name + "] is not a subclass of property type [" + propertyType.FullName + "] and there are no acceptable type conversions."); " is 202.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "				LogLog.Debug (declaringType' "Performing additional conversion of value from [" + convertedValue.GetType ().Name + "] to [" + parsedObjectConversionTargetType.Name + "]"); " is 171.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "					LogLog.Debug (declaringType' "Setting Property [" + propInfo.Name + "] to " + convertedValue.GetType ().Name + " value [" + convertedValue.ToString () + "]"); " is 158.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "						LogLog.Error (declaringType' "Failed to set parameter [" + propInfo.Name + "] on object [" + target + "] using value [" + convertedValue + "]"' targetInvocationEx.InnerException); " is 179.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "					LogLog.Debug (declaringType' "Setting Collection Property [" + methInfo.Name + "] to " + convertedValue.GetType ().Name + " value [" + convertedValue.ToString () + "]"); " is 169.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "						LogLog.Error (declaringType' "Failed to set parameter [" + name + "] on object [" + target + "] using value [" + convertedValue + "]"' targetInvocationEx.InnerException); " is 170.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "				LogLog.Warn (declaringType' "Unable to set property [" + name + "] on object [" + target + "] using value [" + propertyValue + "] (with acceptable conversion types)"); " is 167.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "						LogLog.Error (declaringType' "Failed to set parameter [" + propInfo.Name + "] on object [" + target + "] using value [" + createdObject + "]"' targetInvocationEx.InnerException); " is 178.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "						LogLog.Error (declaringType' "Failed to set parameter [" + methInfo.Name + "] on object [" + target + "] using value [" + createdObject + "]"' targetInvocationEx.InnerException); " is 178.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,FindMethodInfo,The length of the statement  "			if (string.Compare (methInfo.Name' requiredMethodNameA' true' System.Globalization.CultureInfo.InvariantCulture) == 0 || string.Compare (methInfo.Name' requiredMethodNameB' true' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 237.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,The length of the statement  "			LogLog.Error (declaringType' "Object type not specified. Cannot create object of type [" + typeConstraint.FullName + "]. Missing Value or Type."); " is 146.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,The length of the statement  "				LogLog.Error (declaringType' "Object type [" + objectType.FullName + "] is not assignable to type [" + typeConstraint.FullName + "]. There are no acceptable type conversions."); " is 177.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,The length of the statement  "		LogLog.Error (declaringType' "XmlHierarchyConfigurator: Failed to construct object of type [" + objectType.FullName + "] Exception: " + createInstanceEx.ToString ()); " is 166.
Long Statement,log4net.Util,LogicalThreadContextProperties,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\LogicalThreadContextProperties.cs,GetProperties,The length of the statement  "			LogLog.Warn (declaringType' "SecurityException while accessing CallContext. Disabling LogicalThreadContextProperties"' secEx); " is 126.
Long Statement,log4net.Util,NativeError,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\NativeError.cs,GetErrorMessage,The length of the statement  "		// If the function succeeds' the return value is the number of TCHARs stored in the output buffer' excluding the terminating null character " is 139.
Long Statement,log4net.Util,NativeError,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\NativeError.cs,GetErrorMessage,The length of the statement  "		int messageSize = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS' ref sourcePtr' messageId' 0' ref msgBuf' 255' argumentsPtr); " is 186.
Long Statement,log4net.Util,NativeError,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\NativeError.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "0x{0:x8}"' this.Number) + (this.Message != null ? ": " + this.Message : ""); " is 129.
Long Statement,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ConvertTypeTo,The length of the statement  "	throw new ArgumentException ("Cannot convert source object [" + sourceInstance.ToString () + "] to target type [" + targetType.Name + "]"' "sourceInstance"); " is 157.
Long Statement,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,InstantiateByClassName,The length of the statement  "				LogLog.Error (declaringType' "OptionConverter: A [" + className + "] object is not assignable to a [" + superClass.FullName + "] variable."); " is 141.
Long Statement,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The length of the statement  "					formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo); " is 171.
Long Statement,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The length of the statement  "					formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo); " is 171.
Long Statement,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The length of the statement  "						if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 138.
Long Statement,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ProcessConverter,The length of the statement  "	LogLog.Debug (declaringType' "Converter [" + converterName + "] Option [" + option + "] Format [min=" + formattingInfo.Min + "'max=" + formattingInfo.Max + "'leftAlign=" + formattingInfo.LeftAlign + "]"); " is 204.
Long Statement,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ProcessConverter,The length of the statement  "			LogLog.Error (declaringType' "Failed to create instance of Type [" + converterInfo.Type.FullName + "] using default constructor. Exception: " + createInstanceEx.ToString ()); " is 174.
Long Statement,log4net.Util,PatternString,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternString.cs,AddConverter,The length of the statement  "		throw new ArgumentException ("The converter type specified [" + converterInfo.Type + "] must be a subclass of log4net.Util.PatternConverter"' "converterInfo"); " is 159.
Long Statement,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,GetTypeFromString,The length of the statement  "					LogLog.Debug (declaringType' "Loaded type [" + typeName + "] from assembly [" + assembly.FullName + "] by searching loaded assemblies."); " is 137.
Long Statement,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,GetTypeFromString,The length of the statement  "			throw new TypeLoadException ("Could not load type [" + typeName + "]. Tried assembly [" + relativeAssembly.FullName + "] and all loaded assemblies"); " is 149.
Long Statement,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,TryParse,The length of the statement  "		if (Double.TryParse (s' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out doubleVal)) { " is 135.
Long Statement,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,TryParse,The length of the statement  "		if (Double.TryParse (s' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out doubleVal)) { " is 135.
Long Statement,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,TryParse,The length of the statement  "		if (Double.TryParse (s' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out doubleVal)) { " is 135.
Long Statement,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,GetAppSetting,The length of the statement  "		LogLog.Error (declaringType' "Exception while reading ConfigurationSettings. Check your .config file is well formed XML."' ex); " is 127.
Long Statement,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The length of the statement  "	int weightStringEscapes = 3 * (CountSubstrings (stringData' "<") + CountSubstrings (stringData' ">")) + 4 * CountSubstrings (stringData' "&"); " is 142.
Long Statement,log4net.Util,WindowsSecurityContext,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\WindowsSecurityContext.cs,LogonUser,The length of the statement  "	if (!LogonUser (userName' domainName' password' LOGON32_LOGON_INTERACTIVE' LOGON32_PROVIDER_DEFAULT' ref tokenHandle)) { " is 120.
Long Statement,log4net.Util,WindowsSecurityContext,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\WindowsSecurityContext.cs,LogonUser,The length of the statement  "		throw new Exception ("Failed to LogonUser [" + userName + "] in Domain [" + domainName + "]. Error: " + error.ToString ()); " is 123.
Long Statement,log4net.Util.PatternStringConverters,DatePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\DatePatternConverter.cs,ActivateOptions,The length of the statement  "	if (string.Compare (dateFormatStr' AbsoluteTimeDateFormatter.Iso8601TimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 148.
Long Statement,log4net.Util.PatternStringConverters,DatePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\DatePatternConverter.cs,ActivateOptions,The length of the statement  "	else if (string.Compare (dateFormatStr' AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 154.
Long Statement,log4net.Util.PatternStringConverters,DatePatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\DatePatternConverter.cs,ActivateOptions,The length of the statement  "	else if (string.Compare (dateFormatStr' AbsoluteTimeDateFormatter.DateAndTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) { " is 153.
Long Statement,log4net.Util.PatternStringConverters,EnvironmentFolderPathPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\EnvironmentFolderPathPatternConverter.cs,Convert,The length of the statement  "			Environment.SpecialFolder specialFolder = (Environment.SpecialFolder)Enum.Parse (typeof(Environment.SpecialFolder)' Option' true); " is 130.
Long Statement,log4net.Util.PatternStringConverters,EnvironmentFolderPathPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\EnvironmentFolderPathPatternConverter.cs,Convert,The length of the statement  "		LogLog.Debug (declaringType' "Security exception while trying to expand environment variables. Error Ignored. No Expansion."' secEx); " is 133.
Long Statement,log4net.Util.PatternStringConverters,EnvironmentPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\EnvironmentPatternConverter.cs,Convert,The length of the statement  "		LogLog.Debug (declaringType' "Security exception while trying to expand environment variables. Error Ignored. No Expansion."' secEx); " is 133.
Long Statement,log4net.Util.PatternStringConverters,IdentityPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\IdentityPatternConverter.cs,Convert,The length of the statement  "		if (System.Threading.Thread.CurrentPrincipal != null && System.Threading.Thread.CurrentPrincipal.Identity != null && System.Threading.Thread.CurrentPrincipal.Identity.Name != null) { " is 182.
Long Statement,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,ActivateOptions,The length of the statement  "			LogLog.Error (declaringType' "RandomStringPatternConverter: Could not convert Option [" + optionStr + "] to Length Int32"); " is 123.
Long Statement,log4net.Util.TypeConverters,ConversionNotSupportedException,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\TypeConverters\ConversionNotSupportedException.cs,Create,The length of the statement  "		return new ConversionNotSupportedException ("Cannot convert value [null] to type [" + destinationType + "]"' innerException); " is 125.
Long Statement,log4net.Util.TypeConverters,ConversionNotSupportedException,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\TypeConverters\ConversionNotSupportedException.cs,Create,The length of the statement  "		return new ConversionNotSupportedException ("Cannot convert from type [" + sourceValue.GetType () + "] value [" + sourceValue + "] to type [" + destinationType + "]"' innerException); " is 183.
Long Statement,log4net.Util.TypeConverters,ConverterRegistry,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\TypeConverters\ConverterRegistry.cs,CreateConverterInstance,The length of the statement  "		throw new ArgumentNullException ("converterType"' "CreateConverterInstance cannot create instance' converterType is null"); " is 123.
Long Statement,log4net.Util.TypeConverters,ConverterRegistry,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\TypeConverters\ConverterRegistry.cs,CreateConverterInstance,The length of the statement  "			LogLog.Error (declaringType' "Cannot CreateConverterInstance of type [" + converterType.FullName + "]' Exception in call to Activator.CreateInstance"' ex); " is 155.
Long Statement,log4net.Util.TypeConverters,ConverterRegistry,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\TypeConverters\ConverterRegistry.cs,CreateConverterInstance,The length of the statement  "		LogLog.Error (declaringType' "Cannot CreateConverterInstance of type [" + converterType.FullName + "]' type does not implement IConvertFrom or IConvertTo"); " is 156.
Complex Conditional,log4net.Appender,BufferingAppenderSkeleton,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\BufferingAppenderSkeleton.cs,Append,The conditional expression  "(!m_lossy) || (m_evaluator != null && m_evaluator.IsTriggeringEvent (loggingEvent)) || (m_lossyEvaluator != null && m_lossyEvaluator.IsTriggeringEvent (loggingEvent))"  is complex.
Complex Conditional,log4net.Util.TypeConverters,IPAddressConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\TypeConverters\IPAddressConverter.cs,ConvertFrom,The conditional expression  "host != null && host.AddressList != null && host.AddressList.Length > 0 && host.AddressList [0] != null"  is complex.
Virtual Method Call from Constructor,log4net.Appender,AppenderCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AppenderCollection.cs,AppenderCollection,The constructor "AppenderCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Appender,AppenderCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AppenderCollection.cs,AppenderCollection,The constructor "AppenderCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Appender,AppenderCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AppenderCollection.cs,AppenderCollection,The constructor "AppenderCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Core,LevelCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LevelCollection.cs,LevelCollection,The constructor "LevelCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Core,LevelCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LevelCollection.cs,LevelCollection,The constructor "LevelCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Core,LevelCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\LevelCollection.cs,LevelCollection,The constructor "LevelCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Plugin,PluginCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Plugin\PluginCollection.cs,PluginCollection,The constructor "PluginCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Plugin,PluginCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Plugin\PluginCollection.cs,PluginCollection,The constructor "PluginCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Plugin,PluginCollection,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Plugin\PluginCollection.cs,PluginCollection,The constructor "PluginCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Util,PatternString,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternString.cs,PatternString,The constructor "PatternString" calls a virtual method "ActivateOptions".
Empty Catch Block,log4net.Appender,AdoNetAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AdoNetAppender.cs,SendBuffer,The method has an empty catch block.
Empty Catch Block,log4net.Appender,LocalSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\LocalSyslogAppender.cs,OnClose,The method has an empty catch block.
Empty Catch Block,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The method has an empty catch block.
Empty Catch Block,log4net.Config,XmlConfiguratorAttribute,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfiguratorAttribute.cs,Configure,The method has an empty catch block.
Empty Catch Block,log4net.Core,DefaultRepositorySelector,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The method has an empty catch block.
Empty Catch Block,log4net.Layout.Pattern,AspNetRequestPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\AspNetRequestPatternConverter.cs,Convert,The method has an empty catch block.
Empty Catch Block,log4net.ObjectRenderer,RendererMap,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\ObjectRenderer\RendererMap.cs,FindAndRender,The method has an empty catch block.
Empty Catch Block,log4net.Repository.Hierarchy,Logger,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Repository\Hierarchy\Logger.cs,CallAppenders,The method has an empty catch block.
Empty Catch Block,log4net.Util,LogLog,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\LogLog.cs,EmitOutLine,The method has an empty catch block.
Empty Catch Block,log4net.Util,LogLog,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\LogLog.cs,EmitErrorLine,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,GetTypeFromString,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,TryParse,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,TryParse,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,TryParse,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\SystemInfo.cs,ConvertToFullPath,The method has an empty catch block.
Magic Number,log4net.Appender,AnsiColorTerminalAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AnsiColorTerminalAppender.cs,Append,The following statement contains a magic number: if (loggingMessage.Length > 1) {  	if (loggingMessage.EndsWith ("\r\n") || loggingMessage.EndsWith ("\n\r")) {  		loggingMessage = loggingMessage.Insert (loggingMessage.Length - 2' PostEventCodes);  	}  	else if (loggingMessage.EndsWith ("\n") || loggingMessage.EndsWith ("\r")) {  		loggingMessage = loggingMessage.Insert (loggingMessage.Length - 1' PostEventCodes);  	}  	else {  		loggingMessage = loggingMessage + PostEventCodes;  	}  }  else {  	if (loggingMessage [0] == '\n' || loggingMessage [0] == '\r') {  		loggingMessage = PostEventCodes + loggingMessage;  	}  	else {  		loggingMessage = loggingMessage + PostEventCodes;  	}  }  
Magic Number,log4net.Appender,AnsiColorTerminalAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AnsiColorTerminalAppender.cs,Append,The following statement contains a magic number: if (loggingMessage.EndsWith ("\r\n") || loggingMessage.EndsWith ("\n\r")) {  	loggingMessage = loggingMessage.Insert (loggingMessage.Length - 2' PostEventCodes);  }  else if (loggingMessage.EndsWith ("\n") || loggingMessage.EndsWith ("\r")) {  	loggingMessage = loggingMessage.Insert (loggingMessage.Length - 1' PostEventCodes);  }  else {  	loggingMessage = loggingMessage + PostEventCodes;  }  
Magic Number,log4net.Appender,AnsiColorTerminalAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AnsiColorTerminalAppender.cs,Append,The following statement contains a magic number: loggingMessage = loggingMessage.Insert (loggingMessage.Length - 2' PostEventCodes);  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (m_consoleOutputWriter != null) {  	IntPtr consoleHandle = IntPtr.Zero;  	if (m_writeToErrorStream) {  		// Write to the error stream  		consoleHandle = GetStdHandle (STD_ERROR_HANDLE);  	}  	else {  		// Write to the output stream  		consoleHandle = GetStdHandle (STD_OUTPUT_HANDLE);  	}  	// Default to white on black  	ushort colorInfo = (ushort)Colors.White;  	// see if there is a specified lookup  	LevelColors levelColors = m_levelMapping.Lookup (loggingEvent.Level) as LevelColors;  	if (levelColors != null) {  		colorInfo = levelColors.CombinedColor;  	}  	// Render the event to a string  	string strLoggingMessage = RenderLoggingEvent (loggingEvent);  	// get the current console color - to restore later  	CONSOLE_SCREEN_BUFFER_INFO bufferInfo;  	GetConsoleScreenBufferInfo (consoleHandle' out bufferInfo);  	// set the console colors  	SetConsoleTextAttribute (consoleHandle' colorInfo);  	// Using WriteConsoleW seems to be unreliable.  	// If a large buffer is written' say 15'000 chars  	// Followed by a larger buffer' say 20'000 chars  	// then WriteConsoleW will fail' last error 8  	// 'Not enough storage is available to process this command.'  	//   	// Although the documentation states that the buffer must  	// be less that 64KB (i.e. 32'000 WCHARs) the longest string  	// that I can write out a the first call to WriteConsoleW  	// is only 30'704 chars.  	//  	// Unlike the WriteFile API the WriteConsoleW method does not   	// seem to be able to partially write out from the input buffer.  	// It does have a lpNumberOfCharsWritten parameter' but this is  	// either the length of the input buffer if any output was written'  	// or 0 when an error occurs.  	//  	// All results above were observed on Windows XP SP1 running  	// .NET runtime 1.1 SP1.  	//  	// Old call to WriteConsoleW:  	//  	// WriteConsoleW(  	//     consoleHandle'  	//     strLoggingMessage'  	//     (UInt32)strLoggingMessage.Length'  	//     out (UInt32)ignoreWrittenCount'  	//     IntPtr.Zero);  	//  	// Instead of calling WriteConsoleW we use WriteFile which   	// handles large buffers correctly. Because WriteFile does not  	// handle the codepage conversion as WriteConsoleW does we   	// need to use a System.IO.StreamWriter with the appropriate  	// Encoding. The WriteFile calls are wrapped up in the  	// System.IO.__ConsoleStream internal class obtained through  	// the System.Console.OpenStandardOutput method.  	//  	// See the ActivateOptions method below for the code that  	// retrieves and wraps the stream.  	// The windows console uses ScrollConsoleScreenBuffer internally to  	// scroll the console buffer when the display buffer of the console  	// has been used up. ScrollConsoleScreenBuffer fills the area uncovered  	// by moving the current content with the background color   	// currently specified on the console. This means that it fills the  	// whole line in front of the cursor position with the current   	// background color.  	// This causes an issue when writing out text with a non default  	// background color. For example; We write a message with a Blue  	// background color and the scrollable area of the console is full.  	// When we write the newline at the end of the message the console  	// needs to scroll the buffer to make space available for the new line.  	// The ScrollConsoleScreenBuffer internals will fill the newly created  	// space with the current background color: Blue.  	// We then change the console color back to default (White text on a  	// Black background). We write some text to the console' the text is  	// written correctly in White with a Black background' however the  	// remainder of the line still has a Blue background.  	//   	// This causes a disjointed appearance to the output where the background  	// colors change.  	//  	// This can be remedied by restoring the console colors before causing  	// the buffer to scroll' i.e. before writing the last newline. This does  	// assume that the rendered message will end with a newline.  	//  	// Therefore we identify a trailing newline in the message and don't  	// write this to the output' then we restore the console color and write  	// a newline. Note that we must AutoFlush before we restore the console  	// color otherwise we will have no effect.  	//  	// There will still be a slight artefact for the last line of the message  	// will have the background extended to the end of the line' however this  	// is unlikely to cause any user issues.  	//  	// Note that none of the above is visible while the console buffer is scrollable  	// within the console window viewport' the effects only arise when the actual  	// buffer is full and needs to be scrolled.  	char[] messageCharArray = strLoggingMessage.ToCharArray ();  	int arrayLength = messageCharArray.Length;  	bool appendNewline = false;  	// Trim off last newline' if it exists  	if (arrayLength > 1 && messageCharArray [arrayLength - 2] == '\r' && messageCharArray [arrayLength - 1] == '\n') {  		arrayLength -= 2;  		appendNewline = true;  	}  	// Write to the output stream  	m_consoleOutputWriter.Write (messageCharArray' 0' arrayLength);  	// Restore the console back to its previous color scheme  	SetConsoleTextAttribute (consoleHandle' bufferInfo.wAttributes);  	if (appendNewline) {  		// Write the newline' after changing the color scheme  		m_consoleOutputWriter.Write (s_windowsNewline' 0' 2);  	}  }  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (m_consoleOutputWriter != null) {  	IntPtr consoleHandle = IntPtr.Zero;  	if (m_writeToErrorStream) {  		// Write to the error stream  		consoleHandle = GetStdHandle (STD_ERROR_HANDLE);  	}  	else {  		// Write to the output stream  		consoleHandle = GetStdHandle (STD_OUTPUT_HANDLE);  	}  	// Default to white on black  	ushort colorInfo = (ushort)Colors.White;  	// see if there is a specified lookup  	LevelColors levelColors = m_levelMapping.Lookup (loggingEvent.Level) as LevelColors;  	if (levelColors != null) {  		colorInfo = levelColors.CombinedColor;  	}  	// Render the event to a string  	string strLoggingMessage = RenderLoggingEvent (loggingEvent);  	// get the current console color - to restore later  	CONSOLE_SCREEN_BUFFER_INFO bufferInfo;  	GetConsoleScreenBufferInfo (consoleHandle' out bufferInfo);  	// set the console colors  	SetConsoleTextAttribute (consoleHandle' colorInfo);  	// Using WriteConsoleW seems to be unreliable.  	// If a large buffer is written' say 15'000 chars  	// Followed by a larger buffer' say 20'000 chars  	// then WriteConsoleW will fail' last error 8  	// 'Not enough storage is available to process this command.'  	//   	// Although the documentation states that the buffer must  	// be less that 64KB (i.e. 32'000 WCHARs) the longest string  	// that I can write out a the first call to WriteConsoleW  	// is only 30'704 chars.  	//  	// Unlike the WriteFile API the WriteConsoleW method does not   	// seem to be able to partially write out from the input buffer.  	// It does have a lpNumberOfCharsWritten parameter' but this is  	// either the length of the input buffer if any output was written'  	// or 0 when an error occurs.  	//  	// All results above were observed on Windows XP SP1 running  	// .NET runtime 1.1 SP1.  	//  	// Old call to WriteConsoleW:  	//  	// WriteConsoleW(  	//     consoleHandle'  	//     strLoggingMessage'  	//     (UInt32)strLoggingMessage.Length'  	//     out (UInt32)ignoreWrittenCount'  	//     IntPtr.Zero);  	//  	// Instead of calling WriteConsoleW we use WriteFile which   	// handles large buffers correctly. Because WriteFile does not  	// handle the codepage conversion as WriteConsoleW does we   	// need to use a System.IO.StreamWriter with the appropriate  	// Encoding. The WriteFile calls are wrapped up in the  	// System.IO.__ConsoleStream internal class obtained through  	// the System.Console.OpenStandardOutput method.  	//  	// See the ActivateOptions method below for the code that  	// retrieves and wraps the stream.  	// The windows console uses ScrollConsoleScreenBuffer internally to  	// scroll the console buffer when the display buffer of the console  	// has been used up. ScrollConsoleScreenBuffer fills the area uncovered  	// by moving the current content with the background color   	// currently specified on the console. This means that it fills the  	// whole line in front of the cursor position with the current   	// background color.  	// This causes an issue when writing out text with a non default  	// background color. For example; We write a message with a Blue  	// background color and the scrollable area of the console is full.  	// When we write the newline at the end of the message the console  	// needs to scroll the buffer to make space available for the new line.  	// The ScrollConsoleScreenBuffer internals will fill the newly created  	// space with the current background color: Blue.  	// We then change the console color back to default (White text on a  	// Black background). We write some text to the console' the text is  	// written correctly in White with a Black background' however the  	// remainder of the line still has a Blue background.  	//   	// This causes a disjointed appearance to the output where the background  	// colors change.  	//  	// This can be remedied by restoring the console colors before causing  	// the buffer to scroll' i.e. before writing the last newline. This does  	// assume that the rendered message will end with a newline.  	//  	// Therefore we identify a trailing newline in the message and don't  	// write this to the output' then we restore the console color and write  	// a newline. Note that we must AutoFlush before we restore the console  	// color otherwise we will have no effect.  	//  	// There will still be a slight artefact for the last line of the message  	// will have the background extended to the end of the line' however this  	// is unlikely to cause any user issues.  	//  	// Note that none of the above is visible while the console buffer is scrollable  	// within the console window viewport' the effects only arise when the actual  	// buffer is full and needs to be scrolled.  	char[] messageCharArray = strLoggingMessage.ToCharArray ();  	int arrayLength = messageCharArray.Length;  	bool appendNewline = false;  	// Trim off last newline' if it exists  	if (arrayLength > 1 && messageCharArray [arrayLength - 2] == '\r' && messageCharArray [arrayLength - 1] == '\n') {  		arrayLength -= 2;  		appendNewline = true;  	}  	// Write to the output stream  	m_consoleOutputWriter.Write (messageCharArray' 0' arrayLength);  	// Restore the console back to its previous color scheme  	SetConsoleTextAttribute (consoleHandle' bufferInfo.wAttributes);  	if (appendNewline) {  		// Write the newline' after changing the color scheme  		m_consoleOutputWriter.Write (s_windowsNewline' 0' 2);  	}  }  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (m_consoleOutputWriter != null) {  	IntPtr consoleHandle = IntPtr.Zero;  	if (m_writeToErrorStream) {  		// Write to the error stream  		consoleHandle = GetStdHandle (STD_ERROR_HANDLE);  	}  	else {  		// Write to the output stream  		consoleHandle = GetStdHandle (STD_OUTPUT_HANDLE);  	}  	// Default to white on black  	ushort colorInfo = (ushort)Colors.White;  	// see if there is a specified lookup  	LevelColors levelColors = m_levelMapping.Lookup (loggingEvent.Level) as LevelColors;  	if (levelColors != null) {  		colorInfo = levelColors.CombinedColor;  	}  	// Render the event to a string  	string strLoggingMessage = RenderLoggingEvent (loggingEvent);  	// get the current console color - to restore later  	CONSOLE_SCREEN_BUFFER_INFO bufferInfo;  	GetConsoleScreenBufferInfo (consoleHandle' out bufferInfo);  	// set the console colors  	SetConsoleTextAttribute (consoleHandle' colorInfo);  	// Using WriteConsoleW seems to be unreliable.  	// If a large buffer is written' say 15'000 chars  	// Followed by a larger buffer' say 20'000 chars  	// then WriteConsoleW will fail' last error 8  	// 'Not enough storage is available to process this command.'  	//   	// Although the documentation states that the buffer must  	// be less that 64KB (i.e. 32'000 WCHARs) the longest string  	// that I can write out a the first call to WriteConsoleW  	// is only 30'704 chars.  	//  	// Unlike the WriteFile API the WriteConsoleW method does not   	// seem to be able to partially write out from the input buffer.  	// It does have a lpNumberOfCharsWritten parameter' but this is  	// either the length of the input buffer if any output was written'  	// or 0 when an error occurs.  	//  	// All results above were observed on Windows XP SP1 running  	// .NET runtime 1.1 SP1.  	//  	// Old call to WriteConsoleW:  	//  	// WriteConsoleW(  	//     consoleHandle'  	//     strLoggingMessage'  	//     (UInt32)strLoggingMessage.Length'  	//     out (UInt32)ignoreWrittenCount'  	//     IntPtr.Zero);  	//  	// Instead of calling WriteConsoleW we use WriteFile which   	// handles large buffers correctly. Because WriteFile does not  	// handle the codepage conversion as WriteConsoleW does we   	// need to use a System.IO.StreamWriter with the appropriate  	// Encoding. The WriteFile calls are wrapped up in the  	// System.IO.__ConsoleStream internal class obtained through  	// the System.Console.OpenStandardOutput method.  	//  	// See the ActivateOptions method below for the code that  	// retrieves and wraps the stream.  	// The windows console uses ScrollConsoleScreenBuffer internally to  	// scroll the console buffer when the display buffer of the console  	// has been used up. ScrollConsoleScreenBuffer fills the area uncovered  	// by moving the current content with the background color   	// currently specified on the console. This means that it fills the  	// whole line in front of the cursor position with the current   	// background color.  	// This causes an issue when writing out text with a non default  	// background color. For example; We write a message with a Blue  	// background color and the scrollable area of the console is full.  	// When we write the newline at the end of the message the console  	// needs to scroll the buffer to make space available for the new line.  	// The ScrollConsoleScreenBuffer internals will fill the newly created  	// space with the current background color: Blue.  	// We then change the console color back to default (White text on a  	// Black background). We write some text to the console' the text is  	// written correctly in White with a Black background' however the  	// remainder of the line still has a Blue background.  	//   	// This causes a disjointed appearance to the output where the background  	// colors change.  	//  	// This can be remedied by restoring the console colors before causing  	// the buffer to scroll' i.e. before writing the last newline. This does  	// assume that the rendered message will end with a newline.  	//  	// Therefore we identify a trailing newline in the message and don't  	// write this to the output' then we restore the console color and write  	// a newline. Note that we must AutoFlush before we restore the console  	// color otherwise we will have no effect.  	//  	// There will still be a slight artefact for the last line of the message  	// will have the background extended to the end of the line' however this  	// is unlikely to cause any user issues.  	//  	// Note that none of the above is visible while the console buffer is scrollable  	// within the console window viewport' the effects only arise when the actual  	// buffer is full and needs to be scrolled.  	char[] messageCharArray = strLoggingMessage.ToCharArray ();  	int arrayLength = messageCharArray.Length;  	bool appendNewline = false;  	// Trim off last newline' if it exists  	if (arrayLength > 1 && messageCharArray [arrayLength - 2] == '\r' && messageCharArray [arrayLength - 1] == '\n') {  		arrayLength -= 2;  		appendNewline = true;  	}  	// Write to the output stream  	m_consoleOutputWriter.Write (messageCharArray' 0' arrayLength);  	// Restore the console back to its previous color scheme  	SetConsoleTextAttribute (consoleHandle' bufferInfo.wAttributes);  	if (appendNewline) {  		// Write the newline' after changing the color scheme  		m_consoleOutputWriter.Write (s_windowsNewline' 0' 2);  	}  }  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (arrayLength > 1 && messageCharArray [arrayLength - 2] == '\r' && messageCharArray [arrayLength - 1] == '\n') {  	arrayLength -= 2;  	appendNewline = true;  }  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (arrayLength > 1 && messageCharArray [arrayLength - 2] == '\r' && messageCharArray [arrayLength - 1] == '\n') {  	arrayLength -= 2;  	appendNewline = true;  }  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: arrayLength -= 2;  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (appendNewline) {  	// Write the newline' after changing the color scheme  	m_consoleOutputWriter.Write (s_windowsNewline' 0' 2);  }  
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: m_consoleOutputWriter.Write (s_windowsNewline' 0' 2);  
Magic Number,log4net.Appender,EventLogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\EventLogAppender.cs,GetMaxEventLogMessageSize,The following statement contains a magic number: if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major >= 6)  	return MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER;  
Magic Number,log4net.Appender,LocalSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\LocalSyslogAppender.cs,GeneratePriority,The following statement contains a magic number: return ((int)facility * 8) + (int)severity;  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: try {  	// Priority  	int priority = GeneratePriority (m_facility' GetSeverity (loggingEvent.Level));  	// Identity  	string identity;  	if (m_identity != null) {  		identity = m_identity.Format (loggingEvent);  	}  	else {  		identity = loggingEvent.Domain;  	}  	// Message. The message goes after the tag/identity  	string message = RenderLoggingEvent (loggingEvent);  	Byte[] buffer;  	int i = 0;  	char c;  	StringBuilder builder = new StringBuilder ();  	while (i < message.Length) {  		// Clear StringBuilder  		builder.Length = 0;  		// Write priority  		builder.Append ('<');  		builder.Append (priority);  		builder.Append ('>');  		// Write identity  		builder.Append (identity);  		builder.Append (": ");  		for (; i < message.Length; i++) {  			c = message [i];  			// Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3  			if (((int)c >= 32) && ((int)c <= 126)) {  				builder.Append (c);  			}  			// If character is newline' break and send the current line  			else if ((c == '\r') || (c == '\n')) {  				// Check the next character to handle \r\n or \n\r  				if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  					i++;  				}  				i++;  				break;  			}  		}  		// Grab as a byte array  		buffer = this.Encoding.GetBytes (builder.ToString ());  		this.Client.Send (buffer' buffer.Length' this.RemoteEndPoint);  	}  }  catch (Exception e) {  	ErrorHandler.Error ("Unable to send logging event to remote syslog " + this.RemoteAddress.ToString () + " on port " + this.RemotePort + "."' e' ErrorCode.WriteFailure);  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: try {  	// Priority  	int priority = GeneratePriority (m_facility' GetSeverity (loggingEvent.Level));  	// Identity  	string identity;  	if (m_identity != null) {  		identity = m_identity.Format (loggingEvent);  	}  	else {  		identity = loggingEvent.Domain;  	}  	// Message. The message goes after the tag/identity  	string message = RenderLoggingEvent (loggingEvent);  	Byte[] buffer;  	int i = 0;  	char c;  	StringBuilder builder = new StringBuilder ();  	while (i < message.Length) {  		// Clear StringBuilder  		builder.Length = 0;  		// Write priority  		builder.Append ('<');  		builder.Append (priority);  		builder.Append ('>');  		// Write identity  		builder.Append (identity);  		builder.Append (": ");  		for (; i < message.Length; i++) {  			c = message [i];  			// Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3  			if (((int)c >= 32) && ((int)c <= 126)) {  				builder.Append (c);  			}  			// If character is newline' break and send the current line  			else if ((c == '\r') || (c == '\n')) {  				// Check the next character to handle \r\n or \n\r  				if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  					i++;  				}  				i++;  				break;  			}  		}  		// Grab as a byte array  		buffer = this.Encoding.GetBytes (builder.ToString ());  		this.Client.Send (buffer' buffer.Length' this.RemoteEndPoint);  	}  }  catch (Exception e) {  	ErrorHandler.Error ("Unable to send logging event to remote syslog " + this.RemoteAddress.ToString () + " on port " + this.RemotePort + "."' e' ErrorCode.WriteFailure);  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: while (i < message.Length) {  	// Clear StringBuilder  	builder.Length = 0;  	// Write priority  	builder.Append ('<');  	builder.Append (priority);  	builder.Append ('>');  	// Write identity  	builder.Append (identity);  	builder.Append (": ");  	for (; i < message.Length; i++) {  		c = message [i];  		// Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3  		if (((int)c >= 32) && ((int)c <= 126)) {  			builder.Append (c);  		}  		// If character is newline' break and send the current line  		else if ((c == '\r') || (c == '\n')) {  			// Check the next character to handle \r\n or \n\r  			if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  				i++;  			}  			i++;  			break;  		}  	}  	// Grab as a byte array  	buffer = this.Encoding.GetBytes (builder.ToString ());  	this.Client.Send (buffer' buffer.Length' this.RemoteEndPoint);  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: while (i < message.Length) {  	// Clear StringBuilder  	builder.Length = 0;  	// Write priority  	builder.Append ('<');  	builder.Append (priority);  	builder.Append ('>');  	// Write identity  	builder.Append (identity);  	builder.Append (": ");  	for (; i < message.Length; i++) {  		c = message [i];  		// Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3  		if (((int)c >= 32) && ((int)c <= 126)) {  			builder.Append (c);  		}  		// If character is newline' break and send the current line  		else if ((c == '\r') || (c == '\n')) {  			// Check the next character to handle \r\n or \n\r  			if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  				i++;  			}  			i++;  			break;  		}  	}  	// Grab as a byte array  	buffer = this.Encoding.GetBytes (builder.ToString ());  	this.Client.Send (buffer' buffer.Length' this.RemoteEndPoint);  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: for (; i < message.Length; i++) {  	c = message [i];  	// Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3  	if (((int)c >= 32) && ((int)c <= 126)) {  		builder.Append (c);  	}  	// If character is newline' break and send the current line  	else if ((c == '\r') || (c == '\n')) {  		// Check the next character to handle \r\n or \n\r  		if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  			i++;  		}  		i++;  		break;  	}  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: for (; i < message.Length; i++) {  	c = message [i];  	// Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3  	if (((int)c >= 32) && ((int)c <= 126)) {  		builder.Append (c);  	}  	// If character is newline' break and send the current line  	else if ((c == '\r') || (c == '\n')) {  		// Check the next character to handle \r\n or \n\r  		if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  			i++;  		}  		i++;  		break;  	}  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: if (((int)c >= 32) && ((int)c <= 126)) {  	builder.Append (c);  }  // If character is newline' break and send the current line  else if ((c == '\r') || (c == '\n')) {  	// Check the next character to handle \r\n or \n\r  	if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  		i++;  	}  	i++;  	break;  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,Append,The following statement contains a magic number: if (((int)c >= 32) && ((int)c <= 126)) {  	builder.Append (c);  }  // If character is newline' break and send the current line  else if ((c == '\r') || (c == '\n')) {  	// Check the next character to handle \r\n or \n\r  	if ((message.Length > i + 1) && ((message [i + 1] == '\r') || (message [i + 1] == '\n'))) {  		i++;  	}  	i++;  	break;  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,GeneratePriority,The following statement contains a magic number: unchecked {  	return ((int)facility * 8) + (int)severity;  }  
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemoteSyslogAppender.cs,GeneratePriority,The following statement contains a magic number: return ((int)facility * 8) + (int)severity;  
Magic Number,log4net.Appender,RemotingAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemotingAppender.cs,OnClose,The following statement contains a magic number: if (!m_workQueueEmptyEvent.WaitOne (30 * 1000' false)) {  	ErrorHandler.Error ("RemotingAppender [" + Name + "] failed to send all queued events before close' in OnClose.");  }  
Magic Number,log4net.Appender,RemotingAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RemotingAppender.cs,OnClose,The following statement contains a magic number: if (!m_workQueueEmptyEvent.WaitOne (30 * 1000' false)) {  	ErrorHandler.Error ("RemotingAppender [" + Name + "] failed to send all queued events before close' in OnClose.");  }  
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: switch (rollPoint) {  case RollPoint.TopOfMinute:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (1);  	break;  case RollPoint.TopOfHour:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (1);  	break;  case RollPoint.HalfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	if (current.Hour < 12) {  		current = current.AddHours (12 - current.Hour);  	}  	else {  		current = current.AddHours (-current.Hour);  		current = current.AddDays (1);  	}  	break;  case RollPoint.TopOfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1);  	break;  case RollPoint.TopOfWeek:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (7 - (int)current.DayOfWeek);  	break;  case RollPoint.TopOfMonth:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1 - current.Day);  	/* first day of month is 1 not 0 */current = current.AddMonths (1);  	break;  }  
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: switch (rollPoint) {  case RollPoint.TopOfMinute:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (1);  	break;  case RollPoint.TopOfHour:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (1);  	break;  case RollPoint.HalfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	if (current.Hour < 12) {  		current = current.AddHours (12 - current.Hour);  	}  	else {  		current = current.AddHours (-current.Hour);  		current = current.AddDays (1);  	}  	break;  case RollPoint.TopOfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1);  	break;  case RollPoint.TopOfWeek:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (7 - (int)current.DayOfWeek);  	break;  case RollPoint.TopOfMonth:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1 - current.Day);  	/* first day of month is 1 not 0 */current = current.AddMonths (1);  	break;  }  
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: switch (rollPoint) {  case RollPoint.TopOfMinute:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (1);  	break;  case RollPoint.TopOfHour:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (1);  	break;  case RollPoint.HalfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	if (current.Hour < 12) {  		current = current.AddHours (12 - current.Hour);  	}  	else {  		current = current.AddHours (-current.Hour);  		current = current.AddDays (1);  	}  	break;  case RollPoint.TopOfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1);  	break;  case RollPoint.TopOfWeek:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (7 - (int)current.DayOfWeek);  	break;  case RollPoint.TopOfMonth:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1 - current.Day);  	/* first day of month is 1 not 0 */current = current.AddMonths (1);  	break;  }  
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: if (current.Hour < 12) {  	current = current.AddHours (12 - current.Hour);  }  else {  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1);  }  
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: if (current.Hour < 12) {  	current = current.AddHours (12 - current.Hour);  }  else {  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1);  }  
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: current = current.AddHours (12 - current.Hour);  
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: current = current.AddDays (7 - (int)current.DayOfWeek);  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: if (configFile == null) {  	LogLog.Error (declaringType' "Configure called with null 'configFile' parameter");  }  else {  	// Have to use File.Exists() rather than configFile.Exists()  	// because configFile.Exists() caches the value' not what we want.  	if (File.Exists (configFile.FullName)) {  		// Open the file for reading  		FileStream fs = null;  		// Try hard to open the file  		for (int retry = 5; --retry >= 0;) {  			try {  				fs = configFile.Open (FileMode.Open' FileAccess.Read' FileShare.Read);  				break;  			}  			catch (IOException ex) {  				if (retry == 0) {  					LogLog.Error (declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);  					// The stream cannot be valid  					fs = null;  				}  				System.Threading.Thread.Sleep (250);  			}  		}  		if (fs != null) {  			try {  				// Load the configuration from the stream  				InternalConfigure (repository' fs);  			}  			finally {  				// Force the file closed whatever happens  				fs.Close ();  			}  		}  	}  	else {  		LogLog.Debug (declaringType' "config file [" + configFile.FullName + "] not found. Configuration unchanged.");  	}  }  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: if (configFile == null) {  	LogLog.Error (declaringType' "Configure called with null 'configFile' parameter");  }  else {  	// Have to use File.Exists() rather than configFile.Exists()  	// because configFile.Exists() caches the value' not what we want.  	if (File.Exists (configFile.FullName)) {  		// Open the file for reading  		FileStream fs = null;  		// Try hard to open the file  		for (int retry = 5; --retry >= 0;) {  			try {  				fs = configFile.Open (FileMode.Open' FileAccess.Read' FileShare.Read);  				break;  			}  			catch (IOException ex) {  				if (retry == 0) {  					LogLog.Error (declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);  					// The stream cannot be valid  					fs = null;  				}  				System.Threading.Thread.Sleep (250);  			}  		}  		if (fs != null) {  			try {  				// Load the configuration from the stream  				InternalConfigure (repository' fs);  			}  			finally {  				// Force the file closed whatever happens  				fs.Close ();  			}  		}  	}  	else {  		LogLog.Debug (declaringType' "config file [" + configFile.FullName + "] not found. Configuration unchanged.");  	}  }  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: if (File.Exists (configFile.FullName)) {  	// Open the file for reading  	FileStream fs = null;  	// Try hard to open the file  	for (int retry = 5; --retry >= 0;) {  		try {  			fs = configFile.Open (FileMode.Open' FileAccess.Read' FileShare.Read);  			break;  		}  		catch (IOException ex) {  			if (retry == 0) {  				LogLog.Error (declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);  				// The stream cannot be valid  				fs = null;  			}  			System.Threading.Thread.Sleep (250);  		}  	}  	if (fs != null) {  		try {  			// Load the configuration from the stream  			InternalConfigure (repository' fs);  		}  		finally {  			// Force the file closed whatever happens  			fs.Close ();  		}  	}  }  else {  	LogLog.Debug (declaringType' "config file [" + configFile.FullName + "] not found. Configuration unchanged.");  }  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: if (File.Exists (configFile.FullName)) {  	// Open the file for reading  	FileStream fs = null;  	// Try hard to open the file  	for (int retry = 5; --retry >= 0;) {  		try {  			fs = configFile.Open (FileMode.Open' FileAccess.Read' FileShare.Read);  			break;  		}  		catch (IOException ex) {  			if (retry == 0) {  				LogLog.Error (declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);  				// The stream cannot be valid  				fs = null;  			}  			System.Threading.Thread.Sleep (250);  		}  	}  	if (fs != null) {  		try {  			// Load the configuration from the stream  			InternalConfigure (repository' fs);  		}  		finally {  			// Force the file closed whatever happens  			fs.Close ();  		}  	}  }  else {  	LogLog.Debug (declaringType' "config file [" + configFile.FullName + "] not found. Configuration unchanged.");  }  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: for (int retry = 5; --retry >= 0;) {  	try {  		fs = configFile.Open (FileMode.Open' FileAccess.Read' FileShare.Read);  		break;  	}  	catch (IOException ex) {  		if (retry == 0) {  			LogLog.Error (declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);  			// The stream cannot be valid  			fs = null;  		}  		System.Threading.Thread.Sleep (250);  	}  }  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: for (int retry = 5; --retry >= 0;) {  	try {  		fs = configFile.Open (FileMode.Open' FileAccess.Read' FileShare.Read);  		break;  	}  	catch (IOException ex) {  		if (retry == 0) {  			LogLog.Error (declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);  			// The stream cannot be valid  			fs = null;  		}  		System.Threading.Thread.Sleep (250);  	}  }  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: try {  	fs = configFile.Open (FileMode.Open' FileAccess.Read' FileShare.Read);  	break;  }  catch (IOException ex) {  	if (retry == 0) {  		LogLog.Error (declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);  		// The stream cannot be valid  		fs = null;  	}  	System.Threading.Thread.Sleep (250);  }  
Magic Number,log4net.Config,XmlConfigurator,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: System.Threading.Thread.Sleep (250);  
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (hour < 10) {  	buffer.Append ('0');  }  
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (mins < 10) {  	buffer.Append ('0');  }  
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (secs < 10) {  	buffer.Append ('0');  }  
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDate,The following statement contains a magic number: lock (s_lastTimeStrings) {  	// Calculate the current time precise only to the second  	long currentTimeToTheSecond = (dateToFormat.Ticks - (dateToFormat.Ticks % TimeSpan.TicksPerSecond));  	string timeString = null;  	// Compare this time with the stored last time  	// If we are in the same second then append  	// the previously calculated time string  	if (s_lastTimeToTheSecond != currentTimeToTheSecond) {  		s_lastTimeStrings.Clear ();  	}  	else {  		timeString = (string)s_lastTimeStrings [GetType ()];  	}  	if (timeString == null) {  		// lock so that only one thread can use the buffer and  		// update the s_lastTimeToTheSecond and s_lastTimeStrings  		// PERF: Try removing this lock and using a new StringBuilder each time  		lock (s_lastTimeBuf) {  			timeString = (string)s_lastTimeStrings [GetType ()];  			if (timeString == null) {  				// We are in a new second.  				s_lastTimeBuf.Length = 0;  				// Calculate the new string for this second  				FormatDateWithoutMillis (dateToFormat' s_lastTimeBuf);  				// Render the string buffer to a string  				timeString = s_lastTimeBuf.ToString ();  				#if NET_1_1  										// Ensure that the above string is written into the variable NOW on all threads. 						// This is only required on multiprocessor machines with weak memeory models 						System.Threading.Thread.MemoryBarrier(); #endif  				// Store the time as a string (we only have to do this once per second)  				s_lastTimeStrings [GetType ()] = timeString;  				s_lastTimeToTheSecond = currentTimeToTheSecond;  			}  		}  	}  	writer.Write (timeString);  	// Append the current millisecond info  	writer.Write (''');  	int millis = dateToFormat.Millisecond;  	if (millis < 100) {  		writer.Write ('0');  	}  	if (millis < 10) {  		writer.Write ('0');  	}  	writer.Write (millis);  }  
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDate,The following statement contains a magic number: lock (s_lastTimeStrings) {  	// Calculate the current time precise only to the second  	long currentTimeToTheSecond = (dateToFormat.Ticks - (dateToFormat.Ticks % TimeSpan.TicksPerSecond));  	string timeString = null;  	// Compare this time with the stored last time  	// If we are in the same second then append  	// the previously calculated time string  	if (s_lastTimeToTheSecond != currentTimeToTheSecond) {  		s_lastTimeStrings.Clear ();  	}  	else {  		timeString = (string)s_lastTimeStrings [GetType ()];  	}  	if (timeString == null) {  		// lock so that only one thread can use the buffer and  		// update the s_lastTimeToTheSecond and s_lastTimeStrings  		// PERF: Try removing this lock and using a new StringBuilder each time  		lock (s_lastTimeBuf) {  			timeString = (string)s_lastTimeStrings [GetType ()];  			if (timeString == null) {  				// We are in a new second.  				s_lastTimeBuf.Length = 0;  				// Calculate the new string for this second  				FormatDateWithoutMillis (dateToFormat' s_lastTimeBuf);  				// Render the string buffer to a string  				timeString = s_lastTimeBuf.ToString ();  				#if NET_1_1  										// Ensure that the above string is written into the variable NOW on all threads. 						// This is only required on multiprocessor machines with weak memeory models 						System.Threading.Thread.MemoryBarrier(); #endif  				// Store the time as a string (we only have to do this once per second)  				s_lastTimeStrings [GetType ()] = timeString;  				s_lastTimeToTheSecond = currentTimeToTheSecond;  			}  		}  	}  	writer.Write (timeString);  	// Append the current millisecond info  	writer.Write (''');  	int millis = dateToFormat.Millisecond;  	if (millis < 100) {  		writer.Write ('0');  	}  	if (millis < 10) {  		writer.Write ('0');  	}  	writer.Write (millis);  }  
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDate,The following statement contains a magic number: if (millis < 100) {  	writer.Write ('0');  }  
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDate,The following statement contains a magic number: if (millis < 10) {  	writer.Write ('0');  }  
Magic Number,log4net.DateFormatter,DateTimeDateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\DateTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (day < 10) {  	buffer.Append ('0');  }  
Magic Number,log4net.DateFormatter,Iso8601DateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\Iso8601DateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (month < 10) {  	buffer.Append ('0');  }  
Magic Number,log4net.DateFormatter,Iso8601DateFormatter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\DateFormatter\Iso8601DateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (day < 10) {  	buffer.Append ('0');  }  
Magic Number,log4net.Layout,PatternLayout,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\PatternLayout.cs,PatternLayout,The following statement contains a magic number: s_globalRulesRegistry = new Hashtable (45);  
Magic Number,log4net.Layout.Pattern,NamedPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\NamedPatternConverter.cs,Convert,The following statement contains a magic number: if (m_precision <= 0 || name == null || name.Length < 2) {  	writer.Write (name);  }  else {  	int len = name.Length;  	string trailingDot = string.Empty;  	if (name.EndsWith (DOT)) {  		trailingDot = DOT;  		name = name.Substring (0' len - 1);  		len--;  	}  	int end = name.LastIndexOf (DOT);  	for (int i = 1; end > 0 && i < m_precision; i++) {  		end = name.LastIndexOf ('.'' end - 1);  	}  	if (end == -1) {  		writer.Write (name + trailingDot);  	}  	else {  		writer.Write (name.Substring (end + 1' len - end - 1) + trailingDot);  	}  }  
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: try {  	string param = "";  	string[] names = method.Parameters;  	StringBuilder sb = new StringBuilder ();  	if (names != null && names.GetUpperBound (0) > 0) {  		for (int i = 0; i <= names.GetUpperBound (0); i++) {  			sb.AppendFormat ("{0}' "' names [i]);  		}  	}  	if (sb.Length > 0) {  		sb.Remove (sb.Length - 2' 2);  		param = sb.ToString ();  	}  	returnValue = base.GetMethodInformation (method) + "(" + param + ")";  }  catch (Exception ex) {  	LogLog.Error (declaringType' "An exception ocurred while retreiving method information."' ex);  }  
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: try {  	string param = "";  	string[] names = method.Parameters;  	StringBuilder sb = new StringBuilder ();  	if (names != null && names.GetUpperBound (0) > 0) {  		for (int i = 0; i <= names.GetUpperBound (0); i++) {  			sb.AppendFormat ("{0}' "' names [i]);  		}  	}  	if (sb.Length > 0) {  		sb.Remove (sb.Length - 2' 2);  		param = sb.ToString ();  	}  	returnValue = base.GetMethodInformation (method) + "(" + param + ")";  }  catch (Exception ex) {  	LogLog.Error (declaringType' "An exception ocurred while retreiving method information."' ex);  }  
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: if (sb.Length > 0) {  	sb.Remove (sb.Length - 2' 2);  	param = sb.ToString ();  }  
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: if (sb.Length > 0) {  	sb.Remove (sb.Length - 2' 2);  	param = sb.ToString ();  }  
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,log4net.Util,NativeError,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\NativeError.cs,GetErrorMessage,The following statement contains a magic number: if (messageId != 0) {  	// If the function succeeds' the return value is the number of TCHARs stored in the output buffer' excluding the terminating null character  	int messageSize = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS' ref sourcePtr' messageId' 0' ref msgBuf' 255' argumentsPtr);  	if (messageSize > 0) {  		// Remove trailing null-terminating characters (\r\n) from the message  		msgBuf = msgBuf.TrimEnd (new char[] {  			'\r''  			'\n'  		});  	}  	else {  		// A message could not be located.  		msgBuf = null;  	}  }  else {  	msgBuf = null;  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("KB")) != -1) {  	multiplier = 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("KB")) != -1) {  	multiplier = 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("KB")) != -1) {  	multiplier = 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("KB")) != -1) {  	multiplier = 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("KB")) != -1) {  	multiplier = 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("KB")) != -1) {  	multiplier = 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: multiplier = 1024;  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("MB")) != -1) {  	multiplier = 1024 * 1024;  	s = s.Substring (0' index);  }  else if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: multiplier = 1024 * 1024;  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: multiplier = 1024 * 1024;  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf ("GB")) != -1) {  	multiplier = 1024 * 1024 * 1024;  	s = s.Substring (0' index);  }  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: multiplier = 1024 * 1024 * 1024;  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: multiplier = 1024 * 1024 * 1024;  
Magic Number,log4net.Util,OptionConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: multiplier = 1024 * 1024 * 1024;  
Magic Number,log4net.Util,PatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: while (length >= 32) {  	writer.Write (SPACES [5]);  	length -= 32;  }  
Magic Number,log4net.Util,PatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: while (length >= 32) {  	writer.Write (SPACES [5]);  	length -= 32;  }  
Magic Number,log4net.Util,PatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: while (length >= 32) {  	writer.Write (SPACES [5]);  	length -= 32;  }  
Magic Number,log4net.Util,PatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: writer.Write (SPACES [5]);  
Magic Number,log4net.Util,PatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: length -= 32;  
Magic Number,log4net.Util,PatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: for (int i = 4; i >= 0; i--) {  	if ((length & (1 << i)) != 0) {  		writer.Write (SPACES [i]);  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while (offset < pattern.Length) {  	int i = pattern.IndexOf ('%'' offset);  	if (i < 0 || i == pattern.Length - 1) {  		ProcessLiteral (pattern.Substring (offset));  		offset = pattern.Length;  	}  	else {  		if (pattern [i + 1] == '%') {  			// Escaped  			ProcessLiteral (pattern.Substring (offset' i - offset + 1));  			offset = i + 2;  		}  		else {  			ProcessLiteral (pattern.Substring (offset' i - offset));  			offset = i + 1;  			FormattingInfo formattingInfo = new FormattingInfo ();  			// Process formatting options  			// Look for the align flag  			if (offset < pattern.Length) {  				if (pattern [offset] == '-') {  					// Seen align flag  					formattingInfo.LeftAlign = true;  					offset++;  				}  			}  			// Look for the minimum length  			while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  				// Seen digit  				if (formattingInfo.Min < 0) {  					formattingInfo.Min = 0;  				}  				formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  				offset++;  			}  			// Look for the separator between min and max  			if (offset < pattern.Length) {  				if (pattern [offset] == '.') {  					// Seen separator  					offset++;  				}  			}  			// Look for the maximum length  			while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  				// Seen digit  				if (formattingInfo.Max == int.MaxValue) {  					formattingInfo.Max = 0;  				}  				formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  				offset++;  			}  			int remainingStringLength = pattern.Length - offset;  			// Look for pattern  			for (int m = 0; m < matches.Length; m++) {  				if (matches [m].Length <= remainingStringLength) {  					if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  						// Found match  						offset = offset + matches [m].Length;  						string option = null;  						// Look for option  						if (offset < pattern.Length) {  							if (pattern [offset] == '{') {  								// Seen option start  								offset++;  								int optEnd = pattern.IndexOf ('}'' offset);  								if (optEnd < 0) {  									// error  								}  								else {  									option = pattern.Substring (offset' optEnd - offset);  									offset = optEnd + 1;  								}  							}  						}  						ProcessConverter (matches [m]' option' formattingInfo);  						break;  					}  				}  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while (offset < pattern.Length) {  	int i = pattern.IndexOf ('%'' offset);  	if (i < 0 || i == pattern.Length - 1) {  		ProcessLiteral (pattern.Substring (offset));  		offset = pattern.Length;  	}  	else {  		if (pattern [i + 1] == '%') {  			// Escaped  			ProcessLiteral (pattern.Substring (offset' i - offset + 1));  			offset = i + 2;  		}  		else {  			ProcessLiteral (pattern.Substring (offset' i - offset));  			offset = i + 1;  			FormattingInfo formattingInfo = new FormattingInfo ();  			// Process formatting options  			// Look for the align flag  			if (offset < pattern.Length) {  				if (pattern [offset] == '-') {  					// Seen align flag  					formattingInfo.LeftAlign = true;  					offset++;  				}  			}  			// Look for the minimum length  			while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  				// Seen digit  				if (formattingInfo.Min < 0) {  					formattingInfo.Min = 0;  				}  				formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  				offset++;  			}  			// Look for the separator between min and max  			if (offset < pattern.Length) {  				if (pattern [offset] == '.') {  					// Seen separator  					offset++;  				}  			}  			// Look for the maximum length  			while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  				// Seen digit  				if (formattingInfo.Max == int.MaxValue) {  					formattingInfo.Max = 0;  				}  				formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  				offset++;  			}  			int remainingStringLength = pattern.Length - offset;  			// Look for pattern  			for (int m = 0; m < matches.Length; m++) {  				if (matches [m].Length <= remainingStringLength) {  					if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  						// Found match  						offset = offset + matches [m].Length;  						string option = null;  						// Look for option  						if (offset < pattern.Length) {  							if (pattern [offset] == '{') {  								// Seen option start  								offset++;  								int optEnd = pattern.IndexOf ('}'' offset);  								if (optEnd < 0) {  									// error  								}  								else {  									option = pattern.Substring (offset' optEnd - offset);  									offset = optEnd + 1;  								}  							}  						}  						ProcessConverter (matches [m]' option' formattingInfo);  						break;  					}  				}  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while (offset < pattern.Length) {  	int i = pattern.IndexOf ('%'' offset);  	if (i < 0 || i == pattern.Length - 1) {  		ProcessLiteral (pattern.Substring (offset));  		offset = pattern.Length;  	}  	else {  		if (pattern [i + 1] == '%') {  			// Escaped  			ProcessLiteral (pattern.Substring (offset' i - offset + 1));  			offset = i + 2;  		}  		else {  			ProcessLiteral (pattern.Substring (offset' i - offset));  			offset = i + 1;  			FormattingInfo formattingInfo = new FormattingInfo ();  			// Process formatting options  			// Look for the align flag  			if (offset < pattern.Length) {  				if (pattern [offset] == '-') {  					// Seen align flag  					formattingInfo.LeftAlign = true;  					offset++;  				}  			}  			// Look for the minimum length  			while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  				// Seen digit  				if (formattingInfo.Min < 0) {  					formattingInfo.Min = 0;  				}  				formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  				offset++;  			}  			// Look for the separator between min and max  			if (offset < pattern.Length) {  				if (pattern [offset] == '.') {  					// Seen separator  					offset++;  				}  			}  			// Look for the maximum length  			while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  				// Seen digit  				if (formattingInfo.Max == int.MaxValue) {  					formattingInfo.Max = 0;  				}  				formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  				offset++;  			}  			int remainingStringLength = pattern.Length - offset;  			// Look for pattern  			for (int m = 0; m < matches.Length; m++) {  				if (matches [m].Length <= remainingStringLength) {  					if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  						// Found match  						offset = offset + matches [m].Length;  						string option = null;  						// Look for option  						if (offset < pattern.Length) {  							if (pattern [offset] == '{') {  								// Seen option start  								offset++;  								int optEnd = pattern.IndexOf ('}'' offset);  								if (optEnd < 0) {  									// error  								}  								else {  									option = pattern.Substring (offset' optEnd - offset);  									offset = optEnd + 1;  								}  							}  						}  						ProcessConverter (matches [m]' option' formattingInfo);  						break;  					}  				}  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: if (i < 0 || i == pattern.Length - 1) {  	ProcessLiteral (pattern.Substring (offset));  	offset = pattern.Length;  }  else {  	if (pattern [i + 1] == '%') {  		// Escaped  		ProcessLiteral (pattern.Substring (offset' i - offset + 1));  		offset = i + 2;  	}  	else {  		ProcessLiteral (pattern.Substring (offset' i - offset));  		offset = i + 1;  		FormattingInfo formattingInfo = new FormattingInfo ();  		// Process formatting options  		// Look for the align flag  		if (offset < pattern.Length) {  			if (pattern [offset] == '-') {  				// Seen align flag  				formattingInfo.LeftAlign = true;  				offset++;  			}  		}  		// Look for the minimum length  		while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  			// Seen digit  			if (formattingInfo.Min < 0) {  				formattingInfo.Min = 0;  			}  			formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  			offset++;  		}  		// Look for the separator between min and max  		if (offset < pattern.Length) {  			if (pattern [offset] == '.') {  				// Seen separator  				offset++;  			}  		}  		// Look for the maximum length  		while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  			// Seen digit  			if (formattingInfo.Max == int.MaxValue) {  				formattingInfo.Max = 0;  			}  			formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  			offset++;  		}  		int remainingStringLength = pattern.Length - offset;  		// Look for pattern  		for (int m = 0; m < matches.Length; m++) {  			if (matches [m].Length <= remainingStringLength) {  				if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  					// Found match  					offset = offset + matches [m].Length;  					string option = null;  					// Look for option  					if (offset < pattern.Length) {  						if (pattern [offset] == '{') {  							// Seen option start  							offset++;  							int optEnd = pattern.IndexOf ('}'' offset);  							if (optEnd < 0) {  								// error  							}  							else {  								option = pattern.Substring (offset' optEnd - offset);  								offset = optEnd + 1;  							}  						}  					}  					ProcessConverter (matches [m]' option' formattingInfo);  					break;  				}  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: if (i < 0 || i == pattern.Length - 1) {  	ProcessLiteral (pattern.Substring (offset));  	offset = pattern.Length;  }  else {  	if (pattern [i + 1] == '%') {  		// Escaped  		ProcessLiteral (pattern.Substring (offset' i - offset + 1));  		offset = i + 2;  	}  	else {  		ProcessLiteral (pattern.Substring (offset' i - offset));  		offset = i + 1;  		FormattingInfo formattingInfo = new FormattingInfo ();  		// Process formatting options  		// Look for the align flag  		if (offset < pattern.Length) {  			if (pattern [offset] == '-') {  				// Seen align flag  				formattingInfo.LeftAlign = true;  				offset++;  			}  		}  		// Look for the minimum length  		while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  			// Seen digit  			if (formattingInfo.Min < 0) {  				formattingInfo.Min = 0;  			}  			formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  			offset++;  		}  		// Look for the separator between min and max  		if (offset < pattern.Length) {  			if (pattern [offset] == '.') {  				// Seen separator  				offset++;  			}  		}  		// Look for the maximum length  		while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  			// Seen digit  			if (formattingInfo.Max == int.MaxValue) {  				formattingInfo.Max = 0;  			}  			formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  			offset++;  		}  		int remainingStringLength = pattern.Length - offset;  		// Look for pattern  		for (int m = 0; m < matches.Length; m++) {  			if (matches [m].Length <= remainingStringLength) {  				if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  					// Found match  					offset = offset + matches [m].Length;  					string option = null;  					// Look for option  					if (offset < pattern.Length) {  						if (pattern [offset] == '{') {  							// Seen option start  							offset++;  							int optEnd = pattern.IndexOf ('}'' offset);  							if (optEnd < 0) {  								// error  							}  							else {  								option = pattern.Substring (offset' optEnd - offset);  								offset = optEnd + 1;  							}  						}  					}  					ProcessConverter (matches [m]' option' formattingInfo);  					break;  				}  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: if (i < 0 || i == pattern.Length - 1) {  	ProcessLiteral (pattern.Substring (offset));  	offset = pattern.Length;  }  else {  	if (pattern [i + 1] == '%') {  		// Escaped  		ProcessLiteral (pattern.Substring (offset' i - offset + 1));  		offset = i + 2;  	}  	else {  		ProcessLiteral (pattern.Substring (offset' i - offset));  		offset = i + 1;  		FormattingInfo formattingInfo = new FormattingInfo ();  		// Process formatting options  		// Look for the align flag  		if (offset < pattern.Length) {  			if (pattern [offset] == '-') {  				// Seen align flag  				formattingInfo.LeftAlign = true;  				offset++;  			}  		}  		// Look for the minimum length  		while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  			// Seen digit  			if (formattingInfo.Min < 0) {  				formattingInfo.Min = 0;  			}  			formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  			offset++;  		}  		// Look for the separator between min and max  		if (offset < pattern.Length) {  			if (pattern [offset] == '.') {  				// Seen separator  				offset++;  			}  		}  		// Look for the maximum length  		while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  			// Seen digit  			if (formattingInfo.Max == int.MaxValue) {  				formattingInfo.Max = 0;  			}  			formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  			offset++;  		}  		int remainingStringLength = pattern.Length - offset;  		// Look for pattern  		for (int m = 0; m < matches.Length; m++) {  			if (matches [m].Length <= remainingStringLength) {  				if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  					// Found match  					offset = offset + matches [m].Length;  					string option = null;  					// Look for option  					if (offset < pattern.Length) {  						if (pattern [offset] == '{') {  							// Seen option start  							offset++;  							int optEnd = pattern.IndexOf ('}'' offset);  							if (optEnd < 0) {  								// error  							}  							else {  								option = pattern.Substring (offset' optEnd - offset);  								offset = optEnd + 1;  							}  						}  					}  					ProcessConverter (matches [m]' option' formattingInfo);  					break;  				}  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: if (pattern [i + 1] == '%') {  	// Escaped  	ProcessLiteral (pattern.Substring (offset' i - offset + 1));  	offset = i + 2;  }  else {  	ProcessLiteral (pattern.Substring (offset' i - offset));  	offset = i + 1;  	FormattingInfo formattingInfo = new FormattingInfo ();  	// Process formatting options  	// Look for the align flag  	if (offset < pattern.Length) {  		if (pattern [offset] == '-') {  			// Seen align flag  			formattingInfo.LeftAlign = true;  			offset++;  		}  	}  	// Look for the minimum length  	while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  		// Seen digit  		if (formattingInfo.Min < 0) {  			formattingInfo.Min = 0;  		}  		formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  		offset++;  	}  	// Look for the separator between min and max  	if (offset < pattern.Length) {  		if (pattern [offset] == '.') {  			// Seen separator  			offset++;  		}  	}  	// Look for the maximum length  	while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  		// Seen digit  		if (formattingInfo.Max == int.MaxValue) {  			formattingInfo.Max = 0;  		}  		formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  		offset++;  	}  	int remainingStringLength = pattern.Length - offset;  	// Look for pattern  	for (int m = 0; m < matches.Length; m++) {  		if (matches [m].Length <= remainingStringLength) {  			if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  				// Found match  				offset = offset + matches [m].Length;  				string option = null;  				// Look for option  				if (offset < pattern.Length) {  					if (pattern [offset] == '{') {  						// Seen option start  						offset++;  						int optEnd = pattern.IndexOf ('}'' offset);  						if (optEnd < 0) {  							// error  						}  						else {  							option = pattern.Substring (offset' optEnd - offset);  							offset = optEnd + 1;  						}  					}  				}  				ProcessConverter (matches [m]' option' formattingInfo);  				break;  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: if (pattern [i + 1] == '%') {  	// Escaped  	ProcessLiteral (pattern.Substring (offset' i - offset + 1));  	offset = i + 2;  }  else {  	ProcessLiteral (pattern.Substring (offset' i - offset));  	offset = i + 1;  	FormattingInfo formattingInfo = new FormattingInfo ();  	// Process formatting options  	// Look for the align flag  	if (offset < pattern.Length) {  		if (pattern [offset] == '-') {  			// Seen align flag  			formattingInfo.LeftAlign = true;  			offset++;  		}  	}  	// Look for the minimum length  	while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  		// Seen digit  		if (formattingInfo.Min < 0) {  			formattingInfo.Min = 0;  		}  		formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  		offset++;  	}  	// Look for the separator between min and max  	if (offset < pattern.Length) {  		if (pattern [offset] == '.') {  			// Seen separator  			offset++;  		}  	}  	// Look for the maximum length  	while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  		// Seen digit  		if (formattingInfo.Max == int.MaxValue) {  			formattingInfo.Max = 0;  		}  		formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  		offset++;  	}  	int remainingStringLength = pattern.Length - offset;  	// Look for pattern  	for (int m = 0; m < matches.Length; m++) {  		if (matches [m].Length <= remainingStringLength) {  			if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  				// Found match  				offset = offset + matches [m].Length;  				string option = null;  				// Look for option  				if (offset < pattern.Length) {  					if (pattern [offset] == '{') {  						// Seen option start  						offset++;  						int optEnd = pattern.IndexOf ('}'' offset);  						if (optEnd < 0) {  							// error  						}  						else {  							option = pattern.Substring (offset' optEnd - offset);  							offset = optEnd + 1;  						}  					}  				}  				ProcessConverter (matches [m]' option' formattingInfo);  				break;  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: if (pattern [i + 1] == '%') {  	// Escaped  	ProcessLiteral (pattern.Substring (offset' i - offset + 1));  	offset = i + 2;  }  else {  	ProcessLiteral (pattern.Substring (offset' i - offset));  	offset = i + 1;  	FormattingInfo formattingInfo = new FormattingInfo ();  	// Process formatting options  	// Look for the align flag  	if (offset < pattern.Length) {  		if (pattern [offset] == '-') {  			// Seen align flag  			formattingInfo.LeftAlign = true;  			offset++;  		}  	}  	// Look for the minimum length  	while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  		// Seen digit  		if (formattingInfo.Min < 0) {  			formattingInfo.Min = 0;  		}  		formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  		offset++;  	}  	// Look for the separator between min and max  	if (offset < pattern.Length) {  		if (pattern [offset] == '.') {  			// Seen separator  			offset++;  		}  	}  	// Look for the maximum length  	while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  		// Seen digit  		if (formattingInfo.Max == int.MaxValue) {  			formattingInfo.Max = 0;  		}  		formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  		offset++;  	}  	int remainingStringLength = pattern.Length - offset;  	// Look for pattern  	for (int m = 0; m < matches.Length; m++) {  		if (matches [m].Length <= remainingStringLength) {  			if (String.Compare (pattern' offset' matches [m]' 0' matches [m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) {  				// Found match  				offset = offset + matches [m].Length;  				string option = null;  				// Look for option  				if (offset < pattern.Length) {  					if (pattern [offset] == '{') {  						// Seen option start  						offset++;  						int optEnd = pattern.IndexOf ('}'' offset);  						if (optEnd < 0) {  							// error  						}  						else {  							option = pattern.Substring (offset' optEnd - offset);  							offset = optEnd + 1;  						}  					}  				}  				ProcessConverter (matches [m]' option' formattingInfo);  				break;  			}  		}  	}  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: offset = i + 2;  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  	// Seen digit  	if (formattingInfo.Min < 0) {  		formattingInfo.Min = 0;  	}  	formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  	offset++;  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while (offset < pattern.Length && char.IsDigit (pattern [offset])) {  	// Seen digit  	if (formattingInfo.Max == int.MaxValue) {  		formattingInfo.Max = 0;  	}  	formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  	offset++;  }  
Magic Number,log4net.Util,PatternParser,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse (pattern [offset].ToString (CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  
Magic Number,log4net.Util,PatternString,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternString.cs,PatternString,The following statement contains a magic number: s_globalRulesRegistry = new Hashtable (15);  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (weightStringEscapes <= weightCData) {  	// Write string using string escapes  	writer.WriteString (stringData);  }  else {  	// Write string using CDATA section  	int end = stringData.IndexOf (CDATA_END);  	if (end < 0) {  		writer.WriteCData (stringData);  	}  	else {  		int start = 0;  		while (end > -1) {  			writer.WriteCData (stringData.Substring (start' end - start));  			if (end == stringData.Length - 3) {  				start = stringData.Length;  				writer.WriteString (CDATA_END);  				break;  			}  			else {  				writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  				start = end + 2;  				end = stringData.IndexOf (CDATA_END' start);  			}  		}  		if (start < stringData.Length) {  			writer.WriteCData (stringData.Substring (start));  		}  	}  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (weightStringEscapes <= weightCData) {  	// Write string using string escapes  	writer.WriteString (stringData);  }  else {  	// Write string using CDATA section  	int end = stringData.IndexOf (CDATA_END);  	if (end < 0) {  		writer.WriteCData (stringData);  	}  	else {  		int start = 0;  		while (end > -1) {  			writer.WriteCData (stringData.Substring (start' end - start));  			if (end == stringData.Length - 3) {  				start = stringData.Length;  				writer.WriteString (CDATA_END);  				break;  			}  			else {  				writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  				start = end + 2;  				end = stringData.IndexOf (CDATA_END' start);  			}  		}  		if (start < stringData.Length) {  			writer.WriteCData (stringData.Substring (start));  		}  	}  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (end < 0) {  	writer.WriteCData (stringData);  }  else {  	int start = 0;  	while (end > -1) {  		writer.WriteCData (stringData.Substring (start' end - start));  		if (end == stringData.Length - 3) {  			start = stringData.Length;  			writer.WriteString (CDATA_END);  			break;  		}  		else {  			writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  			start = end + 2;  			end = stringData.IndexOf (CDATA_END' start);  		}  	}  	if (start < stringData.Length) {  		writer.WriteCData (stringData.Substring (start));  	}  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (end < 0) {  	writer.WriteCData (stringData);  }  else {  	int start = 0;  	while (end > -1) {  		writer.WriteCData (stringData.Substring (start' end - start));  		if (end == stringData.Length - 3) {  			start = stringData.Length;  			writer.WriteString (CDATA_END);  			break;  		}  		else {  			writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  			start = end + 2;  			end = stringData.IndexOf (CDATA_END' start);  		}  	}  	if (start < stringData.Length) {  		writer.WriteCData (stringData.Substring (start));  	}  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: while (end > -1) {  	writer.WriteCData (stringData.Substring (start' end - start));  	if (end == stringData.Length - 3) {  		start = stringData.Length;  		writer.WriteString (CDATA_END);  		break;  	}  	else {  		writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  		start = end + 2;  		end = stringData.IndexOf (CDATA_END' start);  	}  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: while (end > -1) {  	writer.WriteCData (stringData.Substring (start' end - start));  	if (end == stringData.Length - 3) {  		start = stringData.Length;  		writer.WriteString (CDATA_END);  		break;  	}  	else {  		writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  		start = end + 2;  		end = stringData.IndexOf (CDATA_END' start);  	}  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (end == stringData.Length - 3) {  	start = stringData.Length;  	writer.WriteString (CDATA_END);  	break;  }  else {  	writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  	start = end + 2;  	end = stringData.IndexOf (CDATA_END' start);  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (end == stringData.Length - 3) {  	start = stringData.Length;  	writer.WriteString (CDATA_END);  	break;  }  else {  	writer.WriteString (CDATA_UNESCAPABLE_TOKEN);  	start = end + 2;  	end = stringData.IndexOf (CDATA_END' start);  }  
Magic Number,log4net.Util,Transform,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: start = end + 2;  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try {  	lock (s_random) {  		for (int i = 0; i < m_length; i++) {  			int randValue = s_random.Next (36);  			if (randValue < 26) {  				// Letter  				char ch = (char)('A' + randValue);  				writer.Write (ch);  			}  			else if (randValue < 36) {  				// Number  				char ch = (char)('0' + (randValue - 26));  				writer.Write (ch);  			}  			else {  				// Should not get here  				writer.Write ('X');  			}  		}  	}  }  catch (Exception ex) {  	LogLog.Error (declaringType' "Error occurred while converting."' ex);  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try {  	lock (s_random) {  		for (int i = 0; i < m_length; i++) {  			int randValue = s_random.Next (36);  			if (randValue < 26) {  				// Letter  				char ch = (char)('A' + randValue);  				writer.Write (ch);  			}  			else if (randValue < 36) {  				// Number  				char ch = (char)('0' + (randValue - 26));  				writer.Write (ch);  			}  			else {  				// Should not get here  				writer.Write ('X');  			}  		}  	}  }  catch (Exception ex) {  	LogLog.Error (declaringType' "Error occurred while converting."' ex);  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try {  	lock (s_random) {  		for (int i = 0; i < m_length; i++) {  			int randValue = s_random.Next (36);  			if (randValue < 26) {  				// Letter  				char ch = (char)('A' + randValue);  				writer.Write (ch);  			}  			else if (randValue < 36) {  				// Number  				char ch = (char)('0' + (randValue - 26));  				writer.Write (ch);  			}  			else {  				// Should not get here  				writer.Write ('X');  			}  		}  	}  }  catch (Exception ex) {  	LogLog.Error (declaringType' "Error occurred while converting."' ex);  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try {  	lock (s_random) {  		for (int i = 0; i < m_length; i++) {  			int randValue = s_random.Next (36);  			if (randValue < 26) {  				// Letter  				char ch = (char)('A' + randValue);  				writer.Write (ch);  			}  			else if (randValue < 36) {  				// Number  				char ch = (char)('0' + (randValue - 26));  				writer.Write (ch);  			}  			else {  				// Should not get here  				writer.Write ('X');  			}  		}  	}  }  catch (Exception ex) {  	LogLog.Error (declaringType' "Error occurred while converting."' ex);  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: lock (s_random) {  	for (int i = 0; i < m_length; i++) {  		int randValue = s_random.Next (36);  		if (randValue < 26) {  			// Letter  			char ch = (char)('A' + randValue);  			writer.Write (ch);  		}  		else if (randValue < 36) {  			// Number  			char ch = (char)('0' + (randValue - 26));  			writer.Write (ch);  		}  		else {  			// Should not get here  			writer.Write ('X');  		}  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: lock (s_random) {  	for (int i = 0; i < m_length; i++) {  		int randValue = s_random.Next (36);  		if (randValue < 26) {  			// Letter  			char ch = (char)('A' + randValue);  			writer.Write (ch);  		}  		else if (randValue < 36) {  			// Number  			char ch = (char)('0' + (randValue - 26));  			writer.Write (ch);  		}  		else {  			// Should not get here  			writer.Write ('X');  		}  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: lock (s_random) {  	for (int i = 0; i < m_length; i++) {  		int randValue = s_random.Next (36);  		if (randValue < 26) {  			// Letter  			char ch = (char)('A' + randValue);  			writer.Write (ch);  		}  		else if (randValue < 36) {  			// Number  			char ch = (char)('0' + (randValue - 26));  			writer.Write (ch);  		}  		else {  			// Should not get here  			writer.Write ('X');  		}  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: lock (s_random) {  	for (int i = 0; i < m_length; i++) {  		int randValue = s_random.Next (36);  		if (randValue < 26) {  			// Letter  			char ch = (char)('A' + randValue);  			writer.Write (ch);  		}  		else if (randValue < 36) {  			// Number  			char ch = (char)('0' + (randValue - 26));  			writer.Write (ch);  		}  		else {  			// Should not get here  			writer.Write ('X');  		}  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: for (int i = 0; i < m_length; i++) {  	int randValue = s_random.Next (36);  	if (randValue < 26) {  		// Letter  		char ch = (char)('A' + randValue);  		writer.Write (ch);  	}  	else if (randValue < 36) {  		// Number  		char ch = (char)('0' + (randValue - 26));  		writer.Write (ch);  	}  	else {  		// Should not get here  		writer.Write ('X');  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: for (int i = 0; i < m_length; i++) {  	int randValue = s_random.Next (36);  	if (randValue < 26) {  		// Letter  		char ch = (char)('A' + randValue);  		writer.Write (ch);  	}  	else if (randValue < 36) {  		// Number  		char ch = (char)('0' + (randValue - 26));  		writer.Write (ch);  	}  	else {  		// Should not get here  		writer.Write ('X');  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: for (int i = 0; i < m_length; i++) {  	int randValue = s_random.Next (36);  	if (randValue < 26) {  		// Letter  		char ch = (char)('A' + randValue);  		writer.Write (ch);  	}  	else if (randValue < 36) {  		// Number  		char ch = (char)('0' + (randValue - 26));  		writer.Write (ch);  	}  	else {  		// Should not get here  		writer.Write ('X');  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: for (int i = 0; i < m_length; i++) {  	int randValue = s_random.Next (36);  	if (randValue < 26) {  		// Letter  		char ch = (char)('A' + randValue);  		writer.Write (ch);  	}  	else if (randValue < 36) {  		// Number  		char ch = (char)('0' + (randValue - 26));  		writer.Write (ch);  	}  	else {  		// Should not get here  		writer.Write ('X');  	}  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: if (randValue < 26) {  	// Letter  	char ch = (char)('A' + randValue);  	writer.Write (ch);  }  else if (randValue < 36) {  	// Number  	char ch = (char)('0' + (randValue - 26));  	writer.Write (ch);  }  else {  	// Should not get here  	writer.Write ('X');  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: if (randValue < 26) {  	// Letter  	char ch = (char)('A' + randValue);  	writer.Write (ch);  }  else if (randValue < 36) {  	// Number  	char ch = (char)('0' + (randValue - 26));  	writer.Write (ch);  }  else {  	// Should not get here  	writer.Write ('X');  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: if (randValue < 26) {  	// Letter  	char ch = (char)('A' + randValue);  	writer.Write (ch);  }  else if (randValue < 36) {  	// Number  	char ch = (char)('0' + (randValue - 26));  	writer.Write (ch);  }  else {  	// Should not get here  	writer.Write ('X');  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: if (randValue < 36) {  	// Number  	char ch = (char)('0' + (randValue - 26));  	writer.Write (ch);  }  else {  	// Should not get here  	writer.Write ('X');  }  
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: if (randValue < 36) {  	// Number  	char ch = (char)('0' + (randValue - 26));  	writer.Write (ch);  }  else {  	// Should not get here  	writer.Write ('X');  }  
Missing Default,log4net.Appender,AppenderSkeleton,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\AppenderSkeleton.cs,FilterEvent,The following switch statement is missing a default case: switch (f.Decide (loggingEvent)) {  case FilterDecision.Deny:  	return false;  // Return without appending  case FilterDecision.Accept:  	f = null;  	// Break out of the loop  	break;  case FilterDecision.Neutral:  	f = f.Next;  	// Move to next filter  	break;  }  
Missing Default,log4net.Appender,RollingFileAppender,C:\repos\PhantomMatthew_TeahourFm\log4net-1.2.13\src\Appender\RollingFileAppender.cs,NextCheckDate,The following switch statement is missing a default case: switch (rollPoint) {  case RollPoint.TopOfMinute:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (1);  	break;  case RollPoint.TopOfHour:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (1);  	break;  case RollPoint.HalfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	if (current.Hour < 12) {  		current = current.AddHours (12 - current.Hour);  	}  	else {  		current = current.AddHours (-current.Hour);  		current = current.AddDays (1);  	}  	break;  case RollPoint.TopOfDay:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1);  	break;  case RollPoint.TopOfWeek:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (7 - (int)current.DayOfWeek);  	break;  case RollPoint.TopOfMonth:  	current = current.AddMilliseconds (-current.Millisecond);  	current = current.AddSeconds (-current.Second);  	current = current.AddMinutes (-current.Minute);  	current = current.AddHours (-current.Hour);  	current = current.AddDays (1 - current.Day);  	/* first day of month is 1 not 0 */current = current.AddMonths (1);  	break;  }  
