Implementation smell,Namespace,Class,File,Method,Description
Long Method,MetroLog.NetCore.Targets.SQLite,TableQuery<T>,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,CompileExpr,The method has 201 lines of code.
Complex Method,MetroLog.Targets,SQLiteTarget,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLiteTarget.cs,ReadLogEntriesAsync,Cyclomatic complexity of the method is 11
Complex Method,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,CreateTable,Cyclomatic complexity of the method is 9
Complex Method,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,Insert,Cyclomatic complexity of the method is 8
Long Parameter List,MetroLog.NetCore.Targets.SQLite,SQLite3,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,BindText,The method has 5 parameters. Parameters: stmt' index' val' n' free
Long Parameter List,MetroLog.NetCore.Targets.SQLite,SQLite3,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,BindBlob,The method has 5 parameters. Parameters: stmt' index' val' n' free
Long Statement,MetroLog.Targets,SQLiteTarget,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLiteTarget.cs,GetSessionAsync,The length of the statement  "                    header = await conn.Table<SessionHeaderItem>().Where(v => v.SessionGuid == environment.SessionId).FirstOrDefaultAsync(); " is 120.
Long Statement,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,Execute,The length of the statement  "                Debug.WriteLine(string.Format("Finished in {0} ms ({1:0.0} s total)"' _sw.ElapsedMilliseconds' _elapsedMilliseconds / 1000.0)); " is 127.
Long Statement,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,ExecuteScalar,The length of the statement  "                Debug.WriteLine(string.Format("Finished in {0} ms ({1:0.0} s total)"' _sw.ElapsedMilliseconds' _elapsedMilliseconds / 1000.0)); " is 127.
Long Statement,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,DoSavePointExecute,The length of the statement  "            throw new ArgumentException("savePoint is not valid' and should be the result of a call to SaveTransactionPoint."' "savePoint"); " is 128.
Long Statement,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,Update,The length of the statement  "                if (ex.Result == SQLite3.Result.Constraint && SQLite3.ExtendedErrCode(this.Handle) == SQLite3.ExtendedResult.ConstraintNotNull) " is 127.
Long Statement,MetroLog.NetCore.Targets.SQLite,Orm,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,SqlType,The length of the statement  "            if (clrType == typeof(Boolean) || clrType == typeof(Byte) || clrType == typeof(UInt16) || clrType == typeof(SByte) || clrType == typeof(Int16) || clrType == typeof(Int32) || clrType == typeof(UInt32) || clrType == typeof(Int64)) " is 228.
Long Statement,MetroLog.NetCore.Targets.SQLite,PreparedSqlLiteInsertCommand,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,ExecuteNonQuery,The length of the statement  "            else if (r == SQLite3.Result.Constraint && SQLite3.ExtendedErrCode(Connection.Handle) == SQLite3.ExtendedResult.ConstraintNotNull) " is 130.
Long Statement,MetroLog.NetCore.Targets.SQLite,TableQuery<T>,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,CompileExpr,The length of the statement  "                    if (val != null && val is System.Collections.IEnumerable && !(val is string) && !(val is System.Collections.Generic.IEnumerable<byte>)) " is 135.
Complex Conditional,MetroLog.NetCore.Targets.SQLite,Column,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,Column,The conditional expression  "!Indices.Any()                      && !IsPK                      && ((createFlags & CreateFlags.ImplicitIndex) == CreateFlags.ImplicitIndex)                      && Name.EndsWith(Orm.ImplicitIndexSuffix' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,MetroLog.NetCore.Targets.SQLite,Orm,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,SqlType,The conditional expression  "clrType == typeof(Boolean) || clrType == typeof(Byte) || clrType == typeof(UInt16) || clrType == typeof(SByte) || clrType == typeof(Int16) || clrType == typeof(Int32) || clrType == typeof(UInt32) || clrType == typeof(Int64)"  is complex.
Complex Conditional,MetroLog.NetCore.Targets.SQLite,SQLiteCommand,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,BindParameter,The conditional expression  "value is Byte || value is UInt16 || value is SByte || value is Int16"  is complex.
Complex Conditional,MetroLog.NetCore.Targets.SQLite,TableQuery<T>,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,CompileExpr,The conditional expression  "val != null && val is System.Collections.IEnumerable && !(val is string) && !(val is System.Collections.Generic.IEnumerable<byte>)"  is complex.
Empty Catch Block,MetroLog.Targets,SQLiteTarget,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLiteTarget.cs,DoEnsureInitialize,The method has an empty catch block.
Magic Number,MetroLog.Targets,SQLiteTarget,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLiteTarget.cs,SQLiteTarget,The following statement contains a magic number: this.RetainDays = 30;
Magic Number,MetroLog.Targets,SQLiteTarget,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLiteTarget.cs,CheckCleanup,The following statement contains a magic number: if (DateTime.UtcNow > this.NextCleanupUtc && this.RetainDays > 0)              {                  // delete out...                  try                  {                      var threshold = DateTime.UtcNow.AddDays(0 - this.RetainDays);                        // delete...                      var conn = GetConnection();                      await conn.ExecuteAsync("delete from LogEventInfoItem where datetimeutc <= ?"' threshold);                        this.NextCleanupUtc = DateTime.UtcNow.AddHours(12);                  }                  catch (Exception ex)                  {                      InternalLogger.Current.Error("Failed to run cleanup operation."' ex);                  }              }
Magic Number,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,SQLiteConnection,The following statement contains a magic number: BusyTimeout = TimeSpan.FromSeconds(0.1);
Magic Number,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,Execute,The following statement contains a magic number: if (TimeExecution)              {                  _sw.Stop();                  _elapsedMilliseconds += _sw.ElapsedMilliseconds;                  Debug.WriteLine(string.Format("Finished in {0} ms ({1:0.0} s total)"' _sw.ElapsedMilliseconds' _elapsedMilliseconds / 1000.0));              }
Magic Number,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,ExecuteScalar,The following statement contains a magic number: if (TimeExecution)              {                  _sw.Stop();                  _elapsedMilliseconds += _sw.ElapsedMilliseconds;                  Debug.WriteLine(string.Format("Finished in {0} ms ({1:0.0} s total)"' _sw.ElapsedMilliseconds' _elapsedMilliseconds / 1000.0));              }
Magic Number,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,DoSavePointExecute,The following statement contains a magic number: if (firstLen >= 2 && savepoint.Length > firstLen + 1)              {                  int depth;                  if (Int32.TryParse(savepoint.Substring(firstLen + 1)' out depth))                  {                      // TODO: Mild race here' but inescapable without locking almost everywhere.                      if (0 <= depth && depth < _transactionDepth)                      {  #if NETFX_CORE || USE_SQLITEPCL_RAW                          Volatile.Write(ref _transactionDepth' depth);  #elif SILVERLIGHT  						_transactionDepth = depth;  #else                          Thread.VolatileWrite (ref _transactionDepth' depth);  #endif                          Execute(cmd + savepoint);                          return;                      }                  }              }
Magic Number,MetroLog.NetCore.Targets.SQLite,SQLiteCommand,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,BindParameter,The following statement contains a magic number: if (value == null)              {                  SQLite3.BindNull(stmt' index);              }              else {                  if (value is Int32)                  {                      SQLite3.BindInt(stmt' index' (int)value);                  }                  else if (value is String)                  {                      SQLite3.BindText(stmt' index' (string)value' -1' NegativePointer);                  }                  else if (value is Byte || value is UInt16 || value is SByte || value is Int16)                  {                      SQLite3.BindInt(stmt' index' Convert.ToInt32(value));                  }                  else if (value is Boolean)                  {                      SQLite3.BindInt(stmt' index' (bool)value ? 1 : 0);                  }                  else if (value is UInt32 || value is Int64)                  {                      SQLite3.BindInt64(stmt' index' Convert.ToInt64(value));                  }                  else if (value is Single || value is Double || value is Decimal)                  {                      SQLite3.BindDouble(stmt' index' Convert.ToDouble(value));                  }                  else if (value is TimeSpan)                  {                      SQLite3.BindInt64(stmt' index' ((TimeSpan)value).Ticks);                  }                  else if (value is DateTime)                  {                      if (storeDateTimeAsTicks)                      {                          SQLite3.BindInt64(stmt' index' ((DateTime)value).Ticks);                      }                      else {                          SQLite3.BindText(stmt' index' ((DateTime)value).ToString("yyyy-MM-dd HH:mm:ss")' -1' NegativePointer);                      }                  }                  else if (value is DateTimeOffset)                  {                      SQLite3.BindInt64(stmt' index' ((DateTimeOffset)value).UtcTicks);  #if !USE_NEW_REFLECTION_API  				} else if (value.GetType().IsEnum) {  #else                  }                  else if (value.GetType().GetTypeInfo().IsEnum)                  {  #endif                      SQLite3.BindInt(stmt' index' Convert.ToInt32(value));                  }                  else if (value is byte[])                  {                      SQLite3.BindBlob(stmt' index' (byte[])value' ((byte[])value).Length' NegativePointer);                  }                  else if (value is Guid)                  {                      SQLite3.BindText(stmt' index' ((Guid)value).ToString()' 72' NegativePointer);                  }                  else {                      throw new NotSupportedException("Cannot store type: " + value.GetType());                  }              }
Magic Number,MetroLog.NetCore.Targets.SQLite,TableQuery<T>,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,CompileExpr,The following statement contains a magic number: if (expr == null)              {                  throw new NotSupportedException("Expression is NULL");              }              else if (expr is BinaryExpression)              {                  var bin = (BinaryExpression)expr;                    var leftr = CompileExpr(bin.Left' queryArgs);                  var rightr = CompileExpr(bin.Right' queryArgs);                    //If either side is a parameter and is null' then handle the other side specially (for "is null"/"is not null")                  string text;                  if (leftr.CommandText == "?" && leftr.Value == null)                      text = CompileNullBinaryExpression(bin' rightr);                  else if (rightr.CommandText == "?" && rightr.Value == null)                      text = CompileNullBinaryExpression(bin' leftr);                  else                      text = "(" + leftr.CommandText + " " + GetSqlName(bin) + " " + rightr.CommandText + ")";                  return new CompileResult { CommandText = text };              }              else if (expr.NodeType == ExpressionType.Not)              {                  var operandExpr = ((UnaryExpression)expr).Operand;                  var opr = CompileExpr(operandExpr' queryArgs);                  object val = opr.Value;                  if (val is bool)                      val = !((bool)val);                  return new CompileResult                  {                      CommandText = "NOT(" + opr.CommandText + ")"'                      Value = val                  };              }              else if (expr.NodeType == ExpressionType.Call)              {                    var call = (MethodCallExpression)expr;                  var args = new CompileResult[call.Arguments.Count];                  var obj = call.Object != null ? CompileExpr(call.Object' queryArgs) : null;                    for (var i = 0; i < args.Length; i++)                  {                      args[i] = CompileExpr(call.Arguments[i]' queryArgs);                  }                    var sqlCall = "";                    if (call.Method.Name == "Like" && args.Length == 2)                  {                      sqlCall = "(" + args[0].CommandText + " like " + args[1].CommandText + ")";                  }                  else if (call.Method.Name == "Contains" && args.Length == 2)                  {                      sqlCall = "(" + args[1].CommandText + " in " + args[0].CommandText + ")";                  }                  else if (call.Method.Name == "Contains" && args.Length == 1)                  {                      if (call.Object != null && call.Object.Type == typeof(string))                      {                          sqlCall = "(" + obj.CommandText + " like ('%' || " + args[0].CommandText + " || '%'))";                      }                      else {                          sqlCall = "(" + args[0].CommandText + " in " + obj.CommandText + ")";                      }                  }                  else if (call.Method.Name == "StartsWith" && args.Length == 1)                  {                      sqlCall = "(" + obj.CommandText + " like (" + args[0].CommandText + " || '%'))";                  }                  else if (call.Method.Name == "EndsWith" && args.Length == 1)                  {                      sqlCall = "(" + obj.CommandText + " like ('%' || " + args[0].CommandText + "))";                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      sqlCall = "(" + obj.CommandText + " = (" + args[0].CommandText + "))";                  }                  else if (call.Method.Name == "ToLower")                  {                      sqlCall = "(lower(" + obj.CommandText + "))";                  }                  else if (call.Method.Name == "ToUpper")                  {                      sqlCall = "(upper(" + obj.CommandText + "))";                  }                  else {                      sqlCall = call.Method.Name.ToLower() + "(" + string.Join("'"' args.Select(a => a.CommandText).ToArray()) + ")";                  }                  return new CompileResult { CommandText = sqlCall };                }              else if (expr.NodeType == ExpressionType.Constant)              {                  var c = (ConstantExpression)expr;                  queryArgs.Add(c.Value);                  return new CompileResult                  {                      CommandText = "?"'                      Value = c.Value                  };              }              else if (expr.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)expr;                  var ty = u.Type;                  var valr = CompileExpr(u.Operand' queryArgs);                  return new CompileResult                  {                      CommandText = valr.CommandText'                      Value = valr.Value != null ? ConvertTo(valr.Value' ty) : null                  };              }              else if (expr.NodeType == ExpressionType.MemberAccess)              {                  var mem = (MemberExpression)expr;                    if (mem.Expression != null && mem.Expression.NodeType == ExpressionType.Parameter)                  {                      //                      // This is a column of our table' output just the column name                      // Need to translate it if that column name is mapped                      //                      var columnName = Table.FindColumnWithPropertyName(mem.Member.Name).Name;                      return new CompileResult { CommandText = "\"" + columnName + "\"" };                  }                  else {                      object obj = null;                      if (mem.Expression != null)                      {                          var r = CompileExpr(mem.Expression' queryArgs);                          if (r.Value == null)                          {                              throw new NotSupportedException("Member access failed to compile expression");                          }                          if (r.CommandText == "?")                          {                              queryArgs.RemoveAt(queryArgs.Count - 1);                          }                          obj = r.Value;                      }                        //                      // Get the member value                      //                      object val = null;    #if !USE_NEW_REFLECTION_API  					if (mem.Member.MemberType == MemberTypes.Property) {  #else                      if (mem.Member is PropertyInfo)                      {  #endif                          var m = (PropertyInfo)mem.Member;                          val = m.GetValue(obj' null);  #if !USE_NEW_REFLECTION_API  					} else if (mem.Member.MemberType == MemberTypes.Field) {  #else                      }                      else if (mem.Member is FieldInfo)                      {  #endif  #if SILVERLIGHT  						val = Expression.Lambda (expr).Compile ().DynamicInvoke ();  #else                          var m = (FieldInfo)mem.Member;                          val = m.GetValue(obj);  #endif                      }                      else {  #if !USE_NEW_REFLECTION_API  						throw new NotSupportedException ("MemberExpr: " + mem.Member.MemberType);  #else                          throw new NotSupportedException("MemberExpr: " + mem.Member.DeclaringType);  #endif                      }                        //                      // Work special magic for enumerables                      //                      if (val != null && val is System.Collections.IEnumerable && !(val is string) && !(val is System.Collections.Generic.IEnumerable<byte>))                      {                          var sb = new System.Text.StringBuilder();                          sb.Append("(");                          var head = "";                          foreach (var a in (System.Collections.IEnumerable)val)                          {                              queryArgs.Add(a);                              sb.Append(head);                              sb.Append("?");                              head = "'";                          }                          sb.Append(")");                          return new CompileResult                          {                              CommandText = sb.ToString()'                              Value = val                          };                      }                      else {                          queryArgs.Add(val);                          return new CompileResult                          {                              CommandText = "?"'                              Value = val                          };                      }                  }              }
Magic Number,MetroLog.NetCore.Targets.SQLite,TableQuery<T>,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,CompileExpr,The following statement contains a magic number: if (expr == null)              {                  throw new NotSupportedException("Expression is NULL");              }              else if (expr is BinaryExpression)              {                  var bin = (BinaryExpression)expr;                    var leftr = CompileExpr(bin.Left' queryArgs);                  var rightr = CompileExpr(bin.Right' queryArgs);                    //If either side is a parameter and is null' then handle the other side specially (for "is null"/"is not null")                  string text;                  if (leftr.CommandText == "?" && leftr.Value == null)                      text = CompileNullBinaryExpression(bin' rightr);                  else if (rightr.CommandText == "?" && rightr.Value == null)                      text = CompileNullBinaryExpression(bin' leftr);                  else                      text = "(" + leftr.CommandText + " " + GetSqlName(bin) + " " + rightr.CommandText + ")";                  return new CompileResult { CommandText = text };              }              else if (expr.NodeType == ExpressionType.Not)              {                  var operandExpr = ((UnaryExpression)expr).Operand;                  var opr = CompileExpr(operandExpr' queryArgs);                  object val = opr.Value;                  if (val is bool)                      val = !((bool)val);                  return new CompileResult                  {                      CommandText = "NOT(" + opr.CommandText + ")"'                      Value = val                  };              }              else if (expr.NodeType == ExpressionType.Call)              {                    var call = (MethodCallExpression)expr;                  var args = new CompileResult[call.Arguments.Count];                  var obj = call.Object != null ? CompileExpr(call.Object' queryArgs) : null;                    for (var i = 0; i < args.Length; i++)                  {                      args[i] = CompileExpr(call.Arguments[i]' queryArgs);                  }                    var sqlCall = "";                    if (call.Method.Name == "Like" && args.Length == 2)                  {                      sqlCall = "(" + args[0].CommandText + " like " + args[1].CommandText + ")";                  }                  else if (call.Method.Name == "Contains" && args.Length == 2)                  {                      sqlCall = "(" + args[1].CommandText + " in " + args[0].CommandText + ")";                  }                  else if (call.Method.Name == "Contains" && args.Length == 1)                  {                      if (call.Object != null && call.Object.Type == typeof(string))                      {                          sqlCall = "(" + obj.CommandText + " like ('%' || " + args[0].CommandText + " || '%'))";                      }                      else {                          sqlCall = "(" + args[0].CommandText + " in " + obj.CommandText + ")";                      }                  }                  else if (call.Method.Name == "StartsWith" && args.Length == 1)                  {                      sqlCall = "(" + obj.CommandText + " like (" + args[0].CommandText + " || '%'))";                  }                  else if (call.Method.Name == "EndsWith" && args.Length == 1)                  {                      sqlCall = "(" + obj.CommandText + " like ('%' || " + args[0].CommandText + "))";                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      sqlCall = "(" + obj.CommandText + " = (" + args[0].CommandText + "))";                  }                  else if (call.Method.Name == "ToLower")                  {                      sqlCall = "(lower(" + obj.CommandText + "))";                  }                  else if (call.Method.Name == "ToUpper")                  {                      sqlCall = "(upper(" + obj.CommandText + "))";                  }                  else {                      sqlCall = call.Method.Name.ToLower() + "(" + string.Join("'"' args.Select(a => a.CommandText).ToArray()) + ")";                  }                  return new CompileResult { CommandText = sqlCall };                }              else if (expr.NodeType == ExpressionType.Constant)              {                  var c = (ConstantExpression)expr;                  queryArgs.Add(c.Value);                  return new CompileResult                  {                      CommandText = "?"'                      Value = c.Value                  };              }              else if (expr.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)expr;                  var ty = u.Type;                  var valr = CompileExpr(u.Operand' queryArgs);                  return new CompileResult                  {                      CommandText = valr.CommandText'                      Value = valr.Value != null ? ConvertTo(valr.Value' ty) : null                  };              }              else if (expr.NodeType == ExpressionType.MemberAccess)              {                  var mem = (MemberExpression)expr;                    if (mem.Expression != null && mem.Expression.NodeType == ExpressionType.Parameter)                  {                      //                      // This is a column of our table' output just the column name                      // Need to translate it if that column name is mapped                      //                      var columnName = Table.FindColumnWithPropertyName(mem.Member.Name).Name;                      return new CompileResult { CommandText = "\"" + columnName + "\"" };                  }                  else {                      object obj = null;                      if (mem.Expression != null)                      {                          var r = CompileExpr(mem.Expression' queryArgs);                          if (r.Value == null)                          {                              throw new NotSupportedException("Member access failed to compile expression");                          }                          if (r.CommandText == "?")                          {                              queryArgs.RemoveAt(queryArgs.Count - 1);                          }                          obj = r.Value;                      }                        //                      // Get the member value                      //                      object val = null;    #if !USE_NEW_REFLECTION_API  					if (mem.Member.MemberType == MemberTypes.Property) {  #else                      if (mem.Member is PropertyInfo)                      {  #endif                          var m = (PropertyInfo)mem.Member;                          val = m.GetValue(obj' null);  #if !USE_NEW_REFLECTION_API  					} else if (mem.Member.MemberType == MemberTypes.Field) {  #else                      }                      else if (mem.Member is FieldInfo)                      {  #endif  #if SILVERLIGHT  						val = Expression.Lambda (expr).Compile ().DynamicInvoke ();  #else                          var m = (FieldInfo)mem.Member;                          val = m.GetValue(obj);  #endif                      }                      else {  #if !USE_NEW_REFLECTION_API  						throw new NotSupportedException ("MemberExpr: " + mem.Member.MemberType);  #else                          throw new NotSupportedException("MemberExpr: " + mem.Member.DeclaringType);  #endif                      }                        //                      // Work special magic for enumerables                      //                      if (val != null && val is System.Collections.IEnumerable && !(val is string) && !(val is System.Collections.Generic.IEnumerable<byte>))                      {                          var sb = new System.Text.StringBuilder();                          sb.Append("(");                          var head = "";                          foreach (var a in (System.Collections.IEnumerable)val)                          {                              queryArgs.Add(a);                              sb.Append(head);                              sb.Append("?");                              head = "'";                          }                          sb.Append(")");                          return new CompileResult                          {                              CommandText = sb.ToString()'                              Value = val                          };                      }                      else {                          queryArgs.Add(val);                          return new CompileResult                          {                              CommandText = "?"'                              Value = val                          };                      }                  }              }
Missing Default,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,BeginTransaction,The following switch statement is missing a default case: switch (sqlExp.Result)                          {                              case SQLite3.Result.IOError:                              case SQLite3.Result.Full:                              case SQLite3.Result.Busy:                              case SQLite3.Result.NoMem:                              case SQLite3.Result.Interrupt:                                  RollbackTo(null' true);                                  break;                          }
Missing Default,MetroLog.NetCore.Targets.SQLite,SQLiteConnection,C:\repos\mbrit_MetroLog\MetroLog.Targets.SQLite\SQLite\SQLite.cs,SaveTransactionPoint,The following switch statement is missing a default case: switch (sqlExp.Result)                      {                          case SQLite3.Result.IOError:                          case SQLite3.Result.Full:                          case SQLite3.Result.Busy:                          case SQLite3.Result.NoMem:                          case SQLite3.Result.Interrupt:                              RollbackTo(null' true);                              break;                      }
