Implementation smell,Namespace,Class,File,Method,Description
Long Method,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CleanWord2000,The method has 118 lines of code.
Long Method,TidyNet,ClsStreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ClsStreamInImpl.cs,ReadChar,The method has 106 lines of code.
Long Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseEntity,The method has 107 lines of code.
Long Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,SetXhtmlDocType,The method has 107 lines of code.
Long Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FixDocType,The method has 166 lines of code.
Long Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The method has 828 lines of code.
Long Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseAttribute,The method has 118 lines of code.
Long Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseValue,The method has 256 lines of code.
Long Method,TidyNet,ParseHTMLCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 200 lines of code.
Long Method,TidyNet,ParseBodyCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 276 lines of code.
Long Method,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 525 lines of code.
Long Method,TidyNet,ParseListCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 114 lines of code.
Long Method,TidyNet,ParseDefListCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 127 lines of code.
Long Method,TidyNet,ParsePreCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 192 lines of code.
Long Method,TidyNet,ParseBlockCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 413 lines of code.
Long Method,TidyNet,ParseTableTagCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 125 lines of code.
Long Method,TidyNet,ParseRowGroupCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 141 lines of code.
Long Method,TidyNet,ParseRowCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The method has 143 lines of code.
Long Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The method has 284 lines of code.
Long Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttrValue,The method has 155 lines of code.
Long Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The method has 258 lines of code.
Long Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintXmlTree,The method has 119 lines of code.
Long Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintSlide,The method has 101 lines of code.
Long Method,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,Warning,The method has 177 lines of code.
Long Method,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The method has 148 lines of code.
Long Method,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadChar,The method has 106 lines of code.
Long Method,TidyNet,Tidy,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Tidy.cs,ParseInternal,The method has 200 lines of code.
Complex Method,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CreateProps,Cyclomatic complexity of the method is 10
Complex Method,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CleanBodyAttrs,Cyclomatic complexity of the method is 11
Complex Method,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,NestedList,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,BlockStyle,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CleanNode,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CleanWord2000,Cyclomatic complexity of the method is 15
Complex Method,TidyNet,ClsStreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ClsStreamInImpl.cs,ReadChar,Cyclomatic complexity of the method is 16
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseEntity,Cyclomatic complexity of the method is 10
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,Cyclomatic complexity of the method is 13
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,SetXhtmlDocType,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FixDocType,Cyclomatic complexity of the method is 13
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,Cyclomatic complexity of the method is 13
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseAttribute,Cyclomatic complexity of the method is 15
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseServerInstruction,Cyclomatic complexity of the method is 10
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseValue,Cyclomatic complexity of the method is 29
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,PopInline,Cyclomatic complexity of the method is 11
Complex Method,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,CanPrune,Cyclomatic complexity of the method is 10
Complex Method,TidyNet,Node,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Node.cs,CheckNodeIntegrity,Cyclomatic complexity of the method is 13
Complex Method,TidyNet,ParserImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,parseDocument,Cyclomatic complexity of the method is 8
Complex Method,TidyNet,ParserImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,parseXMLElement,Cyclomatic complexity of the method is 14
Complex Method,TidyNet,ParserImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,parseXMLDocument,Cyclomatic complexity of the method is 10
Complex Method,TidyNet,ParseHTMLCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 29
Complex Method,TidyNet,ParseHeadCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 13
Complex Method,TidyNet,ParseTitleCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,ParseBodyCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 35
Complex Method,TidyNet,ParseFrameSetCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 68
Complex Method,TidyNet,ParseListCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 17
Complex Method,TidyNet,ParseDefListCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 18
Complex Method,TidyNet,ParsePreCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 26
Complex Method,TidyNet,ParseBlockCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 42
Complex Method,TidyNet,ParseTableTagCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 15
Complex Method,TidyNet,ParseColGroupCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,TidyNet,ParseRowGroupCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 20
Complex Method,TidyNet,ParseRowCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 20
Complex Method,TidyNet,ParseNoFramesCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,TidyNet,ParseTextCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,WrapLine,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,WrapAttrVal,Cyclomatic complexity of the method is 8
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,Cyclomatic complexity of the method is 34
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttrValue,Cyclomatic complexity of the method is 17
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttribute,Cyclomatic complexity of the method is 10
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTag,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,ShouldIndent,Cyclomatic complexity of the method is 11
Complex Method,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintSlide,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,ErrorSummary,Cyclomatic complexity of the method is 18
Complex Method,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,Cyclomatic complexity of the method is 9
Complex Method,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadChar,Cyclomatic complexity of the method is 16
Complex Method,TidyNet,Tidy,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Tidy.cs,ParseInternal,Cyclomatic complexity of the method is 11
Complex Method,TidyNet,TidyOptions,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\TidyOptions.cs,Adjust,Cyclomatic complexity of the method is 8
Long Parameter List,TidyNet,AttVal,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AttVal.cs,AttVal,The method has 5 parameters. Parameters: next' dict' delim' attribute' val
Long Parameter List,TidyNet,AttVal,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AttVal.cs,AttVal,The method has 7 parameters. Parameters: next' dict' asp' php' delim' attribute' val
Long Parameter List,TidyNet,Dict,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Dict.cs,Dict,The method has 5 parameters. Parameters: name' versions' model' parser' checkAttribs
Long Parameter List,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,NewNode,The method has 5 parameters. Parameters: type' textarray' start' end' element
Long Parameter List,TidyNet,Node,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Node.cs,Node,The method has 6 parameters. Parameters: type' textarray' start' end' element' tt
Long Parameter List,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintText,The method has 6 parameters. Parameters: fout' mode' indent' textarray' start' end
Long Parameter List,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttrValue,The method has 5 parameters. Parameters: fout' indent' val' delim' wrappable
Long Parameter List,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTag,The method has 5 parameters. Parameters: lexer' fout' mode' indent' node
Long Parameter List,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The method has 5 parameters. Parameters: fout' mode' indent' lexer' node
Long Parameter List,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintXmlTree,The method has 5 parameters. Parameters: fout' mode' indent' lexer' node
Long Parameter List,TidyNet,TidyMessage,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\TidyMessage.cs,TidyMessage,The method has 6 parameters. Parameters: filename' line' column' message' level' options
Long Statement,TidyNet,AlignAttrCheck,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AlignAttrCheck.cs,Check,The length of the statement  "			else if (!(String.Compare(val' "left") == 0 || String.Compare(val' "center") == 0 || String.Compare(val' "right") == 0 || String.Compare(val' "justify") == 0)) " is 159.
Long Statement,TidyNet,AttVal,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AttVal.cs,CheckAttribute,The length of the statement  "			else if (!lexer.Options.XmlTags && !(node.Tag == null) && _asp == null && !(node.Tag != null && ((node.Tag.Versions & HtmlVersion.Proprietary) != HtmlVersion.Unknown))) " is 168.
Long Statement,TidyNet,AttVal,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AttVal.cs,CheckUniqueAttribute,The length of the statement  "				if (Attribute != null && attr.Attribute != null && attr.Asp == null && attr.Php == null && String.Compare(Attribute' attr.Attribute) == 0) " is 138.
Long Statement,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CreateProps,The length of the statement  "				prop = InsertProperty(prop' style.Substring(name_start' (name_end) - (name_start))' style.Substring(value_start' (value_end) - (value_start))); " is 143.
Long Statement,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,NiceBody,The length of the statement  "				if (body.GetAttrByName("background") != null || body.GetAttrByName("bgcolor") != null || body.GetAttrByName("text") != null || body.GetAttrByName("link") != null || body.GetAttrByName("vlink") != null || body.GetAttrByName("alink") != null) " is 240.
Long Statement,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,PurgeAttributes,The length of the statement  "				else if (attr.Attribute != null && (attr.Attribute.Equals("class") || attr.Attribute.Equals("style") || attr.Attribute.Equals("lang") || attr.Attribute.StartsWith("x:") || ((attr.Attribute.Equals("height") || attr.Attribute.Equals("width")) && (node.Tag == _tt.TagTd || node.Tag == _tt.TagTr || node.Tag == _tt.TagTh)))) " is 320.
Long Statement,TidyNet,DomNodeImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\DomNodeImpl.cs,InsertBefore,The length of the statement  "				if (newCh.Adaptee.Type != Node.StartTag && newCh.Adaptee.Type != Node.StartEndTag && newCh.Adaptee.Type != Node.CommentTag && newCh.Adaptee.Type != Node.TextNode && newCh.Adaptee.Type != Node.CDATATag) " is 201.
Long Statement,TidyNet,DomNodeImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\DomNodeImpl.cs,ReplaceChild,The length of the statement  "				if (newCh.Adaptee.Type != Node.StartTag && newCh.Adaptee.Type != Node.StartEndTag && newCh.Adaptee.Type != Node.CommentTag && newCh.Adaptee.Type != Node.TextNode && newCh.Adaptee.Type != Node.CDATATag) " is 201.
Long Statement,TidyNet,DomNodeImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\DomNodeImpl.cs,AppendChild,The length of the statement  "				if (newCh.Adaptee.Type != Node.StartTag && newCh.Adaptee.Type != Node.StartEndTag && newCh.Adaptee.Type != Node.CommentTag && newCh.Adaptee.Type != Node.TextNode && newCh.Adaptee.Type != Node.CDATATag) " is 201.
Long Statement,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddGenerator,The length of the statement  "							if (attval != null && attval.Val != null && attval.Val.Length >= 9 && String.Compare(attval.Val.Substring(0' 9)' "HTML Tidy") == 0) " is 131.
Long Statement,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,CheckDocTypeKeyWords,The length of the statement  "			return !(FindBadSubString("SYSTEM"' s' len) || FindBadSubString("PUBLIC"' s' len) || FindBadSubString("//DTD"' s' len) || FindBadSubString("//W3C"' s' len) || FindBadSubString("//EN"' s' len)); " is 193.
Long Statement,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The length of the statement  "					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart)); " is 140.
Long Statement,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseValue,The length of the statement  "				if (!AttributeTable.DefaultAttributeTable.IsScript(name) && !(AttributeTable.DefaultAttributeTable.IsUrl(name) && (GetString(lexbuf' start' 11)).Equals("javascript:"))) " is 168.
Long Statement,TidyNet,Node,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Node.cs,TrimInitialSpace,The length of the statement  "				if (((element.Tag.Model & ContentModel.Inline) != 0) && !((element.Tag.Model & ContentModel.Field) != 0) && element.Parent.Content != element) " is 142.
Long Statement,TidyNet,Node,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Node.cs,InsertMisc,The length of the statement  "			if (node.Type == CommentTag || node.Type == ProcInsTag || node.Type == CDATATag || node.Type == SectionTag || node.Type == AspTag || node.Type == JsteTag || node.Type == PhpTag) " is 177.
Long Statement,TidyNet,ParserImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,XMLPreserveWhiteSpace,The length of the statement  "			if (String.Compare(element.Element' "pre") == 0 || String.Compare(element.Element' "script") == 0 || String.Compare(element.Element' "style") == 0) " is 147.
Long Statement,TidyNet,ParserImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,isJavaScript,The length of the statement  "				if ((String.Compare(attr.Attribute' "language") == 0 || String.Compare(attr.Attribute' "type") == 0) && wsubstr(attr.Val' "javascript")) " is 136.
Long Statement,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The length of the statement  "					if (node.Type == Node.StartTag && node.Tag == element.Tag && lexer.IsPushed(node) && !node.Isimplicit && !element.Isimplicit && node.Tag != null && ((node.Tag.Model & ContentModel.Inline) != 0) && node.Tag != tt.TagA && node.Tag != tt.TagFont && node.Tag != tt.TagBig && node.Tag != tt.TagSmall) " is 295.
Long Statement,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The length of the statement  "					if (node.Tag == tt.TagP && node.Type == Node.StartTag && ((mode & Lexer.Preformatted) != 0 || element.Tag == tt.TagDt || element.IsDescendantOf(tt.TagDt))) " is 155.
Long Statement,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The length of the statement  "						else if ((node.Tag.Model & ContentModel.Inline) != 0 && node.Tag != tt.TagA && !((node.Tag.Model & ContentModel.Object) != 0) && (element.Tag.Model & ContentModel.Inline) != 0) " is 176.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttrs,The length of the statement  "			if (_options.XmlOut && _options.XmlSpace && ParserImpl.XMLPreserveWhiteSpace(node' _options.tt) && node.GetAttrByName("xml:space") == null) " is 139.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTag,The length of the statement  "			if ((_options.XmlOut || lexer != null && lexer.isvoyager) && (node.Type == Node.StartEndTag || (node.Tag.Model & ContentModel.Empty) != 0)) " is 139.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTag,The length of the statement  "						if (!((mode & NOWRAP) != 0) && (!((node.Tag.Model & ContentModel.Inline) != 0) || (node.Tag == tt.TagBr) || (((node.Tag.Model & ContentModel.Empty) != 0) && node.Next == null && node.Parent.Tag == tt.TagA))) " is 207.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The length of the statement  "						else if ((node.Tag.Model & ContentModel.Html) != 0 || node.Tag == tt.TagNoframes || ((node.Tag.Model & ContentModel.Head) != 0 && !(node.Tag == tt.TagTitle))) " is 158.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The length of the statement  "							if (last != null && !_options.IndentContent && last.Type == Node.TextNode && content.Tag != null && (content.Tag.Model & ContentModel.Block) != 0) " is 146.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The length of the statement  "					if (ShouldIndent(node) || (((node.Tag.Model & ContentModel.Html) != 0 || node.Tag == tt.TagNoframes || ((node.Tag.Model & ContentModel.Head) != 0 && !(node.Tag == tt.TagTitle))) && _options.HideEndTags == false)) " is 212.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The length of the statement  "					if (_options.IndentContent == false && node.Next != null && _options.HideEndTags == false && (node.Tag.Model & (ContentModel.Block | ContentModel.List | ContentModel.Deflist | ContentModel.Table)) != 0) " is 202.
Long Statement,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintSlide,The length of the statement  "				if (last != null && !_options.IndentContent && last.Type == Node.TextNode && content.Tag != null && (content.Tag.Model & ContentModel.Block) != 0) " is 146.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,Warning,The length of the statement  "				AddMessage(lexer' String.Format(GetMessage("missing_endtag_before")' element.Element' Tag(lexer' node))' MessageLevel.Warning); " is 127.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,Warning,The length of the statement  "				AddMessage(lexer' String.Format(GetMessage("non_matching_endtag_1")' Tag(lexer' node)' element.Element)' MessageLevel.Warning); " is 127.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,Warning,The length of the statement  "				AddMessage(lexer' String.Format(GetMessage("tag_not_allowed_in")' Tag(lexer' node)' element.Element)' MessageLevel.Warning); " is 124.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,ErrorSummary,The length of the statement  "				TidyMessage msg2 = new TidyMessage(lexer' String.Format(GetMessage("badaccess_summary")' ACCESS_URL)' MessageLevel.Info); " is 121.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,ReportVersion,The length of the statement  "			lexer.messages.Add(new TidyMessage(lexer' String.Format(GetMessage("report_version")' (vers != null ? vers : "HTML proprietary"))' MessageLevel.Info)); " is 151.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,ReportNumWarnings,The length of the statement  "				lexer.messages.Add(new TidyMessage(lexer' String.Format(GetMessage("num_warnings_errors")' lexer.messages.Warnings' lexer.messages.Errors)' MessageLevel.Info)); " is 160.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,ReportNumWarnings,The length of the statement  "				lexer.messages.Add(new TidyMessage(lexer' String.Format(GetMessage("num_errors")' lexer.messages.Errors)' MessageLevel.Info)); " is 126.
Long Statement,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,ReportNumWarnings,The length of the statement  "				lexer.messages.Add(new TidyMessage(lexer' String.Format(GetMessage("num_warnings")' lexer.messages.Warnings)' MessageLevel.Info)); " is 130.
Long Statement,TidyNet,TagTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\TagTable.cs,DefineInlineTag,The length of the statement  "			Add(new Dict(name' HtmlVersion.Proprietary' (ContentModel.Inline | ContentModel.NoIndent | ContentModel.New)' ParserImpl.ParseBlock' null)); " is 140.
Long Statement,TidyNet,TagTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\TagTable.cs,DefineBlockTag,The length of the statement  "			Add(new Dict(name' HtmlVersion.Proprietary' (ContentModel.Block | ContentModel.NoIndent | ContentModel.New)' ParserImpl.ParseBlock' null)); " is 139.
Long Statement,TidyNet,TagTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\TagTable.cs,defineEmptyTag,The length of the statement  "			Add(new Dict(name' HtmlVersion.Proprietary' (ContentModel.Empty | ContentModel.NoIndent | ContentModel.New)' ParserImpl.ParseBlock' null)); " is 139.
Long Statement,TidyNet,TagTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\TagTable.cs,DefinePreTag,The length of the statement  "			Add(new Dict(name' HtmlVersion.Proprietary' (ContentModel.Block | ContentModel.NoIndent | ContentModel.New)' ParserImpl.ParsePre' null)); " is 137.
Long Statement,TidyNet,ValignAttrCheck,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ValignAttrCheck.cs,Check,The length of the statement  "			else if (String.Compare(val' "top") == 0 || String.Compare(val' "middle") == 0 || String.Compare(val' "bottom") == 0 || String.Compare(val' "baseline") == 0) " is 157.
Long Statement,TidyNet,ValignAttrCheck,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ValignAttrCheck.cs,Check,The length of the statement  "			else if (String.Compare(val' "texttop") == 0 || String.Compare(val' "absmiddle") == 0 || String.Compare(val' "absbottom") == 0 || String.Compare(val' "textbottom") == 0) " is 169.
Complex Conditional,TidyNet,AlignAttrCheck,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AlignAttrCheck.cs,Check,The conditional expression  "!(String.Compare(val' "left") == 0 || String.Compare(val' "center") == 0 || String.Compare(val' "right") == 0 || String.Compare(val' "justify") == 0)"  is complex.
Complex Conditional,TidyNet,AttVal,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AttVal.cs,CheckAttribute,The conditional expression  "!lexer.Options.XmlTags && !(node.Tag == null) && _asp == null && !(node.Tag != null && ((node.Tag.Versions & HtmlVersion.Proprietary) != HtmlVersion.Unknown))"  is complex.
Complex Conditional,TidyNet,AttVal,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\AttVal.cs,CheckUniqueAttribute,The conditional expression  "Attribute != null && attr.Attribute != null && attr.Asp == null && attr.Php == null && String.Compare(Attribute' attr.Attribute) == 0"  is complex.
Complex Conditional,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,NiceBody,The conditional expression  "body.GetAttrByName("background") != null || body.GetAttrByName("bgcolor") != null || body.GetAttrByName("text") != null || body.GetAttrByName("link") != null || body.GetAttrByName("vlink") != null || body.GetAttrByName("alink") != null"  is complex.
Complex Conditional,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,NestedEmphasis,The conditional expression  "(node.Tag == _tt.TagB || node.Tag == _tt.TagI) && node.Parent != null && node.Parent.Tag == node.Tag"  is complex.
Complex Conditional,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,List2BQ,The conditional expression  "node.Tag != null && node.Tag.Parser == ParserImpl.ParseList && node.HasOneChild() && node.Content.Isimplicit"  is complex.
Complex Conditional,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,PurgeAttributes,The conditional expression  "attr.Attribute != null && attr.Val != null && attr.Attribute.Equals("class") && attr.Val.Equals("Code")"  is complex.
Complex Conditional,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,PurgeAttributes,The conditional expression  "attr.Attribute != null && (attr.Attribute.Equals("class") || attr.Attribute.Equals("style") || attr.Attribute.Equals("lang") || attr.Attribute.StartsWith("x:") || ((attr.Attribute.Equals("height") || attr.Attribute.Equals("width")) && (node.Tag == _tt.TagTd || node.Tag == _tt.TagTr || node.Tag == _tt.TagTh)))"  is complex.
Complex Conditional,TidyNet,DomNodeImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\DomNodeImpl.cs,InsertBefore,The conditional expression  "newCh.Adaptee.Type != Node.StartTag && newCh.Adaptee.Type != Node.StartEndTag && newCh.Adaptee.Type != Node.CommentTag && newCh.Adaptee.Type != Node.TextNode && newCh.Adaptee.Type != Node.CDATATag"  is complex.
Complex Conditional,TidyNet,DomNodeImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\DomNodeImpl.cs,ReplaceChild,The conditional expression  "newCh.Adaptee.Type != Node.StartTag && newCh.Adaptee.Type != Node.StartEndTag && newCh.Adaptee.Type != Node.CommentTag && newCh.Adaptee.Type != Node.TextNode && newCh.Adaptee.Type != Node.CDATATag"  is complex.
Complex Conditional,TidyNet,DomNodeImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\DomNodeImpl.cs,AppendChild,The conditional expression  "newCh.Adaptee.Type != Node.StartTag && newCh.Adaptee.Type != Node.StartEndTag && newCh.Adaptee.Type != Node.CommentTag && newCh.Adaptee.Type != Node.TextNode && newCh.Adaptee.Type != Node.CDATATag"  is complex.
Complex Conditional,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddGenerator,The conditional expression  "attval != null && attval.Val != null && attval.Val.Length >= 9 && String.Compare(attval.Val.Substring(0' 9)' "HTML Tidy") == 0"  is complex.
Complex Conditional,TidyNet,Node,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Node.cs,InsertMisc,The conditional expression  "node.Type == CommentTag || node.Type == ProcInsTag || node.Type == CDATATag || node.Type == SectionTag || node.Type == AspTag || node.Type == JsteTag || node.Type == PhpTag"  is complex.
Complex Conditional,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The conditional expression  "node.Type == Node.StartTag && node.Tag == element.Tag && lexer.IsPushed(node) && !node.Isimplicit && !element.Isimplicit && node.Tag != null && ((node.Tag.Model & ContentModel.Inline) != 0) && node.Tag != tt.TagA && node.Tag != tt.TagFont && node.Tag != tt.TagBig && node.Tag != tt.TagSmall"  is complex.
Complex Conditional,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The conditional expression  "node.Tag == tt.TagP && node.Type == Node.StartTag && ((mode & Lexer.Preformatted) != 0 || element.Tag == tt.TagDt || element.IsDescendantOf(tt.TagDt))"  is complex.
Complex Conditional,TidyNet,ParseInlineCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The conditional expression  "(node.Tag.Model & ContentModel.Inline) != 0 && node.Tag != tt.TagA && !((node.Tag.Model & ContentModel.Object) != 0) && (element.Tag.Model & ContentModel.Inline) != 0"  is complex.
Complex Conditional,TidyNet,ParseBlockCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The conditional expression  "node.Type == Node.EndTag && node.Tag != null && (node.Tag == element.Tag || element.Was == node.Tag)"  is complex.
Complex Conditional,TidyNet,ParseSelectCheckTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ParserImpl.cs,Parse,The conditional expression  "node.Type == Node.StartTag && (node.Tag == tt.TagOption || node.Tag == tt.TagOptgroup || node.Tag == tt.TagScript)"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttrs,The conditional expression  "_options.XmlOut && _options.XmlSpace && ParserImpl.XMLPreserveWhiteSpace(node' _options.tt) && node.GetAttrByName("xml:space") == null"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTag,The conditional expression  "(_options.XmlOut || lexer != null && lexer.isvoyager) && (node.Type == Node.StartEndTag || (node.Tag.Model & ContentModel.Empty) != 0)"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTag,The conditional expression  "!((mode & NOWRAP) != 0) && (!((node.Tag.Model & ContentModel.Inline) != 0) || (node.Tag == tt.TagBr) || (((node.Tag.Model & ContentModel.Empty) != 0) && node.Next == null && node.Parent.Tag == tt.TagA))"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The conditional expression  "node.Tag == tt.TagBr && node.Prev != null && node.Prev.Tag != tt.TagBr && _options.BreakBeforeBR"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The conditional expression  "(node.Tag.Model & ContentModel.Html) != 0 || node.Tag == tt.TagNoframes || ((node.Tag.Model & ContentModel.Head) != 0 && !(node.Tag == tt.TagTitle))"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The conditional expression  "last != null && !_options.IndentContent && last.Type == Node.TextNode && content.Tag != null && (content.Tag.Model & ContentModel.Block) != 0"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The conditional expression  "ShouldIndent(node) || (((node.Tag.Model & ContentModel.Html) != 0 || node.Tag == tt.TagNoframes || ((node.Tag.Model & ContentModel.Head) != 0 && !(node.Tag == tt.TagTitle))) && _options.HideEndTags == false)"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintTree,The conditional expression  "_options.IndentContent == false && node.Next != null && _options.HideEndTags == false && (node.Tag.Model & (ContentModel.Block | ContentModel.List | ContentModel.Deflist | ContentModel.Table)) != 0"  is complex.
Complex Conditional,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintSlide,The conditional expression  "last != null && !_options.IndentContent && last.Type == Node.TextNode && content.Tag != null && (content.Tag.Model & ContentModel.Block) != 0"  is complex.
Complex Conditional,TidyNet,ValignAttrCheck,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ValignAttrCheck.cs,Check,The conditional expression  "String.Compare(val' "top") == 0 || String.Compare(val' "middle") == 0 || String.Compare(val' "bottom") == 0 || String.Compare(val' "baseline") == 0"  is complex.
Complex Conditional,TidyNet,ValignAttrCheck,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ValignAttrCheck.cs,Check,The conditional expression  "String.Compare(val' "texttop") == 0 || String.Compare(val' "absmiddle") == 0 || String.Compare(val' "absbottom") == 0 || String.Compare(val' "textbottom") == 0"  is complex.
Empty Catch Block,TidyNet,EntityTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\EntityTable.cs,EntityCode,The method has an empty catch block.
Empty Catch Block,TidyNet,Tidy,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Tidy.cs,Parse,The method has an empty catch block.
Empty Catch Block,TidyNet,Tidy,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Tidy.cs,Parse,The method has an empty catch block.
Empty Catch Block,TidyNet,Tidy,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Tidy.cs,ParseInternal,The method has an empty catch block.
Empty Catch Block,TidyNet,Tidy,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Tidy.cs,ParseInternal,The method has an empty catch block.
Empty Catch Block,TidyNet,Tidy,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Tidy.cs,ParseInternal,The method has an empty catch block.
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CreatePropString,The following statement contains a magic number: for (len = 0' prop = props; prop != null; prop = prop.Next)  			{  				len += prop.Name.Length + 2;  				len += prop.Val.Length + 2;  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,CreatePropString,The following statement contains a magic number: for (len = 0' prop = props; prop != null; prop = prop.Next)  			{  				len += prop.Name.Length + 2;  				len += prop.Val.Length + 2;  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,FontSize2Name,The following statement contains a magic number: if (size.Length > 0 && size[0] == '-')  			{  				if (size.Length > 1 && '0' <= size[1] && size[1] <= '6')  				{  					int n = size[1] - '0';  					double x;  					  					for (x = 1.0; n > 0; --n)  					{  						x *= 0.8;  					}  					  					x *= 100.0;    					buf = String.Format("{0}%"' (int)x);  					  					return buf;  				}  				  				return "smaller"; /*"70%"; */  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,FontSize2Name,The following statement contains a magic number: if (size.Length > 0 && size[0] == '-')  			{  				if (size.Length > 1 && '0' <= size[1] && size[1] <= '6')  				{  					int n = size[1] - '0';  					double x;  					  					for (x = 1.0; n > 0; --n)  					{  						x *= 0.8;  					}  					  					x *= 100.0;    					buf = String.Format("{0}%"' (int)x);  					  					return buf;  				}  				  				return "smaller"; /*"70%"; */  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,FontSize2Name,The following statement contains a magic number: if (size.Length > 1 && '0' <= size[1] && size[1] <= '6')  			{  				int n = size[1] - '0';  				double x;  				  				for (x = 1.0; n > 0; --n)  				{  					x *= 1.2;  				}  				  				x *= 100.0;    				buf = String.Format("{0}%"' (int)x);  				  				return buf;  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,FontSize2Name,The following statement contains a magic number: if (size.Length > 1 && '0' <= size[1] && size[1] <= '6')  			{  				int n = size[1] - '0';  				double x;  				  				for (x = 1.0; n > 0; --n)  				{  					x *= 1.2;  				}  				  				x *= 100.0;    				buf = String.Format("{0}%"' (int)x);  				  				return buf;  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,BQ2Div,The following statement contains a magic number: while (node != null)  			{  				if (node.Tag == _tt.TagBlockquote && node.Isimplicit)  				{  					indent = 1;  					  					while (node.HasOneChild() && node.Content.Tag == _tt.TagBlockquote && node.Isimplicit)  					{  						++indent;  						StripOnlyChild(node);  					}  					  					if (node.Content != null)  					{  						BQ2Div(node.Content);  					}  					  					indent_buf = "margin-left: " + (2 * indent).ToString() + "em";  					  					node.Element = _tt.TagDiv.Name;  					node.Tag = _tt.TagDiv;  					node.AddAttribute("style"' indent_buf);  				}  				else if (node.Content != null)  				{  					BQ2Div(node.Content);  				}  				  				  				node = node.Next;  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,PruneSection,The following statement contains a magic number: for (; ; )  			{  				/* discard node and returns next */  				node = Node.DiscardElement(node);  				  				if (node == null)  					return null;  				  				if (node.Type == Node.SectionTag)  				{  					if ((Lexer.GetString(node.Textarray' node.Start' 2)).Equals("if"))  					{  						node = PruneSection(lexer' node);  						continue;  					}  					  					if ((Lexer.GetString(node.Textarray' node.Start' 5)).Equals("endif"))  					{  						node = Node.DiscardElement(node);  						break;  					}  				}  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,PruneSection,The following statement contains a magic number: for (; ; )  			{  				/* discard node and returns next */  				node = Node.DiscardElement(node);  				  				if (node == null)  					return null;  				  				if (node.Type == Node.SectionTag)  				{  					if ((Lexer.GetString(node.Textarray' node.Start' 2)).Equals("if"))  					{  						node = PruneSection(lexer' node);  						continue;  					}  					  					if ((Lexer.GetString(node.Textarray' node.Start' 5)).Equals("endif"))  					{  						node = Node.DiscardElement(node);  						break;  					}  				}  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,DropSections,The following statement contains a magic number: while (node != null)  			{  				if (node.Type == Node.SectionTag)  				{  					/* prune up to matching endif */  					if ((Lexer.GetString(node.Textarray' node.Start' 2)).Equals("if"))  					{  						node = PruneSection(lexer' node);  						continue;  					}  					  					/* discard others as well */  					node = Node.DiscardElement(node);  					continue;  				}  				  				if (node.Content != null)  				{  					DropSections(lexer' node.Content);  				}  				  				node = node.Next;  			}
Magic Number,TidyNet,Clean,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Clean.cs,NormalizeSpaces,The following statement contains a magic number: while (node != null)  			{  				if (node.Content != null)  				{  					NormalizeSpaces(lexer' node.Content);  				}  				  				if (node.Type == Node.TextNode)  				{  					int i;  					MutableInteger c = new MutableInteger();  					int p = node.Start;  					  					for (i = node.Start; i < node.End; ++i)  					{  						c.Val = (int) node.Textarray[i];  						  						/* look for UTF-8 multibyte character */  						if (c.Val > 0x7F)  						{  							i += PPrint.GetUTF8(node.Textarray' i' c);  						}  						  						if (c.Val == 160)  						{  							c.Val = ' ';  						}  						  						p = PPrint.PutUTF8(node.Textarray' p' c.Val);  					}  				}  				  				node = node.Next;  			}
Magic Number,TidyNet,ClsStreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ClsStreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Magic Number,TidyNet,ClsStreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ClsStreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Magic Number,TidyNet,ClsStreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ClsStreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Magic Number,TidyNet,ClsStreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ClsStreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Magic Number,TidyNet,EntityTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\EntityTable.cs,EntityCode,The following statement contains a magic number: if (name[1] == '#')  			{  				c = 0; /* zero on missing/bad number */  				  				/* 'x' prefix denotes hexadecimal number format */  				try  				{  					if (name.Length >= 4 && name[2] == 'x')  					{  						c = Convert.ToInt32(name.Substring(3)' 16);  					}  					else if (name.Length >= 3)  					{  						c = Int32.Parse(name.Substring(2));  					}  				}  				catch (FormatException)  				{  				}  				  				return (short) c;  			}
Magic Number,TidyNet,EntityTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\EntityTable.cs,EntityCode,The following statement contains a magic number: if (name[1] == '#')  			{  				c = 0; /* zero on missing/bad number */  				  				/* 'x' prefix denotes hexadecimal number format */  				try  				{  					if (name.Length >= 4 && name[2] == 'x')  					{  						c = Convert.ToInt32(name.Substring(3)' 16);  					}  					else if (name.Length >= 3)  					{  						c = Int32.Parse(name.Substring(2));  					}  				}  				catch (FormatException)  				{  				}  				  				return (short) c;  			}
Magic Number,TidyNet,EntityTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\EntityTable.cs,EntityCode,The following statement contains a magic number: if (name[1] == '#')  			{  				c = 0; /* zero on missing/bad number */  				  				/* 'x' prefix denotes hexadecimal number format */  				try  				{  					if (name.Length >= 4 && name[2] == 'x')  					{  						c = Convert.ToInt32(name.Substring(3)' 16);  					}  					else if (name.Length >= 3)  					{  						c = Int32.Parse(name.Substring(2));  					}  				}  				catch (FormatException)  				{  				}  				  				return (short) c;  			}
Magic Number,TidyNet,EntityTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\EntityTable.cs,EntityCode,The following statement contains a magic number: if (name[1] == '#')  			{  				c = 0; /* zero on missing/bad number */  				  				/* 'x' prefix denotes hexadecimal number format */  				try  				{  					if (name.Length >= 4 && name[2] == 'x')  					{  						c = Convert.ToInt32(name.Substring(3)' 16);  					}  					else if (name.Length >= 3)  					{  						c = Int32.Parse(name.Substring(2));  					}  				}  				catch (FormatException)  				{  				}  				  				return (short) c;  			}
Magic Number,TidyNet,EntityTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\EntityTable.cs,EntityCode,The following statement contains a magic number: if (name[1] == '#')  			{  				c = 0; /* zero on missing/bad number */  				  				/* 'x' prefix denotes hexadecimal number format */  				try  				{  					if (name.Length >= 4 && name[2] == 'x')  					{  						c = Convert.ToInt32(name.Substring(3)' 16);  					}  					else if (name.Length >= 3)  					{  						c = Int32.Parse(name.Substring(2));  					}  				}  				catch (FormatException)  				{  				}  				  				return (short) c;  			}
Magic Number,TidyNet,EntityTable,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\EntityTable.cs,EntityCode,The following statement contains a magic number: if (name[1] == '#')  			{  				c = 0; /* zero on missing/bad number */  				  				/* 'x' prefix denotes hexadecimal number format */  				try  				{  					if (name.Length >= 4 && name[2] == 'x')  					{  						c = Convert.ToInt32(name.Substring(3)' 16);  					}  					else if (name.Length >= 3)  					{  						c = Int32.Parse(name.Substring(2));  					}  				}  				catch (FormatException)  				{  				}  				  				return (short) c;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddByte,The following statement contains a magic number: if (this.lexsize + 1 >= this.lexlength)  			{  				while (this.lexsize + 1 >= this.lexlength)  				{  					if (this.lexlength == 0)  						this.lexlength = 8192;  					else  						this.lexlength = this.lexlength * 2;  				}  				  				byte[] temp = this.lexbuf;  				this.lexbuf = new byte[this.lexlength];  				if (temp != null)  				{  					Array.Copy(temp' 0' this.lexbuf' 0' temp.Length);  					UpdateNodeTextArrays(temp' this.lexbuf);  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddByte,The following statement contains a magic number: if (this.lexsize + 1 >= this.lexlength)  			{  				while (this.lexsize + 1 >= this.lexlength)  				{  					if (this.lexlength == 0)  						this.lexlength = 8192;  					else  						this.lexlength = this.lexlength * 2;  				}  				  				byte[] temp = this.lexbuf;  				this.lexbuf = new byte[this.lexlength];  				if (temp != null)  				{  					Array.Copy(temp' 0' this.lexbuf' 0' temp.Length);  					UpdateNodeTextArrays(temp' this.lexbuf);  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddCharToLexer,The following statement contains a magic number: if (c < 128)  			{  				AddByte(c);  			}  			else if (c <= 0x7FF)  			{  				AddByte(0xC0 | (c >> 6));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				AddByte(0xE0 | (c >> 12));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				AddByte(0xF0 | (c >> 18));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}  			else  			{  				AddByte(0xF8 | (c >> 24));  				AddByte(0x80 | ((c >> 18) & 0x3F));  				AddByte(0x80 | ((c >> 12) & 0x3F));  				AddByte(0x80 | ((c >> 6) & 0x3F));  				AddByte(0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseEntity,The following statement contains a magic number: if (ch <= 0)  			{  				/* set error position just before offending chararcter */  				this.lines = this.input.curline;  				this.columns = startcol;  				  				if (this.lexsize > start + 1)  				{  					Report.EntityError(this' Report.UNKNOWN_ENTITY' str' ch);  					  					if (semicolon)  						AddCharToLexer(';');  				}  					/* naked & */  				else  				{  					Report.EntityError(this' Report.UNESCAPED_AMPERSAND' str' ch);  				}  			}  			else  			{  				if (c != ';')  					/* issue warning if not terminated by ';' */  				{  					/* set error position just before offending chararcter */  					this.lines = this.input.curline;  					this.columns = startcol;  					Report.EntityError(this' Report.MISSING_SEMICOLON' str' c);  				}  				  				this.lexsize = start;  				  				if (ch == 160 && (mode & Preformatted) != 0)  					ch = ' ';  				  				AddCharToLexer(ch);  				  				if (ch == '&' && !Options.QuoteAmpersand)  				{  					AddCharToLexer('a');  					AddCharToLexer('m');  					AddCharToLexer('p');  					AddCharToLexer(';');  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddGenerator,The following statement contains a magic number: if (head != null)  			{  				for (node = head.Content; node != null; node = node.Next)  				{  					if (node.Tag == Options.tt.TagMeta)  					{  						attval = node.GetAttrByName("name");  						  						if (attval != null && attval.Val != null && String.Compare(attval.Val' "generator") == 0)  						{  							attval = node.GetAttrByName("content");  							  							if (attval != null && attval.Val != null && attval.Val.Length >= 9 && String.Compare(attval.Val.Substring(0' 9)' "HTML Tidy") == 0)  							{  								return false;  							}  						}  					}  				}  				  				node = this.InferredTag("meta");  				node.AddAttribute("content"' "HTML Tidy' see www.w3.org");  				node.AddAttribute("name"' "generator");  				Node.InsertNodeAtStart(head' node);  				return true;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,AddGenerator,The following statement contains a magic number: if (head != null)  			{  				for (node = head.Content; node != null; node = node.Next)  				{  					if (node.Tag == Options.tt.TagMeta)  					{  						attval = node.GetAttrByName("name");  						  						if (attval != null && attval.Val != null && String.Compare(attval.Val' "generator") == 0)  						{  							attval = node.GetAttrByName("content");  							  							if (attval != null && attval.Val != null && attval.Val.Length >= 9 && String.Compare(attval.Val.Substring(0' 9)' "HTML Tidy") == 0)  							{  								return false;  							}  						}  					}  				}  				  				node = this.InferredTag("meta");  				node.AddAttribute("content"' "HTML Tidy' see www.w3.org");  				node.AddAttribute("name"' "generator");  				Node.InsertNodeAtStart(head' node);  				return true;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: str1 = GetString(this.lexbuf' doctype.Start' 5);
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: str1 = GetString(this.lexbuf' doctype.Start + 5' 7);
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: str1 = GetString(this.lexbuf' doctype.Start + 5' 7);
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: if (String.Compare(str1' "SYSTEM ") == 0)  			{  				/* but at least ensure the case is correct */  				if (!str1.Substring(0' (6) - (0)).Equals("SYSTEM"))  				{  					Array.Copy(GetBytes("SYSTEM")' 0' this.lexbuf' doctype.Start + 5' 6);  				}  				return 0; /* unrecognized */  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: if (String.Compare(str1' "SYSTEM ") == 0)  			{  				/* but at least ensure the case is correct */  				if (!str1.Substring(0' (6) - (0)).Equals("SYSTEM"))  				{  					Array.Copy(GetBytes("SYSTEM")' 0' this.lexbuf' doctype.Start + 5' 6);  				}  				return 0; /* unrecognized */  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: if (String.Compare(str1' "SYSTEM ") == 0)  			{  				/* but at least ensure the case is correct */  				if (!str1.Substring(0' (6) - (0)).Equals("SYSTEM"))  				{  					Array.Copy(GetBytes("SYSTEM")' 0' this.lexbuf' doctype.Start + 5' 6);  				}  				return 0; /* unrecognized */  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: if (String.Compare(str1' "PUBLIC ") == 0)  			{  				if (!str1.Substring(0' (6) - (0)).Equals("PUBLIC"))  					Array.Copy(GetBytes("PUBLIC ")' 0' this.lexbuf' doctype.Start + 5' 6);  			}  			else  			{  				this.badDoctype = true;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: if (String.Compare(str1' "PUBLIC ") == 0)  			{  				if (!str1.Substring(0' (6) - (0)).Equals("PUBLIC"))  					Array.Copy(GetBytes("PUBLIC ")' 0' this.lexbuf' doctype.Start + 5' 6);  			}  			else  			{  				this.badDoctype = true;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: if (String.Compare(str1' "PUBLIC ") == 0)  			{  				if (!str1.Substring(0' (6) - (0)).Equals("PUBLIC"))  					Array.Copy(GetBytes("PUBLIC ")' 0' this.lexbuf' doctype.Start + 5' 6);  			}  			else  			{  				this.badDoctype = true;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FindGivenVersion,The following statement contains a magic number: for (i = doctype.Start; i < doctype.End; ++i)  			{  				if (this.lexbuf[i] == (byte) '"')  				{  					str1 = GetString(this.lexbuf' i + 1' 12);  					str2 = GetString(this.lexbuf' i + 1' 13);  					if (str1.Equals("-//W3C//DTD "))  					{  						/* compute length of identifier e.g. "HTML 4.0 Transitional" */  						for (j = i + 13; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 13;  						p = GetString(this.lexbuf' i + 13' len);  						  						for (j = 1; j < W3CVersion.Length; ++j)  						{  							s = W3CVersion[j].Name;  							if (len == s.Length && s.Equals(p))  							{  								return W3CVersion[j].Version;  							}  						}  						  						/* else unrecognized version */  					}  					else if (str2.Equals("-//IETF//DTD "))  					{  						/* compute length of identifier e.g. "HTML 2.0" */  						for (j = i + 14; j < doctype.End && this.lexbuf[j] != (byte) '/'; ++j)  							;  						len = j - i - 14;  						  						p = GetString(this.lexbuf' i + 14' len);  						s = W3CVersion[0].Name;  						if (len == s.Length && s.Equals(p))  						{  							return W3CVersion[0].Version;  						}  						  						/* else unrecognized version */  					}  					break;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,SetXhtmlDocType,The following statement contains a magic number: if (sysid.Length + 6 >= this.Options.WrapLen)  			{  				AddStringLiteral("\n\"");  			}  			else  			{  				AddStringLiteral("\n    \"");  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FixXmlPI,The following statement contains a magic number: if (root.Content != null && root.Content.Type == Node.ProcInsTag)  			{  				s = root.Content.Start;  				  				if (this.lexbuf[s] == (byte) 'x' && this.lexbuf[s + 1] == (byte) 'm' && this.lexbuf[s + 2] == (byte) 'l')  				{  					return true;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetCDATA,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}  				/* treat \r\n as \n and \r as \n */  				  				if (c == (int) '/' && lastc == (int) '<')  				{  					if (endtag)  					{  						lines = input.curline;  						columns = input.curcol - 3;  						  						Report.Warning(this' null' null' Report.BAD_CDATA_CONTENT);  					}  					  					start = lexsize + 1; /* to first letter */  					endtag = true;  				}  				else if (c == (int) '>' && start >= 0)  				{  					len = lexsize - start;  					if (len == container.Element.Length)  					{  						str = GetString(lexbuf' start' len);  						if (String.Compare(str' container.Element) == 0)  						{  							txtend = start - 2;  							break;  						}  					}  					  					lines = input.curline;  					columns = input.curcol - 3;  					  					Report.Warning(this' null' null' Report.BAD_CDATA_CONTENT);  					  					/* if javascript insert backslash before / */  					  					if (ParserImpl.isJavaScript(container))  					{  						for (i = lexsize; i > start - 1; --i)  						{  							lexbuf[i] = lexbuf[i - 1];  						}  						  						lexbuf[start - 1] = (byte) '\\';  						lexsize++;  					}  					  					start = - 1;  				}  				else if (c == (int) '\r')  				{  					c = input.ReadChar();  					  					if (c != (int) '\n')  					{  						input.UngetChar(c);  					}  					  					c = (int) '\n';  				}  				  				AddCharToLexer((int) c);  				txtend = lexsize;  				lastc = c;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetCDATA,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}  				/* treat \r\n as \n and \r as \n */  				  				if (c == (int) '/' && lastc == (int) '<')  				{  					if (endtag)  					{  						lines = input.curline;  						columns = input.curcol - 3;  						  						Report.Warning(this' null' null' Report.BAD_CDATA_CONTENT);  					}  					  					start = lexsize + 1; /* to first letter */  					endtag = true;  				}  				else if (c == (int) '>' && start >= 0)  				{  					len = lexsize - start;  					if (len == container.Element.Length)  					{  						str = GetString(lexbuf' start' len);  						if (String.Compare(str' container.Element) == 0)  						{  							txtend = start - 2;  							break;  						}  					}  					  					lines = input.curline;  					columns = input.curcol - 3;  					  					Report.Warning(this' null' null' Report.BAD_CDATA_CONTENT);  					  					/* if javascript insert backslash before / */  					  					if (ParserImpl.isJavaScript(container))  					{  						for (i = lexsize; i > start - 1; --i)  						{  							lexbuf[i] = lexbuf[i - 1];  						}  						  						lexbuf[start - 1] = (byte) '\\';  						lexsize++;  					}  					  					start = - 1;  				}  				else if (c == (int) '\r')  				{  					c = input.ReadChar();  					  					if (c != (int) '\n')  					{  						input.UngetChar(c);  					}  					  					c = (int) '\n';  				}  				  				AddCharToLexer((int) c);  				txtend = lexsize;  				lastc = c;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetCDATA,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}  				/* treat \r\n as \n and \r as \n */  				  				if (c == (int) '/' && lastc == (int) '<')  				{  					if (endtag)  					{  						lines = input.curline;  						columns = input.curcol - 3;  						  						Report.Warning(this' null' null' Report.BAD_CDATA_CONTENT);  					}  					  					start = lexsize + 1; /* to first letter */  					endtag = true;  				}  				else if (c == (int) '>' && start >= 0)  				{  					len = lexsize - start;  					if (len == container.Element.Length)  					{  						str = GetString(lexbuf' start' len);  						if (String.Compare(str' container.Element) == 0)  						{  							txtend = start - 2;  							break;  						}  					}  					  					lines = input.curline;  					columns = input.curcol - 3;  					  					Report.Warning(this' null' null' Report.BAD_CDATA_CONTENT);  					  					/* if javascript insert backslash before / */  					  					if (ParserImpl.isJavaScript(container))  					{  						for (i = lexsize; i > start - 1; --i)  						{  							lexbuf[i] = lexbuf[i - 1];  						}  						  						lexbuf[start - 1] = (byte) '\\';  						lexsize++;  					}  					  					start = - 1;  				}  				else if (c == (int) '\r')  				{  					c = input.ReadChar();  					  					if (c != (int) '\n')  					{  						input.UngetChar(c);  					}  					  					c = (int) '\n';  				}  				  				AddCharToLexer((int) c);  				txtend = lexsize;  				lastc = c;  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following statement contains a magic number: while (true)  			{  				c = input.ReadChar();  				if (c == StreamIn.EndOfStream)  				{  					break;  				}    				if (insertspace && mode != IgnoreWhitespace)  				{  					AddCharToLexer(' ');  					waswhite = true;  					insertspace = false;  				}  				  				/* treat \r\n as \n and \r as \n */  				  				if (c == '\r')  				{  					c = input.ReadChar();  					  					if (c != '\n')  					{  						input.UngetChar(c);  					}  					  					c = '\n';  				}  				  				AddCharToLexer(c);  				  				switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseAsp,The following statement contains a magic number: lexsize -= 2;
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParsePhp,The following statement contains a magic number: lexsize -= 2;
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseValue,The following statement contains a magic number: if (quotewarning > 10 && seen_gt && munge)  			{  				/*  				there is almost certainly a missing trailling quote mark  				as we have see too many newlines' < or > characters.  				  				an exception is made for Javascript attributes and the  				javascript URL scheme which may legitimately include < and >  				*/  				if (!AttributeTable.DefaultAttributeTable.IsScript(name) && !(AttributeTable.DefaultAttributeTable.IsUrl(name) && (GetString(lexbuf' start' 11)).Equals("javascript:")))  					Report.Error(this' null' null' Report.SUSPECTED_MISSING_QUOTE);  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ParseValue,The following statement contains a magic number: if (quotewarning > 10 && seen_gt && munge)  			{  				/*  				there is almost certainly a missing trailling quote mark  				as we have see too many newlines' < or > characters.  				  				an exception is made for Javascript attributes and the  				javascript URL scheme which may legitimately include < and >  				*/  				if (!AttributeTable.DefaultAttributeTable.IsScript(name) && !(AttributeTable.DefaultAttributeTable.IsUrl(name) && (GetString(lexbuf' start' 11)).Equals("javascript:")))  					Report.Error(this' null' null' Report.SUSPECTED_MISSING_QUOTE);  			}
Magic Number,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,MAP,The following statement contains a magic number: return ((int) c < 128 ? (short)lexmap[(int) c] : (short)0);
Magic Number,TidyNet,Node,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Node.cs,TrimTrailingSpace,The following statement contains a magic number: if (last != null && last.Type == Node.TextNode && last.End > last.Start)  			{  				c = lexer.lexbuf[last.End - 1];  				  				if (c == 160 || c == (byte) ' ')  				{  					/* take care with <td>&nbsp;</td> */  					if (element.Tag == tt.TagTd || element.Tag == tt.TagTh)  					{  						if (last.End > last.Start + 1)  						{  							last.End -= 1;  						}  					}  					else  					{  						last.End -= 1;  						  						if (((element.Tag.Model & ContentModel.Inline) != 0) && !((element.Tag.Model & ContentModel.Field) != 0))  						{  							lexer.insertspace = true;  						}  						  						/* if empty string then delete from parse tree */  						if (last.Start == last.End)  						{  							TrimEmptyElement(lexer' last);  						}  					}  				}  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following statement contains a magic number: try  			{  				if (Encoding == CharEncoding.UTF8)  				{  					if (c < 128)  					{  						Output.WriteByte((byte) c);  					}  					else if (c <= 0x7FF)  					{  						ch = (0xC0 | (c >> 6)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0xFFFF)  					{  						ch = (0xE0 | (c >> 12)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else if (c <= 0x1FFFFF)  					{  						ch = (0xF0 | (c >> 18)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  					else  					{  						ch = (0xF8 | (c >> 24)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 18) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 12) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | ((c >> 6) & 0x3F)); Output.WriteByte((byte) ch);  						ch = (0x80 | (c & 0x3F)); Output.WriteByte((byte) ch);  					}  				}  				else if (Encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						State = StreamIn.FSM_ESC;  					}  					else  					{  						switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}  					}  					  					Output.WriteByte((byte) c);  				}  				else  				{  					Output.WriteByte((byte) c);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("OutImpl.outc: " + e.ToString());  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: if ((c & 0xE0) == 0xC0)  			{  				/* 110X XXXX  two bytes */  				n = c & 31;  				bytes = 2;  			}  			else if ((c & 0xF0) == 0xE0)  			{  				/* 1110 XXXX  three bytes */  				n = c & 15;  				bytes = 3;  			}  			else if ((c & 0xF8) == 0xF0)  			{  				/* 1111 0XXX  four bytes */  				n = c & 7;  				bytes = 4;  			}  			else if ((c & 0xFC) == 0xF8)  			{  				/* 1111 10XX  five bytes */  				n = c & 3;  				bytes = 5;  			}  			else if ((c & 0xFE) == 0xFC)  			{  				/* 1111 110X  six bytes */  				n = c & 1;  				bytes = 6;  			}  			else  			{  				/* 0XXX XXXX one byte */  				ch.Val = c;  				return 0;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,GetUTF8,The following statement contains a magic number: for (i = 1; i < bytes; ++i)  			{  				c = ((int) str[start + i]) & 0xFF; // Convert to unsigned.  				n = (n << 6) | (c & 0x3F);  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PutUTF8,The following statement contains a magic number: if (c < 128)  			{  				buf[start++] = (byte) c;  			}  			else if (c <= 0x7FF)  			{  				buf[start++] = (byte) (0xC0 | (c >> 6));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0xFFFF)  			{  				buf[start++] = (byte) (0xE0 | (c >> 12));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else if (c <= 0x1FFFFF)  			{  				buf[start++] = (byte) (0xF0 | (c >> 18));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}  			else  			{  				buf[start++] = (byte) (0xF8 | (c >> 24));  				buf[start++] = (byte) (0x80 | ((c >> 18) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 12) & 0x3F));  				buf[start++] = (byte) (0x80 | ((c >> 6) & 0x3F));  				buf[start++] = (byte) (0x80 | (c & 0x3F));  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,AddC,The following statement contains a magic number: if (index + 1 >= lbufsize)  			{  				while (index + 1 >= lbufsize)  				{  					if (lbufsize == 0)  						lbufsize = 256;  					else  						lbufsize = lbufsize * 2;  				}  				  				int[] temp = new int[lbufsize];  				if (linebuf != null)  					Array.Copy(linebuf' 0' temp' 0' index);  				linebuf = temp;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,AddC,The following statement contains a magic number: if (index + 1 >= lbufsize)  			{  				while (index + 1 >= lbufsize)  				{  					if (lbufsize == 0)  						lbufsize = 256;  					else  						lbufsize = lbufsize * 2;  				}  				  				int[] temp = new int[lbufsize];  				if (linebuf != null)  					Array.Copy(linebuf' 0' temp' 0' index);  				linebuf = temp;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following statement contains a magic number: if (!((mode & CDATA) != 0))  			{  				if (c == '<')  				{  					AddC('&'' linelen++);  					AddC('l'' linelen++);  					AddC('t'' linelen++);  					AddC(';'' linelen++);  					return;  				}  				  				if (c == '>')  				{  					AddC('&'' linelen++);  					AddC('g'' linelen++);  					AddC('t'' linelen++);  					AddC(';'' linelen++);  					return;  				}  				  				/*  				naked '&' chars can be left alone or  				quoted as &amp; The latter is required  				for XML where naked '&' are illegal.  				*/  				if (c == '&' && _options.QuoteAmpersand)  				{  					AddC('&'' linelen++);  					AddC('a'' linelen++);  					AddC('m'' linelen++);  					AddC('p'' linelen++);  					AddC(';'' linelen++);  					return;  				}  				  				if (c == '"' && _options.QuoteMarks)  				{  					AddC('&'' linelen++);  					AddC('q'' linelen++);  					AddC('u'' linelen++);  					AddC('o'' linelen++);  					AddC('t'' linelen++);  					AddC(';'' linelen++);  					return;  				}  				  				if (c == '\'' && _options.QuoteMarks)  				{  					AddC('&'' linelen++);  					AddC('#'' linelen++);  					AddC('3'' linelen++);  					AddC('9'' linelen++);  					AddC(';'' linelen++);  					return;  				}  				  				if (c == 160 && _options.CharEncoding != CharEncoding.Raw)  				{  					if (_options.QuoteNbsp)  					{  						AddC('&'' linelen++);  						  						if (_options.NumEntities)  						{  							AddC('#'' linelen++);  							AddC('1'' linelen++);  							AddC('6'' linelen++);  							AddC('0'' linelen++);  						}  						else  						{  							AddC('n'' linelen++);  							AddC('b'' linelen++);  							AddC('s'' linelen++);  							AddC('p'' linelen++);  						}  						  						AddC(';'' linelen++);  					}  					else  					{  						AddC(c' linelen++);  					}    					return;  				}  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following statement contains a magic number: if (c == 160 && ((mode & PREFORMATTED) != 0))  			{  				AddC(' '' linelen++);  				return;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following statement contains a magic number: if (_options.CharEncoding == CharEncoding.Latin1)  			{  				if (c > 255)  				{  					/* multi byte chars */  					if (!_options.NumEntities)  					{  						entity = EntityTable.DefaultEntityTable.EntityName((short) c);  						if (entity != null)  						{  							entity = "&" + entity + ";";  						}  						else  						{  							entity = "&#" + c + ";";  						}  					}  					else  					{  						entity = "&#" + c + ";";  					}  					  					for (int i = 0; i < entity.Length; i++)  					{  						AddC((int) entity[i]' linelen++);  					}  					  					return;  				}  				  				if (c > 126 && c < 160)  				{  					entity = "&#" + c + ";";  					  					for (int i = 0; i < entity.Length; i++)  					{  						AddC((int) entity[i]' linelen++);  					}  					  					return;  				}  				  				AddC(c' linelen++);  				return;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following statement contains a magic number: if (_options.CharEncoding == CharEncoding.Latin1)  			{  				if (c > 255)  				{  					/* multi byte chars */  					if (!_options.NumEntities)  					{  						entity = EntityTable.DefaultEntityTable.EntityName((short) c);  						if (entity != null)  						{  							entity = "&" + entity + ";";  						}  						else  						{  							entity = "&#" + c + ";";  						}  					}  					else  					{  						entity = "&#" + c + ";";  					}  					  					for (int i = 0; i < entity.Length; i++)  					{  						AddC((int) entity[i]' linelen++);  					}  					  					return;  				}  				  				if (c > 126 && c < 160)  				{  					entity = "&#" + c + ";";  					  					for (int i = 0; i < entity.Length; i++)  					{  						AddC((int) entity[i]' linelen++);  					}  					  					return;  				}  				  				AddC(c' linelen++);  				return;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following statement contains a magic number: if (_options.CharEncoding == CharEncoding.Latin1)  			{  				if (c > 255)  				{  					/* multi byte chars */  					if (!_options.NumEntities)  					{  						entity = EntityTable.DefaultEntityTable.EntityName((short) c);  						if (entity != null)  						{  							entity = "&" + entity + ";";  						}  						else  						{  							entity = "&#" + c + ";";  						}  					}  					else  					{  						entity = "&#" + c + ";";  					}  					  					for (int i = 0; i < entity.Length; i++)  					{  						AddC((int) entity[i]' linelen++);  					}  					  					return;  				}  				  				if (c > 126 && c < 160)  				{  					entity = "&#" + c + ";";  					  					for (int i = 0; i < entity.Length; i++)  					{  						AddC((int) entity[i]' linelen++);  					}  					  					return;  				}  				  				AddC(c' linelen++);  				return;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following statement contains a magic number: if (_options.XmlTags)  			{  				/* if ASCII use numeric entities for chars > 127 */  				if (c > 127 && _options.CharEncoding == CharEncoding.ASCII)  				{  					entity = "&#" + c + ";";  					  					for (int i = 0; i < entity.Length; i++)  					{  						AddC((int) entity[i]' linelen++);  					}  					  					return;  				}  				  				/* otherwise output char raw */  				AddC(c' linelen++);  				return;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following statement contains a magic number: if (c > 126 || (c < ' ' && c != '\t'))  			{  				if (!_options.NumEntities)  				{  					entity = EntityTable.DefaultEntityTable.EntityName((short) c);  					if (entity != null)  					{  						entity = "&" + entity + ";";  					}  					else  					{  						entity = "&#" + c + ";";  					}  				}  				else  				{  					entity = "&#" + c + ";";  				}  				  				for (int i = 0; i < entity.Length; i++)  				{  					AddC((int) entity[i]' linelen++);  				}  				  				return;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttrValue,The following statement contains a magic number: if (valueChars != null && valueChars.Length >= 5 && valueChars[0] == '<')  			{  				char[] tmpChar;  				tmpChar = new char[valueChars.Length];  				valueChars.CopyTo(tmpChar' 0);  				if (valueChars[1] == '%' || valueChars[1] == '@' || (new string(tmpChar' 0' 5)).Equals("<?php"))  					mode |= CDATA;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintAttrValue,The following statement contains a magic number: if (valueChars != null && valueChars.Length >= 5 && valueChars[0] == '<')  			{  				char[] tmpChar;  				tmpChar = new char[valueChars.Length];  				valueChars.CopyTo(tmpChar' 0);  				if (valueChars[1] == '%' || valueChars[1] == '@' || (new string(tmpChar' 0' 5)).Equals("<?php"))  					mode |= CDATA;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,AfterSpace,The following statement contains a magic number: if (prev != null)  			{  				if (prev.Type == Node.TextNode && prev.End > prev.Start)  				{  					c = ((int) prev.Textarray[prev.End - 1]) & 0xFF; // Convert to unsigned.  					  					if (c == 160 || c == ' ' || c == '\n')  					{  						return true;  					}  				}  				  				return false;  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,AddTransitionEffect,The following statement contains a magic number: if (0 <= effect && effect <= 23)  			{  				transition = "revealTrans(Duration=" + (duration).ToString() + "'Transition=" + effect + ")";  			}  			else  			{  				transition = "blendTrans(Duration=" + (duration).ToString() + ")";  			}
Magic Number,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,CreateSlides,The following statement contains a magic number: AddTransitionEffect(lexer' root' EFFECT_BLEND' 3.0);
Magic Number,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,AttrError,The following statement contains a magic number: if (lexer.messages.Errors > 6)  			{  				return;  			}
Magic Number,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,Warning,The following statement contains a magic number: if (lexer.messages.Errors > 6)  			{  				return;  			}
Magic Number,TidyNet,Report,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Report.cs,Error,The following statement contains a magic number: if (lexer.messages.Errors > 6)  			{  				return;  			}
Magic Number,TidyNet,ScriptCheckAttribs,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ScriptCheckAttribs.cs,Check,The following statement contains a magic number: if (type == null)  			{  				Report.AttrError(lexer' node' "type"' Report.MISSING_ATTRIBUTE);    				/* check for javascript */  				if (lang != null)  				{  					string str = lang.Val;  					if (str.Length > 10)  					{  						str = str.Substring(0' 10);  					}    					if ((String.Compare(str' "javascript") == 0) || (String.Compare(str' "jscript") == 0))  					{  						node.AddAttribute("type"' "text/javascript");  					}  				}  				else  				{  					node.AddAttribute("type"' "text/javascript");  				}  			}
Magic Number,TidyNet,ScriptCheckAttribs,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\ScriptCheckAttribs.cs,Check,The following statement contains a magic number: if (type == null)  			{  				Report.AttrError(lexer' node' "type"' Report.MISSING_ATTRIBUTE);    				/* check for javascript */  				if (lang != null)  				{  					string str = lang.Val;  					if (str.Length > 10)  					{  						str = str.Substring(0' 10);  					}    					if ((String.Compare(str' "javascript") == 0) || (String.Compare(str' "jscript") == 0))  					{  						node.AddAttribute("type"' "text/javascript");  					}  				}  				else  				{  					node.AddAttribute("type"' "text/javascript");  				}  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following statement contains a magic number: try  			{  				c = stream.ReadByte();  				if (c == EndOfStream)  				{  					endOfStream = true;  					return c;  				}  				  				/*  				A document in ISO-2022 based encoding uses some ESC sequences  				called "designator" to switch character sets. The designators  				defined and used in ISO-2022-JP are:  				  				"ESC" + "(" + ?     for ISO646 variants  				  				"ESC" + "$" + ?     and  				"ESC" + "$" + "(" + ?   for multibyte character sets  				  				Where ? stands for a single character used to indicate the  				character set for multibyte characters.  				  				Tidy handles this by preserving the escape sequence and  				setting the top bit of each byte for non-ascii chars. This  				bit is then cleared on output. The input stream keeps track  				of the state to determine when to set/clear the bit.  				*/  				  				if (encoding == CharEncoding.ISO2022)  				{  					if (c == 0x1b)  					{  						/* ESC */  						state = FSM_ESC;  						return c;  					}  					  					switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}  					  					return c;  				}  				  				if (encoding != CharEncoding.UTF8)  				{  					return c;  				}  				  				/* deal with UTF-8 encoded char */  				  				if ((c & 0xE0) == 0xC0)  				{  					/* 110X XXXX  two bytes */  					n = c & 31;  					count = 1;  				}  				else if ((c & 0xF0) == 0xE0)  				{  					/* 1110 XXXX  three bytes */  					n = c & 15;  					count = 2;  				}  				else if ((c & 0xF8) == 0xF0)  				{  					/* 1111 0XXX  four bytes */  					n = c & 7;  					count = 3;  				}  				else if ((c & 0xFC) == 0xF8)  				{  					/* 1111 10XX  five bytes */  					n = c & 3;  					count = 4;  				}  				else if ((c & 0xFE) == 0xFC)  				{  					/* 1111 110X  six bytes */  					n = c & 1;  					count = 5;  				}  				else  				{  					/* 0XXX XXXX one byte */  					return c;  				}  				  				/* successor bytes should have the form 10XX XXXX */  				for (i = 1; i <= count; ++i)  				{  					c = stream.ReadByte();  					if (c == EndOfStream)  					{  						endOfStream = true;  						return c;  					}  					  					n = (n << 6) | (c & 0x3F);  				}  			}  			catch (IOException e)  			{  				Console.Error.WriteLine("StreamInImpl.readCharFromStream: " + e.ToString());  				n = EndOfStream;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Magic Number,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadChar,The following statement contains a magic number: for (;;)  			{  				c = ReadCharFromStream();  				if (c < 0)  				{  					return EndOfStream;  				}  				  				if (c == '\n')  				{  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\r')  				{  					c = ReadCharFromStream();  					if (c != '\n')  					{  						UngetChar(c);  						c = '\n';  					}  					curcol = 1;  					curline++;  					break;  				}  				  				if (c == '\t')  				{  					tabs = tabsize - ((curcol - 1) % tabsize) - 1;  					curcol++;  					c = ' ';  					break;  				}  				  				/* strip control characters' except for Esc */  				  				if (c == '\x001B')  				{  					break;  				}  				  				if (0 < c && c < 32)  				{  					continue;  				}    				/* watch out for IS02022 */  				  				if (encoding == CharEncoding.Raw || encoding == CharEncoding.ISO2022)  				{  					curcol++;  					break;  				}  				  				if (encoding == CharEncoding.MacroMan)  				{  					c = Mac2Unicode[c];  				}  				  				/* produced e.g. as a side-effect of smart quotes in Word */  				if (127 < c && c < 160)  				{  					Report.EncodingError((Lexer) Lexer' Report.WINDOWS_CHARS' c);  					  					c = Win2Unicode[c - 128];  					if (c == 0)  					{  						continue;  					}  				}  				  				curcol++;  				break;  			}
Duplicate Code,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The method contains a code clone-set at the following line numbers (starting from the method definition): ((189' 213)' (261' 285))
Duplicate Code,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintSlide,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 37)' (80' 100))
Missing Default,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,ApparentVersion,The following switch statement is missing a default case: switch (this.doctype)  			{  			case HtmlVersion.Unknown:   				return GetHtmlVersion();    			case HtmlVersion.Html20:   				if ((this.versions & HtmlVersion.Html20) != 0)  				{  					return HtmlVersion.Html20;  				}  				break;    			case HtmlVersion.Html32:   				if ((this.versions & HtmlVersion.Html32) != 0)  				{  					return HtmlVersion.Html32;  				}  				break; /* to replace old version by new */    			case HtmlVersion.Html40Strict:   				if ((this.versions & HtmlVersion.Html40Strict) != 0)  				{  					return HtmlVersion.Html40Strict;  				}  				break;  				  			case HtmlVersion.Html40Loose:   				if ((this.versions & HtmlVersion.Html40Loose) != 0)  				{  					return HtmlVersion.Html40Loose;  				}  				break; /* to replace old version by new */    			case HtmlVersion.Frames:  				if ((this.versions & HtmlVersion.Frames) != 0)  				{  					return HtmlVersion.Frames;  				}  				break;  			}
Missing Default,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,FixDocType,The following switch statement is missing a default case: switch (this.doctype)  					{  					case HtmlVersion.Unknown:  						return false;    					case HtmlVersion.Html20:  						if ((this.versions & HtmlVersion.Html20) != 0)  						{  							return true;  						}  						break; /* to replace old version by new */  						  						  					case HtmlVersion.Html32:  						if ((this.versions & HtmlVersion.Html32) != 0)  						{  							return true;  						}  						break; /* to replace old version by new */  						  						  					case HtmlVersion.Html40Strict:  						if ((this.versions & HtmlVersion.Html40Strict) != 0)  						{  							return true;  						}  						break; /* to replace old version by new */  						  						  					case HtmlVersion.Html40Loose:  						if ((this.versions & HtmlVersion.Html40Loose) != 0)  						{  							return true;  						}  						break; /* to replace old version by new */  						  						  					case HtmlVersion.Frames:  						if ((this.versions & HtmlVersion.Frames) != 0)  						{  							return true;  						}  						break; /* to replace old version by new */  					}
Missing Default,TidyNet,Lexer,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\Lexer.cs,GetToken,The following switch statement is missing a default case: switch (state)  				{  				case LEX_CONTENT:   					map = MAP((char) c);  						  					/*  						Discard white space if appropriate. Its cheaper  						to do this here rather than in parser methods  						for elements that don't have mixed content.  						*/  					if (((map & WHITE) != 0) && (mode == IgnoreWhitespace) && lexsize == txtstart + 1)  					{  						--lexsize;  						waswhite = false;  						lines = input.curline;  						columns = input.curcol;  						continue;  					}  						  					if (c == '<')  					{  						state = LEX_GT;  						continue;  					}  						  					if ((map & WHITE) != 0)  					{  						/* was previous char white? */  						if (waswhite)  						{  							if (mode != Preformatted && mode != IgnoreMarkup)  							{  								--lexsize;  								lines = input.curline;  								columns = input.curcol;  							}  						}  							/* prev char wasn't white */  						else  						{  							waswhite = true;  							lastc = c;  								  							if (mode != Preformatted && mode != IgnoreMarkup && c != ' ')  							{  								ChangeChar((byte) ' ');  							}  						}  							  						continue;  					}  					else if (c == '&' && mode != IgnoreMarkup)  					{  						ParseEntity(mode);  					}  						  					/* this is needed to avoid trimming trailing whitespace */  					if (mode == IgnoreWhitespace)  						mode = MixedContent;  						  					waswhite = false;  					continue;  					  					  				case LEX_GT:   					if (c == '/')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  						map = MAP((char) c);  							  						if ((map & LETTER) != 0)  						{  							lexsize -= 3;  							txtend = lexsize;  							input.UngetChar(c);  							state = LEX_ENDTAG;  							lexbuf[lexsize] = (byte) '\x0000'; /* debug */  							input.curcol -= 2;  								  							/* if some text before the </ return it now */  							if (txtend > txtstart)  							{  								/* trim space char before end tag */  								if (mode == IgnoreWhitespace && lexbuf[lexsize - 1] == (byte) ' ')  								{  									lexsize -= 1;  									txtend = lexsize;  								}  									  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							continue; /* no text so keep going */  						}  							  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					if (mode == IgnoreMarkup)  					{  						/* otherwise treat as CDATA */  						waswhite = false;  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						look out for comments' doctype or marked sections  						this isn't quite right' but its getting there ...  						*/  					if (c == '!')  					{  						c = input.ReadChar();  						if (c == '-')  						{  							c = input.ReadChar();  							if (c == '-')  							{  								state = LEX_COMMENT; /* comment */  								lexsize -= 2;  								txtend = lexsize;  									  								/* if some text before < return it now */  								if (txtend > txtstart)  								{  									token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  									return token;  								}  									  								txtstart = lexsize;  								continue;  							}  								  							Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  						}  						else if (c == 'd' || c == 'D')  						{  							state = LEX_DOCTYPE; /* doctype */  							lexsize -= 2;  							txtend = lexsize;  							mode = IgnoreWhitespace;  								  							/* skip until white space or '>' */  								  							for (; ; )  							{  								c = input.ReadChar();  									  								if (c == StreamIn.EndOfStream || c == '>')  								{  									input.UngetChar(c);  									break;  								}  									  								map = MAP((char) c);  								if ((map & WHITE) == 0)  								{  									continue;  								}  									  								/* and skip to end of whitespace */  									  								for (; ; )  								{  									c = input.ReadChar();  										  									if (c == StreamIn.EndOfStream || c == '>')  									{  										input.UngetChar(c);  										break;  									}  										  									map = MAP((char) c);  										  									if ((map & WHITE) != 0)  									{  										continue;  									}  										  									input.UngetChar(c);  									break;  								}  									  								break;  							}  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  						else if (c == '[')  						{  							/* Word 2000 embeds <![if ...]> ... <![endif]> sequences */  							lexsize -= 2;  							state = LEX_SECTION;  							txtend = lexsize;  								  							/* if some text before < return it now */  							if (txtend > txtstart)  							{  								token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  								return token;  							}  								  							txtstart = lexsize;  							continue;  						}  							  						/* otherwise swallow chars up to and including next '>' */  						while (true)  						{  							c = input.ReadChar();  							if (c == '>')  							{  								break;  							}  							if (c == - 1)  							{  								input.UngetChar(c);  								break;  							}  						}  							  						lexsize -= 2;  						lexbuf[lexsize] = (byte) '\x0000';  						state = LEX_CONTENT;  						continue;  					}  						  					/*  						processing instructions  						*/  						  					if (c == '?')  					{  						lexsize -= 2;  						state = LEX_PROCINSTR;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Microsoft ASP's e.g. <% ... server-code ... %> */  					if (c == '%')  					{  						lexsize -= 2;  						state = LEX_ASP;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					/* Netscapes JSTE e.g. <# ... server-code ... #> */  					if (c == '#')  					{  						lexsize -= 2;  						state = LEX_JSTE;  						txtend = lexsize;  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						txtstart = lexsize;  						continue;  					}  						  					map = MAP((char) c);  						  					/* check for start tag */  					if ((map & LETTER) != 0)  					{  						input.UngetChar(c); /* push back letter */  						lexsize -= 2; /* discard "<" + letter */  						txtend = lexsize;  						state = LEX_STARTTAG; /* ready to read tag name */  							  						/* if some text before < return it now */  						if (txtend > txtstart)  						{  							token = NewNode(Node.TextNode' lexbuf' txtstart' txtend);  							return token;  						}  							  						continue; /* no text so keep going */  					}  						  					/* otherwise treat as CDATA */  					state = LEX_CONTENT;  					waswhite = false;  					continue;  					  					  				case LEX_ENDTAG:   					txtstart = lexsize - 1;  					input.curcol += 2;  					c = ParseTagName();  					token = NewNode(Node.EndTag' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  					lexsize = txtstart;  					txtend = txtstart;  						  					/* skip to '>' */  					while (c != '>')  					{  						c = input.ReadChar();  						if (c == StreamIn.EndOfStream)  						{  							break;  						}  					}  						  					if (c == StreamIn.EndOfStream)  					{  						input.UngetChar(c);  						continue;  					}  						  					state = LEX_CONTENT;  					waswhite = false;  					return token; /* the endtag token */  					  					  				case LEX_STARTTAG:   					txtstart = lexsize - 1; /* set txtstart to first letter */  					c = ParseTagName();  					isempty.Val = false;  					attributes = null;  					token = NewNode((isempty.Val ? Node.StartEndTag : Node.StartTag)' lexbuf' txtstart' txtend' GetString(lexbuf' txtstart' txtend - txtstart));  						  					/* parse attributes' consuming closing ">" */  					if (c != '>')  					{  						if (c == '/')  						{  							input.UngetChar(c);  						}  							  						attributes = ParseAttrs(isempty);  					}  						  					if (isempty.Val)  					{  						token.Type = Node.StartEndTag;  					}  						  					token.Attributes = attributes;  					lexsize = txtstart;  					txtend = txtstart;  						  					/* swallow newline following start tag */  					/* special check needed for CRLF sequence */  					/* this doesn't apply to empty elements */  						  					if (ExpectsContent(token) || token.Tag == Options.tt.TagBr)  					{  						c = input.ReadChar();  						if (c == '\r')  						{  							c = input.ReadChar();  								  							if (c != '\n')  							{  								input.UngetChar(c);  							}  						}  						else if (c != '\n' && c != '\f')  						{  							input.UngetChar(c);  						}  							  						waswhite = true; /* to swallow leading whitespace */  					}  					else  					{  						waswhite = false;  					}  						  					state = LEX_CONTENT;  						  					if (token.Tag == null)  					{  						Report.Error(this' null' token' Report.UNKNOWN_ELEMENT);  					}  					else if (!Options.XmlTags)  					{  						versions &= token.Tag.Versions;  							  						if ((token.Tag.Versions & HtmlVersion.Proprietary) != 0)  						{  							if (!Options.MakeClean && (token.Tag == Options.tt.TagNobr || token.Tag == Options.tt.TagWbr))  							{  								Report.Warning(this' null' token' Report.PROPRIETARY_ELEMENT);  							}  						}  							  						if (token.Tag.CheckAttribs != null)  						{  							token.CheckUniqueAttributes(this);  							token.Tag.CheckAttribs.Check(this' this.token);  						}  						else  						{  							token.CheckAttributes(this);  						}  					}  					return token; /* return start tag */    				case LEX_COMMENT:   					if (c != '-')  					{  						continue;  					}  						  					c = input.ReadChar();  					AddCharToLexer(c);  					if (c != '-')  					{  						continue;  					}  						  					while (true)  					{  						c = input.ReadChar();  							  						if (c == '>')  						{  							if (badcomment != 0)  							{  								Report.Warning(this' null' null' Report.MALFORMED_COMMENT);  							}  								  							txtend = lexsize - 2; // AQ 8Jul2000  							lexbuf[lexsize] = (byte) '\x0000';  							state = LEX_CONTENT;  							waswhite = false;  							token = NewNode(Node.CommentTag' lexbuf' txtstart' txtend);  								  							/* now look for a line break */  								  							c = input.ReadChar();  								  							if (c == '\r')  							{  								c = input.ReadChar();  									  								if (c != '\n')  								{  									token.Linebreak = true;  								}  							}  								  							if (c == '\n')  							{  								token.Linebreak = true;  							}  							else  							{  								input.UngetChar(c);  							}  								  							return token;  						}  							  						/* note position of first such error in the comment */  						if (badcomment == 0)  						{  							lines = input.curline;  							columns = input.curcol - 3;  						}  							  						badcomment++;  						if (Options.FixComments)  						{  							lexbuf[lexsize - 2] = (byte) '=';  						}  							  						AddCharToLexer(c);  							  						/* if '-' then look for '>' to end the comment */  						if (c != '-')  						{  							break;  						}  					}  						  					/* otherwise continue to look for --> */  					lexbuf[lexsize - 2] = (byte) '=';  					continue;  					  					  				case LEX_DOCTYPE:   					map = MAP((char) c);  						  					if ((map & WHITE) != 0)  					{  						if (waswhite)  						{  							lexsize -= 1;  						}  							  						waswhite = true;  					}  					else  					{  						waswhite = false;  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.DocTypeTag' lexbuf' txtstart' txtend);  					/* make a note of the version named by the doctype */  					doctype = FindGivenVersion(token);  					return token;  					  					  				case LEX_PROCINSTR:   						  					if (lexsize - txtstart == 3)  					{  						if ((GetString(lexbuf' txtstart' 3)).Equals("php"))  						{  							state = LEX_PHP;  							continue;  						}  					}  						  					if (Options.XmlPIs)  					{  						/* insist on ?> as terminator */  						if (c != '?')  						{  							continue;  						}  							  						/* now look for '>' */  						c = input.ReadChar();  							  						if (c == StreamIn.EndOfStream)  						{  							Report.Warning(this' null' null' Report.UNEXPECTED_END_OF_FILE);  							input.UngetChar(c);  							continue;  						}  							  						AddCharToLexer(c);  					}  						  					if (c != '>')  					{  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.ProcInsTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_ASP:   					if (c != '%')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();    					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.AspTag' lexbuf' txtstart' txtend);  					return this.token;    				case LEX_JSTE:   					if (c != '#')  					{  						continue;  					}  	  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.JsteTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_PHP:   					if (c != '?')  					{  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.PhpTag' lexbuf' txtstart' txtend);  					return token;  					  					  				case LEX_SECTION:   					if (c == '[')  					{  						if (lexsize == (txtstart + 6) && (GetString(lexbuf' txtstart' 6)).Equals("CDATA["))  						{  							state = LEX_CDATA;  							lexsize -= 6;  							continue;  						}  					}  						  					if (c != ']')  					{  						continue;  					}    					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.SectionTag' lexbuf' txtstart' txtend);  					return token;    				case LEX_CDATA:   					if (c != ']')  					{  						continue;  					}    					/* now look for ']' */  					c = input.ReadChar();  					if (c != ']')  					{  						input.UngetChar(c);  						continue;  					}  						  					/* now look for '>' */  					c = input.ReadChar();  					if (c != '>')  					{  						input.UngetChar(c);  						continue;  					}  						  					lexsize -= 1;  					txtend = lexsize;  					lexbuf[lexsize] = (byte) '\x0000';  					state = LEX_CONTENT;  					waswhite = false;  					token = NewNode(Node.CDATATag' lexbuf' txtstart' txtend);  					return token;  				}
Missing Default,TidyNet,OutImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\OutImpl.cs,Outc,The following switch statement is missing a default case: switch (State)  						{  						case StreamIn.FSM_ESC:   							if (c == '$')  							{  								State = StreamIn.FSM_ESCD;  							}  							else if (c == '(')  							{  								State = StreamIn.FSM_ESCP;  							}  							else  							{  								State = StreamIn.FSM_ASCII;  							}  							break;  							  						case StreamIn.FSM_ESCD:   							if (c == '(')  							{  								State = StreamIn.FSM_ESCDP;  							}  							else  							{  								State = StreamIn.FSM_NONASCII;  							}  							break;    						case StreamIn.FSM_ESCDP:   							State = StreamIn.FSM_NONASCII;  							break;    						case StreamIn.FSM_ESCP:   							State = StreamIn.FSM_ASCII;  							break;    						case StreamIn.FSM_NONASCII:   							c &= 0x7F;  							break;  						}
Missing Default,TidyNet,PPrint,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\PPrint.cs,PrintChar,The following switch statement is missing a default case: switch (c)  					{  					case 0x2013:   					case 0x2014:   						c = '-';  						break;    					case 0x2018:   					case 0x2019:   					case 0x201A:   						c = '\'';  						break;    					case 0x201C:   					case 0x201D:   					case 0x201E:   						c = '"';  						break;  					}
Missing Default,TidyNet,StreamInImpl,C:\repos\mlocati_betterpoeditor\src\TidyNet\tidy\StreamInImpl.cs,ReadCharFromStream,The following switch statement is missing a default case: switch (state)  					{  					case FSM_ESC:   						if (c == '$')  						{  							state = FSM_ESCD;  						}  						else if (c == '(')  						{  							state = FSM_ESCP;  						}  						else  						{  							state = FSM_ASCII;  						}  						break;  						  						  					case FSM_ESCD:   						if (c == '(')  						{  							state = FSM_ESCDP;  						}  						else  						{  							state = FSM_NONASCII;  						}  						break;  						  						  					case FSM_ESCDP:   						state = FSM_NONASCII;  						break;    					case FSM_ESCP:   						state = FSM_ASCII;  						break;    					case FSM_NONASCII:   						c |= 0x80;  						break;  					}
