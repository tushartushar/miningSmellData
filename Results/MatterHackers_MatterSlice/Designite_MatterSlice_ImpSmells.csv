Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The method has 142 lines of code.
Long Method,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The method has 171 lines of code.
Long Method,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,ExtruderData,The method has 108 lines of code.
Long Method,MatterHackers.MatterSlice,MatterSlice,C:\repos\MatterHackers_MatterSlice\main.cs,ProcessArgs,The method has 103 lines of code.
Long Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,ProcessSliceData,The method has 110 lines of code.
Long Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The method has 213 lines of code.
Long Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The method has 206 lines of code.
Long Method,MatterHackers.MatterSlice,PathOrderOptimizer,C:\repos\MatterHackers_MatterSlice\PathOrderOptimizer.cs,Optimize,The method has 142 lines of code.
Complex Method,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,GenerateTopAndBottoms,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ForceMinimumLayerTime,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,Cyclomatic complexity of the method is 20
Complex Method,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,GetSingleIslandAngle,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,BridgeAngle,Cyclomatic complexity of the method is 14
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GenerateRaftOutlines,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,Cyclomatic complexity of the method is 24
Complex Method,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,GetTouchingSegmentIndex,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,ExtruderData,Cyclomatic complexity of the method is 14
Complex Method,MatterHackers.MatterSlice,MatterSlice,C:\repos\MatterHackers_MatterSlice\main.cs,ProcessArgs,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,ProcessSliceData,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,Cyclomatic complexity of the method is 30
Complex Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,Cyclomatic complexity of the method is 26
Complex Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,Cyclomatic complexity of the method is 14
Complex Method,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,Cyclomatic complexity of the method is 20
Complex Method,MatterHackers.MatterSlice,PathOrderOptimizer,C:\repos\MatterHackers_MatterSlice\PathOrderOptimizer.cs,Optimize,Cyclomatic complexity of the method is 17
Complex Method,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateConcentricInfill,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,BooleanProcessing,C:\repos\MatterHackers_MatterSlice\MultiExtruders.cs,BooleanProcessing,Cyclomatic complexity of the method is 8
Long Parameter List,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,GenerateTopAndBottoms,The method has 5 parameters. Parameters: layerIndex' extrusionWidth_um' outerPerimeterWidth_um' downLayerCount' upLayerCount
Long Parameter List,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,InitializeLayerData,The method has 5 parameters. Parameters: slicer' config' extruderIndex' extruderCount' extraPathingConsideration
Long Parameter List,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,GenerateFillConsideringBridging,The method has 5 parameters. Parameters: bottomFillIsland' bottomFillLines' config' bridgePolygons' debugName
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GenerateSkirt,The method has 6 parameters. Parameters: distance' extrusionWidth_um' numberOfLoops' brimCount' minLength' config
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GenerateWipeTowerInfill,The method has 5 parameters. Parameters: extruderIndex' partOutline' outputfillPolygons' extrusionWidth_um' config
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,PrimeOnWipeTower,The method has 5 parameters. Parameters: extruderIndex' layerIndex' gcodeLayer' fillConfig' config
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GetSkirtBounds,The method has 6 parameters. Parameters: config' storage' externalOnly' distance' extrusionWidth_um' brimCount
Long Parameter List,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,GetInsides,The method has 6 parameters. Parameters: insides' content' startingChar' endingChar' startIndex' endIndex
Long Parameter List,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The method has 6 parameters. Parameters: slicingData' layerGcodePlanner' extruderIndex' layerIndex' extrusionWidth_um' currentZ_um
Long Parameter List,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueClosetsInset,The method has 5 parameters. Parameters: insetsToConsider' limitDistance' pathConfig' layerIndex' gcodeLayer
Long Parameter List,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The method has 6 parameters. Parameters: slicingData' layerGcodePlanner' extruderIndex' layerIndex' extrusionWidth_um' currentZ_um
Long Parameter List,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePolygonsConsideringSupport,The method has 5 parameters. Parameters: layerIndex' gcodeLayer' polygonsToWrite' fillConfig' supportWriteType
Long Parameter List,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,GetSegmentsConsideringSupport,The method has 6 parameters. Parameters: polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' forAirGap' closedLoop
Long Parameter List,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The method has 8 parameters. Parameters: slicingData' extruderIndex' layerIndex' part' bottomFillLines' fillPolygons' topFillPolygons' bridgePolygons
Long Parameter List,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetRetractionSettings,The method has 8 parameters. Parameters: retractionAmount' retractionSpeed' extruderSwitchRetraction' minimumExtrusionBeforeRetraction_mm' retractionZHop_mm' wipeAfterRetraction' unretractExtrusionExtra_mm' unretractExtraOnExtruderSwitch_mm
Long Parameter List,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,SetPositionAndSize,The method has 5 parameters. Parameters: simpleMeshCollection' xCenter_um' yCenter_um' zClip_um' centerObjectInXy
Long Parameter List,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,convex3,The method has 6 parameters. Parameters: x0' y0' x1' y1' x2' y2
Long Parameter List,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateGridInfill,The method has 5 parameters. Parameters: config' partOutline' fillPolygons' fillAngle' linespacing_um
Long Parameter List,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexagonInfill,The method has 5 parameters. Parameters: config' partOutline' fillPolygons' fillAngle' layerIndex
Long Parameter List,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The method has 6 parameters. Parameters: in_outline' result' lineSpacing' infillExtendIntoPerimeter_um' rotationDegrees' layerIndex
Long Parameter List,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateLineInfill,The method has 5 parameters. Parameters: config' partOutline' fillPolygons' fillAngle' linespacing_um
Long Parameter List,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateLinePaths,The method has 6 parameters. Parameters: polygonToInfill' infillLinesToPrint' lineSpacing' infillExtendIntoPerimeter_um' rotation' rotationOffset
Long Identifier,MatterHackers.MatterSlice,LayerIsland,C:\repos\MatterHackers_MatterSlice\LayerIsland.cs,,The length of the parameter minimumDistanceToCreateNewPosition is 34.
Long Identifier,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The length of the parameter minimumDistanceToCreateNewPosition is 34.
Long Identifier,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetRetractionSettings,The length of the parameter minimumExtrusionBeforeRetraction_mm is 35.
Long Identifier,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetRetractionSettings,The length of the parameter unretractExtraOnExtruderSwitch_mm is 33.
Long Identifier,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,,The length of the parameter extrusionAmountAtPreviousRetraction_mm is 38.
Long Identifier,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,,The length of the parameter minimumExtrusionBeforeRetraction_mm is 35.
Long Identifier,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,,The length of the parameter unretractExtraOnExtruderSwitch_mm is 33.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,GenerateTopAndBottoms,The length of the statement  "						bottomOutlines = RemoveIslandsFromPolygons(extruder.Layers[layerIndex - 1].Islands' island.BoundingBox' bottomOutlines); " is 120.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,GenerateTopAndBottoms,The length of the statement  "							totalPartsToRemove = AddIslandsToPolygons(extruder.Layers[layerToTest].Islands' island.BoundingBox' totalPartsToRemove); " is 120.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,GenerateTopAndBottoms,The length of the statement  "							totalPartsToRemove = AddIslandsToPolygons(extruder.Layers[layerToTest].Islands' island.BoundingBox' totalPartsToRemove); " is 120.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,InitializeLayerData,The length of the statement  "				LogOutput.Log("Generating Layer Outlines {0}/{1}\n".FormatWith(start + layerIndex + 1' extruderCount * slicer.layers.Count)); " is 125.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,AddIslandsToPolygons,The length of the statement  "						polysToIntersect = polysToIntersect.CreateUnion(islands[islandIndex].InsetToolPaths[islands[islandIndex].InsetToolPaths.Count - 1]); " is 132.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,RemoveIslandsFromPolygons,The length of the statement  "						polygonsToSubtractFrom = polygonsToSubtractFrom.CreateDifference(islands[islandIndex].InsetToolPaths[islands[islandIndex].InsetToolPaths.Count - 1]); " is 149.
Long Statement,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ForceMinimumLayerTime,The length of the statement  "				//Only slow down with the minimum time if that will be slower then a factor already set. First layer slowdown also sets the speed factor. " is 137.
Long Statement,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The length of the statement  "					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2)) " is 136.
Long Statement,MatterHackers.MatterSlice,IntPointSorter,C:\repos\MatterHackers_MatterSlice\GrahamScan.cs,ComparePoints,The length of the statement  "					double distanceA = Math.Sqrt((((long)lowestPoint.X - a.X) * ((long)lowestPoint.X - a.X)) + (((long)lowestPoint.Y - a.Y) * ((long)lowestPoint.Y - a.Y))); " is 152.
Long Statement,MatterHackers.MatterSlice,IntPointSorter,C:\repos\MatterHackers_MatterSlice\GrahamScan.cs,ComparePoints,The length of the statement  "					double distanceB = Math.Sqrt((((long)lowestPoint.X - b.X) * ((long)lowestPoint.X - b.X)) + (((long)lowestPoint.Y - b.Y) * ((long)lowestPoint.Y - b.Y))); " is 152.
Long Statement,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,GenerateFillConsideringBridging,The length of the statement  "				// TODO: Make this code handle very complex pathing between different sizes or layouts of support under the island to fill. " is 123.
Long Statement,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,GenerateFillConsideringBridging,The length of the statement  "				Infill.GenerateLinePaths(bottomFillIsland' bridgePolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' bridgeAngle); " is 135.
Long Statement,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,GenerateFillConsideringBridging,The length of the statement  "				Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle); " is 151.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "						wipeShield = wipeShield.CreateUnion(this.Extruders[extruderIndex].Layers[layerIndex].Islands[islandIndex].IslandOutline.Offset(config.WipeShieldDistanceFromShapes_um)); " is 168.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "			int offsetAngle = (int)Math.Tan(60.0 * Math.PI / 180) * config.LayerThickness_um;//Allow for a 60deg angle in the wipeShield. " is 125.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "				this.wipeShield[layerIndex] = this.wipeShield[layerIndex].CreateUnion(this.wipeShield[layerIndex - 1].Offset(-offsetAngle)); " is 124.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "				this.wipeShield[layerIndex - 1] = this.wipeShield[layerIndex - 1].CreateUnion(this.wipeShield[layerIndex].Offset(-offsetAngle)); " is 128.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The length of the statement  "			wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um' this.modelMax.Y + 3000 + config.WipeTowerSize_um)); " is 133.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The length of the statement  "			this.wipePoint = new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um / 2' this.modelMax.Y + 3000 + config.WipeTowerSize_um / 2); " is 138.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,DumpLayerparts,The length of the statement  "					streamToWriteTo.Write("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" style=\"width: 500px; height:500px\">\n"); " is 123.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,DumpLayerparts,The length of the statement  "								streamToWriteTo.Write("{0}'{1} ".FormatWith((float)(part.IslandOutline[j][k].X - modelMin.X) / modelSize.X * 500' (float)(part.IslandOutline[j][k].Y - modelMin.Y) / modelSize.Y * 500)); " is 185.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GenerateRaftOutlines,The length of the statement  "					storage.raftOutline = storage.raftOutline.CreateUnion(layer.Islands[partIndex].IslandOutline.Offset(extraDistanceAroundPart_um)); " is 129.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GenerateRaftOutlines,The length of the statement  "				storage.raftOutline = storage.raftOutline.CreateUnion(storage.support.GetBedOutlines().Offset(extraDistanceAroundPart_um)); " is 123.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "				raftSurfaceConfig.SetData((config.RaftSurfacePrintSpeed > 0) ? config.RaftSurfacePrintSpeed : config.RaftPrintSpeed' config.RaftSurfaceExtrusionWidth_um' "SUPPORT"); " is 165.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 150.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "						Infill.GenerateLinePaths(raftIsland.Offset(-config.RaftBaseExtrusionWidth_um) ' raftLines' config.RaftBaseLineSpacing_um' config.InfillExtendIntoPerimeter_um' 0); " is 162.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 150.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45); " is 134.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 150.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceThickness_um * raftSurfaceIndex); " is 126.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "						// make sure the top layer of the raft is 90 degrees offset to the first layer of the part so that it has minimum contact points. " is 129.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90); " is 161.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 90 * raftSurfaceIndex); " is 151.
Long Statement,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The length of the statement  "			// Link up all the missing ends' closing up the smallest gaps first. This is an inefficient implementation which can run in O(n*n*n) time. " is 138.
Long Statement,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The length of the statement  "						IntPoint diff1 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][0]; " is 126.
Long Statement,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The length of the statement  "							IntPoint diff2 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][openPolygonList[polygonBIndex].Count - 1]; " is 165.
Long Statement,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.start.X = (long)(singlePointOnSide.X + (double)(otherSide1.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5); " is 177.
Long Statement,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.start.Y = (long)(singlePointOnSide.Y + (double)(otherSide1.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5); " is 177.
Long Statement,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.end.X = (long)(singlePointOnSide.X + (double)(otherSide2.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5); " is 175.
Long Statement,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.end.Y = (long)(singlePointOnSide.Y + (double)(otherSide2.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5); " is 175.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueAirGappedBottomLayer,The length of the statement  "						Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueAirGappedBottomLayer,The length of the statement  "						Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueInterfaceSupportLayer,The length of the statement  "					Infill.GenerateLineInfill(config' interfaceOutline' supportLines' config.InfillStartingAngle + 90' config.ExtrusionWidth_um); " is 125.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "					Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.ExtrusionWidth_um); " is 129.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "							Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "							Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,PushUpTops,The length of the statement  "				for (int layerToAddToIndex = Math.Min(layerIndex + layersFor2Mm' numLayers - 1); layerToAddToIndex >= 0; layerToAddToIndex--) " is 125.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,PushUpTops,The length of the statement  "				pushedUpPolys[layerIndex] = Clipper.CleanPolygons(curLayerPolys.Offset(config.ExtrusionWidth_um + config.SupportXYDistance_um)' cleanDistance_um); " is 146.
Long Statement,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,RemoveSelfSupportedSections,The length of the statement  "						allRequiredSupportOutlines[layerIndex] = Clipper.CleanPolygons(allRequiredSupportOutlines[layerIndex]' cleanDistance_um); " is 121.
Long Statement,MatterHackers.MatterSlice,MatterSlice,C:\repos\MatterHackers_MatterSlice\main.cs,print_usage,The length of the statement  "			LogOutput.LogError("usage: MatterSlice [-h] [-d] [-v] [-t] [-m 3x3matrix]\n       [-b boolean math] [-c <config file>]\n       [-s <settingkey>=<value>] -o <output.gcode> <model.stl>\n\n"); " is 189.
Long Statement,MatterHackers.MatterSlice,MatterSlice,C:\repos\MatterHackers_MatterSlice\main.cs,print_usage,The length of the statement  "			LogOutput.LogError("    -d Save the currently loaded settings to settings.ini (useful to see\n       all settings).\n"); " is 120.
Long Statement,MatterHackers.MatterSlice,MatterSlice,C:\repos\MatterHackers_MatterSlice\main.cs,print_usage,The length of the statement  "			LogOutput.LogError("    -b A string describing the boolean math to do on the loaded models.\n       (indexA'indexB) - parentheses = union\n       {indexA'indexBToRemove} - curly brackets = difference\n       [indexA'indexB] - square brackets = intersection\n       Example: b (0'[1'{2'3}]) intersect 2+3' remove from 1' union with 0\n"); " is 337.
Long Statement,MatterHackers.MatterSlice,MatterSlice,C:\repos\MatterHackers_MatterSlice\main.cs,print_usage,The length of the statement  "			LogOutput.LogError("    -c A config file to apply to the current settings.\n       Can be applied multiple times.\n       Formated like the default.ini (partial settings are fine).\n"); " is 185.
Long Statement,MatterHackers.MatterSlice,MatterSlice,C:\repos\MatterHackers_MatterSlice\main.cs,print_usage,The length of the statement  "			LogOutput.LogError("    -s Specify a setting on the command line.\n       Uses the same names and values as default.ini.\n"); " is 125.
Long Statement,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,DumpSettings,The length of the statement  "						lines.Add("{0}={1} # {2}{3}".FormatWith(name' value' GetEnumHelpText(property.PropertyType' property.PropertyType.Name)' fieldDescription)); " is 140.
Long Statement,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetSetting,The length of the statement  "				// TODO: No one makes use of the LegacyName attribute thus the possibleNames HashSet and the LegacyName class could be removed as part of a code cleanup pass " is 157.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "			stream.Write("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" style='width:{0}px;height:{1}px'>\n".FormatWith((int)(size.X / scale)' (int)(size.Y / scale))); " is 167.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "			stream.Write("<marker id='MidMarker' viewBox='0 0 10 10' refX='5' refY='5' markerUnits='strokeWidth' markerWidth='10' markerHeight='10' stroke='lightblue' stroke-width='2' fill='none' orient='auto'>"); " is 201.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "					stream.Write("{0}'{1} "' (double)(polygon[intPointIndex].X - bounds.minX) / scale' (double)(polygon[intPointIndex].Y - bounds.maxY) / scale); " is 141.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "					stream.Write("{0}'{1} "' (double)(openPolygon[n].X - bounds.minX) / scale' (double)(openPolygon[n].Y - bounds.maxY) / scale); " is 125.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,DoProcessing,The length of the statement  "			optomizedMeshCollection.SetPositionAndSize(simpleMeshCollection' config.PositionToPlaceObjectCenter_um.X' config.PositionToPlaceObjectCenter_um.Y' -config.BottomClipAmount_um' config.CenterObjectInXy); " is 201.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,DoProcessing,The length of the statement  "				LogOutput.Log("  Face counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count) * 100)); " is 377.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,DoProcessing,The length of the statement  "				LogOutput.Log("  Vertex counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3) * 100)); " is 377.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,preSetup,The length of the statement  "			gcode.SetRetractionSettings(config.RetractionOnTravel' config.RetractionSpeed' config.RetractionOnExtruderSwitch' config.MinimumExtrusionBeforeRetraction' config.RetractionZHop' config.WipeAfterRetraction' config.UnretractExtraExtrusion' config.UnretractExtraOnExtruderSwitch); " is 277.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,SliceModels,The length of the statement  "			for (int optimizedMeshIndex = 0; optimizedMeshIndex < optomizedMeshCollection.OptimizedMeshes.Count; optimizedMeshIndex++) " is 122.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,SliceModels,The length of the statement  "				slicingData.Extruders[extruderIndex].InitializeLayerData(extruderList[extruderIndex]' config' extruderIndex' extruderList.Count' extraPathingConsideration); " is 156.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,SliceModels,The length of the statement  "						slicingData.Extruders[extruderIndex].Layers[layerIndex].LayerZ += config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um; " is 128.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,ProcessSliceData,The length of the statement  "						layer.GenerateInsets(config.FirstLayerExtrusionWidth_um' config.FirstLayerExtrusionWidth_um' insetCount' config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter); " is 171.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,ProcessSliceData,The length of the statement  "						layer.GenerateInsets(config.ExtrusionWidth_um' config.OutsideExtrusionWidth_um' insetCount' config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter); " is 158.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,ProcessSliceData,The length of the statement  "							slicingData.Extruders[extruderIndex].GenerateTopAndBottoms(layerIndex' config.FirstLayerExtrusionWidth_um' config.FirstLayerExtrusionWidth_um' config.NumberOfBottomLayers' config.NumberOfTopLayers); " is 198.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,ProcessSliceData,The length of the statement  "							slicingData.Extruders[extruderIndex].GenerateTopAndBottoms(layerIndex' config.ExtrusionWidth_um' config.OutsideExtrusionWidth_um' config.NumberOfBottomLayers' config.NumberOfTopLayers); " is 185.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The length of the statement  "				GCodePlanner layerGcodePlanner = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 157.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The length of the statement  "					z += config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceLayers * config.RaftSurfaceThickness_um; " is 127.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The length of the statement  "						layerGcodePlanner.QueueTravel(slicingData.wipePoint - config.ExtruderOffsets[prevExtruder] + config.ExtruderOffsets[layerGcodePlanner.GetExtruder()]); " is 150.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The length of the statement  "						QueueExtruderLayerToGCode(slicingData' layerGcodePlanner' extruderIndex' layerIndex' config.FirstLayerExtrusionWidth_um' z); " is 124.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The length of the statement  "						QueueAirGappedExtruderLayerToGCode(slicingData' layerGcodePlanner' extruderIndex' layerIndex' config.ExtrusionWidth_um' z); " is 123.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The length of the statement  "			//Store the object height for when we are printing multiple objects' as we need to clear every one of them when moving to the next position. " is 140.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePerimeterWithMergOverlaps,The length of the statement  "				pathHadOverlaps = perimeterToCheckForMerge.MergePerimeterOverlaps(config.lineWidth_um' out pathsWithOverlapsRemoved' pathIsClosed) " is 130.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePerimeterWithMergOverlaps,The length of the statement  "				QueuePolygonsConsideringSupport(layerIndex' gcodeLayer' pathsWithOverlapsRemoved' config' SupportWriteType.UnsupportedAreas); " is 125.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePerimeterWithMergOverlaps,The length of the statement  "				QueuePolygonsConsideringSupport(layerIndex' gcodeLayer' new Polygons() { perimeterToCheckForMerge }' config' SupportWriteType.UnsupportedAreas); " is 144.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' topFillPolygons' bridgePolygons); " is 135.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "					// The island could be a rectangle with 4 screew holes. So' with 3 perimeters that colud be the outside 3 + the foles 4 * 3' 15 polygons. " is 137.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "									limitDistance = QueueClosetsInset(insetsForThisIsland[insetIndex]' limitDistance' insetXConfig' layerIndex' layerGcodePlanner); " is 127.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls " is 128.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 5' out thinLines' true)) " is 151.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas); " is 128.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "				// TODO: Put all of these segments into a list that can be queued together and still preserver their individual config settings. " is 128.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas); " is 136.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,MoveToIsland,The length of the statement  "				if (island.PathFinder.OutlinePolygons.PointIsInside(layerGcodePlanner.LastPosition' island.PathFinder.OutlineEdgeQuadTrees)) " is 124.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueClosetsInset,The length of the statement  "					QueuePolygonsConsideringSupport(layerIndex' gcodeLayer' new Polygons() { insetsToConsider[polygonPrintedIndex] }' pathConfig' SupportWriteType.UnsupportedAreas); " is 161.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "					layerGcodePlanner.QueueTravel(slicingData.wipePoint - config.ExtruderOffsets[prevExtruder] + config.ExtruderOffsets[layerGcodePlanner.GetExtruder()]); " is 150.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "							QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' island.InsetToolPaths[insetIndex]' airGappedBottomConfig' SupportWriteType.SupportedAreas); " is 154.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "							QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' island.InsetToolPaths[0]' airGappedBottomConfig' SupportWriteType.SupportedAreas); " is 145.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "						QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' airGappedBottomConfig' SupportWriteType.SupportedAreas); " is 139.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePolygonsConsideringSupport,The length of the statement  "						GetSegmentsConsideringSupport(polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' false' fillConfig.closedLoop); " is 150.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePolygonsConsideringSupport,The length of the statement  "					GetSegmentsConsideringSupport(polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' true' fillConfig.closedLoop); " is 149.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The length of the statement  "							Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle); " is 151.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The length of the statement  "							Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90); " is 156.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The length of the statement  "					Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.FirstLayerExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle); " is 161.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The length of the statement  "					Infill.GenerateLinePaths(outline' topFillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle); " is 142.
Long Statement,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The length of the statement  "						Infill.GenerateLinePaths(outline' fillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90 * (layerIndex % 2)); " is 163.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetExtrusion,The length of the statement  "			double filamentArea = Math.PI * ((double)(filamentDiameter) / 1000.0 / 2.0) * ((double)(filamentDiameter) / 1000.0 / 2.0); " is 122.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SwitchExtruder,The length of the statement  "				gcodeFileStream.Write("G1 F{0} E{1:0.####} ; retract\n"' retractionSpeed * 60' extrusionAmount_mm - extruderSwitchRetraction_mm); " is 129.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The length of the statement  "						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure. " is 159.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The length of the statement  "			estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed); " is 181.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteRetraction,The length of the statement  "				gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm - retractionAmount_mm)); " is 123.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteRetraction,The length of the statement  "				estimateCalculator.plan(new TimeEstimateCalculator.Position((double)(currentPosition_um.X) / 1000.0' (currentPosition_um.Y) / 1000.0' (double)(currentPosition_um.Z) / 1000.0' extrusionAmount_mm - retractionAmount_mm)' currentSpeed); " is 232.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The length of the statement  "					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0)); " is 166.
Long Statement,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The length of the statement  "					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed); " is 137.
Long Statement,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,SetPositionAndSize,The length of the statement  "				IntPoint modelXYCenterZBottom_um = new IntPoint((minXYZ_um.X + maxXYZ_um.X) / 2' (minXYZ_um.Y + maxXYZ_um.Y) / 2' minXYZ_um.Z); " is 127.
Long Statement,MatterHackers.MatterSlice,PathOrderOptimizer,C:\repos\MatterHackers_MatterSlice\PathOrderOptimizer.cs,Optimize,The length of the statement  "					// If there are only 2 points (a single line) or the path is marked as travel both ways' we are willing to start from the start or the end. " is 139.
Long Statement,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexagonInfill,The length of the statement  "			Infill.GenerateHexLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' layerIndex); " is 131.
Long Statement,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The length of the statement  "					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect " is 169.
Long Statement,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateLinePaths,The length of the statement  "					PointMatrix matrix = new PointMatrix(-(rotation + 90)); // we are rotating the part so we rotate by the negative so the lines go the way we expect " is 146.
Long Statement,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The length of the statement  "			Infill.GenerateLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' offset); " is 124.
Long Statement,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The length of the statement  "			Infill.GenerateLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' offset); " is 124.
Long Statement,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The length of the statement  "			Infill.GenerateLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' offset); " is 124.
Long Statement,MatterHackers.MatterSlice,MultiExtruders,C:\repos\MatterHackers_MatterSlice\MultiExtruders.cs,RemoveExtruderIntersections,The length of the statement  "			//Go trough all the extruders' and remove the previous extruders outlines from our own outline' so we never have overlapped areas. " is 130.
Complex Conditional,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ValidatePaths,The conditional expression  "pathIndex == paths.Count-1  							&& polyIndex == path.polygon.Count-1  							&& lastValidPathFinder != null  							&& !lastValidPathFinder.OutlinePolygons.PointIsInside((position + lastPosition) / 2)"  is complex.
Complex Conditional,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,LastLayerWithChange,The conditional expression  "(extruderToCheck < Extruders.Count && Extruders[extruderToCheck].Layers[checkLayer].AllOutlines.Count > 0)  						|| (config.SupportExtruder == extruderToCheck && support != null && support.HasNormalSupport(checkLayer))  						|| (config.SupportInterfaceExtruder == extruderToCheck && support != null && support.HasInterfaceSupport(checkLayer))"  is complex.
Complex Conditional,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The conditional expression  "insetCount == 0   							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0"  is complex.
Empty Catch Block,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetSetting,The method has an empty catch block.
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,GenerateTopAndBottoms,The following statement contains a magic number: for (int islandIndex = 0; islandIndex < layer.Islands.Count; islandIndex++)  			{  				LayerIsland island = layer.Islands[islandIndex];  				if (island.InsetToolPaths.Count == 0)  				{  					continue;  				}  				// this is the entire extrusion width to make sure we are outside of the extrusion line  				Polygons lastInset = island.InsetToolPaths[island.InsetToolPaths.Count - 1];  				Polygons insetWithOffset = lastInset.Offset(-extrusionWidth_um);  				Polygons infillOutlines = new Polygons(insetWithOffset);    				// calculate the bottom outlines  				if (downLayerCount > 0)  				{  					Polygons bottomOutlines = new Polygons(insetWithOffset);    					if (layerIndex - 1 >= 0)  					{  						bottomOutlines = RemoveIslandsFromPolygons(extruder.Layers[layerIndex - 1].Islands' island.BoundingBox' bottomOutlines);  						bottomOutlines.RemoveSmallAreas(extrusionWidth_um);  					}    					infillOutlines = infillOutlines.CreateDifference(bottomOutlines);  					infillOutlines = Clipper.CleanPolygons(infillOutlines' cleanDistance_um);    					island.SolidBottomToolPaths = bottomOutlines;  				}    				// calculate the top outlines  				if (upLayerCount > 0)  				{  					Polygons topOutlines = new Polygons(insetWithOffset);  					topOutlines = topOutlines.CreateDifference(island.SolidBottomToolPaths);  					topOutlines = Clipper.CleanPolygons(topOutlines' cleanDistance_um);    					if (layerIndex + 1 < extruder.Layers.Count)  					{  						// Remove the top layer that is above this one to get only the data that is a top layer on this layer.  						topOutlines = RemoveIslandsFromPolygons(extruder.Layers[layerIndex + 1].Islands' island.BoundingBox' topOutlines);  					}    					topOutlines.RemoveSmallAreas(extrusionWidth_um);    					infillOutlines = infillOutlines.CreateDifference(topOutlines);  					infillOutlines = Clipper.CleanPolygons(infillOutlines' cleanDistance_um);    					island.SolidTopToolPaths = topOutlines;  				}    				// calculate the solid infill outlines  				if (upLayerCount > 1 || downLayerCount > 1)  				{  					Polygons solidInfillOutlines = new Polygons(insetWithOffset);  					solidInfillOutlines = solidInfillOutlines.CreateDifference(island.SolidBottomToolPaths);  					solidInfillOutlines = Clipper.CleanPolygons(solidInfillOutlines' cleanDistance_um);  					solidInfillOutlines = solidInfillOutlines.CreateDifference(island.SolidTopToolPaths);    					solidInfillOutlines = Clipper.CleanPolygons(solidInfillOutlines' cleanDistance_um);    					int upEnd = layerIndex + upLayerCount + 1;  					if (upEnd <= extruder.Layers.Count && layerIndex - downLayerCount >= 0)  					{  						Polygons totalPartsToRemove = new Polygons(insetWithOffset);    						int upStart = layerIndex + 2;    						for (int layerToTest = upStart; layerToTest < upEnd; layerToTest++)  						{  							totalPartsToRemove = AddIslandsToPolygons(extruder.Layers[layerToTest].Islands' island.BoundingBox' totalPartsToRemove);  							totalPartsToRemove = Clipper.CleanPolygons(totalPartsToRemove' cleanDistance_um);  						}    						int downStart = layerIndex - 1;  						int downEnd = layerIndex - downLayerCount;    						for (int layerToTest = downStart; layerToTest >= downEnd; layerToTest--)  						{  							totalPartsToRemove = AddIslandsToPolygons(extruder.Layers[layerToTest].Islands' island.BoundingBox' totalPartsToRemove);  							totalPartsToRemove = Clipper.CleanPolygons(totalPartsToRemove' cleanDistance_um);  						}    						solidInfillOutlines = solidInfillOutlines.CreateDifference(totalPartsToRemove);  						solidInfillOutlines.RemoveSmallAreas(extrusionWidth_um);    						solidInfillOutlines = Clipper.CleanPolygons(solidInfillOutlines' cleanDistance_um);  					}    					island.SolidInfillToolPaths = solidInfillOutlines;  					infillOutlines = infillOutlines.CreateDifference(solidInfillOutlines);  				}    				infillOutlines.RemoveSmallAreas(extrusionWidth_um);  				infillOutlines = Clipper.CleanPolygons(infillOutlines' cleanDistance_um);  				island.InfillToolPaths = infillOutlines;  			}
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,InitializeLayerData,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < slicer.layers.Count; layerIndex++)  			{  				int start = slicer.layers.Count * extruderIndex;  				LogOutput.Log("Generating Layer Outlines {0}/{1}\n".FormatWith(start + layerIndex + 1' extruderCount * slicer.layers.Count));  				if (config.outputOnlyFirstLayer && layerIndex > 0)  				{  					break;  				}    				Layers.Add(new SliceLayer());  				Layers[layerIndex].LayerZ = slicer.layers[layerIndex].Z;    				Layers[layerIndex].AllOutlines = slicer.layers[layerIndex].PolygonList;    				Layers[layerIndex].AllOutlines = Layers[layerIndex].AllOutlines.GetCorrectedWinding();    				long avoidInset = config.ExtrusionWidth_um * 3 / 2;  				var boundary = Layers[layerIndex].AllOutlines.GetBounds();  				var extraBoundary = extraPathingConsideration.GetBounds();  				boundary.ExpandToInclude(extraBoundary);  				boundary.Inflate(config.ExtrusionWidth_um * 10);  				Layers[layerIndex].PathFinder = new Pathfinding.PathFinder(Layers[layerIndex].AllOutlines' avoidInset' boundary);  			}
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,InitializeLayerData,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < slicer.layers.Count; layerIndex++)  			{  				int start = slicer.layers.Count * extruderIndex;  				LogOutput.Log("Generating Layer Outlines {0}/{1}\n".FormatWith(start + layerIndex + 1' extruderCount * slicer.layers.Count));  				if (config.outputOnlyFirstLayer && layerIndex > 0)  				{  					break;  				}    				Layers.Add(new SliceLayer());  				Layers[layerIndex].LayerZ = slicer.layers[layerIndex].Z;    				Layers[layerIndex].AllOutlines = slicer.layers[layerIndex].PolygonList;    				Layers[layerIndex].AllOutlines = Layers[layerIndex].AllOutlines.GetCorrectedWinding();    				long avoidInset = config.ExtrusionWidth_um * 3 / 2;  				var boundary = Layers[layerIndex].AllOutlines.GetBounds();  				var extraBoundary = extraPathingConsideration.GetBounds();  				boundary.ExpandToInclude(extraBoundary);  				boundary.Inflate(config.ExtrusionWidth_um * 10);  				Layers[layerIndex].PathFinder = new Pathfinding.PathFinder(Layers[layerIndex].AllOutlines' avoidInset' boundary);  			}
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,C:\repos\MatterHackers_MatterSlice\ExtruderLayers.cs,InitializeLayerData,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < slicer.layers.Count; layerIndex++)  			{  				int start = slicer.layers.Count * extruderIndex;  				LogOutput.Log("Generating Layer Outlines {0}/{1}\n".FormatWith(start + layerIndex + 1' extruderCount * slicer.layers.Count));  				if (config.outputOnlyFirstLayer && layerIndex > 0)  				{  					break;  				}    				Layers.Add(new SliceLayer());  				Layers[layerIndex].LayerZ = slicer.layers[layerIndex].Z;    				Layers[layerIndex].AllOutlines = slicer.layers[layerIndex].PolygonList;    				Layers[layerIndex].AllOutlines = Layers[layerIndex].AllOutlines.GetCorrectedWinding();    				long avoidInset = config.ExtrusionWidth_um * 3 / 2;  				var boundary = Layers[layerIndex].AllOutlines.GetBounds();  				var extraBoundary = extraPathingConsideration.GetBounds();  				boundary.ExpandToInclude(extraBoundary);  				boundary.Inflate(config.ExtrusionWidth_um * 10);  				Layers[layerIndex].PathFinder = new Pathfinding.PathFinder(Layers[layerIndex].AllOutlines' avoidInset' boundary);  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,GCodePlanner,The following statement contains a magic number: extrudeSpeedFactor = 100;
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,GCodePlanner,The following statement contains a magic number: travelSpeedFactor = 100;
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,TrimPerimeter,The following statement contains a magic number: if (path.polygon.Count > 1)  			{  				for (int pointIndex = path.polygon.Count - 1; pointIndex > 0; pointIndex--)  				{  					// Calculate distance between 2 points  					currentDistance = (path.polygon[pointIndex] - path.polygon[pointIndex - 1]).Length();    					// If distance exceeds clip distance:  					//  - Sets the new last path point  					if (currentDistance > targetDistance)  					{  						long newDistance = currentDistance - targetDistance;  						if (targetDistance > 50) // Don't clip segments less than 50 um. We get too much truncation error.  						{  							IntPoint dir = (path.polygon[pointIndex] - path.polygon[pointIndex - 1]) * newDistance / currentDistance;    							IntPoint clippedEndpoint = path.polygon[pointIndex - 1] + dir;    							path.polygon[pointIndex] = clippedEndpoint;  						}  						break;  					}  					else if (currentDistance == targetDistance)  					{  						// Pops off last point because it is at the limit distance  						path.polygon.RemoveAt(path.polygon.Count - 1);  						break;  					}  					else  					{  						// Pops last point and reduces distance remaining to target  						targetDistance -= currentDistance;  						path.polygon.RemoveAt(path.polygon.Count - 1);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ForceMinimumLayerTime,The following statement contains a magic number: if (totalTime < minTime && extrudeTime > 0.0)  			{  				double minExtrudeTime = minTime - travelTime;  				if (minExtrudeTime < 1)  				{  					minExtrudeTime = 1;  				}    				double factor = extrudeTime / minExtrudeTime;  				for (int n = 0; n < paths.Count; n++)  				{  					GCodePath path = paths[n];  					if (path.config.lineWidth_um == 0)  					{  						continue;  					}    					int speed = (int)(path.config.speed * factor);  					if (speed < minimumPrintingSpeed)  					{  						factor = (double)(minimumPrintingSpeed) / (double)(path.config.speed);  					}  				}    				//Only slow down with the minimum time if that will be slower then a factor already set. First layer slowdown also sets the speed factor.  				if (factor * 100 < getExtrudeSpeedFactor())  				{  					SetExtrudeSpeedFactor((int)(factor * 100));  				}  				else  				{  					factor = getExtrudeSpeedFactor() / 100.0;  				}    				if (minTime - (extrudeTime / factor) - travelTime > 0.1)  				{  					//TODO: Use up this extra time (circle around the print?)  					this.extraTime = minTime - (extrudeTime / factor) - travelTime;  				}  				this.totalPrintTime = (extrudeTime / factor) + travelTime;  			}  			else  			{  				this.totalPrintTime = totalTime;  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ForceMinimumLayerTime,The following statement contains a magic number: if (totalTime < minTime && extrudeTime > 0.0)  			{  				double minExtrudeTime = minTime - travelTime;  				if (minExtrudeTime < 1)  				{  					minExtrudeTime = 1;  				}    				double factor = extrudeTime / minExtrudeTime;  				for (int n = 0; n < paths.Count; n++)  				{  					GCodePath path = paths[n];  					if (path.config.lineWidth_um == 0)  					{  						continue;  					}    					int speed = (int)(path.config.speed * factor);  					if (speed < minimumPrintingSpeed)  					{  						factor = (double)(minimumPrintingSpeed) / (double)(path.config.speed);  					}  				}    				//Only slow down with the minimum time if that will be slower then a factor already set. First layer slowdown also sets the speed factor.  				if (factor * 100 < getExtrudeSpeedFactor())  				{  					SetExtrudeSpeedFactor((int)(factor * 100));  				}  				else  				{  					factor = getExtrudeSpeedFactor() / 100.0;  				}    				if (minTime - (extrudeTime / factor) - travelTime > 0.1)  				{  					//TODO: Use up this extra time (circle around the print?)  					this.extraTime = minTime - (extrudeTime / factor) - travelTime;  				}  				this.totalPrintTime = (extrudeTime / factor) + travelTime;  			}  			else  			{  				this.totalPrintTime = totalTime;  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ForceMinimumLayerTime,The following statement contains a magic number: if (totalTime < minTime && extrudeTime > 0.0)  			{  				double minExtrudeTime = minTime - travelTime;  				if (minExtrudeTime < 1)  				{  					minExtrudeTime = 1;  				}    				double factor = extrudeTime / minExtrudeTime;  				for (int n = 0; n < paths.Count; n++)  				{  					GCodePath path = paths[n];  					if (path.config.lineWidth_um == 0)  					{  						continue;  					}    					int speed = (int)(path.config.speed * factor);  					if (speed < minimumPrintingSpeed)  					{  						factor = (double)(minimumPrintingSpeed) / (double)(path.config.speed);  					}  				}    				//Only slow down with the minimum time if that will be slower then a factor already set. First layer slowdown also sets the speed factor.  				if (factor * 100 < getExtrudeSpeedFactor())  				{  					SetExtrudeSpeedFactor((int)(factor * 100));  				}  				else  				{  					factor = getExtrudeSpeedFactor() / 100.0;  				}    				if (minTime - (extrudeTime / factor) - travelTime > 0.1)  				{  					//TODO: Use up this extra time (circle around the print?)  					this.extraTime = minTime - (extrudeTime / factor) - travelTime;  				}  				this.totalPrintTime = (extrudeTime / factor) + travelTime;  			}  			else  			{  				this.totalPrintTime = totalTime;  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ForceMinimumLayerTime,The following statement contains a magic number: if (totalTime < minTime && extrudeTime > 0.0)  			{  				double minExtrudeTime = minTime - travelTime;  				if (minExtrudeTime < 1)  				{  					minExtrudeTime = 1;  				}    				double factor = extrudeTime / minExtrudeTime;  				for (int n = 0; n < paths.Count; n++)  				{  					GCodePath path = paths[n];  					if (path.config.lineWidth_um == 0)  					{  						continue;  					}    					int speed = (int)(path.config.speed * factor);  					if (speed < minimumPrintingSpeed)  					{  						factor = (double)(minimumPrintingSpeed) / (double)(path.config.speed);  					}  				}    				//Only slow down with the minimum time if that will be slower then a factor already set. First layer slowdown also sets the speed factor.  				if (factor * 100 < getExtrudeSpeedFactor())  				{  					SetExtrudeSpeedFactor((int)(factor * 100));  				}  				else  				{  					factor = getExtrudeSpeedFactor() / 100.0;  				}    				if (minTime - (extrudeTime / factor) - travelTime > 0.1)  				{  					//TODO: Use up this extra time (circle around the print?)  					this.extraTime = minTime - (extrudeTime / factor) - travelTime;  				}  				this.totalPrintTime = (extrudeTime / factor) + travelTime;  			}  			else  			{  				this.totalPrintTime = totalTime;  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,QueuePolygon,The following statement contains a magic number: if (config.closedLoop)  			{  				for (int positionIndex = 1; positionIndex < polygon.Count; positionIndex++)  				{  					IntPoint destination = polygon[(startIndex + positionIndex) % polygon.Count];  					QueueExtrusionMove(destination' config);  					currentPosition = destination;  				}    				// We need to actually close the polygon so go back to the first point  				if (polygon.Count > 2)  				{  					QueueExtrusionMove(polygon[startIndex]' config);  				}  			}  			else // we are not closed  			{  				if (startIndex == 0)  				{  					for (int positionIndex = 1; positionIndex < polygon.Count; positionIndex++)  					{  						IntPoint destination = polygon[positionIndex];  						QueueExtrusionMove(destination' config);  						currentPosition = destination;  					}  				}  				else  				{  					for (int positionIndex = polygon.Count - 1; positionIndex >= 1; positionIndex--)  					{  						IntPoint destination = polygon[(startIndex + positionIndex) % polygon.Count];  						QueueExtrusionMove(destination' config);  						currentPosition = destination;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,ValidatePaths,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				var path = paths[pathIndex];  				for (int polyIndex = 0; polyIndex < path.polygon.Count; polyIndex++)  				{  					var position = path.polygon[polyIndex];  					if (first)  					{  						first = false;  					}  					else  					{  						if(pathIndex == paths.Count-1  							&& polyIndex == path.polygon.Count-1  							&& lastValidPathFinder != null  							&& !lastValidPathFinder.OutlinePolygons.PointIsInside((position + lastPosition) / 2))  						{  							// an easy way to get the path  							string startEndString = $"start:({position.X}' {position.Y})' end:({lastPosition.X}' {lastPosition.Y})";  							string outlineString = lastValidPathFinder.OutlinePolygons.WriteToString();  							long length = (position - lastPosition).Length();  							int a = 0;  						}  					}  					lastPosition = position;  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodePlanner,C:\repos\MatterHackers_MatterSlice\GCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: for (int pathIndex = 0; pathIndex < paths.Count; pathIndex++)  			{  				GCodePath path = paths[pathIndex];  				if (extruderIndex != path.extruderIndex)  				{  					extruderIndex = path.extruderIndex;  					gcodeExport.SwitchExtruder(extruderIndex);  				}  				else if (path.Retract)  				{  					gcodeExport.WriteRetraction();  				}  				if (path.config != travelConfig && lastConfig != path.config)  				{  					if (path.config.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(bridgeFanSpeedPercent);  					}  					else if (lastConfig?.gcodeComment == "BRIDGE" && bridgeFanSpeedPercent != -1)  					{  						gcodeExport.WriteFanCommand(fanSpeedPercent);  					}    					gcodeExport.WriteComment("TYPE:{0}".FormatWith(path.config.gcodeComment));  					lastConfig = path.config;  				}    				double speed = path.config.speed;    				if (path.config.lineWidth_um != 0)  				{  					// Prevent cooling overrides from affecting bridge moves  					if (path.config.gcodeComment != "BRIDGE")  					{  						speed = speed * extrudeSpeedFactor / 100;  					}  				}  				else  				{  					speed = speed * travelSpeedFactor / 100;  				}    				if (path.polygon.Count == 1  					&& path.config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  				{  					//Check for lots of small moves and combine them into one large line  					IntPoint nextPosition = path.polygon[0];  					int i = pathIndex + 1;  					while (i < paths.Count && paths[i].polygon.Count == 1 && (nextPosition - paths[i].polygon[0]).ShorterThen(path.config.lineWidth_um * 2))  					{  						nextPosition = paths[i].polygon[0];  						i++;  					}  					if (paths[i - 1].config == travelConfig)  					{  						i--;  					}    					if (i > pathIndex + 2)  					{  						nextPosition = gcodeExport.GetPosition();  						for (int x = pathIndex; x < i - 1; x += 2)  						{  							long oldLen = (nextPosition - paths[x].polygon[0]).Length();  							IntPoint newPoint = (paths[x].polygon[0] + paths[x + 1].polygon[0]) / 2;  							long newLen = (gcodeExport.GetPosition() - newPoint).Length();  							if (newLen > 0)  							{  								gcodeExport.WriteMove(newPoint' speed' (int)(path.config.lineWidth_um * oldLen / newLen));  							}    							nextPosition = paths[x + 1].polygon[0];  						}    						long lineWidth_um = path.config.lineWidth_um;  						if (paths[i - 1].polygon[0].Width != 0)  						{  							lineWidth_um = paths[i - 1].polygon[0].Width;  						}    						gcodeExport.WriteMove(paths[i - 1].polygon[0]' speed' lineWidth_um);  						pathIndex = i - 1;  						continue;  					}  				}    				bool spiralize = path.config.spiralize;  				if (spiralize)  				{  					//Check if we are the last spiralize path in the list' if not' do not spiralize.  					for (int m = pathIndex + 1; m < paths.Count; m++)  					{  						if (paths[m].config.spiralize)  						{  							spiralize = false;  						}  					}  				}    				if (spiralize) // if we are still in spiralize mode  				{  					//If we need to spiralize then raise the head slowly by 1 layer as this path progresses.  					double totalLength = 0;  					long z = gcodeExport.GetPositionZ();  					IntPoint currentPosition = gcodeExport.GetPositionXY();  					for (int pointIndex = 0; pointIndex < path.polygon.Count; pointIndex++)  					{  						IntPoint nextPosition = path.polygon[pointIndex];  						totalLength += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  					}    					double length = 0.0;  					currentPosition = gcodeExport.GetPositionXY();  					for (int i = 0; i < path.polygon.Count; i++)  					{  						IntPoint nextPosition = path.polygon[i];  						length += (currentPosition - nextPosition).LengthMm();  						currentPosition = nextPosition;  						IntPoint nextExtrusion = path.polygon[i];  						nextExtrusion.Z = (int)(z + layerThickness * length / totalLength + .5);  						gcodeExport.WriteMove(nextExtrusion' speed' path.config.lineWidth_um);  					}  				}  				else  				{  					// This is test code to remove double drawn small perimeter lines.  					if (path.config.gcodeComment == "WALL-OUTER" || path.config.gcodeComment == "WALL-INNER")  					{  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(path);  						if (perimeterStartEndOverlapRatio < 1)  						{  							path = TrimPerimeter(path' perimeterStartEndOverlapRatio);  						}  					}    					int outputCount = path.polygon.Count;  					for (int i = 0; i < outputCount; i++)  					{  						long lineWidth_um = path.config.lineWidth_um;  						if (path.polygon[i].Width != 0)  						{  							lineWidth_um = path.polygon[i].Width;  						}    						gcodeExport.WriteMove(path.polygon[i]' speed' lineWidth_um);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GrahamScan,C:\repos\MatterHackers_MatterSlice\GrahamScan.cs,GetConvexHull,The following statement contains a magic number: if (sorted.Count < 3)  			{  				throw new System.ArgumentException("can only create a convex hull of 3 or more unique points");  			}
Magic Number,MatterHackers.MatterSlice,GrahamScan,C:\repos\MatterHackers_MatterSlice\GrahamScan.cs,GetConvexHull,The following statement contains a magic number: for (int i = 2; i < sorted.Count; i++)  			{  				IntPoint head = sorted[i];  				IntPoint middle = stack.Pop();  				IntPoint tail = stack.Peek();    				Turn turn = GetTurn(tail' middle' head);  				switch (turn)  				{  					case Turn.CounterClockwise:  						stack.Push(middle);  						stack.Push(head);  						break;    					case Turn.Clockwise:  						i--;  						break;    					case Turn.Collinear:  						stack.Push(head);  						break;  				}  			}
Magic Number,MatterHackers.MatterSlice,GrahamScan,C:\repos\MatterHackers_MatterSlice\GrahamScan.cs,AreAllCollinear,The following statement contains a magic number: if (points.Count < 2)  			{  				return true;  			}
Magic Number,MatterHackers.MatterSlice,GrahamScan,C:\repos\MatterHackers_MatterSlice\GrahamScan.cs,AreAllCollinear,The following statement contains a magic number: for (int i = 2; i < points.Count; i++)  			{  				IntPoint c = points[i];    				if (GetTurn(a' b' c) != Turn.Collinear)  				{  					return false;  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerIsland,C:\repos\MatterHackers_MatterSlice\LayerIsland.cs,GenerateInsets,The following statement contains a magic number: part.PathFinder = new PathFinder(part.IslandOutline' extrusionWidth_um * 3 / 2);
Magic Number,MatterHackers.MatterSlice,LayerIsland,C:\repos\MatterHackers_MatterSlice\LayerIsland.cs,GenerateInsets,The following statement contains a magic number: part.PathFinder = new PathFinder(part.IslandOutline' extrusionWidth_um * 3 / 2);
Magic Number,MatterHackers.MatterSlice,LayerIsland,C:\repos\MatterHackers_MatterSlice\LayerIsland.cs,GenerateInsets,The following statement contains a magic number: if (insetCount == 0)  			{  				// if we have no insets defined still create one  				part.InsetToolPaths.Add(part.IslandOutline);  			}  			else // generate the insets  			{  				int currentOffset = 0;    				// Inset 0 will use the outerExtrusionWidth_um' everyone else will use extrusionWidth_um  				int offsetBy = outerExtrusionWidth_um / 2;    				for (int i = 0; i < insetCount; i++)  				{  					// Increment by half the offset amount  					currentOffset += offsetBy;    					Polygons currentInset = part.IslandOutline.Offset(-currentOffset);  					// make sure our polygon data is reasonable  					currentInset = Clipper.CleanPolygons(currentInset' minimumDistanceToCreateNewPosition);    					// check that we have actual paths  					if (currentInset.Count > 0)  					{  						part.InsetToolPaths.Add(currentInset);    						// Increment by the second half  						currentOffset += offsetBy;  					}  					else  					{  						// we are done making insets as we have no area left  						break;  					}    					if (i == 0)  					{  						// Reset offset amount to half the standard extrusion width  						offsetBy = extrusionWidth_um / 2;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerIsland,C:\repos\MatterHackers_MatterSlice\LayerIsland.cs,GenerateInsets,The following statement contains a magic number: if (insetCount == 0)  			{  				// if we have no insets defined still create one  				part.InsetToolPaths.Add(part.IslandOutline);  			}  			else // generate the insets  			{  				int currentOffset = 0;    				// Inset 0 will use the outerExtrusionWidth_um' everyone else will use extrusionWidth_um  				int offsetBy = outerExtrusionWidth_um / 2;    				for (int i = 0; i < insetCount; i++)  				{  					// Increment by half the offset amount  					currentOffset += offsetBy;    					Polygons currentInset = part.IslandOutline.Offset(-currentOffset);  					// make sure our polygon data is reasonable  					currentInset = Clipper.CleanPolygons(currentInset' minimumDistanceToCreateNewPosition);    					// check that we have actual paths  					if (currentInset.Count > 0)  					{  						part.InsetToolPaths.Add(currentInset);    						// Increment by the second half  						currentOffset += offsetBy;  					}  					else  					{  						// we are done making insets as we have no area left  						break;  					}    					if (i == 0)  					{  						// Reset offset amount to half the standard extrusion width  						offsetBy = extrusionWidth_um / 2;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,GetSingleIslandAngle,The following statement contains a magic number: for (int island0PointIndex = 0; island0PointIndex < island0PointCount; island0PointIndex++)  			{  				IntPoint curr = island[(startIndex + island0PointIndex) % island0PointCount];    				if (!outline[0].Contains(curr))  				{  					IntPoint prev = island[(startIndex + island0PointIndex + island0PointCount - 1) % island0PointCount];  					IntPoint convexStart = prev;    					// We found a concave angle. now we want to find the first non-concave angle and make  					// a bridge at the start and end angle of the concave region  					for (int j = island0PointIndex + 1; j < island0PointCount + island0PointIndex; j++)  					{  						IntPoint curr2 = island[(startIndex + j) % island0PointCount];    						if (outline[0].Contains(curr2))  						{  							IntPoint sideDelta = curr2 - convexStart;  							double lengthOfSide = sideDelta.Length();  							if (lengthOfSide > longestSide)  							{  								bestAngle = Math.Atan2(sideDelta.Y' sideDelta.X) * 180 / Math.PI;  								longestSide = lengthOfSide;  								if (OUTPUT_DEBUG_DATA)  								{  									island.SaveToGCode("{0} - angle {1:0.}.gcode".FormatWith(debugName' bestAngle));  								}  								island0PointIndex = j + 1;  								break;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,BridgeAngle,The following statement contains a magic number: if (islandsToRestOn.Count > 5 || islandsToRestOn.Count < 1)  			{  				return false;  			}
Magic Number,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,BridgeAngle,The following statement contains a magic number: bridgeAngle = Math.Atan2(center2.Y - center1.Y' center2.X - center1.X) / Math.PI * 180;
Magic Number,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,Range0To360,The following statement contains a magic number: if (angle < 0)  			{  				angle += 360;  			}
Magic Number,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,Range0To360,The following statement contains a magic number: if (angle > 360)  			{  				angle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,SliceLayer,C:\repos\MatterHackers_MatterSlice\SliceLayer.cs,Range0To360,The following statement contains a magic number: if (angle > 360)  			{  				angle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < totalLayers; layerIndex++)  			{  				this.wipeShield[layerIndex] = this.wipeShield[layerIndex].Offset(-1000).Offset(1000);  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < totalLayers; layerIndex++)  			{  				this.wipeShield[layerIndex] = this.wipeShield[layerIndex].Offset(-1000).Offset(1000);  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: int offsetAngle = (int)Math.Tan(60.0 * Math.PI / 180) * config.LayerThickness_um;
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: int offsetAngle = (int)Math.Tan(60.0 * Math.PI / 180) * config.LayerThickness_um;
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000' this.modelMax.Y + 3000));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000' this.modelMax.Y + 3000));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000' this.modelMax.Y + 3000 + config.WipeTowerSize_um));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000' this.modelMax.Y + 3000 + config.WipeTowerSize_um));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um' this.modelMax.Y + 3000 + config.WipeTowerSize_um));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um' this.modelMax.Y + 3000 + config.WipeTowerSize_um));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um' this.modelMax.Y + 3000));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: wipeTowerShape.Add(new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um' this.modelMax.Y + 3000));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: this.wipePoint = new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um / 2' this.modelMax.Y + 3000 + config.WipeTowerSize_um / 2);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: this.wipePoint = new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um / 2' this.modelMax.Y + 3000 + config.WipeTowerSize_um / 2);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: this.wipePoint = new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um / 2' this.modelMax.Y + 3000 + config.WipeTowerSize_um / 2);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: this.wipePoint = new IntPoint(this.modelMin.X - 3000 - config.WipeTowerSize_um / 2' this.modelMax.Y + 3000 + config.WipeTowerSize_um / 2);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,DumpLayerparts,The following statement contains a magic number: for (int extruderIndex = 0; extruderIndex < storage.Extruders.Count; extruderIndex++)  			{  				for (int layerNr = 0; layerNr < storage.Extruders[extruderIndex].Layers.Count; layerNr++)  				{  					streamToWriteTo.Write("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" style=\"width: 500px; height:500px\">\n");  					SliceLayer layer = storage.Extruders[extruderIndex].Layers[layerNr];  					for (int i = 0; i < layer.Islands.Count; i++)  					{  						LayerIsland part = layer.Islands[i];  						for (int j = 0; j < part.IslandOutline.Count; j++)  						{  							streamToWriteTo.Write("<polygon points=\"");  							for (int k = 0; k < part.IslandOutline[j].Count; k++)  								streamToWriteTo.Write("{0}'{1} ".FormatWith((float)(part.IslandOutline[j][k].X - modelMin.X) / modelSize.X * 500' (float)(part.IslandOutline[j][k].Y - modelMin.Y) / modelSize.Y * 500));  							if (j == 0)  								streamToWriteTo.Write("\" style=\"fill:gray; stroke:black;stroke-width:1\" />\n");  							else  								streamToWriteTo.Write("\" style=\"fill:red; stroke:black;stroke-width:1\" />\n");  						}  					}  					streamToWriteTo.Write("</svg>\n");  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,DumpLayerparts,The following statement contains a magic number: for (int extruderIndex = 0; extruderIndex < storage.Extruders.Count; extruderIndex++)  			{  				for (int layerNr = 0; layerNr < storage.Extruders[extruderIndex].Layers.Count; layerNr++)  				{  					streamToWriteTo.Write("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" style=\"width: 500px; height:500px\">\n");  					SliceLayer layer = storage.Extruders[extruderIndex].Layers[layerNr];  					for (int i = 0; i < layer.Islands.Count; i++)  					{  						LayerIsland part = layer.Islands[i];  						for (int j = 0; j < part.IslandOutline.Count; j++)  						{  							streamToWriteTo.Write("<polygon points=\"");  							for (int k = 0; k < part.IslandOutline[j].Count; k++)  								streamToWriteTo.Write("{0}'{1} ".FormatWith((float)(part.IslandOutline[j][k].X - modelMin.X) / modelSize.X * 500' (float)(part.IslandOutline[j][k].Y - modelMin.Y) / modelSize.Y * 500));  							if (j == 0)  								streamToWriteTo.Write("\" style=\"fill:gray; stroke:black;stroke-width:1\" />\n");  							else  								streamToWriteTo.Write("\" style=\"fill:red; stroke:black;stroke-width:1\" />\n");  						}  					}  					streamToWriteTo.Write("</svg>\n");  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GenerateRaftOutlines,The following statement contains a magic number: for (int extruderIndex = 0; extruderIndex < storage.Extruders.Count; extruderIndex++)  			{  				if (config.ContinuousSpiralOuterPerimeter && extruderIndex > 0)  				{  					continue;  				}    				if (storage.Extruders[extruderIndex].Layers.Count < 1)  				{  					continue;  				}    				SliceLayer layer = storage.Extruders[extruderIndex].Layers[0];  				// let's find the first layer that has something in it for the raft rather than a zero layer  				if (layer.Islands.Count == 0 && storage.Extruders[extruderIndex].Layers.Count > 2)  				{  					layer = storage.Extruders[extruderIndex].Layers[1];  				}    				for (int partIndex = 0; partIndex < layer.Islands.Count; partIndex++)  				{  					if (config.ContinuousSpiralOuterPerimeter && partIndex > 0)  					{  						continue;  					}    					storage.raftOutline = storage.raftOutline.CreateUnion(layer.Islands[partIndex].IslandOutline.Offset(extraDistanceAroundPart_um));  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GenerateSkirt,The following statement contains a magic number: if (skirtPolygons.Count > 0)  			{    				// Find convex hull for the skirt outline  				Polygons convexHull = new Polygons(new[] { skirtPolygons.CreateConvexHull() });    				// Create skirt loops from the ConvexHull  				for (int skirtLoop = 0; skirtLoop < numberOfLoops; skirtLoop++)  				{  					int offsetDistance = distance + extrusionWidth_um * skirtLoop + extrusionWidth_um / 2;    					storage.skirt.AddAll(convexHull.Offset(offsetDistance));    					int length = (int)storage.skirt.PolygonLength();  					if (skirtLoop + 1 >= numberOfLoops && length > 0 && length < minLength)  					{  						// add more loops for as long as we have not extruded enough length  						numberOfLoops++;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: if (config.ShouldGenerateRaft())  			{  				GCodePathConfig raftBaseConfig = new GCodePathConfig("raftBaseConfig");  				raftBaseConfig.SetData(config.FirstLayerSpeed' config.RaftBaseExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftMiddleConfig = new GCodePathConfig("raftMiddleConfig");  				raftMiddleConfig.SetData(config.RaftPrintSpeed' config.RaftInterfaceExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftSurfaceConfig = new GCodePathConfig("raftMiddleConfig");  				raftSurfaceConfig.SetData((config.RaftSurfacePrintSpeed > 0) ? config.RaftSurfacePrintSpeed : config.RaftPrintSpeed' config.RaftSurfaceExtrusionWidth_um' "SUPPORT");    				// create the raft base  				{  					gcode.WriteComment("RAFT BASE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					if (config.RaftExtruder >= 0)  					{  						// if we have a specified raft extruder use it  						gcodeLayer.SetExtruder(config.RaftExtruder);  					}  					else if (config.SupportExtruder >= 0)  					{  						// else preserve the old behavior of using the support extruder if set.  						gcodeLayer.SetExtruder(config.SupportExtruder);  					}    					gcode.SetZ(config.RaftBaseThickness_um);    					gcode.LayerChanged(-3);    					gcode.SetExtrusion(config.RaftBaseThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					// write the skirt around the raft  					gcodeLayer.QueuePolygonsByOptimizer(storage.skirt' raftBaseConfig);    					List<Polygons> raftIslands = storage.raftOutline.ProcessIntoSeparatIslands();  					foreach (var raftIsland in raftIslands)  					{  						// write the outline of the raft  						gcodeLayer.QueuePolygonsByOptimizer(raftIsland' raftBaseConfig);    						Polygons raftLines = new Polygons();  						Infill.GenerateLinePaths(raftIsland.Offset(-config.RaftBaseExtrusionWidth_um) ' raftLines' config.RaftBaseLineSpacing_um' config.InfillExtendIntoPerimeter_um' 0);    						// write the inside of the raft base  						gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftBaseConfig);    						if (config.RetractWhenChangingIslands)  						{  							gcodeLayer.ForceRetract();  						}  					}    					gcodeLayer.WriteQueuedGCode(config.RaftBaseThickness_um);  				}    				if (config.RaftFanSpeedPercent > 0)  				{  					gcode.WriteFanCommand(config.RaftFanSpeedPercent);  				}    				// raft middle layers  				{  					gcode.WriteComment("RAFT MIDDLE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um);  					gcode.LayerChanged(-2);  					gcode.SetExtrusion(config.RaftInterfaceThicknes_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45);  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftMiddleConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}    				for (int raftSurfaceIndex = 1; raftSurfaceIndex <= config.RaftSurfaceLayers; raftSurfaceIndex++)  				{  					gcode.WriteComment("RAFT SURFACE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceThickness_um * raftSurfaceIndex);  					gcode.LayerChanged(-1);  					gcode.SetExtrusion(config.RaftSurfaceThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					if (raftSurfaceIndex == config.RaftSurfaceLayers)  					{  						// make sure the top layer of the raft is 90 degrees offset to the first layer of the part so that it has minimum contact points.  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90);  					}  					else  					{  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 90 * raftSurfaceIndex);  					}  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftSurfaceConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: if (config.ShouldGenerateRaft())  			{  				GCodePathConfig raftBaseConfig = new GCodePathConfig("raftBaseConfig");  				raftBaseConfig.SetData(config.FirstLayerSpeed' config.RaftBaseExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftMiddleConfig = new GCodePathConfig("raftMiddleConfig");  				raftMiddleConfig.SetData(config.RaftPrintSpeed' config.RaftInterfaceExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftSurfaceConfig = new GCodePathConfig("raftMiddleConfig");  				raftSurfaceConfig.SetData((config.RaftSurfacePrintSpeed > 0) ? config.RaftSurfacePrintSpeed : config.RaftPrintSpeed' config.RaftSurfaceExtrusionWidth_um' "SUPPORT");    				// create the raft base  				{  					gcode.WriteComment("RAFT BASE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					if (config.RaftExtruder >= 0)  					{  						// if we have a specified raft extruder use it  						gcodeLayer.SetExtruder(config.RaftExtruder);  					}  					else if (config.SupportExtruder >= 0)  					{  						// else preserve the old behavior of using the support extruder if set.  						gcodeLayer.SetExtruder(config.SupportExtruder);  					}    					gcode.SetZ(config.RaftBaseThickness_um);    					gcode.LayerChanged(-3);    					gcode.SetExtrusion(config.RaftBaseThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					// write the skirt around the raft  					gcodeLayer.QueuePolygonsByOptimizer(storage.skirt' raftBaseConfig);    					List<Polygons> raftIslands = storage.raftOutline.ProcessIntoSeparatIslands();  					foreach (var raftIsland in raftIslands)  					{  						// write the outline of the raft  						gcodeLayer.QueuePolygonsByOptimizer(raftIsland' raftBaseConfig);    						Polygons raftLines = new Polygons();  						Infill.GenerateLinePaths(raftIsland.Offset(-config.RaftBaseExtrusionWidth_um) ' raftLines' config.RaftBaseLineSpacing_um' config.InfillExtendIntoPerimeter_um' 0);    						// write the inside of the raft base  						gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftBaseConfig);    						if (config.RetractWhenChangingIslands)  						{  							gcodeLayer.ForceRetract();  						}  					}    					gcodeLayer.WriteQueuedGCode(config.RaftBaseThickness_um);  				}    				if (config.RaftFanSpeedPercent > 0)  				{  					gcode.WriteFanCommand(config.RaftFanSpeedPercent);  				}    				// raft middle layers  				{  					gcode.WriteComment("RAFT MIDDLE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um);  					gcode.LayerChanged(-2);  					gcode.SetExtrusion(config.RaftInterfaceThicknes_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45);  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftMiddleConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}    				for (int raftSurfaceIndex = 1; raftSurfaceIndex <= config.RaftSurfaceLayers; raftSurfaceIndex++)  				{  					gcode.WriteComment("RAFT SURFACE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceThickness_um * raftSurfaceIndex);  					gcode.LayerChanged(-1);  					gcode.SetExtrusion(config.RaftSurfaceThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					if (raftSurfaceIndex == config.RaftSurfaceLayers)  					{  						// make sure the top layer of the raft is 90 degrees offset to the first layer of the part so that it has minimum contact points.  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90);  					}  					else  					{  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 90 * raftSurfaceIndex);  					}  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftSurfaceConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: if (config.ShouldGenerateRaft())  			{  				GCodePathConfig raftBaseConfig = new GCodePathConfig("raftBaseConfig");  				raftBaseConfig.SetData(config.FirstLayerSpeed' config.RaftBaseExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftMiddleConfig = new GCodePathConfig("raftMiddleConfig");  				raftMiddleConfig.SetData(config.RaftPrintSpeed' config.RaftInterfaceExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftSurfaceConfig = new GCodePathConfig("raftMiddleConfig");  				raftSurfaceConfig.SetData((config.RaftSurfacePrintSpeed > 0) ? config.RaftSurfacePrintSpeed : config.RaftPrintSpeed' config.RaftSurfaceExtrusionWidth_um' "SUPPORT");    				// create the raft base  				{  					gcode.WriteComment("RAFT BASE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					if (config.RaftExtruder >= 0)  					{  						// if we have a specified raft extruder use it  						gcodeLayer.SetExtruder(config.RaftExtruder);  					}  					else if (config.SupportExtruder >= 0)  					{  						// else preserve the old behavior of using the support extruder if set.  						gcodeLayer.SetExtruder(config.SupportExtruder);  					}    					gcode.SetZ(config.RaftBaseThickness_um);    					gcode.LayerChanged(-3);    					gcode.SetExtrusion(config.RaftBaseThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					// write the skirt around the raft  					gcodeLayer.QueuePolygonsByOptimizer(storage.skirt' raftBaseConfig);    					List<Polygons> raftIslands = storage.raftOutline.ProcessIntoSeparatIslands();  					foreach (var raftIsland in raftIslands)  					{  						// write the outline of the raft  						gcodeLayer.QueuePolygonsByOptimizer(raftIsland' raftBaseConfig);    						Polygons raftLines = new Polygons();  						Infill.GenerateLinePaths(raftIsland.Offset(-config.RaftBaseExtrusionWidth_um) ' raftLines' config.RaftBaseLineSpacing_um' config.InfillExtendIntoPerimeter_um' 0);    						// write the inside of the raft base  						gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftBaseConfig);    						if (config.RetractWhenChangingIslands)  						{  							gcodeLayer.ForceRetract();  						}  					}    					gcodeLayer.WriteQueuedGCode(config.RaftBaseThickness_um);  				}    				if (config.RaftFanSpeedPercent > 0)  				{  					gcode.WriteFanCommand(config.RaftFanSpeedPercent);  				}    				// raft middle layers  				{  					gcode.WriteComment("RAFT MIDDLE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um);  					gcode.LayerChanged(-2);  					gcode.SetExtrusion(config.RaftInterfaceThicknes_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45);  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftMiddleConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}    				for (int raftSurfaceIndex = 1; raftSurfaceIndex <= config.RaftSurfaceLayers; raftSurfaceIndex++)  				{  					gcode.WriteComment("RAFT SURFACE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceThickness_um * raftSurfaceIndex);  					gcode.LayerChanged(-1);  					gcode.SetExtrusion(config.RaftSurfaceThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					if (raftSurfaceIndex == config.RaftSurfaceLayers)  					{  						// make sure the top layer of the raft is 90 degrees offset to the first layer of the part so that it has minimum contact points.  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90);  					}  					else  					{  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 90 * raftSurfaceIndex);  					}  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftSurfaceConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: if (config.ShouldGenerateRaft())  			{  				GCodePathConfig raftBaseConfig = new GCodePathConfig("raftBaseConfig");  				raftBaseConfig.SetData(config.FirstLayerSpeed' config.RaftBaseExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftMiddleConfig = new GCodePathConfig("raftMiddleConfig");  				raftMiddleConfig.SetData(config.RaftPrintSpeed' config.RaftInterfaceExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftSurfaceConfig = new GCodePathConfig("raftMiddleConfig");  				raftSurfaceConfig.SetData((config.RaftSurfacePrintSpeed > 0) ? config.RaftSurfacePrintSpeed : config.RaftPrintSpeed' config.RaftSurfaceExtrusionWidth_um' "SUPPORT");    				// create the raft base  				{  					gcode.WriteComment("RAFT BASE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					if (config.RaftExtruder >= 0)  					{  						// if we have a specified raft extruder use it  						gcodeLayer.SetExtruder(config.RaftExtruder);  					}  					else if (config.SupportExtruder >= 0)  					{  						// else preserve the old behavior of using the support extruder if set.  						gcodeLayer.SetExtruder(config.SupportExtruder);  					}    					gcode.SetZ(config.RaftBaseThickness_um);    					gcode.LayerChanged(-3);    					gcode.SetExtrusion(config.RaftBaseThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					// write the skirt around the raft  					gcodeLayer.QueuePolygonsByOptimizer(storage.skirt' raftBaseConfig);    					List<Polygons> raftIslands = storage.raftOutline.ProcessIntoSeparatIslands();  					foreach (var raftIsland in raftIslands)  					{  						// write the outline of the raft  						gcodeLayer.QueuePolygonsByOptimizer(raftIsland' raftBaseConfig);    						Polygons raftLines = new Polygons();  						Infill.GenerateLinePaths(raftIsland.Offset(-config.RaftBaseExtrusionWidth_um) ' raftLines' config.RaftBaseLineSpacing_um' config.InfillExtendIntoPerimeter_um' 0);    						// write the inside of the raft base  						gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftBaseConfig);    						if (config.RetractWhenChangingIslands)  						{  							gcodeLayer.ForceRetract();  						}  					}    					gcodeLayer.WriteQueuedGCode(config.RaftBaseThickness_um);  				}    				if (config.RaftFanSpeedPercent > 0)  				{  					gcode.WriteFanCommand(config.RaftFanSpeedPercent);  				}    				// raft middle layers  				{  					gcode.WriteComment("RAFT MIDDLE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um);  					gcode.LayerChanged(-2);  					gcode.SetExtrusion(config.RaftInterfaceThicknes_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45);  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftMiddleConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}    				for (int raftSurfaceIndex = 1; raftSurfaceIndex <= config.RaftSurfaceLayers; raftSurfaceIndex++)  				{  					gcode.WriteComment("RAFT SURFACE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceThickness_um * raftSurfaceIndex);  					gcode.LayerChanged(-1);  					gcode.SetExtrusion(config.RaftSurfaceThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					if (raftSurfaceIndex == config.RaftSurfaceLayers)  					{  						// make sure the top layer of the raft is 90 degrees offset to the first layer of the part so that it has minimum contact points.  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90);  					}  					else  					{  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 90 * raftSurfaceIndex);  					}  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftSurfaceConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: if (config.ShouldGenerateRaft())  			{  				GCodePathConfig raftBaseConfig = new GCodePathConfig("raftBaseConfig");  				raftBaseConfig.SetData(config.FirstLayerSpeed' config.RaftBaseExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftMiddleConfig = new GCodePathConfig("raftMiddleConfig");  				raftMiddleConfig.SetData(config.RaftPrintSpeed' config.RaftInterfaceExtrusionWidth_um' "SUPPORT");    				GCodePathConfig raftSurfaceConfig = new GCodePathConfig("raftMiddleConfig");  				raftSurfaceConfig.SetData((config.RaftSurfacePrintSpeed > 0) ? config.RaftSurfacePrintSpeed : config.RaftPrintSpeed' config.RaftSurfaceExtrusionWidth_um' "SUPPORT");    				// create the raft base  				{  					gcode.WriteComment("RAFT BASE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					if (config.RaftExtruder >= 0)  					{  						// if we have a specified raft extruder use it  						gcodeLayer.SetExtruder(config.RaftExtruder);  					}  					else if (config.SupportExtruder >= 0)  					{  						// else preserve the old behavior of using the support extruder if set.  						gcodeLayer.SetExtruder(config.SupportExtruder);  					}    					gcode.SetZ(config.RaftBaseThickness_um);    					gcode.LayerChanged(-3);    					gcode.SetExtrusion(config.RaftBaseThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					// write the skirt around the raft  					gcodeLayer.QueuePolygonsByOptimizer(storage.skirt' raftBaseConfig);    					List<Polygons> raftIslands = storage.raftOutline.ProcessIntoSeparatIslands();  					foreach (var raftIsland in raftIslands)  					{  						// write the outline of the raft  						gcodeLayer.QueuePolygonsByOptimizer(raftIsland' raftBaseConfig);    						Polygons raftLines = new Polygons();  						Infill.GenerateLinePaths(raftIsland.Offset(-config.RaftBaseExtrusionWidth_um) ' raftLines' config.RaftBaseLineSpacing_um' config.InfillExtendIntoPerimeter_um' 0);    						// write the inside of the raft base  						gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftBaseConfig);    						if (config.RetractWhenChangingIslands)  						{  							gcodeLayer.ForceRetract();  						}  					}    					gcodeLayer.WriteQueuedGCode(config.RaftBaseThickness_um);  				}    				if (config.RaftFanSpeedPercent > 0)  				{  					gcode.WriteFanCommand(config.RaftFanSpeedPercent);  				}    				// raft middle layers  				{  					gcode.WriteComment("RAFT MIDDLE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um);  					gcode.LayerChanged(-2);  					gcode.SetExtrusion(config.RaftInterfaceThicknes_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45);  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftMiddleConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}    				for (int raftSurfaceIndex = 1; raftSurfaceIndex <= config.RaftSurfaceLayers; raftSurfaceIndex++)  				{  					gcode.WriteComment("RAFT SURFACE");  					GCodePlanner gcodeLayer = new GCodePlanner(gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio);  					gcode.SetZ(config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceThickness_um * raftSurfaceIndex);  					gcode.LayerChanged(-1);  					gcode.SetExtrusion(config.RaftSurfaceThickness_um' config.FilamentDiameter_um' config.ExtrusionMultiplier);    					Polygons raftLines = new Polygons();  					if (raftSurfaceIndex == config.RaftSurfaceLayers)  					{  						// make sure the top layer of the raft is 90 degrees offset to the first layer of the part so that it has minimum contact points.  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90);  					}  					else  					{  						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 90 * raftSurfaceIndex);  					}  					gcodeLayer.QueuePolygonsByOptimizer(raftLines' raftSurfaceConfig);    					gcodeLayer.WriteQueuedGCode(config.RaftInterfaceThicknes_um);  				}  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,C:\repos\MatterHackers_MatterSlice\LayerDataStorage.cs,GetSkirtBounds,The following statement contains a magic number: if (config.EnableRaft)  			{  				skirtPolygons = skirtPolygons.CreateUnion(storage.raftOutline);  			}  			else  			{  				Polygons allOutlines = hasWipeTower ? new Polygons(storage.wipeTower) : new Polygons();    				// Loop over every extruder  				for (int extrudeIndex = 0; extrudeIndex < storage.Extruders.Count; extrudeIndex++)  				{  					// Only process the first extruder on spiral vase or  					// skip extruders that have empty layers  					if (config.ContinuousSpiralOuterPerimeter)  					{  						SliceLayer layer0 = storage.Extruders[extrudeIndex].Layers[0];  						allOutlines.AddAll(layer0.Islands[0]?.IslandOutline);  					}  					else  					{  						// Add the layers outline to allOutlines  						SliceLayer layer = storage.Extruders[extrudeIndex].Layers[0];  						foreach(var island in layer.Islands)  						{  							if (island.IslandOutline?.Count > 0)  							{  								allOutlines.Add(island.IslandOutline[0]);  							}  						}  					}  				}    				if (brimCount > 0)  				{  					Polygons unionedIslandOutlines = new Polygons();    					// Grow each island by the current brim distance  					// Union the island brims  					unionedIslandOutlines = unionedIslandOutlines.CreateUnion(allOutlines);    					if (storage.support != null)  					{  						unionedIslandOutlines = unionedIslandOutlines.CreateUnion(storage.support.GetBedOutlines());  					}    					Polygons brimLoops = new Polygons();    					// Loop over the requested brimCount creating and unioning a new perimeter for each island  					for (int brimIndex = 0; brimIndex < brimCount; brimIndex++)  					{  						int offsetDistance = extrusionWidth_um * brimIndex + extrusionWidth_um / 2;    						// Extend the polygons to account for the brim (ensures convex hull takes this data into account)  						brimLoops.AddAll(unionedIslandOutlines.Offset(offsetDistance));  					}    					// TODO: This is a quick hack' reuse the skirt data to stuff in the brim. Good enough from proof of concept  					storage.skirt.AddAll(brimLoops);    					skirtPolygons = skirtPolygons.CreateUnion(brimLoops);  				}  				else  				{  					skirtPolygons = skirtPolygons.CreateUnion(allOutlines);  				}    				if (storage.support != null)  				{  					skirtPolygons = skirtPolygons.CreateUnion(storage.support.GetBedOutlines());  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,CreateSegmentListFromString,The following statement contains a magic number: foreach (string segment in segmentData)  			{  				if (segment != "")  				{  					List<IntPoint> outPoints = new Polygon();  					string[] points = segment.Split('&');  					foreach (string point in points)  					{  						string[] coordinates = point.Split(''');  						string elementX = coordinates[0];  						string elementY = coordinates[1];  						int xIndex = elementX.IndexOf("x:");  						int yIndex = elementY.IndexOf("y:");  						outPoints.Add(new IntPoint(int.Parse(elementX.Substring(xIndex + 2))' int.Parse(elementY.Substring(yIndex + 2))));  					}  					output.Add(new SlicePerimeterSegment(outPoints[0]' outPoints[1]));  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,CreateSegmentListFromString,The following statement contains a magic number: foreach (string segment in segmentData)  			{  				if (segment != "")  				{  					List<IntPoint> outPoints = new Polygon();  					string[] points = segment.Split('&');  					foreach (string point in points)  					{  						string[] coordinates = point.Split(''');  						string elementX = coordinates[0];  						string elementY = coordinates[1];  						int xIndex = elementX.IndexOf("x:");  						int yIndex = elementY.IndexOf("y:");  						outPoints.Add(new IntPoint(int.Parse(elementX.Substring(xIndex + 2))' int.Parse(elementY.Substring(yIndex + 2))));  					}  					output.Add(new SlicePerimeterSegment(outPoints[0]' outPoints[1]));  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: while (true)  			{  				long bestScore = 10000 * 10000;  				int bestA = -1;  				int bestB = -1;  				bool reversed = false;  				for (int polygonAIndex = 0; polygonAIndex < openPolygonList.Count; polygonAIndex++)  				{  					if (openPolygonList[polygonAIndex].Count < 1)  					{  						continue;  					}    					for (int polygonBIndex = 0; polygonBIndex < openPolygonList.Count; polygonBIndex++)  					{  						if (openPolygonList[polygonBIndex].Count < 1)  						{  							continue;  						}    						IntPoint diff1 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][0];  						long distSquared1 = (diff1).LengthSquared();  						if (distSquared1 < bestScore)  						{  							bestScore = distSquared1;  							bestA = polygonAIndex;  							bestB = polygonBIndex;  							reversed = false;    							if (bestScore == 0)  							{  								// found a perfect match stop looking  								break;  							}  						}    						if (polygonAIndex != polygonBIndex)  						{  							IntPoint diff2 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][openPolygonList[polygonBIndex].Count - 1];  							long distSquared2 = (diff2).LengthSquared();  							if (distSquared2 < bestScore)  							{  								bestScore = distSquared2;  								bestA = polygonAIndex;  								bestB = polygonBIndex;  								reversed = true;    								if (bestScore == 0)  								{  									// found a perfect match stop looking  									break;  								}  							}  						}  					}    					if (bestScore == 0)  					{  						// found a perfect match stop looking  						break;  					}  				}    				if (bestScore >= 10000 * 10000)  				{  					break;  				}    				if (bestA == bestB) // This loop connects to itself' close the polygon.  				{  					PolygonList.Add(new Polygon(openPolygonList[bestA]));  					openPolygonList[bestA].Clear(); // B is cleared as it is A  				}  				else  				{  					if (reversed)  					{  						if (openPolygonList[bestA].Count > openPolygonList[bestB].Count)  						{  							for (int indexB = openPolygonList[bestB].Count - 1; indexB >= 0; indexB--)  							{  								openPolygonList[bestA].Add(openPolygonList[bestB][indexB]);  							}  							openPolygonList[bestB].Clear();  						}  						else  						{  							for (int indexA = openPolygonList[bestA].Count - 1; indexA >= 0; indexA--)  							{  								openPolygonList[bestB].Add(openPolygonList[bestA][indexA]);  							}  							openPolygonList[bestA].Clear();  						}  					}  					else  					{  						openPolygonList[bestA].AddRange(openPolygonList[bestB]);  						openPolygonList[bestB].Clear();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: while (true)  			{  				long bestScore = 10000 * 10000;  				int bestA = -1;  				int bestB = -1;  				bool reversed = false;  				for (int polygonAIndex = 0; polygonAIndex < openPolygonList.Count; polygonAIndex++)  				{  					if (openPolygonList[polygonAIndex].Count < 1)  					{  						continue;  					}    					for (int polygonBIndex = 0; polygonBIndex < openPolygonList.Count; polygonBIndex++)  					{  						if (openPolygonList[polygonBIndex].Count < 1)  						{  							continue;  						}    						IntPoint diff1 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][0];  						long distSquared1 = (diff1).LengthSquared();  						if (distSquared1 < bestScore)  						{  							bestScore = distSquared1;  							bestA = polygonAIndex;  							bestB = polygonBIndex;  							reversed = false;    							if (bestScore == 0)  							{  								// found a perfect match stop looking  								break;  							}  						}    						if (polygonAIndex != polygonBIndex)  						{  							IntPoint diff2 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][openPolygonList[polygonBIndex].Count - 1];  							long distSquared2 = (diff2).LengthSquared();  							if (distSquared2 < bestScore)  							{  								bestScore = distSquared2;  								bestA = polygonAIndex;  								bestB = polygonBIndex;  								reversed = true;    								if (bestScore == 0)  								{  									// found a perfect match stop looking  									break;  								}  							}  						}  					}    					if (bestScore == 0)  					{  						// found a perfect match stop looking  						break;  					}  				}    				if (bestScore >= 10000 * 10000)  				{  					break;  				}    				if (bestA == bestB) // This loop connects to itself' close the polygon.  				{  					PolygonList.Add(new Polygon(openPolygonList[bestA]));  					openPolygonList[bestA].Clear(); // B is cleared as it is A  				}  				else  				{  					if (reversed)  					{  						if (openPolygonList[bestA].Count > openPolygonList[bestB].Count)  						{  							for (int indexB = openPolygonList[bestB].Count - 1; indexB >= 0; indexB--)  							{  								openPolygonList[bestA].Add(openPolygonList[bestB][indexB]);  							}  							openPolygonList[bestB].Clear();  						}  						else  						{  							for (int indexA = openPolygonList[bestA].Count - 1; indexA >= 0; indexA--)  							{  								openPolygonList[bestB].Add(openPolygonList[bestA][indexA]);  							}  							openPolygonList[bestA].Clear();  						}  					}  					else  					{  						openPolygonList[bestA].AddRange(openPolygonList[bestB]);  						openPolygonList[bestB].Clear();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: while (true)  			{  				long bestScore = 10000 * 10000;  				int bestA = -1;  				int bestB = -1;  				bool reversed = false;  				for (int polygonAIndex = 0; polygonAIndex < openPolygonList.Count; polygonAIndex++)  				{  					if (openPolygonList[polygonAIndex].Count < 1)  					{  						continue;  					}    					for (int polygonBIndex = 0; polygonBIndex < openPolygonList.Count; polygonBIndex++)  					{  						if (openPolygonList[polygonBIndex].Count < 1)  						{  							continue;  						}    						IntPoint diff1 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][0];  						long distSquared1 = (diff1).LengthSquared();  						if (distSquared1 < bestScore)  						{  							bestScore = distSquared1;  							bestA = polygonAIndex;  							bestB = polygonBIndex;  							reversed = false;    							if (bestScore == 0)  							{  								// found a perfect match stop looking  								break;  							}  						}    						if (polygonAIndex != polygonBIndex)  						{  							IntPoint diff2 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][openPolygonList[polygonBIndex].Count - 1];  							long distSquared2 = (diff2).LengthSquared();  							if (distSquared2 < bestScore)  							{  								bestScore = distSquared2;  								bestA = polygonAIndex;  								bestB = polygonBIndex;  								reversed = true;    								if (bestScore == 0)  								{  									// found a perfect match stop looking  									break;  								}  							}  						}  					}    					if (bestScore == 0)  					{  						// found a perfect match stop looking  						break;  					}  				}    				if (bestScore >= 10000 * 10000)  				{  					break;  				}    				if (bestA == bestB) // This loop connects to itself' close the polygon.  				{  					PolygonList.Add(new Polygon(openPolygonList[bestA]));  					openPolygonList[bestA].Clear(); // B is cleared as it is A  				}  				else  				{  					if (reversed)  					{  						if (openPolygonList[bestA].Count > openPolygonList[bestB].Count)  						{  							for (int indexB = openPolygonList[bestB].Count - 1; indexB >= 0; indexB--)  							{  								openPolygonList[bestA].Add(openPolygonList[bestB][indexB]);  							}  							openPolygonList[bestB].Clear();  						}  						else  						{  							for (int indexA = openPolygonList[bestA].Count - 1; indexA >= 0; indexA--)  							{  								openPolygonList[bestB].Add(openPolygonList[bestA][indexA]);  							}  							openPolygonList[bestA].Clear();  						}  					}  					else  					{  						openPolygonList[bestA].AddRange(openPolygonList[bestB]);  						openPolygonList[bestB].Clear();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: while (true)  			{  				long bestScore = 10000 * 10000;  				int bestA = -1;  				int bestB = -1;  				bool reversed = false;  				for (int polygonAIndex = 0; polygonAIndex < openPolygonList.Count; polygonAIndex++)  				{  					if (openPolygonList[polygonAIndex].Count < 1)  					{  						continue;  					}    					for (int polygonBIndex = 0; polygonBIndex < openPolygonList.Count; polygonBIndex++)  					{  						if (openPolygonList[polygonBIndex].Count < 1)  						{  							continue;  						}    						IntPoint diff1 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][0];  						long distSquared1 = (diff1).LengthSquared();  						if (distSquared1 < bestScore)  						{  							bestScore = distSquared1;  							bestA = polygonAIndex;  							bestB = polygonBIndex;  							reversed = false;    							if (bestScore == 0)  							{  								// found a perfect match stop looking  								break;  							}  						}    						if (polygonAIndex != polygonBIndex)  						{  							IntPoint diff2 = openPolygonList[polygonAIndex][openPolygonList[polygonAIndex].Count - 1] - openPolygonList[polygonBIndex][openPolygonList[polygonBIndex].Count - 1];  							long distSquared2 = (diff2).LengthSquared();  							if (distSquared2 < bestScore)  							{  								bestScore = distSquared2;  								bestA = polygonAIndex;  								bestB = polygonBIndex;  								reversed = true;    								if (bestScore == 0)  								{  									// found a perfect match stop looking  									break;  								}  							}  						}  					}    					if (bestScore == 0)  					{  						// found a perfect match stop looking  						break;  					}  				}    				if (bestScore >= 10000 * 10000)  				{  					break;  				}    				if (bestA == bestB) // This loop connects to itself' close the polygon.  				{  					PolygonList.Add(new Polygon(openPolygonList[bestA]));  					openPolygonList[bestA].Clear(); // B is cleared as it is A  				}  				else  				{  					if (reversed)  					{  						if (openPolygonList[bestA].Count > openPolygonList[bestB].Count)  						{  							for (int indexB = openPolygonList[bestB].Count - 1; indexB >= 0; indexB--)  							{  								openPolygonList[bestA].Add(openPolygonList[bestB][indexB]);  							}  							openPolygonList[bestB].Clear();  						}  						else  						{  							for (int indexA = openPolygonList[bestA].Count - 1; indexA >= 0; indexA--)  							{  								openPolygonList[bestB].Add(openPolygonList[bestA][indexA]);  							}  							openPolygonList[bestA].Clear();  						}  					}  					else  					{  						openPolygonList[bestA].AddRange(openPolygonList[bestB]);  						openPolygonList[bestB].Clear();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: int minimumPerimeter = 1000;
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: double minimumDistanceToCreateNewPosition = 10;
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,FindPolygonPointClosestTo,The following statement contains a magic number: for (int n = 0; n < PolygonList.Count; n++)  			{  				IntPoint p0 = PolygonList[n][PolygonList[n].Count - 1];  				for (int i = 0; i < PolygonList[n].Count; i++)  				{  					IntPoint p1 = PolygonList[n][i];    					//Q = A + Normal( B - A ) * ((( B - A ) dot ( P - A )) / VSize( A - B ));  					IntPoint pDiff = p1 - p0;  					long lineLength = (pDiff).Length();  					if (lineLength > 1)  					{  						long distOnLine = (pDiff).Dot(input - p0) / lineLength;  						if (distOnLine >= 0 && distOnLine <= lineLength)  						{  							IntPoint q = p0 + pDiff * distOnLine / lineLength;  							if ((q - input).ShorterThen(100))  							{  								ret.intersectionPoint = q;  								ret.polygonIdx = n;  								ret.pointIdx = i;  								return ret;  							}  						}  					}  					p0 = p1;  				}  			}
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,C:\repos\MatterHackers_MatterSlice\Slicer\SlicerLayer.cs,GetPositionKey,The following statement contains a magic number: return intPoint.X + (intPoint.Y << 31);
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,ExtruderData,The following statement contains a magic number: int countOfNormalThicknessLayers = Math.Max(0' (int)((heightWithoutFirstLayer / (double)layerThickness_um) + .5));
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,ExtruderData,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < layerCount; layerIndex++)  			{  				long z;  				if (layerIndex == 0)  				{  					z = initialLayerThickness_um / 2;  				}  				else  				{  					z = initialLayerThickness_um + layerThickness_um / 2 + layerThickness_um * (layerIndex - 1);  				}  				layers.Add(new MeshProcessingLayer(z));  			}
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,ExtruderData,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < layerCount; layerIndex++)  			{  				long z;  				if (layerIndex == 0)  				{  					z = initialLayerThickness_um / 2;  				}  				else  				{  					z = initialLayerThickness_um + layerThickness_um / 2 + layerThickness_um * (layerIndex - 1);  				}  				layers.Add(new MeshProcessingLayer(z));  			}
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,ExtruderData,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < ov.facesTriangle.Count; faceIndex++)  			{  				IntPoint p0 = ov.vertices[ov.facesTriangle[faceIndex].vertexIndex[0]].position;  				IntPoint p1 = ov.vertices[ov.facesTriangle[faceIndex].vertexIndex[1]].position;  				IntPoint p2 = ov.vertices[ov.facesTriangle[faceIndex].vertexIndex[2]].position;  				long minZ = p0.Z;  				long maxZ = p0.Z;  				if (p1.Z < minZ) minZ = p1.Z;  				if (p2.Z < minZ) minZ = p2.Z;  				if (p1.Z > maxZ) maxZ = p1.Z;  				if (p2.Z > maxZ) maxZ = p2.Z;    				for (int layerIndex = 0; layerIndex < layers.Count; layerIndex++)  				{  					long z = layers[layerIndex].Z;  					if (z < minZ || z > maxZ)  					{  						continue;  					}    					SlicePerimeterSegment polyCrossingAtThisZ;  					if (p0.Z < z && p1.Z >= z && p2.Z >= z)  					{  						// p1   p2  						// --------  						//   p0  						polyCrossingAtThisZ = GetCrossingAtZ(p0' p2' p1' z);  					}  					else if (p0.Z >= z && p1.Z < z && p2.Z < z)  					{  						//   p0  						// --------  						// p1  p2  						polyCrossingAtThisZ = GetCrossingAtZ(p0' p1' p2' z);  					}  					else if (p1.Z < z && p0.Z >= z && p2.Z >= z)  					{  						// p0   p2  						// --------  						//   p1  						polyCrossingAtThisZ = GetCrossingAtZ(p1' p0' p2' z);  					}  					else if (p1.Z >= z && p0.Z < z && p2.Z < z)  					{  						//   p1  						// --------  						// p0  p2  						polyCrossingAtThisZ = GetCrossingAtZ(p1' p2' p0' z);  					}  					else if (p2.Z < z && p1.Z >= z && p0.Z >= z)  					{  						// p1   p0  						// --------  						//   p2  						polyCrossingAtThisZ = GetCrossingAtZ(p2' p1' p0' z);  					}  					else if (p2.Z >= z && p1.Z < z && p0.Z < z)  					{  						//   p2  						// --------  						// p1  p0  						polyCrossingAtThisZ = GetCrossingAtZ(p2' p0' p1' z);  					}  					else  					{  						//Not all cases create a segment' because a point of a face could create just a dot' and two touching faces  						//  on the slice would create two segments  						continue;  					}    					polyCrossingAtThisZ.hasBeenAddedToPolygon = false;  					layers[layerIndex].SegmentList.Add(polyCrossingAtThisZ);  				}  			}
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,DumpPolygonsToGcode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,DumpSegmentsToGcode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.start.X = (long)(singlePointOnSide.X + (double)(otherSide1.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.start.Y = (long)(singlePointOnSide.Y + (double)(otherSide1.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.end.X = (long)(singlePointOnSide.X + (double)(otherSide2.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,ExtruderData,C:\repos\MatterHackers_MatterSlice\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.end.Y = (long)(singlePointOnSide.Y + (double)(otherSide2.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,NewSupport,The following statement contains a magic number: cleanDistance_um = config.ExtrusionWidth_um / 10;
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,NewSupport,The following statement contains a magic number: long supportWidth_um = (long)(config.ExtrusionWidth_um * (100 - config.SupportPercent) / 100);
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,NewSupport,The following statement contains a magic number: long supportWidth_um = (long)(config.ExtrusionWidth_um * (100 - config.SupportPercent) / 100);
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,NewSupport,The following statement contains a magic number: insetPartOutlines = CreateInsetPartOutlines(allPartOutlines' config.ExtrusionWidth_um / 2);
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,NewSupport,The following statement contains a magic number: easyGrabDistanceOutlines = ExpandToEasyGrabDistance(allRequiredSupportOutlines' (int)(grabDistanceMm * 1000));
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueAirGappedBottomLayer,The following statement contains a magic number: currentAirGappedBottoms = currentAirGappedBottoms.Offset(-config.ExtrusionWidth_um / 2);
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueAirGappedBottomLayer,The following statement contains a magic number: foreach (Polygons islandOutline in supportIslands)  			{  				// force a retract if changing islands  				if (config.RetractWhenChangingIslands)  				{  					gcodeLayer.ForceRetract();  				}    				Polygons islandInfillLines = new Polygons();  				// render a grid of support  				if (config.GenerateSupportPerimeter)  				{  					Polygons outlines = Clipper.CleanPolygons(islandOutline' config.ExtrusionWidth_um / 4);  					gcodeLayer.QueuePolygonsByOptimizer(outlines' supportNormalConfig);  				}  				Polygons infillOutline = islandOutline.Offset(-config.ExtrusionWidth_um / 2);  				switch (config.SupportType)  				{  					case ConfigConstants.SUPPORT_TYPE.GRID:  						Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;    					case ConfigConstants.SUPPORT_TYPE.LINES:  						Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;  				}  				gcodeLayer.QueuePolygonsByOptimizer(islandInfillLines' supportNormalConfig);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueAirGappedBottomLayer,The following statement contains a magic number: foreach (Polygons islandOutline in supportIslands)  			{  				// force a retract if changing islands  				if (config.RetractWhenChangingIslands)  				{  					gcodeLayer.ForceRetract();  				}    				Polygons islandInfillLines = new Polygons();  				// render a grid of support  				if (config.GenerateSupportPerimeter)  				{  					Polygons outlines = Clipper.CleanPolygons(islandOutline' config.ExtrusionWidth_um / 4);  					gcodeLayer.QueuePolygonsByOptimizer(outlines' supportNormalConfig);  				}  				Polygons infillOutline = islandOutline.Offset(-config.ExtrusionWidth_um / 2);  				switch (config.SupportType)  				{  					case ConfigConstants.SUPPORT_TYPE.GRID:  						Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;    					case ConfigConstants.SUPPORT_TYPE.LINES:  						Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;  				}  				gcodeLayer.QueuePolygonsByOptimizer(islandInfillLines' supportNormalConfig);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueInterfaceSupportLayer,The following statement contains a magic number: Polygons currentInterfaceOutlines2 = interfaceLayers[layerIndex].Offset(-config.ExtrusionWidth_um / 2);
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueInterfaceSupportLayer,The following statement contains a magic number: if (currentInterfaceOutlines2.Count > 0)  			{  				List<Polygons> interfaceIslands = currentInterfaceOutlines2.ProcessIntoSeparatIslands();    				foreach (Polygons interfaceOutline in interfaceIslands)  				{  					// force a retract if changing islands  					if (config.RetractWhenChangingIslands)  					{  						gcodeLayer.ForceRetract();  					}    					// make a border if layer 0  					if (layerIndex == 0)  					{  						Polygons infillOutline = interfaceOutline.Offset(-supportInterfaceConfig.lineWidth_um / 2);  						Polygons outlines = Clipper.CleanPolygons(infillOutline' config.ExtrusionWidth_um / 4);  						if (gcodeLayer.QueuePolygonsByOptimizer(outlines' supportInterfaceConfig))  						{  							outputPaths = true;  						}  					}    					Polygons supportLines = new Polygons();  					Infill.GenerateLineInfill(config' interfaceOutline' supportLines' config.InfillStartingAngle + 90' config.ExtrusionWidth_um);  					if (gcodeLayer.QueuePolygonsByOptimizer(supportLines' supportInterfaceConfig))  					{  						outputPaths = true;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueInterfaceSupportLayer,The following statement contains a magic number: if (currentInterfaceOutlines2.Count > 0)  			{  				List<Polygons> interfaceIslands = currentInterfaceOutlines2.ProcessIntoSeparatIslands();    				foreach (Polygons interfaceOutline in interfaceIslands)  				{  					// force a retract if changing islands  					if (config.RetractWhenChangingIslands)  					{  						gcodeLayer.ForceRetract();  					}    					// make a border if layer 0  					if (layerIndex == 0)  					{  						Polygons infillOutline = interfaceOutline.Offset(-supportInterfaceConfig.lineWidth_um / 2);  						Polygons outlines = Clipper.CleanPolygons(infillOutline' config.ExtrusionWidth_um / 4);  						if (gcodeLayer.QueuePolygonsByOptimizer(outlines' supportInterfaceConfig))  						{  							outputPaths = true;  						}  					}    					Polygons supportLines = new Polygons();  					Infill.GenerateLineInfill(config' interfaceOutline' supportLines' config.InfillStartingAngle + 90' config.ExtrusionWidth_um);  					if (gcodeLayer.QueuePolygonsByOptimizer(supportLines' supportInterfaceConfig))  					{  						outputPaths = true;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueInterfaceSupportLayer,The following statement contains a magic number: if (currentInterfaceOutlines2.Count > 0)  			{  				List<Polygons> interfaceIslands = currentInterfaceOutlines2.ProcessIntoSeparatIslands();    				foreach (Polygons interfaceOutline in interfaceIslands)  				{  					// force a retract if changing islands  					if (config.RetractWhenChangingIslands)  					{  						gcodeLayer.ForceRetract();  					}    					// make a border if layer 0  					if (layerIndex == 0)  					{  						Polygons infillOutline = interfaceOutline.Offset(-supportInterfaceConfig.lineWidth_um / 2);  						Polygons outlines = Clipper.CleanPolygons(infillOutline' config.ExtrusionWidth_um / 4);  						if (gcodeLayer.QueuePolygonsByOptimizer(outlines' supportInterfaceConfig))  						{  							outputPaths = true;  						}  					}    					Polygons supportLines = new Polygons();  					Infill.GenerateLineInfill(config' interfaceOutline' supportLines' config.InfillStartingAngle + 90' config.ExtrusionWidth_um);  					if (gcodeLayer.QueuePolygonsByOptimizer(supportLines' supportInterfaceConfig))  					{  						outputPaths = true;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueNormalSupportLayer,The following statement contains a magic number: currentSupportOutlines = currentSupportOutlines.Offset(-supportNormalConfig.lineWidth_um / 2);
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueNormalSupportLayer,The following statement contains a magic number: foreach (Polygons islandOutline in supportIslands)  			{  				// force a retract if changing islands  				if (config.RetractWhenChangingIslands)  				{  					gcodeLayer.ForceRetract();  				}    				Polygons islandInfillLines = new Polygons();  				// render a grid of support  				if (config.GenerateSupportPerimeter || layerIndex == 0)  				{  					Polygons outlines = Clipper.CleanPolygons(islandOutline' config.ExtrusionWidth_um / 4);  					if(gcodeLayer.QueuePolygonsByOptimizer(outlines' supportNormalConfig))  					{  						outputPaths = true;  					}  				}    				Polygons infillOutline = islandOutline.Offset(-supportNormalConfig.lineWidth_um / 2);    				if (layerIndex == 0)  				{  					// on the first layer print this as solid  					Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.ExtrusionWidth_um);  				}  				else  				{  					switch (config.SupportType)  					{  						case ConfigConstants.SUPPORT_TYPE.GRID:  							Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;    						case ConfigConstants.SUPPORT_TYPE.LINES:  							Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;  					}  				}    				if (gcodeLayer.QueuePolygonsByOptimizer(islandInfillLines' supportNormalConfig))  				{  					outputPaths |= true;  				}  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueNormalSupportLayer,The following statement contains a magic number: foreach (Polygons islandOutline in supportIslands)  			{  				// force a retract if changing islands  				if (config.RetractWhenChangingIslands)  				{  					gcodeLayer.ForceRetract();  				}    				Polygons islandInfillLines = new Polygons();  				// render a grid of support  				if (config.GenerateSupportPerimeter || layerIndex == 0)  				{  					Polygons outlines = Clipper.CleanPolygons(islandOutline' config.ExtrusionWidth_um / 4);  					if(gcodeLayer.QueuePolygonsByOptimizer(outlines' supportNormalConfig))  					{  						outputPaths = true;  					}  				}    				Polygons infillOutline = islandOutline.Offset(-supportNormalConfig.lineWidth_um / 2);    				if (layerIndex == 0)  				{  					// on the first layer print this as solid  					Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.ExtrusionWidth_um);  				}  				else  				{  					switch (config.SupportType)  					{  						case ConfigConstants.SUPPORT_TYPE.GRID:  							Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;    						case ConfigConstants.SUPPORT_TYPE.LINES:  							Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;  					}  				}    				if (gcodeLayer.QueuePolygonsByOptimizer(islandInfillLines' supportNormalConfig))  				{  					outputPaths |= true;  				}  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,AccumulateDownPolygons,The following statement contains a magic number: long areaToTryAndBe = 20 * 20 * nozzleSize * nozzleSize;
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,AccumulateDownPolygons,The following statement contains a magic number: long areaToTryAndBe = 20 * 20 * nozzleSize * nozzleSize;
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,AccumulateDownPolygons,The following statement contains a magic number: for (int layerIndex = numLayers - 2; layerIndex >= 0; layerIndex--)  			{  				Polygons aboveRequiredSupport = inputPolys[layerIndex + 1];    				// get all the polygons above us  				Polygons accumulatedAbove = allDownOutlines[layerIndex + 1].CreateUnion(aboveRequiredSupport);    				// experimental and not working well enough yet  				if (config.MinimizeSupportColumns)  				{  					// reduce the amount of support material used  					for (int i = accumulatedAbove.Count - 1; i >= 0; i--)  					{  						Polygon polygon = accumulatedAbove[i];  						double polyArea = polygon.Area();  						if (polyArea > areaToTryAndBe)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(-config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  						else if (polyArea < areaToTryAndBe * .9)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  					}  				}    				// add in the support on this level  				Polygons curRequiredSupport = inputPolys[layerIndex];    				Polygons totalSupportThisLayer = accumulatedAbove.CreateUnion(curRequiredSupport);    				// remove the solid polygons on this level  				Polygons remainingAbove = totalSupportThisLayer.CreateDifference(allPartOutlines[layerIndex]);    				allDownOutlines[layerIndex] = Clipper.CleanPolygons(remainingAbove' cleanDistance_um);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,AccumulateDownPolygons,The following statement contains a magic number: for (int layerIndex = numLayers - 2; layerIndex >= 0; layerIndex--)  			{  				Polygons aboveRequiredSupport = inputPolys[layerIndex + 1];    				// get all the polygons above us  				Polygons accumulatedAbove = allDownOutlines[layerIndex + 1].CreateUnion(aboveRequiredSupport);    				// experimental and not working well enough yet  				if (config.MinimizeSupportColumns)  				{  					// reduce the amount of support material used  					for (int i = accumulatedAbove.Count - 1; i >= 0; i--)  					{  						Polygon polygon = accumulatedAbove[i];  						double polyArea = polygon.Area();  						if (polyArea > areaToTryAndBe)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(-config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  						else if (polyArea < areaToTryAndBe * .9)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  					}  				}    				// add in the support on this level  				Polygons curRequiredSupport = inputPolys[layerIndex];    				Polygons totalSupportThisLayer = accumulatedAbove.CreateUnion(curRequiredSupport);    				// remove the solid polygons on this level  				Polygons remainingAbove = totalSupportThisLayer.CreateDifference(allPartOutlines[layerIndex]);    				allDownOutlines[layerIndex] = Clipper.CleanPolygons(remainingAbove' cleanDistance_um);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,AccumulateDownPolygons,The following statement contains a magic number: for (int layerIndex = numLayers - 2; layerIndex >= 0; layerIndex--)  			{  				Polygons aboveRequiredSupport = inputPolys[layerIndex + 1];    				// get all the polygons above us  				Polygons accumulatedAbove = allDownOutlines[layerIndex + 1].CreateUnion(aboveRequiredSupport);    				// experimental and not working well enough yet  				if (config.MinimizeSupportColumns)  				{  					// reduce the amount of support material used  					for (int i = accumulatedAbove.Count - 1; i >= 0; i--)  					{  						Polygon polygon = accumulatedAbove[i];  						double polyArea = polygon.Area();  						if (polyArea > areaToTryAndBe)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(-config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  						else if (polyArea < areaToTryAndBe * .9)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  					}  				}    				// add in the support on this level  				Polygons curRequiredSupport = inputPolys[layerIndex];    				Polygons totalSupportThisLayer = accumulatedAbove.CreateUnion(curRequiredSupport);    				// remove the solid polygons on this level  				Polygons remainingAbove = totalSupportThisLayer.CreateDifference(allPartOutlines[layerIndex]);    				allDownOutlines[layerIndex] = Clipper.CleanPolygons(remainingAbove' cleanDistance_um);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,AccumulateDownPolygons,The following statement contains a magic number: for (int layerIndex = numLayers - 2; layerIndex >= 0; layerIndex--)  			{  				Polygons aboveRequiredSupport = inputPolys[layerIndex + 1];    				// get all the polygons above us  				Polygons accumulatedAbove = allDownOutlines[layerIndex + 1].CreateUnion(aboveRequiredSupport);    				// experimental and not working well enough yet  				if (config.MinimizeSupportColumns)  				{  					// reduce the amount of support material used  					for (int i = accumulatedAbove.Count - 1; i >= 0; i--)  					{  						Polygon polygon = accumulatedAbove[i];  						double polyArea = polygon.Area();  						if (polyArea > areaToTryAndBe)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(-config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  						else if (polyArea < areaToTryAndBe * .9)  						{  							Polygons offsetPolygons = new Polygons() { polygon }.Offset(config.ExtrusionWidth_um / 2);  							accumulatedAbove.RemoveAt(i);  							foreach (Polygon polyToAdd in offsetPolygons)  							{  								accumulatedAbove.Insert(i' polyToAdd);  							}  						}  					}  				}    				// add in the support on this level  				Polygons curRequiredSupport = inputPolys[layerIndex];    				Polygons totalSupportThisLayer = accumulatedAbove.CreateUnion(curRequiredSupport);    				// remove the solid polygons on this level  				Polygons remainingAbove = totalSupportThisLayer.CreateDifference(allPartOutlines[layerIndex]);    				allDownOutlines[layerIndex] = Clipper.CleanPolygons(remainingAbove' cleanDistance_um);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,CalculateDifferencePerLayer,The following statement contains a magic number: for (int layerIndex = numLayers - 2; layerIndex >= 0; layerIndex--)  			{  				Polygons curRequiredSupport = inputPolys[layerIndex];  				Polygons totalSupportThisLayer = curRequiredSupport.CreateDifference(outlinesToRemove[layerIndex]);    				diferenceLayers[layerIndex] = Clipper.CleanPolygons(totalSupportThisLayer' cleanDistance_um);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,ClipToXyDistance,The following statement contains a magic number: for (int layerIndex = numLayers - 2; layerIndex >= 0; layerIndex--)  			{  				Polygons curRequiredSupport = inputPolys[layerIndex];  				Polygons expandedlayerPolys = allPartOutlines[layerIndex].Offset(config.SupportXYDistance_um);  				Polygons totalSupportThisLayer = curRequiredSupport.CreateDifference(expandedlayerPolys);    				clippedToXyOutlines[layerIndex] = Clipper.CleanPolygons(totalSupportThisLayer' cleanDistance_um);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,CreateInsetPartOutlines,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < numLayers; layerIndex++)  			{  				Polygons insetPolygons = Clipper.CleanPolygons(inputPolys[layerIndex].Offset(-insetAmount_um)' cleanDistance_um);  				List<Polygons> insetIslands = insetPolygons.ProcessIntoSeparatIslands();    				foreach (Polygons insetOutline in insetIslands)  				{  					insetOutline.RemoveSmallAreas(insetAmount_um * 2);  					foreach (var islandPart in insetOutline)  					{  						allInsetOutlines[layerIndex].Add(islandPart);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,CreateInterfaceLayers,The following statement contains a magic number: if (numInterfaceLayers > 0)  			{  				for (int layerIndex = 0; layerIndex < numLayers; layerIndex++)  				{  					Polygons accumulatedAbove = inputPolys[layerIndex].DeepCopy();    					for (int addIndex = layerIndex + 1; addIndex < Math.Min(layerIndex + numInterfaceLayers' numLayers - 2); addIndex++)  					{  						accumulatedAbove = accumulatedAbove.CreateUnion(inputPolys[addIndex]);  						accumulatedAbove = Clipper.CleanPolygons(accumulatedAbove' cleanDistance_um);  					}    					allInterfaceLayers[layerIndex] = accumulatedAbove;  				}  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,FindAllPotentialSupportOutlines,The following statement contains a magic number: for (int layerIndex = numLayers - 2; layerIndex >= 0; layerIndex--)  			{  				Polygons aboveLayerPolys = inputPolys[layerIndex + 1];  				Polygons curLayerPolys = inputPolys[layerIndex].Offset(supportWidth_um);  				Polygons areasNeedingSupport = aboveLayerPolys.CreateDifference(curLayerPolys);  				allPotentialSupportOutlines[layerIndex] = Clipper.CleanPolygons(areasNeedingSupport' cleanDistance_um);  			}
Magic Number,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,PushUpTops,The following statement contains a magic number: int layersFor2Mm = 2000 / config.LayerThickness_um;
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 0] = 0.0;
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 1] = 0.0;
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[0' 2] = 0.0;
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[1' 2] = 0.0;
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 2] = 1.0;
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 2] = 1.0;
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 0] = double.Parse(values[2]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 0] = double.Parse(values[2]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[0' 1] = double.Parse(values[3]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[1' 1] = double.Parse(values[4]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 1] = double.Parse(values[5]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 1] = double.Parse(values[5]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[0' 2] = double.Parse(values[6]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[0' 2] = double.Parse(values[6]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[1' 2] = double.Parse(values[7]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[1' 2] = double.Parse(values[7]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 2] = double.Parse(values[8]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 2] = double.Parse(values[8]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,FMatrix3x3,The following statement contains a magic number: m[2' 2] = double.Parse(values[8]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,apply,The following statement contains a magic number: return new IntPoint(  				(p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0])'  				(p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1])'  				(p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]));
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,apply,The following statement contains a magic number: return new IntPoint(  				(p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0])'  				(p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1])'  				(p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]));
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,apply,The following statement contains a magic number: return new IntPoint(  				(p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0])'  				(p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1])'  				(p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]));
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,apply,The following statement contains a magic number: return new IntPoint(  				(p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0])'  				(p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1])'  				(p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]));
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,apply,The following statement contains a magic number: return new IntPoint(  				(p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0])'  				(p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1])'  				(p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]));
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,apply,The following statement contains a magic number: return new IntPoint(  				(p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0])'  				(p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1])'  				(p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]));
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,FMatrix3x3,C:\repos\MatterHackers_MatterSlice\utils\Vector3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetSetting,The following statement contains a magic number: foreach (PropertyInfo property in allProperties)  			{  				// List of case insensitive names that will import as this property  				HashSet<string> possibleNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);  				possibleNames.Add(property.Name);    				// TODO: No one makes use of the LegacyName attribute thus the possibleNames HashSet and the LegacyName class could be removed as part of a code cleanup pass  				//  				// Including any mapped LegacyName attributes  				foreach (Attribute attribute in Attribute.GetCustomAttributes(property))  				{  					LegacyName legacyName = attribute as LegacyName;  					if (legacyName != null)  					{  						possibleNames.Add(legacyName.Name);  					}  				}    				if (possibleNames.Contains(keyToSet))  				{  					switch (property.PropertyType.Name)  					{  						case "Int32":  							property.SetValue(this' (int)double.Parse(valueToSetTo));  							break;    						case "Double":  							property.SetValue(this' double.Parse(valueToSetTo));  							break;    						case "Boolean":  							property.SetValue(this' bool.Parse(valueToSetTo));  							break;    						case "FMatrix3x3":  							{  								property.SetValue(this' new FMatrix3x3(valueToSetTo));  							}  							break;    						case "DoublePoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new DoublePoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}  							break;    						case "IntPoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new IntPoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}  							break;    						case "IntPoint[]":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								List<IntPoint> points = new List<IntPoint>();    								string intPointString;  								int nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' 0);  								do  								{  									string[] xyValues = intPointString.Split(''');  									points.Add(new IntPoint(double.Parse(xyValues[0]) * 1000' double.Parse(xyValues[1]) * 1000));    									nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' nextIndex);  								} while (nextIndex != -1);  								property.SetValue(this' points.ToArray());  							}  							break;    						case "String":  							property.SetValue(this' valueToSetTo.Replace("\\n"' "\n"));  							break;    						case "REPAIR_OVERLAPS":  						case "REPAIR_OUTLINES":  						case "SUPPORT_TYPE":  						case "INFILL_TYPE":  						case "OUTPUT_TYPE":  							try  							{  								valueToSetTo = valueToSetTo.Replace('|'' ''');  								property.SetValue(this' Enum.Parse(property.PropertyType' valueToSetTo));  							}  							catch (Exception)  							{  							}  							break;    						default:  							throw new NotImplementedException("unknown type");  					}    					return true;  				}  			}
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetSetting,The following statement contains a magic number: foreach (PropertyInfo property in allProperties)  			{  				// List of case insensitive names that will import as this property  				HashSet<string> possibleNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);  				possibleNames.Add(property.Name);    				// TODO: No one makes use of the LegacyName attribute thus the possibleNames HashSet and the LegacyName class could be removed as part of a code cleanup pass  				//  				// Including any mapped LegacyName attributes  				foreach (Attribute attribute in Attribute.GetCustomAttributes(property))  				{  					LegacyName legacyName = attribute as LegacyName;  					if (legacyName != null)  					{  						possibleNames.Add(legacyName.Name);  					}  				}    				if (possibleNames.Contains(keyToSet))  				{  					switch (property.PropertyType.Name)  					{  						case "Int32":  							property.SetValue(this' (int)double.Parse(valueToSetTo));  							break;    						case "Double":  							property.SetValue(this' double.Parse(valueToSetTo));  							break;    						case "Boolean":  							property.SetValue(this' bool.Parse(valueToSetTo));  							break;    						case "FMatrix3x3":  							{  								property.SetValue(this' new FMatrix3x3(valueToSetTo));  							}  							break;    						case "DoublePoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new DoublePoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}  							break;    						case "IntPoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new IntPoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}  							break;    						case "IntPoint[]":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								List<IntPoint> points = new List<IntPoint>();    								string intPointString;  								int nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' 0);  								do  								{  									string[] xyValues = intPointString.Split(''');  									points.Add(new IntPoint(double.Parse(xyValues[0]) * 1000' double.Parse(xyValues[1]) * 1000));    									nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' nextIndex);  								} while (nextIndex != -1);  								property.SetValue(this' points.ToArray());  							}  							break;    						case "String":  							property.SetValue(this' valueToSetTo.Replace("\\n"' "\n"));  							break;    						case "REPAIR_OVERLAPS":  						case "REPAIR_OUTLINES":  						case "SUPPORT_TYPE":  						case "INFILL_TYPE":  						case "OUTPUT_TYPE":  							try  							{  								valueToSetTo = valueToSetTo.Replace('|'' ''');  								property.SetValue(this' Enum.Parse(property.PropertyType' valueToSetTo));  							}  							catch (Exception)  							{  							}  							break;    						default:  							throw new NotImplementedException("unknown type");  					}    					return true;  				}  			}
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FilamentDiameter = 2.89;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerThickness = .3;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: LayerThickness = .1;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerExtrusionWidth = .8;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: ExtrusionWidth = .4;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportExtrusionPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: NumberOfPerimeters = 2;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: NumberOfBottomLayers = 6;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: NumberOfTopLayers = 6;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: TopInfillSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: BottomInfillSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportMaterialSpeed = 40;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillSpeed = 50;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: BridgeSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: BridgeFanSpeedPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RaftFanSpeedPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: OutsidePerimeterSpeed = 50;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InsidePerimetersSpeed = 50;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: TravelSpeed = 200;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerToAllowFan = 2;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SkirtDistanceFromObject = 6;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillPercent = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillExtendIntoPerimeter = .06;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillStartingAngle = 45;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: PositionToPlaceObjectCenter = new DoublePoint(102.5' 102.5);
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: PositionToPlaceObjectCenter = new DoublePoint(102.5' 102.5);
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RaftAirGap = .2;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportAirGap = .3;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RaftExtraDistanceAroundPart = 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportPercent = 50;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportLineSpacing = ExtrusionWidth * 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportXYDistanceFromObject = .7;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportInterfaceLayers = 3;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RetractionOnTravel = 4.5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RetractionSpeed = 45;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RetractionOnExtruderSwitch = 14.5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MinimumTravelToCauseRetraction = 10;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: WipeTowerSize = 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MinimumLayerTimeSeconds = 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MinimumPrintingSpeed = 10;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FanSpeedMinPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FanSpeedMaxPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,C:\repos\MatterHackers_MatterSlice\ConfigSettings.cs,GetEnumHelpText,The following statement contains a magic number: foreach (FieldInfo field in fields)  			{  				string[] names = field.ToString().Split(' ');  				if (names.Length == 2 && names[0] == enumName)  				{  					if (!first)  					{  						helpLine += "' ";  					}  					helpLine += names[1];  					first = false;  				}  			}
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[2] = 0;
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[3] = 1;
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: rotation = rotation / 180 * Math.PI;
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[2] = -matrix[1];
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[3] = matrix[0];
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[2] = -matrix[1];
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[3] = matrix[0];
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,apply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[1]' p.X * matrix[2] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,apply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[1]' p.X * matrix[2] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,unapply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[2]' p.X * matrix[1] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,PointMatrix,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,unapply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[2]' p.X * matrix[1] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,IntPointHelper,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,LengthMm,The following statement contains a magic number: double fx = (double)(thisPoint.X) / 1000.0;
Magic Number,MatterHackers.MatterSlice,IntPointHelper,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,LengthMm,The following statement contains a magic number: double fy = (double)(thisPoint.Y) / 1000.0;
Magic Number,MatterHackers.MatterSlice,IntPointHelper,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,LengthMm,The following statement contains a magic number: double fz = (double)(thisPoint.Z) / 1000.0;
Magic Number,MatterHackers.MatterSlice,IntPointHelper,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,OutputInMm,The following statement contains a magic number: return string.Format("[{0}'{1}'{2}]"' thisPoint.X / 1000.0' thisPoint.Y / 1000.0' thisPoint.Z / 1000.0);
Magic Number,MatterHackers.MatterSlice,IntPointHelper,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,OutputInMm,The following statement contains a magic number: return string.Format("[{0}'{1}'{2}]"' thisPoint.X / 1000.0' thisPoint.Y / 1000.0' thisPoint.Z / 1000.0);
Magic Number,MatterHackers.MatterSlice,IntPointHelper,C:\repos\MatterHackers_MatterSlice\utils\IntpointHelper.cs,OutputInMm,The following statement contains a magic number: return string.Format("[{0}'{1}'{2}]"' thisPoint.X / 1000.0' thisPoint.Y / 1000.0' thisPoint.Z / 1000.0);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,ConvertToLines,The following statement contains a magic number: foreach (Polygon polygon in polygons)  			{  				if (polygon.Count > 2)  				{  					int endIndex = closedLoop ? polygon.Count : polygon.Count - 1;  					for (int vertexIndex = 0; vertexIndex < endIndex; vertexIndex++)  					{  						linePolygons.Add(new Polygon() { polygon[vertexIndex]' polygon[(vertexIndex + 1) % polygon.Count] });  					}  				}  				else  				{  					linePolygons.Add(polygon);  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.minX -= 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.minY -= 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.maxY += 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.maxX += 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,OptimizePolygons,The following statement contains a magic number: for (int n = 0; n < polygons.Count; n++)  			{  				polygons[n].OptimizePolygon();  				if (polygons[n].Count < 3)  				{  					polygons.RemoveAt(n);  					n--;  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double areaOfExtrusion = (extrusionWidth / 1000.0) * (extrusionWidth / 1000.0);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double areaOfExtrusion = (extrusionWidth / 1000.0) * (extrusionWidth / 1000.0);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double minAreaSize = areaOfExtrusion / 2;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: for (int outlineIndex = polygons.Count - 1; outlineIndex >= 0; outlineIndex--)  			{  				double area = Math.Abs(polygons[outlineIndex].Area()) / 1000.0 / 1000.0; // convert from microns to mm's.    				// Only create an up/down Outline if the area is large enough. So you do not create tiny blobs of "trying to fill"  				if (area < minAreaSize)  				{  					polygons.RemoveAt(outlineIndex);  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: for (int outlineIndex = polygons.Count - 1; outlineIndex >= 0; outlineIndex--)  			{  				double area = Math.Abs(polygons[outlineIndex].Area()) / 1000.0 / 1000.0; // convert from microns to mm's.    				// Only create an up/down Outline if the area is large enough. So you do not create tiny blobs of "trying to fill"  				if (area < minAreaSize)  				{  					polygons.RemoveAt(outlineIndex);  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,SaveToGCode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: double scaleDenominator = 150;
Magic Number,MatterHackers.MatterSlice,SplitCommandLine,C:\repos\MatterHackers_MatterSlice\utils\SplitCommandLine.cs,TrimMatchingQuotes,The following statement contains a magic number: if ((input.Length >= 2)  				&& (input[0] == quote)  				&& (input[input.Length - 1] == quote))  			{  				return input.Substring(1' input.Length - 2);  			}
Magic Number,MatterHackers.MatterSlice,SplitCommandLine,C:\repos\MatterHackers_MatterSlice\utils\SplitCommandLine.cs,TrimMatchingQuotes,The following statement contains a magic number: if ((input.Length >= 2)  				&& (input[0] == quote)  				&& (input[input.Length - 1] == quote))  			{  				return input.Substring(1' input.Length - 2);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,DoProcessing,The following statement contains a magic number: for (int meshIndex = 0; meshIndex < simpleMeshCollection.SimpleMeshes.Count; meshIndex++)  			{  				LogOutput.Log("  Face counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count) * 100));  				LogOutput.Log("  Vertex counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3) * 100));  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,DoProcessing,The following statement contains a magic number: for (int meshIndex = 0; meshIndex < simpleMeshCollection.SimpleMeshes.Count; meshIndex++)  			{  				LogOutput.Log("  Face counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count) * 100));  				LogOutput.Log("  Vertex counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3) * 100));  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,DoProcessing,The following statement contains a magic number: for (int meshIndex = 0; meshIndex < simpleMeshCollection.SimpleMeshes.Count; meshIndex++)  			{  				LogOutput.Log("  Face counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count) * 100));  				LogOutput.Log("  Vertex counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3) * 100));  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,DoProcessing,The following statement contains a magic number: for (int meshIndex = 0; meshIndex < simpleMeshCollection.SimpleMeshes.Count; meshIndex++)  			{  				LogOutput.Log("  Face counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].facesTriangle.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count) * 100));  				LogOutput.Log("  Vertex counts: {0} . {1} {2:0.0}%\n".FormatWith((int)simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3' (int)optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count' (double)(optomizedMeshCollection.OptimizedMeshes[meshIndex].vertices.Count) / (double)(simpleMeshCollection.SimpleMeshes[meshIndex].faceTriangles.Count * 3) * 100));  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,ProcessSliceData,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < totalLayers; layerIndex++)  			{  				for (int extruderIndex = 0; extruderIndex < slicingData.Extruders.Count; extruderIndex++)  				{  					if (MatterSlice.Canceled)  					{  						return;  					}  					int insetCount = config.NumberOfPerimeters;  					if (config.ContinuousSpiralOuterPerimeter && (int)(layerIndex) < config.NumberOfBottomLayers && layerIndex % 2 == 1)  					{  						//Add extra insets every 2 layers when spiralizing' this makes bottoms of cups watertight.  						insetCount += 1;  					}    					SliceLayer layer = slicingData.Extruders[extruderIndex].Layers[layerIndex];    					if (layerIndex == 0)  					{  						layer.GenerateInsets(config.FirstLayerExtrusionWidth_um' config.FirstLayerExtrusionWidth_um' insetCount' config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter);  					}  					else  					{  						layer.GenerateInsets(config.ExtrusionWidth_um' config.OutsideExtrusionWidth_um' insetCount' config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter);  					}  				}  				LogOutput.Log("Creating Insets {0}/{1}\n".FormatWith(layerIndex + 1' totalLayers));  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The following statement contains a magic number: if (config.EnableRaft)  			{  				gcode.WriteComment("firstLayerThickness = {0}".FormatWith(config.RaftBaseThickness_um / 1000.0));  			}  			else  			{  				gcode.WriteComment("firstLayerThickness = {0}".FormatWith(config.FirstLayerThickness));  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,WriteGCode,The following statement contains a magic number: if (fileNumber == 1)  			{  				gcode.WriteCode(config.StartCode);  			}  			else  			{  				gcode.WriteFanCommand(0);  				gcode.ResetExtrusionValue();  				gcode.WriteRetraction();  				gcode.SetZ(maxObjectHeight + 5000);  				gcode.WriteMove(gcode.GetPosition()' config.TravelSpeed' 0);  				gcode.WriteMove(new IntPoint(slicingData.modelMin.X' slicingData.modelMin.Y' gcode.CurrentZ)' config.TravelSpeed' 0);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePerimeterWithMergOverlaps,The following statement contains a magic number: if (perimeterToCheckForMerge.Count > 2)  			{  				pathHadOverlaps = perimeterToCheckForMerge.MergePerimeterOverlaps(config.lineWidth_um' out pathsWithOverlapsRemoved' pathIsClosed)  					&& pathsWithOverlapsRemoved.Count > 0;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,GetFanSpeed,The following statement contains a magic number: if (gcodeLayer.getExtrudeSpeedFactor() <= 50)  			{  				fanSpeedPercent = config.FanSpeedMaxPercent;  			}  			else  			{  				int n = gcodeLayer.getExtrudeSpeedFactor() - 50;  				fanSpeedPercent = config.FanSpeedMinPercent * n / 50 + config.FanSpeedMaxPercent * (50 - n) / 50;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,GetFanSpeed,The following statement contains a magic number: if (gcodeLayer.getExtrudeSpeedFactor() <= 50)  			{  				fanSpeedPercent = config.FanSpeedMaxPercent;  			}  			else  			{  				int n = gcodeLayer.getExtrudeSpeedFactor() - 50;  				fanSpeedPercent = config.FanSpeedMinPercent * n / 50 + config.FanSpeedMaxPercent * (50 - n) / 50;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,GetFanSpeed,The following statement contains a magic number: if (gcodeLayer.getExtrudeSpeedFactor() <= 50)  			{  				fanSpeedPercent = config.FanSpeedMaxPercent;  			}  			else  			{  				int n = gcodeLayer.getExtrudeSpeedFactor() - 50;  				fanSpeedPercent = config.FanSpeedMinPercent * n / 50 + config.FanSpeedMaxPercent * (50 - n) / 50;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,GetFanSpeed,The following statement contains a magic number: if (gcodeLayer.getExtrudeSpeedFactor() <= 50)  			{  				fanSpeedPercent = config.FanSpeedMaxPercent;  			}  			else  			{  				int n = gcodeLayer.getExtrudeSpeedFactor() - 50;  				fanSpeedPercent = config.FanSpeedMinPercent * n / 50 + config.FanSpeedMaxPercent * (50 - n) / 50;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,GetFanSpeed,The following statement contains a magic number: if (gcodeLayer.getExtrudeSpeedFactor() <= 50)  			{  				fanSpeedPercent = config.FanSpeedMaxPercent;  			}  			else  			{  				int n = gcodeLayer.getExtrudeSpeedFactor() - 50;  				fanSpeedPercent = config.FanSpeedMinPercent * n / 50 + config.FanSpeedMaxPercent * (50 - n) / 50;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: for (int islandOrderIndex = 0; islandOrderIndex < islandOrderOptimizer.bestIslandOrderIndex.Count; islandOrderIndex++)  			{  				if (config.ContinuousSpiralOuterPerimeter && islandOrderIndex > 0)  				{  					continue;  				}    				LayerIsland island = layer.Islands[islandOrderOptimizer.bestIslandOrderIndex[islandOrderIndex]];    				if (config.AvoidCrossingPerimeters)  				{  					MoveToIsland(layerGcodePlanner' layer' island);  				}  				else  				{  					if(config.RetractWhenChangingIslands)  layerGcodePlanner.ForceRetract();  				}    				Polygons fillPolygons = new Polygons();  				Polygons topFillPolygons = new Polygons();  				Polygons bridgePolygons = new Polygons();    				Polygons bottomFillPolygons = new Polygons();    				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' topFillPolygons' bridgePolygons);  				bottomFillIslandPolygons.Add(bottomFillPolygons);    				if (config.NumberOfPerimeters > 0)  				{  					if (config.ContinuousSpiralOuterPerimeter  						&& layerIndex >= config.NumberOfBottomLayers)  					{  						inset0Config.spiralize = true;  					}    					// Put all the insets into a new list so we can keep track of what has been printed.  					// The island could be a rectangle with 4 screew holes. So' with 3 perimeters that colud be the outside 3 + the foles 4 * 3' 15 polygons.  					List<Polygons> insetsForThisIsland = new List<Polygons>(island.InsetToolPaths.Count);  					for (int insetIndex = 0; insetIndex < island.InsetToolPaths.Count; insetIndex++)  					{  						insetsForThisIsland.Add(new Polygons());  						for (int polygonIndex = 0; polygonIndex < island.InsetToolPaths[insetIndex].Count; polygonIndex++)  						{  							if (island.InsetToolPaths[insetIndex][polygonIndex].Count > 0)  							{  								insetsForThisIsland[insetIndex].Add(island.InsetToolPaths[insetIndex][polygonIndex]);  							}  						}  					}    					// If we are on the very first layer we always start with the outside so that we can stick to the bed better.  					if (config.OutsidePerimetersFirst || layerIndex == 0 || inset0Config.spiralize)  					{  						if (inset0Config.spiralize)  						{  							if (island.InsetToolPaths.Count > 0)  							{  								Polygon outsideSinglePolygon = island.InsetToolPaths[0][0];  								layerGcodePlanner.QueuePolygonsByOptimizer(new Polygons() { outsideSinglePolygon }' inset0Config);  							}  						}  						else  						{  							int insetCount = CountInsetsToPrint(insetsForThisIsland);  							while (insetCount > 0)  							{  								bool limitDistance = false;  								if (island.InsetToolPaths.Count > 0)  								{  									QueueClosetsInset(insetsForThisIsland[0]' limitDistance' inset0Config' layerIndex' layerGcodePlanner);  								}    								// Move to the closest inset 1 and print it  								for (int insetIndex = 1; insetIndex < island.InsetToolPaths.Count; insetIndex++)  								{  									limitDistance = QueueClosetsInset(insetsForThisIsland[insetIndex]' limitDistance' insetXConfig' layerIndex' layerGcodePlanner);  								}    								insetCount = CountInsetsToPrint(insetsForThisIsland);  							}  						}  					}  					else // This is so we can do overhangs better (the outside can stick a bit to the inside).  					{  						int insetCount = CountInsetsToPrint(insetsForThisIsland);  						if(insetCount == 0   							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0)  						{  							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls  							layerGcodePlanner.QueueTravel(island.IslandOutline[0][0]);  						}  						while (insetCount > 0)  						{  							bool limitDistance = false;  							if (island.InsetToolPaths.Count > 0)  							{  								// Print the insets from inside to out (count - 1 to 0).  								for (int insetIndex = island.InsetToolPaths.Count - 1; insetIndex >= 0; insetIndex--)  								{  									if (!config.ContinuousSpiralOuterPerimeter  										&& insetIndex == island.InsetToolPaths.Count - 1)  									{  										var closestInsetStart = FindBestPoint(insetsForThisIsland[0]' layerGcodePlanner.LastPosition);  										if(closestInsetStart.X != long.MinValue)  										{  											layerGcodePlanner.QueueTravel(closestInsetStart);  										}  									}    									limitDistance = QueueClosetsInset(  										insetsForThisIsland[insetIndex]'  										limitDistance'  										insetIndex == 0 ? inset0Config : insetXConfig'  										layerIndex'  										layerGcodePlanner);    									// Figure out if there is another inset  								}  							}    							insetCount = CountInsetsToPrint(insetsForThisIsland);  						}  					}    					// Find the thin lines for this layer and add them to the queue  					if (config.FillThinGaps && !config.ContinuousSpiralOuterPerimeter)  					{  						for (int perimeter = 0; perimeter < config.NumberOfPerimeters; perimeter++)  						{  							Polygons thinLines = null;  							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 5' out thinLines' true))  							{  								fillPolygons.AddRange(thinLines);  							}  						}  					}    					if (config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter)  					{  						Polygons thinLines = null;  						// Collect all of the lines up to one third the extrusion diameter  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(island.IslandOutline);  						if (island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true))  						{  							for(int polyIndex=thinLines.Count-1; polyIndex>=0; polyIndex--)  							{  								var polygon = thinLines[polyIndex];    								if (polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4)  								{  									thinLines.RemoveAt(polyIndex);  								}  								else  								{  									for (int i = 0; i < polygon.Count; i++)  									{  										if (polygon[i].Width > 0)  										{  											polygon[i] = new IntPoint(polygon[i])  											{  												Width = extrusionWidth_um'  											};  										}  									}  								}  							}    							fillPolygons.AddRange(thinLines);  						}  					}  				}    				// Write the bridge polygons after the perimeter so they will have more to hold to while bridging the gaps.  				// It would be even better to slow down the perimeters that are part of bridges but that is for later.  				if (bridgePolygons.Count > 0)  				{  					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas);  				}    				// TODO: Put all of these segments into a list that can be queued together and still preserver their individual config settings.  				// This will make the total amount of travel while printing infill much less.  				layerGcodePlanner.QueuePolygonsByOptimizer(fillPolygons' fillConfig);  				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas);  				layerGcodePlanner.QueuePolygonsByOptimizer(topFillPolygons' topFillConfig);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: for (int islandOrderIndex = 0; islandOrderIndex < islandOrderOptimizer.bestIslandOrderIndex.Count; islandOrderIndex++)  			{  				if (config.ContinuousSpiralOuterPerimeter && islandOrderIndex > 0)  				{  					continue;  				}    				LayerIsland island = layer.Islands[islandOrderOptimizer.bestIslandOrderIndex[islandOrderIndex]];    				if (config.AvoidCrossingPerimeters)  				{  					MoveToIsland(layerGcodePlanner' layer' island);  				}  				else  				{  					if(config.RetractWhenChangingIslands)  layerGcodePlanner.ForceRetract();  				}    				Polygons fillPolygons = new Polygons();  				Polygons topFillPolygons = new Polygons();  				Polygons bridgePolygons = new Polygons();    				Polygons bottomFillPolygons = new Polygons();    				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' topFillPolygons' bridgePolygons);  				bottomFillIslandPolygons.Add(bottomFillPolygons);    				if (config.NumberOfPerimeters > 0)  				{  					if (config.ContinuousSpiralOuterPerimeter  						&& layerIndex >= config.NumberOfBottomLayers)  					{  						inset0Config.spiralize = true;  					}    					// Put all the insets into a new list so we can keep track of what has been printed.  					// The island could be a rectangle with 4 screew holes. So' with 3 perimeters that colud be the outside 3 + the foles 4 * 3' 15 polygons.  					List<Polygons> insetsForThisIsland = new List<Polygons>(island.InsetToolPaths.Count);  					for (int insetIndex = 0; insetIndex < island.InsetToolPaths.Count; insetIndex++)  					{  						insetsForThisIsland.Add(new Polygons());  						for (int polygonIndex = 0; polygonIndex < island.InsetToolPaths[insetIndex].Count; polygonIndex++)  						{  							if (island.InsetToolPaths[insetIndex][polygonIndex].Count > 0)  							{  								insetsForThisIsland[insetIndex].Add(island.InsetToolPaths[insetIndex][polygonIndex]);  							}  						}  					}    					// If we are on the very first layer we always start with the outside so that we can stick to the bed better.  					if (config.OutsidePerimetersFirst || layerIndex == 0 || inset0Config.spiralize)  					{  						if (inset0Config.spiralize)  						{  							if (island.InsetToolPaths.Count > 0)  							{  								Polygon outsideSinglePolygon = island.InsetToolPaths[0][0];  								layerGcodePlanner.QueuePolygonsByOptimizer(new Polygons() { outsideSinglePolygon }' inset0Config);  							}  						}  						else  						{  							int insetCount = CountInsetsToPrint(insetsForThisIsland);  							while (insetCount > 0)  							{  								bool limitDistance = false;  								if (island.InsetToolPaths.Count > 0)  								{  									QueueClosetsInset(insetsForThisIsland[0]' limitDistance' inset0Config' layerIndex' layerGcodePlanner);  								}    								// Move to the closest inset 1 and print it  								for (int insetIndex = 1; insetIndex < island.InsetToolPaths.Count; insetIndex++)  								{  									limitDistance = QueueClosetsInset(insetsForThisIsland[insetIndex]' limitDistance' insetXConfig' layerIndex' layerGcodePlanner);  								}    								insetCount = CountInsetsToPrint(insetsForThisIsland);  							}  						}  					}  					else // This is so we can do overhangs better (the outside can stick a bit to the inside).  					{  						int insetCount = CountInsetsToPrint(insetsForThisIsland);  						if(insetCount == 0   							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0)  						{  							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls  							layerGcodePlanner.QueueTravel(island.IslandOutline[0][0]);  						}  						while (insetCount > 0)  						{  							bool limitDistance = false;  							if (island.InsetToolPaths.Count > 0)  							{  								// Print the insets from inside to out (count - 1 to 0).  								for (int insetIndex = island.InsetToolPaths.Count - 1; insetIndex >= 0; insetIndex--)  								{  									if (!config.ContinuousSpiralOuterPerimeter  										&& insetIndex == island.InsetToolPaths.Count - 1)  									{  										var closestInsetStart = FindBestPoint(insetsForThisIsland[0]' layerGcodePlanner.LastPosition);  										if(closestInsetStart.X != long.MinValue)  										{  											layerGcodePlanner.QueueTravel(closestInsetStart);  										}  									}    									limitDistance = QueueClosetsInset(  										insetsForThisIsland[insetIndex]'  										limitDistance'  										insetIndex == 0 ? inset0Config : insetXConfig'  										layerIndex'  										layerGcodePlanner);    									// Figure out if there is another inset  								}  							}    							insetCount = CountInsetsToPrint(insetsForThisIsland);  						}  					}    					// Find the thin lines for this layer and add them to the queue  					if (config.FillThinGaps && !config.ContinuousSpiralOuterPerimeter)  					{  						for (int perimeter = 0; perimeter < config.NumberOfPerimeters; perimeter++)  						{  							Polygons thinLines = null;  							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 5' out thinLines' true))  							{  								fillPolygons.AddRange(thinLines);  							}  						}  					}    					if (config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter)  					{  						Polygons thinLines = null;  						// Collect all of the lines up to one third the extrusion diameter  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(island.IslandOutline);  						if (island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true))  						{  							for(int polyIndex=thinLines.Count-1; polyIndex>=0; polyIndex--)  							{  								var polygon = thinLines[polyIndex];    								if (polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4)  								{  									thinLines.RemoveAt(polyIndex);  								}  								else  								{  									for (int i = 0; i < polygon.Count; i++)  									{  										if (polygon[i].Width > 0)  										{  											polygon[i] = new IntPoint(polygon[i])  											{  												Width = extrusionWidth_um'  											};  										}  									}  								}  							}    							fillPolygons.AddRange(thinLines);  						}  					}  				}    				// Write the bridge polygons after the perimeter so they will have more to hold to while bridging the gaps.  				// It would be even better to slow down the perimeters that are part of bridges but that is for later.  				if (bridgePolygons.Count > 0)  				{  					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas);  				}    				// TODO: Put all of these segments into a list that can be queued together and still preserver their individual config settings.  				// This will make the total amount of travel while printing infill much less.  				layerGcodePlanner.QueuePolygonsByOptimizer(fillPolygons' fillConfig);  				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas);  				layerGcodePlanner.QueuePolygonsByOptimizer(topFillPolygons' topFillConfig);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: for (int islandOrderIndex = 0; islandOrderIndex < islandOrderOptimizer.bestIslandOrderIndex.Count; islandOrderIndex++)  			{  				if (config.ContinuousSpiralOuterPerimeter && islandOrderIndex > 0)  				{  					continue;  				}    				LayerIsland island = layer.Islands[islandOrderOptimizer.bestIslandOrderIndex[islandOrderIndex]];    				if (config.AvoidCrossingPerimeters)  				{  					MoveToIsland(layerGcodePlanner' layer' island);  				}  				else  				{  					if(config.RetractWhenChangingIslands)  layerGcodePlanner.ForceRetract();  				}    				Polygons fillPolygons = new Polygons();  				Polygons topFillPolygons = new Polygons();  				Polygons bridgePolygons = new Polygons();    				Polygons bottomFillPolygons = new Polygons();    				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' topFillPolygons' bridgePolygons);  				bottomFillIslandPolygons.Add(bottomFillPolygons);    				if (config.NumberOfPerimeters > 0)  				{  					if (config.ContinuousSpiralOuterPerimeter  						&& layerIndex >= config.NumberOfBottomLayers)  					{  						inset0Config.spiralize = true;  					}    					// Put all the insets into a new list so we can keep track of what has been printed.  					// The island could be a rectangle with 4 screew holes. So' with 3 perimeters that colud be the outside 3 + the foles 4 * 3' 15 polygons.  					List<Polygons> insetsForThisIsland = new List<Polygons>(island.InsetToolPaths.Count);  					for (int insetIndex = 0; insetIndex < island.InsetToolPaths.Count; insetIndex++)  					{  						insetsForThisIsland.Add(new Polygons());  						for (int polygonIndex = 0; polygonIndex < island.InsetToolPaths[insetIndex].Count; polygonIndex++)  						{  							if (island.InsetToolPaths[insetIndex][polygonIndex].Count > 0)  							{  								insetsForThisIsland[insetIndex].Add(island.InsetToolPaths[insetIndex][polygonIndex]);  							}  						}  					}    					// If we are on the very first layer we always start with the outside so that we can stick to the bed better.  					if (config.OutsidePerimetersFirst || layerIndex == 0 || inset0Config.spiralize)  					{  						if (inset0Config.spiralize)  						{  							if (island.InsetToolPaths.Count > 0)  							{  								Polygon outsideSinglePolygon = island.InsetToolPaths[0][0];  								layerGcodePlanner.QueuePolygonsByOptimizer(new Polygons() { outsideSinglePolygon }' inset0Config);  							}  						}  						else  						{  							int insetCount = CountInsetsToPrint(insetsForThisIsland);  							while (insetCount > 0)  							{  								bool limitDistance = false;  								if (island.InsetToolPaths.Count > 0)  								{  									QueueClosetsInset(insetsForThisIsland[0]' limitDistance' inset0Config' layerIndex' layerGcodePlanner);  								}    								// Move to the closest inset 1 and print it  								for (int insetIndex = 1; insetIndex < island.InsetToolPaths.Count; insetIndex++)  								{  									limitDistance = QueueClosetsInset(insetsForThisIsland[insetIndex]' limitDistance' insetXConfig' layerIndex' layerGcodePlanner);  								}    								insetCount = CountInsetsToPrint(insetsForThisIsland);  							}  						}  					}  					else // This is so we can do overhangs better (the outside can stick a bit to the inside).  					{  						int insetCount = CountInsetsToPrint(insetsForThisIsland);  						if(insetCount == 0   							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0)  						{  							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls  							layerGcodePlanner.QueueTravel(island.IslandOutline[0][0]);  						}  						while (insetCount > 0)  						{  							bool limitDistance = false;  							if (island.InsetToolPaths.Count > 0)  							{  								// Print the insets from inside to out (count - 1 to 0).  								for (int insetIndex = island.InsetToolPaths.Count - 1; insetIndex >= 0; insetIndex--)  								{  									if (!config.ContinuousSpiralOuterPerimeter  										&& insetIndex == island.InsetToolPaths.Count - 1)  									{  										var closestInsetStart = FindBestPoint(insetsForThisIsland[0]' layerGcodePlanner.LastPosition);  										if(closestInsetStart.X != long.MinValue)  										{  											layerGcodePlanner.QueueTravel(closestInsetStart);  										}  									}    									limitDistance = QueueClosetsInset(  										insetsForThisIsland[insetIndex]'  										limitDistance'  										insetIndex == 0 ? inset0Config : insetXConfig'  										layerIndex'  										layerGcodePlanner);    									// Figure out if there is another inset  								}  							}    							insetCount = CountInsetsToPrint(insetsForThisIsland);  						}  					}    					// Find the thin lines for this layer and add them to the queue  					if (config.FillThinGaps && !config.ContinuousSpiralOuterPerimeter)  					{  						for (int perimeter = 0; perimeter < config.NumberOfPerimeters; perimeter++)  						{  							Polygons thinLines = null;  							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 5' out thinLines' true))  							{  								fillPolygons.AddRange(thinLines);  							}  						}  					}    					if (config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter)  					{  						Polygons thinLines = null;  						// Collect all of the lines up to one third the extrusion diameter  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(island.IslandOutline);  						if (island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true))  						{  							for(int polyIndex=thinLines.Count-1; polyIndex>=0; polyIndex--)  							{  								var polygon = thinLines[polyIndex];    								if (polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4)  								{  									thinLines.RemoveAt(polyIndex);  								}  								else  								{  									for (int i = 0; i < polygon.Count; i++)  									{  										if (polygon[i].Width > 0)  										{  											polygon[i] = new IntPoint(polygon[i])  											{  												Width = extrusionWidth_um'  											};  										}  									}  								}  							}    							fillPolygons.AddRange(thinLines);  						}  					}  				}    				// Write the bridge polygons after the perimeter so they will have more to hold to while bridging the gaps.  				// It would be even better to slow down the perimeters that are part of bridges but that is for later.  				if (bridgePolygons.Count > 0)  				{  					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas);  				}    				// TODO: Put all of these segments into a list that can be queued together and still preserver their individual config settings.  				// This will make the total amount of travel while printing infill much less.  				layerGcodePlanner.QueuePolygonsByOptimizer(fillPolygons' fillConfig);  				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas);  				layerGcodePlanner.QueuePolygonsByOptimizer(topFillPolygons' topFillConfig);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: for (int islandOrderIndex = 0; islandOrderIndex < islandOrderOptimizer.bestIslandOrderIndex.Count; islandOrderIndex++)  			{  				if (config.ContinuousSpiralOuterPerimeter && islandOrderIndex > 0)  				{  					continue;  				}    				LayerIsland island = layer.Islands[islandOrderOptimizer.bestIslandOrderIndex[islandOrderIndex]];    				if (config.AvoidCrossingPerimeters)  				{  					MoveToIsland(layerGcodePlanner' layer' island);  				}  				else  				{  					if(config.RetractWhenChangingIslands)  layerGcodePlanner.ForceRetract();  				}    				Polygons fillPolygons = new Polygons();  				Polygons topFillPolygons = new Polygons();  				Polygons bridgePolygons = new Polygons();    				Polygons bottomFillPolygons = new Polygons();    				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' topFillPolygons' bridgePolygons);  				bottomFillIslandPolygons.Add(bottomFillPolygons);    				if (config.NumberOfPerimeters > 0)  				{  					if (config.ContinuousSpiralOuterPerimeter  						&& layerIndex >= config.NumberOfBottomLayers)  					{  						inset0Config.spiralize = true;  					}    					// Put all the insets into a new list so we can keep track of what has been printed.  					// The island could be a rectangle with 4 screew holes. So' with 3 perimeters that colud be the outside 3 + the foles 4 * 3' 15 polygons.  					List<Polygons> insetsForThisIsland = new List<Polygons>(island.InsetToolPaths.Count);  					for (int insetIndex = 0; insetIndex < island.InsetToolPaths.Count; insetIndex++)  					{  						insetsForThisIsland.Add(new Polygons());  						for (int polygonIndex = 0; polygonIndex < island.InsetToolPaths[insetIndex].Count; polygonIndex++)  						{  							if (island.InsetToolPaths[insetIndex][polygonIndex].Count > 0)  							{  								insetsForThisIsland[insetIndex].Add(island.InsetToolPaths[insetIndex][polygonIndex]);  							}  						}  					}    					// If we are on the very first layer we always start with the outside so that we can stick to the bed better.  					if (config.OutsidePerimetersFirst || layerIndex == 0 || inset0Config.spiralize)  					{  						if (inset0Config.spiralize)  						{  							if (island.InsetToolPaths.Count > 0)  							{  								Polygon outsideSinglePolygon = island.InsetToolPaths[0][0];  								layerGcodePlanner.QueuePolygonsByOptimizer(new Polygons() { outsideSinglePolygon }' inset0Config);  							}  						}  						else  						{  							int insetCount = CountInsetsToPrint(insetsForThisIsland);  							while (insetCount > 0)  							{  								bool limitDistance = false;  								if (island.InsetToolPaths.Count > 0)  								{  									QueueClosetsInset(insetsForThisIsland[0]' limitDistance' inset0Config' layerIndex' layerGcodePlanner);  								}    								// Move to the closest inset 1 and print it  								for (int insetIndex = 1; insetIndex < island.InsetToolPaths.Count; insetIndex++)  								{  									limitDistance = QueueClosetsInset(insetsForThisIsland[insetIndex]' limitDistance' insetXConfig' layerIndex' layerGcodePlanner);  								}    								insetCount = CountInsetsToPrint(insetsForThisIsland);  							}  						}  					}  					else // This is so we can do overhangs better (the outside can stick a bit to the inside).  					{  						int insetCount = CountInsetsToPrint(insetsForThisIsland);  						if(insetCount == 0   							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0)  						{  							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls  							layerGcodePlanner.QueueTravel(island.IslandOutline[0][0]);  						}  						while (insetCount > 0)  						{  							bool limitDistance = false;  							if (island.InsetToolPaths.Count > 0)  							{  								// Print the insets from inside to out (count - 1 to 0).  								for (int insetIndex = island.InsetToolPaths.Count - 1; insetIndex >= 0; insetIndex--)  								{  									if (!config.ContinuousSpiralOuterPerimeter  										&& insetIndex == island.InsetToolPaths.Count - 1)  									{  										var closestInsetStart = FindBestPoint(insetsForThisIsland[0]' layerGcodePlanner.LastPosition);  										if(closestInsetStart.X != long.MinValue)  										{  											layerGcodePlanner.QueueTravel(closestInsetStart);  										}  									}    									limitDistance = QueueClosetsInset(  										insetsForThisIsland[insetIndex]'  										limitDistance'  										insetIndex == 0 ? inset0Config : insetXConfig'  										layerIndex'  										layerGcodePlanner);    									// Figure out if there is another inset  								}  							}    							insetCount = CountInsetsToPrint(insetsForThisIsland);  						}  					}    					// Find the thin lines for this layer and add them to the queue  					if (config.FillThinGaps && !config.ContinuousSpiralOuterPerimeter)  					{  						for (int perimeter = 0; perimeter < config.NumberOfPerimeters; perimeter++)  						{  							Polygons thinLines = null;  							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 5' out thinLines' true))  							{  								fillPolygons.AddRange(thinLines);  							}  						}  					}    					if (config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter)  					{  						Polygons thinLines = null;  						// Collect all of the lines up to one third the extrusion diameter  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(island.IslandOutline);  						if (island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true))  						{  							for(int polyIndex=thinLines.Count-1; polyIndex>=0; polyIndex--)  							{  								var polygon = thinLines[polyIndex];    								if (polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4)  								{  									thinLines.RemoveAt(polyIndex);  								}  								else  								{  									for (int i = 0; i < polygon.Count; i++)  									{  										if (polygon[i].Width > 0)  										{  											polygon[i] = new IntPoint(polygon[i])  											{  												Width = extrusionWidth_um'  											};  										}  									}  								}  							}    							fillPolygons.AddRange(thinLines);  						}  					}  				}    				// Write the bridge polygons after the perimeter so they will have more to hold to while bridging the gaps.  				// It would be even better to slow down the perimeters that are part of bridges but that is for later.  				if (bridgePolygons.Count > 0)  				{  					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas);  				}    				// TODO: Put all of these segments into a list that can be queued together and still preserver their individual config settings.  				// This will make the total amount of travel while printing infill much less.  				layerGcodePlanner.QueuePolygonsByOptimizer(fillPolygons' fillConfig);  				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas);  				layerGcodePlanner.QueuePolygonsByOptimizer(topFillPolygons' topFillConfig);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: for (int islandOrderIndex = 0; islandOrderIndex < islandOrderOptimizer.bestIslandOrderIndex.Count; islandOrderIndex++)  			{  				if (config.ContinuousSpiralOuterPerimeter && islandOrderIndex > 0)  				{  					continue;  				}    				LayerIsland island = layer.Islands[islandOrderOptimizer.bestIslandOrderIndex[islandOrderIndex]];    				if (config.AvoidCrossingPerimeters)  				{  					MoveToIsland(layerGcodePlanner' layer' island);  				}  				else  				{  					if(config.RetractWhenChangingIslands)  layerGcodePlanner.ForceRetract();  				}    				Polygons fillPolygons = new Polygons();  				Polygons topFillPolygons = new Polygons();  				Polygons bridgePolygons = new Polygons();    				Polygons bottomFillPolygons = new Polygons();    				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' topFillPolygons' bridgePolygons);  				bottomFillIslandPolygons.Add(bottomFillPolygons);    				if (config.NumberOfPerimeters > 0)  				{  					if (config.ContinuousSpiralOuterPerimeter  						&& layerIndex >= config.NumberOfBottomLayers)  					{  						inset0Config.spiralize = true;  					}    					// Put all the insets into a new list so we can keep track of what has been printed.  					// The island could be a rectangle with 4 screew holes. So' with 3 perimeters that colud be the outside 3 + the foles 4 * 3' 15 polygons.  					List<Polygons> insetsForThisIsland = new List<Polygons>(island.InsetToolPaths.Count);  					for (int insetIndex = 0; insetIndex < island.InsetToolPaths.Count; insetIndex++)  					{  						insetsForThisIsland.Add(new Polygons());  						for (int polygonIndex = 0; polygonIndex < island.InsetToolPaths[insetIndex].Count; polygonIndex++)  						{  							if (island.InsetToolPaths[insetIndex][polygonIndex].Count > 0)  							{  								insetsForThisIsland[insetIndex].Add(island.InsetToolPaths[insetIndex][polygonIndex]);  							}  						}  					}    					// If we are on the very first layer we always start with the outside so that we can stick to the bed better.  					if (config.OutsidePerimetersFirst || layerIndex == 0 || inset0Config.spiralize)  					{  						if (inset0Config.spiralize)  						{  							if (island.InsetToolPaths.Count > 0)  							{  								Polygon outsideSinglePolygon = island.InsetToolPaths[0][0];  								layerGcodePlanner.QueuePolygonsByOptimizer(new Polygons() { outsideSinglePolygon }' inset0Config);  							}  						}  						else  						{  							int insetCount = CountInsetsToPrint(insetsForThisIsland);  							while (insetCount > 0)  							{  								bool limitDistance = false;  								if (island.InsetToolPaths.Count > 0)  								{  									QueueClosetsInset(insetsForThisIsland[0]' limitDistance' inset0Config' layerIndex' layerGcodePlanner);  								}    								// Move to the closest inset 1 and print it  								for (int insetIndex = 1; insetIndex < island.InsetToolPaths.Count; insetIndex++)  								{  									limitDistance = QueueClosetsInset(insetsForThisIsland[insetIndex]' limitDistance' insetXConfig' layerIndex' layerGcodePlanner);  								}    								insetCount = CountInsetsToPrint(insetsForThisIsland);  							}  						}  					}  					else // This is so we can do overhangs better (the outside can stick a bit to the inside).  					{  						int insetCount = CountInsetsToPrint(insetsForThisIsland);  						if(insetCount == 0   							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0)  						{  							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls  							layerGcodePlanner.QueueTravel(island.IslandOutline[0][0]);  						}  						while (insetCount > 0)  						{  							bool limitDistance = false;  							if (island.InsetToolPaths.Count > 0)  							{  								// Print the insets from inside to out (count - 1 to 0).  								for (int insetIndex = island.InsetToolPaths.Count - 1; insetIndex >= 0; insetIndex--)  								{  									if (!config.ContinuousSpiralOuterPerimeter  										&& insetIndex == island.InsetToolPaths.Count - 1)  									{  										var closestInsetStart = FindBestPoint(insetsForThisIsland[0]' layerGcodePlanner.LastPosition);  										if(closestInsetStart.X != long.MinValue)  										{  											layerGcodePlanner.QueueTravel(closestInsetStart);  										}  									}    									limitDistance = QueueClosetsInset(  										insetsForThisIsland[insetIndex]'  										limitDistance'  										insetIndex == 0 ? inset0Config : insetXConfig'  										layerIndex'  										layerGcodePlanner);    									// Figure out if there is another inset  								}  							}    							insetCount = CountInsetsToPrint(insetsForThisIsland);  						}  					}    					// Find the thin lines for this layer and add them to the queue  					if (config.FillThinGaps && !config.ContinuousSpiralOuterPerimeter)  					{  						for (int perimeter = 0; perimeter < config.NumberOfPerimeters; perimeter++)  						{  							Polygons thinLines = null;  							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 5' out thinLines' true))  							{  								fillPolygons.AddRange(thinLines);  							}  						}  					}    					if (config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter)  					{  						Polygons thinLines = null;  						// Collect all of the lines up to one third the extrusion diameter  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(island.IslandOutline);  						if (island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true))  						{  							for(int polyIndex=thinLines.Count-1; polyIndex>=0; polyIndex--)  							{  								var polygon = thinLines[polyIndex];    								if (polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4)  								{  									thinLines.RemoveAt(polyIndex);  								}  								else  								{  									for (int i = 0; i < polygon.Count; i++)  									{  										if (polygon[i].Width > 0)  										{  											polygon[i] = new IntPoint(polygon[i])  											{  												Width = extrusionWidth_um'  											};  										}  									}  								}  							}    							fillPolygons.AddRange(thinLines);  						}  					}  				}    				// Write the bridge polygons after the perimeter so they will have more to hold to while bridging the gaps.  				// It would be even better to slow down the perimeters that are part of bridges but that is for later.  				if (bridgePolygons.Count > 0)  				{  					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas);  				}    				// TODO: Put all of these segments into a list that can be queued together and still preserver their individual config settings.  				// This will make the total amount of travel while printing infill much less.  				layerGcodePlanner.QueuePolygonsByOptimizer(fillPolygons' fillConfig);  				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas);  				layerGcodePlanner.QueuePolygonsByOptimizer(topFillPolygons' topFillConfig);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: for (int islandOrderIndex = 0; islandOrderIndex < islandOrderOptimizer.bestIslandOrderIndex.Count; islandOrderIndex++)  			{  				if (config.ContinuousSpiralOuterPerimeter && islandOrderIndex > 0)  				{  					continue;  				}    				LayerIsland island = layer.Islands[islandOrderOptimizer.bestIslandOrderIndex[islandOrderIndex]];    				if (config.AvoidCrossingPerimeters)  				{  					MoveToIsland(layerGcodePlanner' layer' island);  				}  				else  				{  					if(config.RetractWhenChangingIslands)  layerGcodePlanner.ForceRetract();  				}    				Polygons fillPolygons = new Polygons();  				Polygons topFillPolygons = new Polygons();  				Polygons bridgePolygons = new Polygons();    				Polygons bottomFillPolygons = new Polygons();    				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' topFillPolygons' bridgePolygons);  				bottomFillIslandPolygons.Add(bottomFillPolygons);    				if (config.NumberOfPerimeters > 0)  				{  					if (config.ContinuousSpiralOuterPerimeter  						&& layerIndex >= config.NumberOfBottomLayers)  					{  						inset0Config.spiralize = true;  					}    					// Put all the insets into a new list so we can keep track of what has been printed.  					// The island could be a rectangle with 4 screew holes. So' with 3 perimeters that colud be the outside 3 + the foles 4 * 3' 15 polygons.  					List<Polygons> insetsForThisIsland = new List<Polygons>(island.InsetToolPaths.Count);  					for (int insetIndex = 0; insetIndex < island.InsetToolPaths.Count; insetIndex++)  					{  						insetsForThisIsland.Add(new Polygons());  						for (int polygonIndex = 0; polygonIndex < island.InsetToolPaths[insetIndex].Count; polygonIndex++)  						{  							if (island.InsetToolPaths[insetIndex][polygonIndex].Count > 0)  							{  								insetsForThisIsland[insetIndex].Add(island.InsetToolPaths[insetIndex][polygonIndex]);  							}  						}  					}    					// If we are on the very first layer we always start with the outside so that we can stick to the bed better.  					if (config.OutsidePerimetersFirst || layerIndex == 0 || inset0Config.spiralize)  					{  						if (inset0Config.spiralize)  						{  							if (island.InsetToolPaths.Count > 0)  							{  								Polygon outsideSinglePolygon = island.InsetToolPaths[0][0];  								layerGcodePlanner.QueuePolygonsByOptimizer(new Polygons() { outsideSinglePolygon }' inset0Config);  							}  						}  						else  						{  							int insetCount = CountInsetsToPrint(insetsForThisIsland);  							while (insetCount > 0)  							{  								bool limitDistance = false;  								if (island.InsetToolPaths.Count > 0)  								{  									QueueClosetsInset(insetsForThisIsland[0]' limitDistance' inset0Config' layerIndex' layerGcodePlanner);  								}    								// Move to the closest inset 1 and print it  								for (int insetIndex = 1; insetIndex < island.InsetToolPaths.Count; insetIndex++)  								{  									limitDistance = QueueClosetsInset(insetsForThisIsland[insetIndex]' limitDistance' insetXConfig' layerIndex' layerGcodePlanner);  								}    								insetCount = CountInsetsToPrint(insetsForThisIsland);  							}  						}  					}  					else // This is so we can do overhangs better (the outside can stick a bit to the inside).  					{  						int insetCount = CountInsetsToPrint(insetsForThisIsland);  						if(insetCount == 0   							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0)  						{  							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls  							layerGcodePlanner.QueueTravel(island.IslandOutline[0][0]);  						}  						while (insetCount > 0)  						{  							bool limitDistance = false;  							if (island.InsetToolPaths.Count > 0)  							{  								// Print the insets from inside to out (count - 1 to 0).  								for (int insetIndex = island.InsetToolPaths.Count - 1; insetIndex >= 0; insetIndex--)  								{  									if (!config.ContinuousSpiralOuterPerimeter  										&& insetIndex == island.InsetToolPaths.Count - 1)  									{  										var closestInsetStart = FindBestPoint(insetsForThisIsland[0]' layerGcodePlanner.LastPosition);  										if(closestInsetStart.X != long.MinValue)  										{  											layerGcodePlanner.QueueTravel(closestInsetStart);  										}  									}    									limitDistance = QueueClosetsInset(  										insetsForThisIsland[insetIndex]'  										limitDistance'  										insetIndex == 0 ? inset0Config : insetXConfig'  										layerIndex'  										layerGcodePlanner);    									// Figure out if there is another inset  								}  							}    							insetCount = CountInsetsToPrint(insetsForThisIsland);  						}  					}    					// Find the thin lines for this layer and add them to the queue  					if (config.FillThinGaps && !config.ContinuousSpiralOuterPerimeter)  					{  						for (int perimeter = 0; perimeter < config.NumberOfPerimeters; perimeter++)  						{  							Polygons thinLines = null;  							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 5' out thinLines' true))  							{  								fillPolygons.AddRange(thinLines);  							}  						}  					}    					if (config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter)  					{  						Polygons thinLines = null;  						// Collect all of the lines up to one third the extrusion diameter  						//string perimeterString = Newtonsoft.Json.JsonConvert.SerializeObject(island.IslandOutline);  						if (island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true))  						{  							for(int polyIndex=thinLines.Count-1; polyIndex>=0; polyIndex--)  							{  								var polygon = thinLines[polyIndex];    								if (polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4)  								{  									thinLines.RemoveAt(polyIndex);  								}  								else  								{  									for (int i = 0; i < polygon.Count; i++)  									{  										if (polygon[i].Width > 0)  										{  											polygon[i] = new IntPoint(polygon[i])  											{  												Width = extrusionWidth_um'  											};  										}  									}  								}  							}    							fillPolygons.AddRange(thinLines);  						}  					}  				}    				// Write the bridge polygons after the perimeter so they will have more to hold to while bridging the gaps.  				// It would be even better to slow down the perimeters that are part of bridges but that is for later.  				if (bridgePolygons.Count > 0)  				{  					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas);  				}    				// TODO: Put all of these segments into a list that can be queued together and still preserver their individual config settings.  				// This will make the total amount of travel while printing infill much less.  				layerGcodePlanner.QueuePolygonsByOptimizer(fillPolygons' fillConfig);  				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas);  				layerGcodePlanner.QueuePolygonsByOptimizer(topFillPolygons' topFillConfig);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,MoveToIsland,The following statement contains a magic number: if (island.IslandOutline.Count > 0)  			{  				// If we are already in the island we are going to' don't go there.  				if (island.PathFinder.OutlinePolygons.PointIsInside(layerGcodePlanner.LastPosition' island.PathFinder.OutlineEdgeQuadTrees))  				{  					islandCurrentlyInside = island;  					layerGcodePlanner.PathFinder = island.PathFinder;  					return;  				}    				var closestPointOnNextIsland = island.IslandOutline.FindClosestPoint(layerGcodePlanner.LastPosition);  				IntPoint closestNextIslandPoint = island.IslandOutline[closestPointOnNextIsland.Item1][closestPointOnNextIsland.Item2];    				if (islandCurrentlyInside?.PathFinder?.OutlinePolygons.Count > 0  					&& islandCurrentlyInside?.PathFinder?.OutlinePolygons?[0]?.Count > 3)  				{  					// start by moving within the last island to the closet point to the next island  					var polygons = islandCurrentlyInside.PathFinder.OutlinePolygons;  					if (polygons.Count > 0)  					{  						var closestPointOnLastIsland = polygons.FindClosestPoint(closestNextIslandPoint);    						IntPoint closestLastIslandPoint = polygons[closestPointOnLastIsland.Item1][closestPointOnLastIsland.Item2];  						// make sure we are planning within the last island we were using  						layerGcodePlanner.PathFinder = islandCurrentlyInside.PathFinder;  						layerGcodePlanner.QueueTravel(closestLastIslandPoint);  					}  				}    				// let's move to this island avoiding running into any other islands  				layerGcodePlanner.PathFinder = layer.PathFinder;  				// find the closest point to where we are now  				// and do a move to there  				if (config.RetractWhenChangingIslands) layerGcodePlanner.ForceRetract();  				layerGcodePlanner.QueueTravel(closestNextIslandPoint);  				// and remember that we are now in the new island  				islandCurrentlyInside = island;  				// set the path planner to the current island  				layerGcodePlanner.PathFinder = island.PathFinder;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueueClosetsInset,The following statement contains a magic number: if (limitDistance)  			{  				// Make it relative to the size of the nozzle  				maxDist_um = config.ExtrusionWidth_um * 4;  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,QueuePolygonsConsideringSupport,The following statement contains a magic number: if (config.GenerateSupport  				&& layerIndex > 0  				&& !config.ContinuousSpiralOuterPerimeter)  			{  				Polygons supportOutlines = slicingData.support.GetRequiredSupportAreas(layerIndex).Offset(fillConfig.lineWidth_um / 2);    				if (supportWriteType == SupportWriteType.UnsupportedAreas)  				{  					if (supportOutlines.Count > 0)  					{  						// write segments at normal height (don't write segments needing air gap)  						Polygons polysToWriteAtNormalHeight = new Polygons();  						Polygons polysToWriteAtAirGapHeight = new Polygons();    						GetSegmentsConsideringSupport(polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' false' fillConfig.closedLoop);  						fillConfig.closedLoop = false;  						gcodeLayer.QueuePolygonsByOptimizer(polysToWriteAtNormalHeight' fillConfig);  					}  					else  					{  						gcodeLayer.QueuePolygonsByOptimizer(polygonsToWrite' fillConfig);  					}  				}  				else if (supportOutlines.Count > 0) // we are checking the supported areas  				{  					// detect and write segments at air gap height  					Polygons polysToWriteAtNormalHeight = new Polygons();  					Polygons polysToWriteAtAirGapHeight = new Polygons();    					GetSegmentsConsideringSupport(polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' true' fillConfig.closedLoop);  					fillConfig.closedLoop = false;  					gcodeLayer.QueuePolygonsByOptimizer(polysToWriteAtAirGapHeight' fillConfig);  				}  			}  			else if (supportWriteType == SupportWriteType.UnsupportedAreas)  			{  				gcodeLayer.QueuePolygonsByOptimizer(polygonsToWrite' fillConfig);  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,GetSegmentsConsideringSupport,The following statement contains a magic number: Polygons maxSupportOutlines = supportOutlines.Offset(fillConfig.lineWidth_um * 2 + config.SupportXYDistance_um);
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: foreach (Polygons bottomFillIsland in part.SolidBottomToolPaths.ProcessIntoSeparatIslands())  			{  				if (layerIndex > 0)  				{  					if (config.GenerateSupport)  					{  						if (config.SupportInterfaceLayers > 0)  						{  							Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle);  						}  						else  						{  							Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90);  						}  					}  					else  					{  						SliceLayer previousLayer = slicingData.Extruders[extruderIndex].Layers[layerIndex - 1];  						previousLayer.GenerateFillConsideringBridging(bottomFillIsland' bottomFillLines' config' bridgePolygons);  					}  				}  				else  				{  					Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.FirstLayerExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle);  				}  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: if (fillPolygons != null)  			{  				foreach (Polygons outline in part.SolidInfillToolPaths.ProcessIntoSeparatIslands())  				{  					if (true) // use the old infill method  					{  						Infill.GenerateLinePaths(outline' fillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90 * (layerIndex % 2));  					}  					else // use the new concentric infill (not tested enough yet) have to handle some bad cases better  					{  						double oldInfillPercent = config.InfillPercent;  						config.InfillPercent = 100;  						Infill.GenerateConcentricInfill(config' outline' fillPolygons);  						config.InfillPercent = oldInfillPercent;  					}  				}    				double fillAngle = config.InfillStartingAngle;    				// generate the sparse infill for this part on this layer  				if (config.InfillPercent > 0)  				{  					switch (config.InfillType)  					{  						case ConfigConstants.INFILL_TYPE.LINES:  							if ((layerIndex & 1) == 1)  							{  								fillAngle += 90;  							}  							Infill.GenerateLineInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.GRID:  							Infill.GenerateGridInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.TRIANGLES:  							Infill.GenerateTriangleInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.HEXAGON:  							Infill.GenerateHexagonInfill(config' part.InfillToolPaths' fillPolygons' fillAngle' layerIndex);  							break;    						case ConfigConstants.INFILL_TYPE.CONCENTRIC:  							Infill.GenerateConcentricInfill(config' part.InfillToolPaths' fillPolygons);  							break;    						default:  							throw new NotImplementedException();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: if (fillPolygons != null)  			{  				foreach (Polygons outline in part.SolidInfillToolPaths.ProcessIntoSeparatIslands())  				{  					if (true) // use the old infill method  					{  						Infill.GenerateLinePaths(outline' fillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90 * (layerIndex % 2));  					}  					else // use the new concentric infill (not tested enough yet) have to handle some bad cases better  					{  						double oldInfillPercent = config.InfillPercent;  						config.InfillPercent = 100;  						Infill.GenerateConcentricInfill(config' outline' fillPolygons);  						config.InfillPercent = oldInfillPercent;  					}  				}    				double fillAngle = config.InfillStartingAngle;    				// generate the sparse infill for this part on this layer  				if (config.InfillPercent > 0)  				{  					switch (config.InfillType)  					{  						case ConfigConstants.INFILL_TYPE.LINES:  							if ((layerIndex & 1) == 1)  							{  								fillAngle += 90;  							}  							Infill.GenerateLineInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.GRID:  							Infill.GenerateGridInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.TRIANGLES:  							Infill.GenerateTriangleInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.HEXAGON:  							Infill.GenerateHexagonInfill(config' part.InfillToolPaths' fillPolygons' fillAngle' layerIndex);  							break;    						case ConfigConstants.INFILL_TYPE.CONCENTRIC:  							Infill.GenerateConcentricInfill(config' part.InfillToolPaths' fillPolygons);  							break;    						default:  							throw new NotImplementedException();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: if (fillPolygons != null)  			{  				foreach (Polygons outline in part.SolidInfillToolPaths.ProcessIntoSeparatIslands())  				{  					if (true) // use the old infill method  					{  						Infill.GenerateLinePaths(outline' fillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90 * (layerIndex % 2));  					}  					else // use the new concentric infill (not tested enough yet) have to handle some bad cases better  					{  						double oldInfillPercent = config.InfillPercent;  						config.InfillPercent = 100;  						Infill.GenerateConcentricInfill(config' outline' fillPolygons);  						config.InfillPercent = oldInfillPercent;  					}  				}    				double fillAngle = config.InfillStartingAngle;    				// generate the sparse infill for this part on this layer  				if (config.InfillPercent > 0)  				{  					switch (config.InfillType)  					{  						case ConfigConstants.INFILL_TYPE.LINES:  							if ((layerIndex & 1) == 1)  							{  								fillAngle += 90;  							}  							Infill.GenerateLineInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.GRID:  							Infill.GenerateGridInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.TRIANGLES:  							Infill.GenerateTriangleInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.HEXAGON:  							Infill.GenerateHexagonInfill(config' part.InfillToolPaths' fillPolygons' fillAngle' layerIndex);  							break;    						case ConfigConstants.INFILL_TYPE.CONCENTRIC:  							Infill.GenerateConcentricInfill(config' part.InfillToolPaths' fillPolygons);  							break;    						default:  							throw new NotImplementedException();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,fffProcessor,C:\repos\MatterHackers_MatterSlice\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: if (fillPolygons != null)  			{  				foreach (Polygons outline in part.SolidInfillToolPaths.ProcessIntoSeparatIslands())  				{  					if (true) // use the old infill method  					{  						Infill.GenerateLinePaths(outline' fillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90 * (layerIndex % 2));  					}  					else // use the new concentric infill (not tested enough yet) have to handle some bad cases better  					{  						double oldInfillPercent = config.InfillPercent;  						config.InfillPercent = 100;  						Infill.GenerateConcentricInfill(config' outline' fillPolygons);  						config.InfillPercent = oldInfillPercent;  					}  				}    				double fillAngle = config.InfillStartingAngle;    				// generate the sparse infill for this part on this layer  				if (config.InfillPercent > 0)  				{  					switch (config.InfillType)  					{  						case ConfigConstants.INFILL_TYPE.LINES:  							if ((layerIndex & 1) == 1)  							{  								fillAngle += 90;  							}  							Infill.GenerateLineInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.GRID:  							Infill.GenerateGridInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.TRIANGLES:  							Infill.GenerateTriangleInfill(config' part.InfillToolPaths' fillPolygons' fillAngle);  							break;    						case ConfigConstants.INFILL_TYPE.HEXAGON:  							Infill.GenerateHexagonInfill(config' part.InfillToolPaths' fillPolygons' fillAngle' layerIndex);  							break;    						case ConfigConstants.INFILL_TYPE.CONCENTRIC:  							Infill.GenerateConcentricInfill(config' part.InfillToolPaths' fillPolygons);  							break;    						default:  							throw new NotImplementedException();  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,GCodeExport,The following statement contains a magic number: extruderSwitchRetraction_mm = 14.5;
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,GCodeExport,The following statement contains a magic number: retractionSpeed = 45;
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)(filamentDiameter) / 1000.0 / 2.0) * ((double)(filamentDiameter) / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)(filamentDiameter) / 1000.0 / 2.0) * ((double)(filamentDiameter) / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)(filamentDiameter) / 1000.0 / 2.0) * ((double)(filamentDiameter) / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)(filamentDiameter) / 1000.0 / 2.0) * ((double)(filamentDiameter) / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: extrusionPerMm = (double)(layerThickness) / 1000.0 / filamentArea * extrusionMultiplier;
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,SwitchExtruder,The following statement contains a magic number: if (extruderSwitchRetraction_mm != 0)  			{  				gcodeFileStream.Write("G1 F{0} E{1:0.####} ; retract\n"' retractionSpeed * 60' extrusionAmount_mm - extruderSwitchRetraction_mm);  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,TellFileSize,The following statement contains a magic number: if (fsize > 1024 * 1024)  			{  				fsize /= 1024.0 * 1024.0;  				LogOutput.Log("Wrote {0:0.0} MB.\n".FormatWith(fsize));  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,TellFileSize,The following statement contains a magic number: if (fsize > 1024 * 1024)  			{  				fsize /= 1024.0 * 1024.0;  				LogOutput.Log("Wrote {0:0.0} MB.\n".FormatWith(fsize));  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,TellFileSize,The following statement contains a magic number: if (fsize > 1024 * 1024)  			{  				fsize /= 1024.0 * 1024.0;  				LogOutput.Log("Wrote {0:0.0} MB.\n".FormatWith(fsize));  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,TellFileSize,The following statement contains a magic number: if (fsize > 1024 * 1024)  			{  				fsize /= 1024.0 * 1024.0;  				LogOutput.Log("Wrote {0:0.0} MB.\n".FormatWith(fsize));  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,TellFileSize,The following statement contains a magic number: if (fsize > 1024)  			{  				fsize /= 1024.0;  				LogOutput.Log("Wrote {0:0.0} kilobytes.\n".FormatWith(fsize));  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,TellFileSize,The following statement contains a magic number: if (fsize > 1024)  			{  				fsize /= 1024.0;  				LogOutput.Log("Wrote {0:0.0} kilobytes.\n".FormatWith(fsize));  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteFanCommand,The following statement contains a magic number: if (speed > 0)  			{  				gcodeFileStream.Write("M106 S{0}\n".FormatWith(speed * 255 / 100));  			}  			else  			{  				gcodeFileStream.Write("M107\n");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteFanCommand,The following statement contains a magic number: if (speed > 0)  			{  				gcodeFileStream.Write("M106 S{0}\n".FormatWith(speed * 255 / 100));  			}  			else  			{  				gcodeFileStream.Write("M107\n");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (lineWidth_um != 0)  			{  				IntPoint diff = movePosition_um - GetPosition();  				if (isRetracted)  				{  					if (retractionZHop_mm > 0)  					{  						double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000;  						lineToWrite.Append("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  					}    					if (extrusionAmount_mm > 10000.0)  					{  						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure.  						ResetExtrusionValue(retractionAmount_mm);  					}    					lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm));    					currentSpeed = retractionSpeed;  					estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);    					isRetracted = false;  				}    				extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();  				lineToWrite.Append("G1");  			}  			else  			{  				lineToWrite.Append("G0");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (lineWidth_um != 0)  			{  				IntPoint diff = movePosition_um - GetPosition();  				if (isRetracted)  				{  					if (retractionZHop_mm > 0)  					{  						double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000;  						lineToWrite.Append("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  					}    					if (extrusionAmount_mm > 10000.0)  					{  						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure.  						ResetExtrusionValue(retractionAmount_mm);  					}    					lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm));    					currentSpeed = retractionSpeed;  					estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);    					isRetracted = false;  				}    				extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();  				lineToWrite.Append("G1");  			}  			else  			{  				lineToWrite.Append("G0");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (lineWidth_um != 0)  			{  				IntPoint diff = movePosition_um - GetPosition();  				if (isRetracted)  				{  					if (retractionZHop_mm > 0)  					{  						double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000;  						lineToWrite.Append("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  					}    					if (extrusionAmount_mm > 10000.0)  					{  						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure.  						ResetExtrusionValue(retractionAmount_mm);  					}    					lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm));    					currentSpeed = retractionSpeed;  					estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);    					isRetracted = false;  				}    				extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();  				lineToWrite.Append("G1");  			}  			else  			{  				lineToWrite.Append("G0");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (lineWidth_um != 0)  			{  				IntPoint diff = movePosition_um - GetPosition();  				if (isRetracted)  				{  					if (retractionZHop_mm > 0)  					{  						double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000;  						lineToWrite.Append("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  					}    					if (extrusionAmount_mm > 10000.0)  					{  						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure.  						ResetExtrusionValue(retractionAmount_mm);  					}    					lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm));    					currentSpeed = retractionSpeed;  					estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);    					isRetracted = false;  				}    				extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();  				lineToWrite.Append("G1");  			}  			else  			{  				lineToWrite.Append("G0");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (lineWidth_um != 0)  			{  				IntPoint diff = movePosition_um - GetPosition();  				if (isRetracted)  				{  					if (retractionZHop_mm > 0)  					{  						double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000;  						lineToWrite.Append("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  					}    					if (extrusionAmount_mm > 10000.0)  					{  						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure.  						ResetExtrusionValue(retractionAmount_mm);  					}    					lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm));    					currentSpeed = retractionSpeed;  					estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);    					isRetracted = false;  				}    				extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();  				lineToWrite.Append("G1");  			}  			else  			{  				lineToWrite.Append("G0");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (lineWidth_um != 0)  			{  				IntPoint diff = movePosition_um - GetPosition();  				if (isRetracted)  				{  					if (retractionZHop_mm > 0)  					{  						double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000;  						lineToWrite.Append("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  					}    					if (extrusionAmount_mm > 10000.0)  					{  						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure.  						ResetExtrusionValue(retractionAmount_mm);  					}    					lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm));    					currentSpeed = retractionSpeed;  					estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);    					isRetracted = false;  				}    				extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();  				lineToWrite.Append("G1");  			}  			else  			{  				lineToWrite.Append("G0");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (lineWidth_um != 0)  			{  				IntPoint diff = movePosition_um - GetPosition();  				if (isRetracted)  				{  					if (retractionZHop_mm > 0)  					{  						double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000;  						lineToWrite.Append("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  					}    					if (extrusionAmount_mm > 10000.0)  					{  						//According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure.  						ResetExtrusionValue(retractionAmount_mm);  					}    					lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm));    					currentSpeed = retractionSpeed;  					estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);    					isRetracted = false;  				}    				extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();  				lineToWrite.Append("G1");  			}  			else  			{  				lineToWrite.Append("G0");  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (currentSpeed != speed)  			{  				lineToWrite.Append(" F{0}".FormatWith(speed * 60));  				currentSpeed = speed;  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: double xWritePosition = (double)(movePosition_um.X - extruderOffset_um[extruderIndex].X) / 1000.0;
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: double yWritePosition = (double)(movePosition_um.Y - extruderOffset_um[extruderIndex].Y) / 1000.0;
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (movePosition_um.Z != currentPosition_um.Z)  			{  				double zWritePosition = (double)(movePosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000.0;  				if (lineWidth_um == 0  					&& isRetracted)  				{  					zWritePosition += retractionZHop_mm;  				}  				lineToWrite.Append(" Z{0:0.###}".FormatWith(zWritePosition));  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: if (wipeAfterRetraction)  			{  				retractionWipePath.Add(movePosition_um);  				if (retractionWipePath.Count > 100)  				{  					retractionWipePath.RemoveAt(0);  				}  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: if (retractionAmount_mm > 0  				&& !isRetracted  				&& extrusionAmountAtPreviousRetraction_mm + minimumExtrusionBeforeRetraction_mm < extrusionAmount_mm)  			{  				gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm - retractionAmount_mm));  				currentSpeed = retractionSpeed;  				estimateCalculator.plan(new TimeEstimateCalculator.Position((double)(currentPosition_um.X) / 1000.0' (currentPosition_um.Y) / 1000.0' (double)(currentPosition_um.Z) / 1000.0' extrusionAmount_mm - retractionAmount_mm)' currentSpeed);    				AddRetractionWipeIfRequired(initialSpeed);    				if (retractionZHop_mm > 0)  				{  					double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000 + retractionZHop_mm;  					gcodeFileStream.Write("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  				}    				// Make sure after a retraction that we will extrude the extra amount on unretraction that the settings want.  				extrusionAmount_mm += unretractExtrusionExtra_mm;    				extrusionAmountAtPreviousRetraction_mm = extrusionAmount_mm;  				isRetracted = true;  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: if (retractionAmount_mm > 0  				&& !isRetracted  				&& extrusionAmountAtPreviousRetraction_mm + minimumExtrusionBeforeRetraction_mm < extrusionAmount_mm)  			{  				gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm - retractionAmount_mm));  				currentSpeed = retractionSpeed;  				estimateCalculator.plan(new TimeEstimateCalculator.Position((double)(currentPosition_um.X) / 1000.0' (currentPosition_um.Y) / 1000.0' (double)(currentPosition_um.Z) / 1000.0' extrusionAmount_mm - retractionAmount_mm)' currentSpeed);    				AddRetractionWipeIfRequired(initialSpeed);    				if (retractionZHop_mm > 0)  				{  					double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000 + retractionZHop_mm;  					gcodeFileStream.Write("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  				}    				// Make sure after a retraction that we will extrude the extra amount on unretraction that the settings want.  				extrusionAmount_mm += unretractExtrusionExtra_mm;    				extrusionAmountAtPreviousRetraction_mm = extrusionAmount_mm;  				isRetracted = true;  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: if (retractionAmount_mm > 0  				&& !isRetracted  				&& extrusionAmountAtPreviousRetraction_mm + minimumExtrusionBeforeRetraction_mm < extrusionAmount_mm)  			{  				gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm - retractionAmount_mm));  				currentSpeed = retractionSpeed;  				estimateCalculator.plan(new TimeEstimateCalculator.Position((double)(currentPosition_um.X) / 1000.0' (currentPosition_um.Y) / 1000.0' (double)(currentPosition_um.Z) / 1000.0' extrusionAmount_mm - retractionAmount_mm)' currentSpeed);    				AddRetractionWipeIfRequired(initialSpeed);    				if (retractionZHop_mm > 0)  				{  					double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000 + retractionZHop_mm;  					gcodeFileStream.Write("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  				}    				// Make sure after a retraction that we will extrude the extra amount on unretraction that the settings want.  				extrusionAmount_mm += unretractExtrusionExtra_mm;    				extrusionAmountAtPreviousRetraction_mm = extrusionAmount_mm;  				isRetracted = true;  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: if (retractionAmount_mm > 0  				&& !isRetracted  				&& extrusionAmountAtPreviousRetraction_mm + minimumExtrusionBeforeRetraction_mm < extrusionAmount_mm)  			{  				gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm - retractionAmount_mm));  				currentSpeed = retractionSpeed;  				estimateCalculator.plan(new TimeEstimateCalculator.Position((double)(currentPosition_um.X) / 1000.0' (currentPosition_um.Y) / 1000.0' (double)(currentPosition_um.Z) / 1000.0' extrusionAmount_mm - retractionAmount_mm)' currentSpeed);    				AddRetractionWipeIfRequired(initialSpeed);    				if (retractionZHop_mm > 0)  				{  					double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000 + retractionZHop_mm;  					gcodeFileStream.Write("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  				}    				// Make sure after a retraction that we will extrude the extra amount on unretraction that the settings want.  				extrusionAmount_mm += unretractExtrusionExtra_mm;    				extrusionAmountAtPreviousRetraction_mm = extrusionAmount_mm;  				isRetracted = true;  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: if (retractionAmount_mm > 0  				&& !isRetracted  				&& extrusionAmountAtPreviousRetraction_mm + minimumExtrusionBeforeRetraction_mm < extrusionAmount_mm)  			{  				gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(retractionSpeed * 60' extrusionAmount_mm - retractionAmount_mm));  				currentSpeed = retractionSpeed;  				estimateCalculator.plan(new TimeEstimateCalculator.Position((double)(currentPosition_um.X) / 1000.0' (currentPosition_um.Y) / 1000.0' (double)(currentPosition_um.Z) / 1000.0' extrusionAmount_mm - retractionAmount_mm)' currentSpeed);    				AddRetractionWipeIfRequired(initialSpeed);    				if (retractionZHop_mm > 0)  				{  					double zWritePosition = (double)(currentPosition_um.Z - extruderOffset_um[extruderIndex].Z) / 1000 + retractionZHop_mm;  					gcodeFileStream.Write("G1 Z{0:0.###}\n".FormatWith(zWritePosition));  				}    				// Make sure after a retraction that we will extrude the extra amount on unretraction that the settings want.  				extrusionAmount_mm += unretractExtrusionExtra_mm;    				extrusionAmountAtPreviousRetraction_mm = extrusionAmount_mm;  				isRetracted = true;  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,GCodeExport,C:\repos\MatterHackers_MatterSlice\gcodeExport.cs,AddRetractionWipeIfRequired,The following statement contains a magic number: if (wipeAfterRetraction && retractionWipePath.Count >= 2)  			{  				IntPoint lastP = retractionWipePath[retractionWipePath.Count - 1];  				int indexStepDirection = -1;  				int i = retractionWipePath.Count - 2;  				double wipeDistanceMm = 10;  				long wipeLeft = (long)(wipeDistanceMm * 1000);    				while (wipeLeft > 0)  				{  					IntPoint p = retractionWipePath[i];  					long len = (lastP - p).Length();    					//Check if we're out of moves  					if (indexStepDirection > 0 && i == retractionWipePath.Count - 1)  					{  						break;  					}  					//Reverse direction (once) to get wipe length if required.  					else if (indexStepDirection < 0 && i == 0)  					{  						indexStepDirection = 1;  					}  					i += indexStepDirection;    					//If move is longer than wipe remaining' calculate angle and move along path but stop short.  					if (len > wipeLeft)  					{  						IntPoint direction = p - lastP;  						long directionLength = direction.Length();  						direction *= wipeLeft;  						direction /= directionLength;  						p = lastP + direction;  						len = wipeLeft;  					}  					wipeLeft -= len;  					lastP = p;  					gcodeFileStream.Write("G0 ");  					if (currentSpeed != initialSpeed)  					{  						currentSpeed = initialSpeed;  						gcodeFileStream.Write("F{0} ".FormatWith(currentSpeed * 60));  					}  					gcodeFileStream.Write("X{0:0.###} Y{1:0.###}\n".FormatWith((p.X - extruderOffset_um[extruderIndex].X) / 1000.0' (p.Y - extruderOffset_um[extruderIndex].Y) / 1000.0));  					estimateCalculator.plan(new TimeEstimateCalculator.Position(p.X / 1000.0' p.Y / 1000.0' currentPosition_um.Z / 1000.0' 0)' currentSpeed);  				}  				retractionWipePath.Clear();  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: vertices.Capacity = simpleMesh.faceTriangles.Count * 3;
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < simpleMesh.faceTriangles.Count; faceIndex++)  			{  				if (MatterSlice.Canceled)  				{  					return;  				}  				OptimizedFace optimizedFace = new OptimizedFace();  				if ((faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2)  				{  					LogOutput.logProgress("optimized"' faceIndex + 1' simpleMesh.faceTriangles.Count);  				}  				for (int vertexIndex = 0; vertexIndex < 3; vertexIndex++)  				{  					IntPoint p = simpleMesh.faceTriangles[faceIndex].vertices[vertexIndex];  					int hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 10) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 20));  					int idx = 0;  					bool add = true;  					if (indexMap.ContainsKey(hash))  					{  						for (int n = 0; n < indexMap[hash].Count; n++)  						{  							if ((vertices[indexMap[hash][n]].position - p).Length() < MELD_DIST)  							{  								idx = indexMap[hash][n];  								add = false;  								break;  							}  						}  					}  					if (add)  					{  						if (!indexMap.ContainsKey(hash))  						{  							indexMap.Add(hash' new List<int>());  						}  						indexMap[hash].Add(vertices.Count);  						idx = vertices.Count;  						vertices.Add(new OptimizedPoint3(p));  					}  					optimizedFace.vertexIndex[vertexIndex] = idx;  				}  				if (optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2])  				{  					//Check if there is a face with the same points  					bool duplicate = false;  					for (int _idx0 = 0; _idx0 < vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Count; _idx0++)  					{  						for (int _idx1 = 0; _idx1 < vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Count; _idx1++)  						{  							for (int _idx2 = 0; _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count; _idx2++)  							{  								if (vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2])  									duplicate = true;  							}  						}  					}  					if (!duplicate)  					{  						vertices[optimizedFace.vertexIndex[0]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[1]].usedByFacesList.Add(facesTriangle.Count);  						vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);  						facesTriangle.Add(optimizedFace);  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < facesTriangle.Count; faceIndex++)  			{  				OptimizedFace optimizedFace = facesTriangle[faceIndex];  				optimizedFace.touchingFaces[0] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[0]' optimizedFace.vertexIndex[1]' faceIndex);  				optimizedFace.touchingFaces[1] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[1]' optimizedFace.vertexIndex[2]' faceIndex);  				optimizedFace.touchingFaces[2] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[2]' optimizedFace.vertexIndex[0]' faceIndex);  				if (optimizedFace.touchingFaces[0] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[1] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[2] == -1)  				{  					openFacesCount++;  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < facesTriangle.Count; faceIndex++)  			{  				OptimizedFace optimizedFace = facesTriangle[faceIndex];  				optimizedFace.touchingFaces[0] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[0]' optimizedFace.vertexIndex[1]' faceIndex);  				optimizedFace.touchingFaces[1] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[1]' optimizedFace.vertexIndex[2]' faceIndex);  				optimizedFace.touchingFaces[2] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[2]' optimizedFace.vertexIndex[0]' faceIndex);  				if (optimizedFace.touchingFaces[0] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[1] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[2] == -1)  				{  					openFacesCount++;  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < facesTriangle.Count; faceIndex++)  			{  				OptimizedFace optimizedFace = facesTriangle[faceIndex];  				optimizedFace.touchingFaces[0] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[0]' optimizedFace.vertexIndex[1]' faceIndex);  				optimizedFace.touchingFaces[1] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[1]' optimizedFace.vertexIndex[2]' faceIndex);  				optimizedFace.touchingFaces[2] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[2]' optimizedFace.vertexIndex[0]' faceIndex);  				if (optimizedFace.touchingFaces[0] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[1] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[2] == -1)  				{  					openFacesCount++;  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < facesTriangle.Count; faceIndex++)  			{  				OptimizedFace optimizedFace = facesTriangle[faceIndex];  				optimizedFace.touchingFaces[0] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[0]' optimizedFace.vertexIndex[1]' faceIndex);  				optimizedFace.touchingFaces[1] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[1]' optimizedFace.vertexIndex[2]' faceIndex);  				optimizedFace.touchingFaces[2] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[2]' optimizedFace.vertexIndex[0]' faceIndex);  				if (optimizedFace.touchingFaces[0] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[1] == -1)  				{  					openFacesCount++;  				}  				if (optimizedFace.touchingFaces[2] == -1)  				{  					openFacesCount++;  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,SetPositionAndSize,The following statement contains a magic number: if (centerObjectInXy)  			{  				IntPoint modelXYCenterZBottom_um = new IntPoint((minXYZ_um.X + maxXYZ_um.X) / 2' (minXYZ_um.Y + maxXYZ_um.Y) / 2' minXYZ_um.Z);  				modelXYCenterZBottom_um -= new IntPoint(xCenter_um' yCenter_um' zClip_um);  				for (int optimizedMeshIndex = 0; optimizedMeshIndex < OptimizedMeshes.Count; optimizedMeshIndex++)  				{  					for (int n = 0; n < OptimizedMeshes[optimizedMeshIndex].vertices.Count; n++)  					{  						OptimizedMeshes[optimizedMeshIndex].vertices[n].position -= modelXYCenterZBottom_um;  					}  				}    				minXYZ_um -= modelXYCenterZBottom_um;  				maxXYZ_um -= modelXYCenterZBottom_um;  			}  			else // we still need to put in the bottom clip  			{  				// Offset by bed center and correctly position in z  				IntPoint modelZBottom_um = new IntPoint(0' 0' minXYZ_um.Z - zClip_um);  				for (int optimizedMeshIndex = 0; optimizedMeshIndex < OptimizedMeshes.Count; optimizedMeshIndex++)  				{  					for (int vertexIndex = 0; vertexIndex < OptimizedMeshes[optimizedMeshIndex].vertices.Count; vertexIndex++)  					{  						OptimizedMeshes[optimizedMeshIndex].vertices[vertexIndex].position -= modelZBottom_um;  					}  				}    				minXYZ_um -= modelZBottom_um;  				maxXYZ_um -= modelZBottom_um;  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,SetPositionAndSize,The following statement contains a magic number: if (centerObjectInXy)  			{  				IntPoint modelXYCenterZBottom_um = new IntPoint((minXYZ_um.X + maxXYZ_um.X) / 2' (minXYZ_um.Y + maxXYZ_um.Y) / 2' minXYZ_um.Z);  				modelXYCenterZBottom_um -= new IntPoint(xCenter_um' yCenter_um' zClip_um);  				for (int optimizedMeshIndex = 0; optimizedMeshIndex < OptimizedMeshes.Count; optimizedMeshIndex++)  				{  					for (int n = 0; n < OptimizedMeshes[optimizedMeshIndex].vertices.Count; n++)  					{  						OptimizedMeshes[optimizedMeshIndex].vertices[n].position -= modelXYCenterZBottom_um;  					}  				}    				minXYZ_um -= modelXYCenterZBottom_um;  				maxXYZ_um -= modelXYCenterZBottom_um;  			}  			else // we still need to put in the bottom clip  			{  				// Offset by bed center and correctly position in z  				IntPoint modelZBottom_um = new IntPoint(0' 0' minXYZ_um.Z - zClip_um);  				for (int optimizedMeshIndex = 0; optimizedMeshIndex < OptimizedMeshes.Count; optimizedMeshIndex++)  				{  					for (int vertexIndex = 0; vertexIndex < OptimizedMeshes[optimizedMeshIndex].vertices.Count; vertexIndex++)  					{  						OptimizedMeshes[optimizedMeshIndex].vertices[vertexIndex].position -= modelZBottom_um;  					}  				}    				minXYZ_um -= modelZBottom_um;  				maxXYZ_um -= modelZBottom_um;  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter(filename))  			{  				BinaryWriter f = new BinaryWriter(stream.BaseStream);  				Byte[] header = new Byte[80];    				f.Write(header);    				int n = vol.facesTriangle.Count;    				f.Write(n);    				for (int i = 0; i < vol.facesTriangle.Count; i++)  				{  					// stl expects a normal (we don't care about it's data)  					f.Write((float)1);  					f.Write((float)1);  					f.Write((float)1);    					for (int vert = 0; vert < 3; vert++)  					{  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.X / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Y / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Z / 1000.0));  					}    					f.Write((short)0);  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter(filename))  			{  				BinaryWriter f = new BinaryWriter(stream.BaseStream);  				Byte[] header = new Byte[80];    				f.Write(header);    				int n = vol.facesTriangle.Count;    				f.Write(n);    				for (int i = 0; i < vol.facesTriangle.Count; i++)  				{  					// stl expects a normal (we don't care about it's data)  					f.Write((float)1);  					f.Write((float)1);  					f.Write((float)1);    					for (int vert = 0; vert < 3; vert++)  					{  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.X / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Y / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Z / 1000.0));  					}    					f.Write((short)0);  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter(filename))  			{  				BinaryWriter f = new BinaryWriter(stream.BaseStream);  				Byte[] header = new Byte[80];    				f.Write(header);    				int n = vol.facesTriangle.Count;    				f.Write(n);    				for (int i = 0; i < vol.facesTriangle.Count; i++)  				{  					// stl expects a normal (we don't care about it's data)  					f.Write((float)1);  					f.Write((float)1);  					f.Write((float)1);    					for (int vert = 0; vert < 3; vert++)  					{  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.X / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Y / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Z / 1000.0));  					}    					f.Write((short)0);  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter(filename))  			{  				BinaryWriter f = new BinaryWriter(stream.BaseStream);  				Byte[] header = new Byte[80];    				f.Write(header);    				int n = vol.facesTriangle.Count;    				f.Write(n);    				for (int i = 0; i < vol.facesTriangle.Count; i++)  				{  					// stl expects a normal (we don't care about it's data)  					f.Write((float)1);  					f.Write((float)1);  					f.Write((float)1);    					for (int vert = 0; vert < 3; vert++)  					{  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.X / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Y / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Z / 1000.0));  					}    					f.Write((short)0);  				}  			}
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,C:\repos\MatterHackers_MatterSlice\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter(filename))  			{  				BinaryWriter f = new BinaryWriter(stream.BaseStream);  				Byte[] header = new Byte[80];    				f.Write(header);    				int n = vol.facesTriangle.Count;    				f.Write(n);    				for (int i = 0; i < vol.facesTriangle.Count; i++)  				{  					// stl expects a normal (we don't care about it's data)  					f.Write((float)1);  					f.Write((float)1);  					f.Write((float)1);    					for (int vert = 0; vert < 3; vert++)  					{  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.X / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Y / 1000.0));  						f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Z / 1000.0));  					}    					f.Write((short)0);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleFace,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,SimpleFace,The following statement contains a magic number: vertices[2] = v2;
Magic Number,MatterHackers.MatterSlice,SimpleMesh,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,maxXYZ_um,The following statement contains a magic number: for (int i = 0; i < faceTriangles.Count; i++)  			{  				SET_MAX(ref ret.X' faceTriangles[i].vertices[0].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[0].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[0].Z);  				SET_MAX(ref ret.X' faceTriangles[i].vertices[1].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[1].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[1].Z);  				SET_MAX(ref ret.X' faceTriangles[i].vertices[2].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[2].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[2].Z);  			}
Magic Number,MatterHackers.MatterSlice,SimpleMesh,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,maxXYZ_um,The following statement contains a magic number: for (int i = 0; i < faceTriangles.Count; i++)  			{  				SET_MAX(ref ret.X' faceTriangles[i].vertices[0].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[0].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[0].Z);  				SET_MAX(ref ret.X' faceTriangles[i].vertices[1].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[1].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[1].Z);  				SET_MAX(ref ret.X' faceTriangles[i].vertices[2].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[2].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[2].Z);  			}
Magic Number,MatterHackers.MatterSlice,SimpleMesh,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,maxXYZ_um,The following statement contains a magic number: for (int i = 0; i < faceTriangles.Count; i++)  			{  				SET_MAX(ref ret.X' faceTriangles[i].vertices[0].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[0].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[0].Z);  				SET_MAX(ref ret.X' faceTriangles[i].vertices[1].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[1].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[1].Z);  				SET_MAX(ref ret.X' faceTriangles[i].vertices[2].X);  				SET_MAX(ref ret.Y' faceTriangles[i].vertices[2].Y);  				SET_MAX(ref ret.Z' faceTriangles[i].vertices[2].Z);  			}
Magic Number,MatterHackers.MatterSlice,SimpleMesh,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,minXYZ_um,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < faceTriangles.Count; faceIndex++)  			{  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[0].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[0].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[0].Z);  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[1].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[1].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[1].Z);  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[2].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[2].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[2].Z);  			}
Magic Number,MatterHackers.MatterSlice,SimpleMesh,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,minXYZ_um,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < faceTriangles.Count; faceIndex++)  			{  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[0].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[0].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[0].Z);  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[1].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[1].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[1].Z);  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[2].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[2].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[2].Z);  			}
Magic Number,MatterHackers.MatterSlice,SimpleMesh,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,minXYZ_um,The following statement contains a magic number: for (int faceIndex = 0; faceIndex < faceTriangles.Count; faceIndex++)  			{  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[0].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[0].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[0].Z);  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[1].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[1].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[1].Z);  				SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[2].X);  				SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[2].Y);  				SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[2].Z);  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: using (StreamReader f = new StreamReader(filename))  			{  				// check for "SOLID"    				Vector3 vertex = new Vector3();  				int n = 0;  				IntPoint v0 = new IntPoint(0' 0' 0);  				IntPoint v1 = new IntPoint(0' 0' 0);  				IntPoint v2 = new IntPoint(0' 0' 0);  				string line = f.ReadLine();  				Regex onlySingleSpaces = new Regex("\\s+"' RegexOptions.Compiled);  				int lineCount = 0;  				while (line != null)  				{  					if (lineCount++ > 100 && vol.faceTriangles.Count == 0)  					{  						return false;  					}  					line = onlySingleSpaces.Replace(line' " ");  					var parts = line.Trim().Split(' ');  					if (parts[0].Trim() == "vertex")  					{  						vertex.x = Convert.ToDouble(parts[1]);  						vertex.y = Convert.ToDouble(parts[2]);  						vertex.z = Convert.ToDouble(parts[3]);    						// change the scale from mm to micrometers  						vertex *= 1000.0;    						n++;  						switch (n)  						{  							case 1:  								v0 = matrix.apply(vertex);  								break;    							case 2:  								v1 = matrix.apply(vertex);  								break;    							case 3:  								v2 = matrix.apply(vertex);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}  					}  					line = f.ReadLine();  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: using (StreamReader f = new StreamReader(filename))  			{  				// check for "SOLID"    				Vector3 vertex = new Vector3();  				int n = 0;  				IntPoint v0 = new IntPoint(0' 0' 0);  				IntPoint v1 = new IntPoint(0' 0' 0);  				IntPoint v2 = new IntPoint(0' 0' 0);  				string line = f.ReadLine();  				Regex onlySingleSpaces = new Regex("\\s+"' RegexOptions.Compiled);  				int lineCount = 0;  				while (line != null)  				{  					if (lineCount++ > 100 && vol.faceTriangles.Count == 0)  					{  						return false;  					}  					line = onlySingleSpaces.Replace(line' " ");  					var parts = line.Trim().Split(' ');  					if (parts[0].Trim() == "vertex")  					{  						vertex.x = Convert.ToDouble(parts[1]);  						vertex.y = Convert.ToDouble(parts[2]);  						vertex.z = Convert.ToDouble(parts[3]);    						// change the scale from mm to micrometers  						vertex *= 1000.0;    						n++;  						switch (n)  						{  							case 1:  								v0 = matrix.apply(vertex);  								break;    							case 2:  								v1 = matrix.apply(vertex);  								break;    							case 3:  								v2 = matrix.apply(vertex);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}  					}  					line = f.ReadLine();  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: using (StreamReader f = new StreamReader(filename))  			{  				// check for "SOLID"    				Vector3 vertex = new Vector3();  				int n = 0;  				IntPoint v0 = new IntPoint(0' 0' 0);  				IntPoint v1 = new IntPoint(0' 0' 0);  				IntPoint v2 = new IntPoint(0' 0' 0);  				string line = f.ReadLine();  				Regex onlySingleSpaces = new Regex("\\s+"' RegexOptions.Compiled);  				int lineCount = 0;  				while (line != null)  				{  					if (lineCount++ > 100 && vol.faceTriangles.Count == 0)  					{  						return false;  					}  					line = onlySingleSpaces.Replace(line' " ");  					var parts = line.Trim().Split(' ');  					if (parts[0].Trim() == "vertex")  					{  						vertex.x = Convert.ToDouble(parts[1]);  						vertex.y = Convert.ToDouble(parts[2]);  						vertex.z = Convert.ToDouble(parts[3]);    						// change the scale from mm to micrometers  						vertex *= 1000.0;    						n++;  						switch (n)  						{  							case 1:  								v0 = matrix.apply(vertex);  								break;    							case 2:  								v1 = matrix.apply(vertex);  								break;    							case 3:  								v2 = matrix.apply(vertex);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}  					}  					line = f.ReadLine();  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: using (StreamReader f = new StreamReader(filename))  			{  				// check for "SOLID"    				Vector3 vertex = new Vector3();  				int n = 0;  				IntPoint v0 = new IntPoint(0' 0' 0);  				IntPoint v1 = new IntPoint(0' 0' 0);  				IntPoint v2 = new IntPoint(0' 0' 0);  				string line = f.ReadLine();  				Regex onlySingleSpaces = new Regex("\\s+"' RegexOptions.Compiled);  				int lineCount = 0;  				while (line != null)  				{  					if (lineCount++ > 100 && vol.faceTriangles.Count == 0)  					{  						return false;  					}  					line = onlySingleSpaces.Replace(line' " ");  					var parts = line.Trim().Split(' ');  					if (parts[0].Trim() == "vertex")  					{  						vertex.x = Convert.ToDouble(parts[1]);  						vertex.y = Convert.ToDouble(parts[2]);  						vertex.z = Convert.ToDouble(parts[3]);    						// change the scale from mm to micrometers  						vertex *= 1000.0;    						n++;  						switch (n)  						{  							case 1:  								v0 = matrix.apply(vertex);  								break;    							case 2:  								v1 = matrix.apply(vertex);  								break;    							case 3:  								v2 = matrix.apply(vertex);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}  					}  					line = f.ReadLine();  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: using (StreamReader f = new StreamReader(filename))  			{  				// check for "SOLID"    				Vector3 vertex = new Vector3();  				int n = 0;  				IntPoint v0 = new IntPoint(0' 0' 0);  				IntPoint v1 = new IntPoint(0' 0' 0);  				IntPoint v2 = new IntPoint(0' 0' 0);  				string line = f.ReadLine();  				Regex onlySingleSpaces = new Regex("\\s+"' RegexOptions.Compiled);  				int lineCount = 0;  				while (line != null)  				{  					if (lineCount++ > 100 && vol.faceTriangles.Count == 0)  					{  						return false;  					}  					line = onlySingleSpaces.Replace(line' " ");  					var parts = line.Trim().Split(' ');  					if (parts[0].Trim() == "vertex")  					{  						vertex.x = Convert.ToDouble(parts[1]);  						vertex.y = Convert.ToDouble(parts[2]);  						vertex.z = Convert.ToDouble(parts[3]);    						// change the scale from mm to micrometers  						vertex *= 1000.0;    						n++;  						switch (n)  						{  							case 1:  								v0 = matrix.apply(vertex);  								break;    							case 2:  								v1 = matrix.apply(vertex);  								break;    							case 3:  								v2 = matrix.apply(vertex);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}  					}  					line = f.ReadLine();  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: using (StreamReader f = new StreamReader(filename))  			{  				// check for "SOLID"    				Vector3 vertex = new Vector3();  				int n = 0;  				IntPoint v0 = new IntPoint(0' 0' 0);  				IntPoint v1 = new IntPoint(0' 0' 0);  				IntPoint v2 = new IntPoint(0' 0' 0);  				string line = f.ReadLine();  				Regex onlySingleSpaces = new Regex("\\s+"' RegexOptions.Compiled);  				int lineCount = 0;  				while (line != null)  				{  					if (lineCount++ > 100 && vol.faceTriangles.Count == 0)  					{  						return false;  					}  					line = onlySingleSpaces.Replace(line' " ");  					var parts = line.Trim().Split(' ');  					if (parts[0].Trim() == "vertex")  					{  						vertex.x = Convert.ToDouble(parts[1]);  						vertex.y = Convert.ToDouble(parts[2]);  						vertex.z = Convert.ToDouble(parts[3]);    						// change the scale from mm to micrometers  						vertex *= 1000.0;    						n++;  						switch (n)  						{  							case 1:  								v0 = matrix.apply(vertex);  								break;    							case 2:  								v1 = matrix.apply(vertex);  								break;    							case 3:  								v2 = matrix.apply(vertex);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}  					}  					line = f.ReadLine();  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: if (vol.faceTriangles.Count > 3)  			{  				simpleModel.SimpleMeshes.Add(vol);  				return true;  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: using (FileStream stlStream = File.Open(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				if (fileContents.Length < currentPosition)  				{  					return false;  				}  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 0)  				{  					stlStream.Close();  					return false;  				}    				IntPoint[] vector = new IntPoint[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new IntPoint(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4) * 1000'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4) * 1000);  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,getBoundaryPointWithOffset,The following statement contains a magic number: IntPoint off0 = ((p1 - p0).Normal(1000)).CrossZ();
Magic Number,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,getBoundaryPointWithOffset,The following statement contains a magic number: IntPoint off1 = ((p2 - p1).Normal(1000)).CrossZ();
Magic Number,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,OptimizePolygon,The following statement contains a magic number: for (int i = 0; i < polygon.Count; i++)  			{  				IntPoint currentPoint = polygon[i];  				if ((previousPoint - currentPoint).IsShorterThen(10))  				{  					polygon.RemoveAt(i);  					i--;  				}  				else  				{  					IntPoint nextPoint;  					if (i < polygon.Count - 1)  					{  						nextPoint = polygon[i + 1];  					}  					else  					{  						nextPoint = polygon[0];  					}    					IntPoint diff0 = (currentPoint - previousPoint).SetLength(1000000);  					IntPoint diff2 = (currentPoint - nextPoint).SetLength(1000000);    					long d = diff0.Dot(diff2);  					if (d < -999999000000)  					{  						polygon.RemoveAt(i);  						i--;  					}  					else  					{  						previousPoint = currentPoint;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,OptimizePolygon,The following statement contains a magic number: for (int i = 0; i < polygon.Count; i++)  			{  				IntPoint currentPoint = polygon[i];  				if ((previousPoint - currentPoint).IsShorterThen(10))  				{  					polygon.RemoveAt(i);  					i--;  				}  				else  				{  					IntPoint nextPoint;  					if (i < polygon.Count - 1)  					{  						nextPoint = polygon[i + 1];  					}  					else  					{  						nextPoint = polygon[0];  					}    					IntPoint diff0 = (currentPoint - previousPoint).SetLength(1000000);  					IntPoint diff2 = (currentPoint - nextPoint).SetLength(1000000);    					long d = diff0.Dot(diff2);  					if (d < -999999000000)  					{  						polygon.RemoveAt(i);  						i--;  					}  					else  					{  						previousPoint = currentPoint;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,OptimizePolygon,The following statement contains a magic number: for (int i = 0; i < polygon.Count; i++)  			{  				IntPoint currentPoint = polygon[i];  				if ((previousPoint - currentPoint).IsShorterThen(10))  				{  					polygon.RemoveAt(i);  					i--;  				}  				else  				{  					IntPoint nextPoint;  					if (i < polygon.Count - 1)  					{  						nextPoint = polygon[i + 1];  					}  					else  					{  						nextPoint = polygon[0];  					}    					IntPoint diff0 = (currentPoint - previousPoint).SetLength(1000000);  					IntPoint diff2 = (currentPoint - nextPoint).SetLength(1000000);    					long d = diff0.Dot(diff2);  					if (d < -999999000000)  					{  						polygon.RemoveAt(i);  						i--;  					}  					else  					{  						previousPoint = currentPoint;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,OptimizePolygon,The following statement contains a magic number: for (int i = 0; i < polygon.Count; i++)  			{  				IntPoint currentPoint = polygon[i];  				if ((previousPoint - currentPoint).IsShorterThen(10))  				{  					polygon.RemoveAt(i);  					i--;  				}  				else  				{  					IntPoint nextPoint;  					if (i < polygon.Count - 1)  					{  						nextPoint = polygon[i + 1];  					}  					else  					{  						nextPoint = polygon[0];  					}    					IntPoint diff0 = (currentPoint - previousPoint).SetLength(1000000);  					IntPoint diff2 = (currentPoint - nextPoint).SetLength(1000000);    					long d = diff0.Dot(diff2);  					if (d < -999999000000)  					{  						polygon.RemoveAt(i);  						i--;  					}  					else  					{  						previousPoint = currentPoint;  					}  				}  			}
Magic Number,MatterHackers.MatterSlice,PolygonHelper,C:\repos\MatterHackers_MatterSlice\utils\PolygonHelper.cs,SaveToGCode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,C:\repos\MatterHackers_MatterSlice\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: for (int polygonIndex = 0; polygonIndex < polygons.Count; polygonIndex++)  			{  				Polygon currentPolygon = polygons[polygonIndex];  				if (canTravelForwardOrBackward || currentPolygon.Count < 3)  				{  					startIndexInPolygon.Add(0);  				}  				else // This is a closed loop.  				{  					// some code for helping create unit tests  					//string polyString = currentPolygon.WriteToString();  					//currentPolygon.SaveToGCode("perimeter.gcode");    					// this is our new seam hiding code  					int bestPointIndex;  					if (config != null  						&& config.DoSeamHiding  						&& !config.spiralize)  					{  						bestPointIndex = currentPolygon.FindGreatestTurnIndex(config.lineWidth_um);  					}  					else  					{  						bestPointIndex = currentPolygon.FindClosestPositionIndex(startPosition);  					}    					startIndexInPolygon.Add(bestPointIndex);  				}  			}
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,C:\repos\MatterHackers_MatterSlice\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: for (int polygonIndexOuterLoop = 0; polygonIndexOuterLoop < polygons.Count; polygonIndexOuterLoop++)  			{  				int bestPolygonIndex = -1;  				double bestDist = double.MaxValue;  				for (int polygonIndex = 0; polygonIndex < polygons.Count; polygonIndex++)  				{  					if (polygonHasBeenAdded[polygonIndex] || polygons[polygonIndex].Count < 1)  					{  						continue;  					}    					// If there are only 2 points (a single line) or the path is marked as travel both ways' we are willing to start from the start or the end.  					if (polygons[polygonIndex].Count == 2 || canTravelForwardOrBackward)  					{  						double distToSart = (polygons[polygonIndex][0] - currentPosition).LengthSquared();  						if (distToSart <= bestDist)  						{  							bestPolygonIndex = polygonIndex;  							bestDist = distToSart;  							startIndexInPolygon[polygonIndex] = 0;  						}    						double distToEnd = (polygons[polygonIndex][polygons[polygonIndex].Count - 1] - currentPosition).LengthSquared();  						if (distToEnd < bestDist)  						{  							bestPolygonIndex = polygonIndex;  							bestDist = distToEnd;  							startIndexInPolygon[polygonIndex] = 1;  						}  					}  					else  					{  						double dist = (polygons[polygonIndex][startIndexInPolygon[polygonIndex]] - currentPosition).LengthSquared();  						if (dist < bestDist)  						{  							bestPolygonIndex = polygonIndex;  							bestDist = dist;  						}  					}  				}    				if (bestPolygonIndex > -1)  				{  					if (polygons[bestPolygonIndex].Count == 2 || canTravelForwardOrBackward)  					{  						// get the point that is opposite from the one we started on  						int startIndex = startIndexInPolygon[bestPolygonIndex];  						if (startIndex == 0)  						{  							currentPosition = polygons[bestPolygonIndex][polygons[bestPolygonIndex].Count - 1];  						}  						else  						{  							currentPosition = polygons[bestPolygonIndex][0];  						}  					}  					else  					{  						currentPosition = polygons[bestPolygonIndex][startIndexInPolygon[bestPolygonIndex]];  					}  					polygonHasBeenAdded[bestPolygonIndex] = true;  					bestIslandOrderIndex.Add(bestPolygonIndex);  				}  			}
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,C:\repos\MatterHackers_MatterSlice\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: for (int polygonIndexOuterLoop = 0; polygonIndexOuterLoop < polygons.Count; polygonIndexOuterLoop++)  			{  				int bestPolygonIndex = -1;  				double bestDist = double.MaxValue;  				for (int polygonIndex = 0; polygonIndex < polygons.Count; polygonIndex++)  				{  					if (polygonHasBeenAdded[polygonIndex] || polygons[polygonIndex].Count < 1)  					{  						continue;  					}    					// If there are only 2 points (a single line) or the path is marked as travel both ways' we are willing to start from the start or the end.  					if (polygons[polygonIndex].Count == 2 || canTravelForwardOrBackward)  					{  						double distToSart = (polygons[polygonIndex][0] - currentPosition).LengthSquared();  						if (distToSart <= bestDist)  						{  							bestPolygonIndex = polygonIndex;  							bestDist = distToSart;  							startIndexInPolygon[polygonIndex] = 0;  						}    						double distToEnd = (polygons[polygonIndex][polygons[polygonIndex].Count - 1] - currentPosition).LengthSquared();  						if (distToEnd < bestDist)  						{  							bestPolygonIndex = polygonIndex;  							bestDist = distToEnd;  							startIndexInPolygon[polygonIndex] = 1;  						}  					}  					else  					{  						double dist = (polygons[polygonIndex][startIndexInPolygon[polygonIndex]] - currentPosition).LengthSquared();  						if (dist < bestDist)  						{  							bestPolygonIndex = polygonIndex;  							bestDist = dist;  						}  					}  				}    				if (bestPolygonIndex > -1)  				{  					if (polygons[bestPolygonIndex].Count == 2 || canTravelForwardOrBackward)  					{  						// get the point that is opposite from the one we started on  						int startIndex = startIndexInPolygon[bestPolygonIndex];  						if (startIndex == 0)  						{  							currentPosition = polygons[bestPolygonIndex][polygons[bestPolygonIndex].Count - 1];  						}  						else  						{  							currentPosition = polygons[bestPolygonIndex][0];  						}  					}  					else  					{  						currentPosition = polygons[bestPolygonIndex][startIndexInPolygon[bestPolygonIndex]];  					}  					polygonHasBeenAdded[bestPolygonIndex] = true;  					bestIslandOrderIndex.Add(bestPolygonIndex);  				}  			}
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,C:\repos\MatterHackers_MatterSlice\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: foreach (int bestPolygonIndex in bestIslandOrderIndex)  			{  				int bestStartPoint = -1;  				double bestDist = double.MaxValue;  				if (canTravelForwardOrBackward)  				{  					bestDist = (polygons[bestPolygonIndex][0] - currentPosition).LengthSquared();  					bestStartPoint = 0;    					// check if the end is better  					int endIndex = polygons[bestPolygonIndex].Count - 1;  					double dist = (polygons[bestPolygonIndex][endIndex] - currentPosition).LengthSquared();  					if (dist < bestDist)  					{  						bestStartPoint = endIndex;  						bestDist = dist;  					}    					startIndexInPolygon[bestPolygonIndex] = bestStartPoint;  				}  				else  				{  					for (int pointIndex = 0; pointIndex < polygons[bestPolygonIndex].Count; pointIndex++)  					{  						double dist = (polygons[bestPolygonIndex][pointIndex] - currentPosition).LengthSquared();  						if (dist < bestDist)  						{  							bestStartPoint = pointIndex;  							bestDist = dist;  						}  					}  				}    				if (polygons[bestPolygonIndex].Count == 2 || canTravelForwardOrBackward)  				{  					if (bestStartPoint == 0)  					{  						currentPosition = polygons[bestPolygonIndex][polygons[bestPolygonIndex].Count - 1];  					}  					else  					{  						currentPosition = polygons[bestPolygonIndex][0];  					}  				}  				else  				{  					currentPosition = polygons[bestPolygonIndex][bestStartPoint];  				}  			}
Magic Number,MatterHackers.MatterSlice,LogOutput,C:\repos\MatterHackers_MatterSlice\logoutput.cs,logProgress,The following statement contains a magic number: if (verbose_level < 2)  			{  				return;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateConcentricInfill,The following statement contains a magic number: int linespacing_um = (int)(extrusionWidthOverride_um / (config.InfillPercent / 100));
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateGridInfill,The following statement contains a magic number: if (linespacing_um == 0)  			{  				if (config.InfillPercent <= 0)  				{  					throw new Exception("infillPercent must be greater than 0.");  				}  				linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 2);  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateGridInfill,The following statement contains a magic number: if (linespacing_um == 0)  			{  				if (config.InfillPercent <= 0)  				{  					throw new Exception("infillPercent must be greater than 0.");  				}  				linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 2);  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateGridInfill,The following statement contains a magic number: fillAngle += 90;
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateGridInfill,The following statement contains a magic number: if (fillAngle > 360)  			{  				fillAngle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateGridInfill,The following statement contains a magic number: if (fillAngle > 360)  			{  				fillAngle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexagonInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3 * .66);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexagonInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3 * .66);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexagonInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3 * .66);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: if (in_outline.Count > 0)  			{  				Polygons outlines = in_outline.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);  					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing;  					boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;  					boundary.max.X += lineSpacing;  					boundary.max.Y += perIncrementOffset;  					Polygons unclipedPatern = new Polygons();    					foreach (IntPoint startPoint in StartPositionIterator(boundary' lineSpacing' layerIndex))  					{  						Polygon attachedLine = new Polygon();  						foreach (IntPoint center in IncrementPositionIterator(startPoint' boundary' lineSpacing' layerIndex))  						{  							// what we are adding are the little pluses that define the points  							//        | top  							//        |  							//        /\ center  							//   left/  \ right  							//  							IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);  							IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);    							switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}  						}  						if (attachedLine.Count > 0)  						{  							unclipedPatern.Add(attachedLine);  						}  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotationDegrees + extraRotationAngle));  					newSegments.ApplyMatrix(inversematrix);    					result.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateLineInfill,The following statement contains a magic number: if (linespacing_um == 0)  			{  				if (config.InfillPercent <= 0)  				{  					throw new Exception("infillPercent must be greater than 0.");  				}    				linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100));  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateLinePaths,The following statement contains a magic number: if (polygonToInfill.Count > 0)  			{  				Polygons outlines = polygonToInfill.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					PointMatrix matrix = new PointMatrix(-(rotation + 90)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing - rotationOffset;  					int xLineCount = (int)((boundary.max.X - boundary.min.X + (lineSpacing - 1)) / lineSpacing);  					Polygons unclipedPatern = new Polygons();    					long firstX = boundary.min.X / lineSpacing * lineSpacing;  					for (int lineIndex = 0; lineIndex < xLineCount; lineIndex++)  					{  						Polygon line = new Polygon();  						line.Add(new IntPoint(firstX + lineIndex * lineSpacing' boundary.min.Y));  						line.Add(new IntPoint(firstX + lineIndex * lineSpacing' boundary.max.Y));  						unclipedPatern.Add(line);  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotation + 90));  					newSegments.ApplyMatrix(inversematrix);    					infillLinesToPrint.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateLinePaths,The following statement contains a magic number: if (polygonToInfill.Count > 0)  			{  				Polygons outlines = polygonToInfill.Offset(infillExtendIntoPerimeter_um);  				if (outlines.Count > 0)  				{  					PointMatrix matrix = new PointMatrix(-(rotation + 90)); // we are rotating the part so we rotate by the negative so the lines go the way we expect    					outlines.ApplyMatrix(matrix);    					Aabb boundary = new Aabb(outlines);    					boundary.min.X = ((boundary.min.X / lineSpacing) - 1) * lineSpacing - rotationOffset;  					int xLineCount = (int)((boundary.max.X - boundary.min.X + (lineSpacing - 1)) / lineSpacing);  					Polygons unclipedPatern = new Polygons();    					long firstX = boundary.min.X / lineSpacing * lineSpacing;  					for (int lineIndex = 0; lineIndex < xLineCount; lineIndex++)  					{  						Polygon line = new Polygon();  						line.Add(new IntPoint(firstX + lineIndex * lineSpacing' boundary.min.Y));  						line.Add(new IntPoint(firstX + lineIndex * lineSpacing' boundary.max.Y));  						unclipedPatern.Add(line);  					}    					PolyTree ret = new PolyTree();  					Clipper clipper = new Clipper();  					clipper.AddPaths(unclipedPatern' PolyType.ptSubject' false);  					clipper.AddPaths(outlines' PolyType.ptClip' true);  					clipper.Execute(ClipType.ctIntersection' ret' PolyFillType.pftPositive' PolyFillType.pftEvenOdd);    					Polygons newSegments = Clipper.OpenPathsFromPolyTree(ret);  					PointMatrix inversematrix = new PointMatrix((rotation + 90));  					newSegments.ApplyMatrix(inversematrix);    					infillLinesToPrint.AddRange(newSegments);  				}  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: long offset = linespacing_um / 2;
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle += 60;
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: if (fillAngle > 360)  			{  				fillAngle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: if (fillAngle > 360)  			{  				fillAngle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle += 60;
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: if (fillAngle > 360)  			{  				fillAngle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: if (fillAngle > 360)  			{  				fillAngle -= 360;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = ((yPosition / perIncrementOffset) % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}  						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}  					break;    				case 1: // left to top  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;    				case 2: // top to right  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = ((yPosition / perIncrementOffset) % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}  						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}  					break;    				case 1: // left to top  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;    				case 2: // top to right  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = ((yPosition / perIncrementOffset) % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}  						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}  					break;    				case 1: // left to top  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;    				case 2: // top to right  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = ((yPosition / perIncrementOffset) % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}  						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}  					break;    				case 1: // left to top  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;    				case 2: // top to right  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = ((yPosition / perIncrementOffset) % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}  						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}  					break;    				case 1: // left to top  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;    				case 2: // top to right  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = ((yPosition / perIncrementOffset) % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}  						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}  					break;    				case 1: // left to top  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;    				case 2: // top to right  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;  			}
Magic Number,MatterHackers.MatterSlice,MultiExtruders,C:\repos\MatterHackers_MatterSlice\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: if (extruders.Count < 2 || overlapUm <= 0)  			{  				return;  			}
Magic Number,MatterHackers.MatterSlice,MultiExtruders,C:\repos\MatterHackers_MatterSlice\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < extruders[0].Layers.Count; layerIndex++)  			{  				Polygons fullLayer = new Polygons();  				for (int extruderIndex = 0; extruderIndex < extruders.Count; extruderIndex++)  				{  					SliceLayer layer1 = extruders[extruderIndex].Layers[layerIndex];  					fullLayer = fullLayer.CreateUnion(layer1.AllOutlines.Offset(20));  				}  				fullLayer = fullLayer.Offset(-20);    				for (int extruderIndex = 0; extruderIndex < extruders.Count; extruderIndex++)  				{  					SliceLayer layer1 = extruders[extruderIndex].Layers[layerIndex];  					layer1.AllOutlines = fullLayer.CreateIntersection(layer1.AllOutlines.Offset(overlapUm / 2));  				}  			}
Magic Number,MatterHackers.MatterSlice,MultiExtruders,C:\repos\MatterHackers_MatterSlice\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < extruders[0].Layers.Count; layerIndex++)  			{  				Polygons fullLayer = new Polygons();  				for (int extruderIndex = 0; extruderIndex < extruders.Count; extruderIndex++)  				{  					SliceLayer layer1 = extruders[extruderIndex].Layers[layerIndex];  					fullLayer = fullLayer.CreateUnion(layer1.AllOutlines.Offset(20));  				}  				fullLayer = fullLayer.Offset(-20);    				for (int extruderIndex = 0; extruderIndex < extruders.Count; extruderIndex++)  				{  					SliceLayer layer1 = extruders[extruderIndex].Layers[layerIndex];  					layer1.AllOutlines = fullLayer.CreateIntersection(layer1.AllOutlines.Offset(overlapUm / 2));  				}  			}
Magic Number,MatterHackers.MatterSlice,MultiExtruders,C:\repos\MatterHackers_MatterSlice\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: for (int layerIndex = 0; layerIndex < extruders[0].Layers.Count; layerIndex++)  			{  				Polygons fullLayer = new Polygons();  				for (int extruderIndex = 0; extruderIndex < extruders.Count; extruderIndex++)  				{  					SliceLayer layer1 = extruders[extruderIndex].Layers[layerIndex];  					fullLayer = fullLayer.CreateUnion(layer1.AllOutlines.Offset(20));  				}  				fullLayer = fullLayer.Offset(-20);    				for (int extruderIndex = 0; extruderIndex < extruders.Count; extruderIndex++)  				{  					SliceLayer layer1 = extruders[extruderIndex].Layers[layerIndex];  					layer1.AllOutlines = fullLayer.CreateIntersection(layer1.AllOutlines.Offset(overlapUm / 2));  				}  			}
Duplicate Code,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The method contains a code clone-set at the following line numbers (starting from the method definition): ((27' 46)' (52' 71))
Missing Default,MatterHackers.MatterSlice,GrahamScan,C:\repos\MatterHackers_MatterSlice\GrahamScan.cs,GetConvexHull,The following switch statement is missing a default case: switch (turn)  				{  					case Turn.CounterClockwise:  						stack.Push(middle);  						stack.Push(head);  						break;    					case Turn.Clockwise:  						i--;  						break;    					case Turn.Collinear:  						stack.Push(head);  						break;  				}
Missing Default,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueAirGappedBottomLayer,The following switch statement is missing a default case: switch (config.SupportType)  				{  					case ConfigConstants.SUPPORT_TYPE.GRID:  						Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;    					case ConfigConstants.SUPPORT_TYPE.LINES:  						Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;  				}
Missing Default,MatterHackers.MatterSlice,NewSupport,C:\repos\MatterHackers_MatterSlice\NewSupport.cs,QueueNormalSupportLayer,The following switch statement is missing a default case: switch (config.SupportType)  					{  						case ConfigConstants.SUPPORT_TYPE.GRID:  							Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;    						case ConfigConstants.SUPPORT_TYPE.LINES:  							Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;  					}
Missing Default,MatterHackers.MatterSlice,SimpleMeshCollection,C:\repos\MatterHackers_MatterSlice\SimpleMesh.cs,loadModelSTL_ascii,The following switch statement is missing a default case: switch (n)  						{  							case 1:  								v0 = matrix.apply(vertex);  								break;    							case 2:  								v1 = matrix.apply(vertex);  								break;    							case 3:  								v2 = matrix.apply(vertex);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}
Missing Default,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,GenerateHexLinePaths,The following switch statement is missing a default case: switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclipedPatern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclipedPatern.Add(new Polygon() { left' center });  									break;  							}
Missing Default,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,IncrementPositionIterator,The following switch statement is missing a default case: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Missing Default,MatterHackers.MatterSlice,Infill,C:\repos\MatterHackers_MatterSlice\infill.cs,StartPositionIterator,The following switch statement is missing a default case: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = ((yPosition / perIncrementOffset) % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}  						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}  					break;    				case 1: // left to top  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;    				case 2: // top to right  					{  						IntPoint nextPoint = new IntPoint();  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = ((yPosition / perIncrementOffset) % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}  					break;  			}
Missing Default,MatterHackers.MatterSlice,BooleanProcessing,C:\repos\MatterHackers_MatterSlice\MultiExtruders.cs,DoLayerBooleans,The following switch statement is missing a default case: switch (booleanType)  			{  				case BooleanType.Union:  					if (layersB.AllOutlines.Count == 0)  					{  						// do nothing we will keep the content of A  					}  					else if (layersA.AllOutlines.Count == 0)  					{  						// there is nothing in A so set it to the content of B  						layersA.AllOutlines = layersB.AllOutlines;  					}  					else  					{  						layersA.AllOutlines = layersA.AllOutlines.CreateUnion(layersB.AllOutlines);  					}  					break;    				case BooleanType.Difference:  					layersA.AllOutlines = layersA.AllOutlines.CreateDifference(layersB.AllOutlines);  					break;    				case BooleanType.Intersection:  					layersA.AllOutlines = layersA.AllOutlines.CreateIntersection(layersB.AllOutlines);  					break;  			}
