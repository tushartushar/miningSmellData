Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetSetting,The method has 104 lines of code.
Long Method,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,GenerateTopAndBottoms,The method has 121 lines of code.
Long Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The method has 260 lines of code.
Long Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The method has 290 lines of code.
Long Method,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,The method has 157 lines of code.
Long Method,MatterHackers.MatterSlice,PathOrderOptimizer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\PathOrderOptimizer.cs,Optimize,The method has 142 lines of code.
Long Method,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,ExtruderData,The method has 123 lines of code.
Long Method,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,MakePolygons,The method has 215 lines of code.
Complex Method,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,DumpSettings,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetSetting,Cyclomatic complexity of the method is 16
Complex Method,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,GenerateTopAndBottoms,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,DoProcessing,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,ProcessSliceData,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,Cyclomatic complexity of the method is 35
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,ChangeExtruderIfRequired,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,Cyclomatic complexity of the method is 50
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,MoveToIsland,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,Cyclomatic complexity of the method is 18
Complex Method,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateConcentricInfill,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,EnsureWipeTowerIsSolid,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GenerateRaftOutlines,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GetSkirtBounds,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,QueuePolygon,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,QueueTravel,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,Cyclomatic complexity of the method is 26
Complex Method,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,ProcessArgs,Cyclomatic complexity of the method is 20
Complex Method,MatterHackers.MatterSlice,BooleanProcessing,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,Process,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,Cyclomatic complexity of the method is 20
Complex Method,MatterHackers.MatterSlice,PathOrderOptimizer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\PathOrderOptimizer.cs,Optimize,Cyclomatic complexity of the method is 21
Complex Method,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,GetSingleIslandAngle,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,BridgeAngle,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,ExtruderData,Cyclomatic complexity of the method is 20
Complex Method,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,MakePolygons,Cyclomatic complexity of the method is 34
Complex Method,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,GetTouchingSegmentIndex,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,Cyclomatic complexity of the method is 9
Long Parameter List,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,GetInsides,The method has 6 parameters. Parameters: insides' content' startingChar' endingChar' startIndex' endIndex
Long Parameter List,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,GenerateTopAndBottoms,The method has 7 parameters. Parameters: config' layerIndex' extrusionWidth_um' outerPerimeterWidth_um' downLayerCount' upLayerCount' infillExtendIntoPerimeter_um
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,ChangeExtruderIfRequired,The method has 6 parameters. Parameters: slicingData' layerPathFinder' layerIndex' layerGcodePlanner' extruderIndex' airGapped
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,DoSkirtAndBrim,The method has 5 parameters. Parameters: slicingData' layerIndex' layerGcodePlanner' extruderIndex' extruderUsedForSupport
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The method has 6 parameters. Parameters: slicingData' layerGcodePlanner' extruderIndex' layerIndex' extrusionWidth_um' currentZ_um
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueClosestInset,The method has 5 parameters. Parameters: insetsToConsider' limitDistance' pathConfig' layerIndex' gcodeLayer
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The method has 7 parameters. Parameters: slicingData' layerPathFinder' layerGcodePlanner' extruderIndex' layerIndex' extrusionWidth_um' currentZ_um
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePolygonsConsideringSupport,The method has 5 parameters. Parameters: layerIndex' gcodeLayer' polygonsToWrite' fillConfig' supportWriteType
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,GetSegmentsConsideringSupport,The method has 6 parameters. Parameters: polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' forAirGap' closedLoop
Long Parameter List,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The method has 9 parameters. Parameters: slicingData' extruderIndex' layerIndex' part' bottomFillLines' fillPolygons' firstTopFillPolygons' topFillPolygons' bridgePolygons
Long Parameter List,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateGridInfill,The method has 5 parameters. Parameters: config' partOutline' fillPolygons' fillAngle' linespacing_um
Long Parameter List,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexagonInfill,The method has 5 parameters. Parameters: config' partOutline' fillPolygons' fillAngle' layerIndex
Long Parameter List,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The method has 6 parameters. Parameters: in_outline' result' lineSpacing' infillExtendIntoPerimeter_um' rotationDegrees' layerIndex
Long Parameter List,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateLineInfill,The method has 5 parameters. Parameters: config' partOutline' fillPolygons' fillAngle' linespacing_um
Long Parameter List,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateLinePaths,The method has 6 parameters. Parameters: polygonToInfill' infillLinesToPrint' lineSpacing_um' infillExtendIntoPerimeter_um' rotation' rotationOffset
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,EnsureWipeTowerIsSolid,The method has 5 parameters. Parameters: layerIndex' pathFinder' layerGcodePlanner' fillConfig' config
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GenerateSkirt,The method has 6 parameters. Parameters: distance_um' extrusionWidth_um' numberOfLoops' brimCount' minLength_um' config
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GenerateWipeTowerInfill,The method has 5 parameters. Parameters: extruderIndex' partOutline' outputfillPolygons' extrusionWidth_um' config
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,PrimeOnWipeTower,The method has 6 parameters. Parameters: layerIndex' layerGcodePlanner' pathFinder' fillConfig' config' airGapped
Long Parameter List,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GetSkirtBounds,The method has 6 parameters. Parameters: config' storage' externalOnly' distance_um' extrusionWidth_um' brimCount
Long Parameter List,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,LayerGCodePlanner,The method has 5 parameters. Parameters: config' gcode' travelSpeed' retractionMinimumDistance_um' perimeterStartEndOverlap
Long Parameter List,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,GenerateInsets,The method has 5 parameters. Parameters: extrusionWidth_um' outerExtrusionWidth_um' insetCount' expandThinWalls' avoidCrossingPerimeters
Long Parameter List,MatterHackers.MatterSlice,PolygonHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonHelper.cs,convex3,The method has 6 parameters. Parameters: x0' y0' x1' y1' x2' y2
Long Identifier,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,,The length of the parameter extrusionAmountAtPreviousRetraction_mm is 38.
Long Identifier,MatterHackers.MatterSlice,LayerIsland,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerIsland.cs,,The length of the parameter minimumDistanceToCreateNewPosition is 34.
Long Identifier,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,MakePolygons,The length of the parameter minimumDistanceToCreateNewPosition is 34.
Long Statement,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,DumpSettings,The length of the statement  "						lines.Add("{0}={1} # {2}{3}".FormatWith(name' value' GetEnumHelpText(property.PropertyType' property.PropertyType.Name)' fieldDescription)); " is 140.
Long Statement,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetSetting,The length of the statement  "				// TODO: No one makes use of the LegacyName attribute thus the possibleNames HashSet and the LegacyName class could be removed as part of a code cleanup pass " is 157.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,GenerateTopAndBottoms,The length of the statement  "							regionsThatWillBeSparse = IntersectWithPolygons(extruder.Layers[layerToTest].Islands' island.BoundingBox' regionsThatWillBeSparse); " is 131.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,GenerateTopAndBottoms,The length of the statement  "							regionsThatWillBeSparse = IntersectWithPolygons(extruder.Layers[layerToTest].Islands' island.BoundingBox' regionsThatWillBeSparse); " is 131.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,GenerateTopAndBottoms,The length of the statement  "							firstTopPaths = IntersectWithSparsePolygons(extruder.Layers[layerIndex - 1].Islands' island.BoundingBox' firstTopPaths); " is 120.
Long Statement,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,IntersectWithPolygons,The length of the statement  "						polysFromIslands = polysFromIslands.CreateUnion(islands[islandIndex].InsetToolPaths[islands[islandIndex].InsetToolPaths.Count - 1]); " is 132.
Long Statement,MatterHackers.MatterSlice,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CurrentThenOtherIndexes,The length of the statement  "			// - When activeIndex is not E0' change extruder ordering to start with the current' then iterate the rest in normal order " is 122.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "				gcodeExport.WriteMove(new IntPoint(slicingData.modelMin.X' slicingData.modelMin.Y' gcodeExport.CurrentZ_um)' config.TravelSpeed' 0); " is 132.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "				var layerPlanner = new LayerGCodePlanner(config' gcodeExport' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 162.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "					z += config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceLayers * config.RaftSurfaceThickness_um; " is 127.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "				var interfaceExturderIndex = config.SupportInterfaceExtruder < config.ExtruderCount ? config.SupportInterfaceExtruder : 0; " is 122.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "				var activeThenOtherExtruders = slicingData.Extruders.CurrentThenOtherIndexes(activeExtruderIndex: layerPlanner.GetExtruder()); " is 126.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "					foreach (int extruderIndex in slicingData.Extruders.CurrentThenOtherIndexes(activeExtruderIndex: layerPlanner.GetExtruder())) " is 125.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "						QueueAirGappedExtruderLayerToGCode(slicingData' layerPathFinder' layerPlanner' extruderIndex' layerIndex' config.ExtrusionWidth_um' z); " is 135.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The length of the statement  "			// Store the object height for when we are printing multiple objects' as we need to clear every one of them when moving to the next position. " is 141.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,The length of the statement  "				var endIndex = Math.Min(slicingData.Extruders[extruderIndex].Layers.Count - 1' outputLayerIndex + config.NumberOfTopLayers + 1); " is 128.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,The length of the statement  "							layer.GenerateInsets(config.FirstLayerExtrusionWidth_um' config.FirstLayerExtrusionWidth_um' insetCount' config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter' config.AvoidCrossingPerimeters); " is 203.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,The length of the statement  "							layer.GenerateInsets(config.ExtrusionWidth_um' config.OutsideExtrusionWidth_um' insetCount' config.ExpandThinWalls && !config.ContinuousSpiralOuterPerimeter' config.AvoidCrossingPerimeters); " is 190.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,The length of the statement  "						slicingData.Extruders[extruderIndex].GenerateTopAndBottoms(config' outputLayerIndex' config.FirstLayerExtrusionWidth_um' config.FirstLayerExtrusionWidth_um' config.NumberOfBottomLayers' config.NumberOfTopLayers' config.InfillExtendIntoPerimeter_um); " is 249.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,The length of the statement  "						slicingData.Extruders[extruderIndex].GenerateTopAndBottoms(config' outputLayerIndex' config.ExtrusionWidth_um' config.OutsideExtrusionWidth_um' config.NumberOfBottomLayers' config.NumberOfTopLayers' config.InfillExtendIntoPerimeter_um); " is 236.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePerimeterWithMergeOverlaps,The length of the statement  "				pathHadOverlaps = perimeterToCheckForMerge.MergePerimeterOverlaps(config.LineWidth_um' out pathsWithOverlapsRemoved' pathIsClosed) " is 130.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePerimeterWithMergeOverlaps,The length of the statement  "				QueuePolygonsConsideringSupport(layerIndex' gcodeLayer' pathsWithOverlapsRemoved' config' SupportWriteType.UnsupportedAreas); " is 125.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePerimeterWithMergeOverlaps,The length of the statement  "				QueuePolygonsConsideringSupport(layerIndex' gcodeLayer' new Polygons() { perimeterToCheckForMerge }' config' SupportWriteType.UnsupportedAreas); " is 144.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "				CalculateInfillData(slicingData' extruderIndex' layerIndex' island' bottomFillPolygons' fillPolygons' firstTopFillPolygons' topFillPolygons' bridgePolygons); " is 157.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "					// The island could be a rectangle with 4 screw holes. So' with 3 perimeters that could be the outside 3 + the holes 4 * 3' 15 polygons. " is 136.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "									QueueClosestInset(insetsForThisIsland[0]' limitDistance' overrideConfig == null ? inset0Config : overrideConfig' layerIndex' layerGcodePlanner); " is 144.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "									limitDistance = QueueClosestInset(insetsForThisIsland[insetIndex]' limitDistance' overrideConfig == null ? insetXConfig : overrideConfig' layerIndex' layerGcodePlanner); " is 169.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "							// There are no insets but we should still try to go to the start position of the first perimeter if we are expanding thin walls " is 128.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "							if (island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 10' out thinLines' true)) " is 152.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "					QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bridgePolygons' bridgeConfig' SupportWriteType.UnsupportedAreas); " is 128.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "				// Put all of these segments into a list that can be queued together and still preserve their individual config settings. " is 121.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The length of the statement  "				QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' bottomFillConfig' SupportWriteType.UnsupportedAreas); " is 136.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,MoveToIsland,The length of the statement  "					|| island.PathFinder.OutlineData.Polygons.PointIsInside(layerGcodePlanner.LastPosition' island.PathFinder.OutlineData.EdgeQuadTrees' island.PathFinder.OutlineData.PointQuadTrees) == true) " is 187.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,MoveToIsland,The length of the statement  "				IntPoint closestNextIslandPoint = island.IslandOutline[closestPointOnNextIsland.polyIndex][closestPointOnNextIsland.pointIndex]; " is 128.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,FindBestPoint,The length of the statement  "				IntPoint closestToPoly = boundaryPolygons[polygonIndex].FindGreatestTurnPosition(config.ExtrusionWidth_um' layerIndex' position); " is 129.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueClosestInset,The length of the statement  "					QueuePolygonsConsideringSupport(layerIndex' gcodeLayer' new Polygons() { insetsToConsider[polygonPrintedIndex] }' pathConfig' SupportWriteType.UnsupportedAreas); " is 161.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "						outputDataForIsland |= QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' island.InsetToolPaths[insetIndex]' airGappedBottomInsetConfig' SupportWriteType.SupportedAreasCheckOnly); " is 191.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "						outputDataForIsland |= QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' island.InsetToolPaths[0]' airGappedBottomInsetConfig' SupportWriteType.SupportedAreasCheckOnly); " is 182.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "					outputDataForIsland |= QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' airGappedBottomConfig' SupportWriteType.SupportedAreasCheckOnly); " is 171.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "							QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' island.InsetToolPaths[insetIndex]' airGappedBottomInsetConfig' SupportWriteType.SupportedAreas); " is 159.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "							QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' island.InsetToolPaths[0]' airGappedBottomInsetConfig' SupportWriteType.SupportedAreas); " is 150.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueAirGappedExtruderLayerToGCode,The length of the statement  "						QueuePolygonsConsideringSupport(layerIndex' layerGcodePlanner' bottomFillPolygons' airGappedBottomConfig' SupportWriteType.SupportedAreas); " is 139.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePolygonsConsideringSupport,The length of the statement  "						GetSegmentsConsideringSupport(polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' false' fillConfig.ClosedLoop); " is 150.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePolygonsConsideringSupport,The length of the statement  "					GetSegmentsConsideringSupport(polygonsToWrite' supportOutlines' polysToWriteAtNormalHeight' polysToWriteAtAirGapHeight' true' fillConfig.ClosedLoop); " is 149.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "						Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' infillAngle); " is 136.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "							// TODO: Make this code handle very complex pathing between different sizes or layouts of support under the island to fill. " is 123.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "							Infill.GenerateLinePaths(bottomFillIsland' bridgePolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' bridgeAngle); " is 135.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "							Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' alternatingInfillAngle); " is 147.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "					Infill.GenerateLinePaths(bottomFillIsland' bottomFillLines' config.FirstLayerExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' alternatingInfillAngle); " is 157.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "					Infill.GenerateLinePaths(outline' topFillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle); " is 142.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "					Infill.GenerateLinePaths(outline' firstTopFillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' alternatingInfillAngle); " is 143.
Long Statement,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The length of the statement  "					Infill.GenerateLinePaths(outline' fillPolygons' config.ExtrusionWidth_um' config.InfillExtendIntoPerimeter_um' alternatingInfillAngle); " is 135.
Long Statement,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SwitchExtruder,The length of the statement  "				gcodeFileStream.Write("G1 E{0:0.####} F{1} ; retract\n"' extrusionAmount_mm - config.RetractionOnExtruderSwitch' config.RetractionSpeed * 60); " is 142.
Long Statement,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The length of the statement  "						// According to https://github.com/Ultimaker/CuraEngine/issues/14 having more then 21m of extrusion causes inaccuracies. So reset it every 10m' just to be sure. " is 160.
Long Statement,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The length of the statement  "			estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed); " is 181.
Long Statement,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The length of the statement  "				&& (forceRetraction || extrusionAmountAtPreviousRetraction_mm + config.MinimumExtrusionBeforeRetraction < extrusionAmount_mm)) " is 126.
Long Statement,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The length of the statement  "				gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(config.RetractionSpeed * 60' extrusionAmount_mm - config.RetractionOnTravel)); " is 136.
Long Statement,MatterHackers.MatterSlice,IntPointSorter,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\GrahamScan.cs,ComparePoints,The length of the statement  "					double distanceA = Math.Sqrt((((long)lowestPoint.X - a.X) * ((long)lowestPoint.X - a.X)) + (((long)lowestPoint.Y - a.Y) * ((long)lowestPoint.Y - a.Y))); " is 152.
Long Statement,MatterHackers.MatterSlice,IntPointSorter,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\GrahamScan.cs,ComparePoints,The length of the statement  "					double distanceB = Math.Sqrt((((long)lowestPoint.X - b.X) * ((long)lowestPoint.X - b.X)) + (((long)lowestPoint.Y - b.Y) * ((long)lowestPoint.Y - b.Y))); " is 152.
Long Statement,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexagonInfill,The length of the statement  "			Infill.GenerateHexLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' layerIndex); " is 131.
Long Statement,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The length of the statement  "					PointMatrix matrix = new PointMatrix(-(rotationDegrees + extraRotationAngle)); // we are rotating the part so we rotate by the negative so the lines go the way we expect " is 169.
Long Statement,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateLinePaths,The length of the statement  "					PointMatrix matrix = new PointMatrix(-(rotation + 90)); // we are rotating the part so we rotate by the negative so the lines go the way we expect " is 146.
Long Statement,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The length of the statement  "			Infill.GenerateLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' offset); " is 124.
Long Statement,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The length of the statement  "			Infill.GenerateLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' offset); " is 124.
Long Statement,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The length of the statement  "			Infill.GenerateLinePaths(partOutline' fillPolygons' linespacing_um' config.InfillExtendIntoPerimeter_um' fillAngle' offset); " is 124.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "					wipeShield = wipeShield.CreateUnion(this.Extruders[extruderIndex].Layers[layerIndex].AllOutlines.Offset(config.WipeShieldDistanceFromShapes_um)); " is 145.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "			long offsetAngle_um = (long)(Math.Tan(60.0 * Math.PI / 180) * config.LayerThickness_um); // Allow for a 60deg angle in the wipeShield. " is 134.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "				this.WipeShield[layerIndex] = this.WipeShield[layerIndex].CreateUnion(this.WipeShield[layerIndex - 1].Offset(-offsetAngle_um)); " is 127.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The length of the statement  "				this.WipeShield[layerIndex - 1] = this.WipeShield[layerIndex - 1].CreateUnion(this.WipeShield[layerIndex].Offset(-offsetAngle_um)); " is 131.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,DumpLayerparts,The length of the statement  "					streamToWriteTo.Write("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" style=\"width: 500px; height:500px\">\n"); " is 123.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,DumpLayerparts,The length of the statement  "								streamToWriteTo.Write("{0}'{1} ".FormatWith((float)(part.IslandOutline[j][k].X - modelMin.X) / modelSize.X * 500' (float)(part.IslandOutline[j][k].Y - modelMin.Y) / modelSize.Y * 500)); " is 185.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GenerateRaftOutlines,The length of the statement  "					storage.raftOutline = storage.raftOutline.CreateUnion(layer.Islands[partIndex].IslandOutline.Offset(extraDistanceAroundPart_um)); " is 129.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GenerateRaftOutlines,The length of the statement  "				storage.raftOutline = storage.raftOutline.CreateUnion(storage.Support.GetBedOutlines().Offset(extraDistanceAroundPart_um)); " is 123.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "				raftSurfaceConfig.SetData((config.RaftSurfacePrintSpeed > 0) ? config.RaftSurfacePrintSpeed : config.RaftPrintSpeed' config.RaftSurfaceExtrusionWidth_um); " is 154.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					var layerPlanner = new LayerGCodePlanner(config' gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 156.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					var layerPlanner = new LayerGCodePlanner(config' gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 156.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45); " is 134.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					var layerPlanner = new LayerGCodePlanner(config' gcode' config.TravelSpeed' config.MinimumTravelToCauseRetraction_um' config.PerimeterStartEndOverlapRatio); " is 156.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "					gcode.CurrentZ_um = config.RaftBaseThickness_um + config.RaftInterfaceThicknes_um + config.RaftSurfaceThickness_um * raftSurfaceIndex; " is 134.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "						// make sure the top layer of the raft is 90 degrees offset to the first layer of the part so that it has minimum contact points. " is 129.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90); " is 161.
Long Statement,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The length of the statement  "						Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 90 * raftSurfaceIndex); " is 151.
Long Statement,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,The length of the statement  "					while (i < paths.Count && paths[i].Polygon.Count == 1 && (nextPosition - paths[i].Polygon[0]).ShorterThen(path.Config.LineWidth_um * 2)) " is 136.
Long Statement,MatterHackers.MatterSlice,LayerIsland,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerIsland.cs,GenerateInsets,The length of the statement  "			part.PathFinder = new PathFinder(part.IslandOutline' extrusionWidth_um * 3 / 2' useInsideCache: avoidCrossingPerimeters); " is 121.
Long Statement,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,print_usage,The length of the statement  "			LogOutput.LogError("usage: MatterSlice [-h] [-d] [-v] [-t] [-m 3x3matrix]\n       [-b boolean math] [-c <config file>]\n       [-s <settingkey>=<value>] -o <output.gcode> <model.stl>\n\n"); " is 189.
Long Statement,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,print_usage,The length of the statement  "			LogOutput.LogError("    -d Save the currently loaded settings to settings.ini (useful to see\n       all settings).\n"); " is 120.
Long Statement,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,print_usage,The length of the statement  "			LogOutput.LogError("    -c A config file to apply to the current settings.\n       Can be applied multiple times.\n       Formated like the default.ini (partial settings are fine).\n"); " is 185.
Long Statement,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,print_usage,The length of the statement  "			LogOutput.LogError("    -s Specify a setting on the command line.\n       Uses the same names and values as default.ini.\n"); " is 125.
Long Statement,MatterHackers.MatterSlice,MultiExtruders,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,RemoveExtruderIntersections,The length of the statement  "			// Go trough all the extruders' and remove the previous extruders outlines from our own outline' so we never have overlapped areas. " is 131.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueAirGappedBottomLayer,The length of the statement  "						Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueAirGappedBottomLayer,The length of the statement  "						Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueAirGappedBottomLayer,The length of the statement  "					pathFinder = new PathFinder(infillOutline' -config.ExtrusionWidth_um / 2' useInsideCache: config.AvoidCrossingPerimeters); " is 122.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueInterfaceSupportLayer,The length of the statement  "						if (gcodeLayer.QueuePolygonsByOptimizer(interfaceIsland.Offset(-config.ExtrusionWidth_um / 2)' null' supportInterfaceConfig' 0)) " is 128.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueInterfaceSupportLayer,The length of the statement  "					Infill.GenerateLineInfill(config' interfaceIsland.Offset(infillOffset)' supportLines' config.InfillStartingAngle + 90' config.ExtrusionWidth_um); " is 145.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "					if (gcodeLayer.QueuePolygonsByOptimizer(supportIsland.Offset(-config.ExtrusionWidth_um / 2)' null' supportNormalConfig' 0)) " is 123.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "					Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.ExtrusionWidth_um); " is 129.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "							Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "							Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um); " is 133.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The length of the statement  "					pathFinder = new PathFinder(infillOutline' -config.ExtrusionWidth_um / 2' useInsideCache: config.AvoidCrossingPerimeters); " is 122.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,ClipToXyDistance,The length of the statement  "				Polygons expandedlayerPolys = allPartOutlines[layerIndex].Offset(config.SupportXYDistance_um + config.ExtrusionWidth_um / 2); " is 125.
Long Statement,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,CreateInterfaceLayers,The length of the statement  "						for (int aboveIndex = layerIndex + 2; aboveIndex < Math.Min(layerIndex + numInterfaceLayers + 1' numLayers); aboveIndex++) " is 122.
Long Statement,MatterHackers.MatterSlice,PathOrderOptimizer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\PathOrderOptimizer.cs,Optimize,The length of the statement  "					// If there are only 2 points (a single line) or the path is marked as travel both ways' we are willing to start from the start or the end. " is 139.
Long Statement,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,GenerateInsets,The length of the statement  "				layer.Islands[islandIndex].GenerateInsets(extrusionWidth_um' outerExtrusionWidth_um' insetCount' avoidCrossingPerimeters); " is 122.
Long Statement,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.start.X = (long)(singlePointOnSide.X + (double)(otherSide1.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5); " is 177.
Long Statement,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.start.Y = (long)(singlePointOnSide.Y + (double)(otherSide1.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5); " is 177.
Long Statement,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.end.X = (long)(singlePointOnSide.X + (double)(otherSide2.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5); " is 175.
Long Statement,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The length of the statement  "			seg.end.Y = (long)(singlePointOnSide.Y + (double)(otherSide2.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5); " is 175.
Long Statement,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,MakePolygons,The length of the statement  "			// Link up all the missing ends' closing up the smallest gaps first. This is an inefficient implementation which can run in O(n*n*n) time. " is 138.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "    <marker id='MidMarker' viewBox='0 0 5 5' refX='2.5' refY='2.5' markerUnits='strokeWidth' markerWidth='5' markerHeight='5' stroke='lightblue' stroke-width='.5' fill='none' orient='auto'> " is 185.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "      <marker id='arrowS' markerWidth='15' markerHeight='15' refX='1.4' refY='3' orient='auto' markerUnits='strokeWidth' viewBox='0 0 20 20'> " is 135.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "      <marker id='arrowE' markerWidth='15' markerHeight='15' refX='5.6' refY='3' orient='auto' markerUnits='strokeWidth' viewBox='0 0 20 20'> " is 135.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "						stream.Write("{0}'{1} "' (double)(polygon[intPointIndex].X - bounds.minX) / scale' (double)(polygon[intPointIndex].Y - bounds.maxY) / scale); " is 141.
Long Statement,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The length of the statement  "						stream.Write("{0}'{1} "' (double)(openPolygon[n].X - bounds.minX) / scale' (double)(openPolygon[n].Y - bounds.maxY) / scale); " is 125.
Complex Conditional,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The conditional expression  "!extrudedAirGappedSupport  							&& ((interfaceExturderIndex <= 0 && extruderIndex == 0) || interfaceExturderIndex == extruderIndex)"  is complex.
Complex Conditional,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,ChangeExtruderIfRequired,The conditional expression  "(extruderUsedForSupport  				|| extruderUsedForWipeTower  				|| extruderUsedForParts)  				&& layerGcodePlanner.ToolChangeRequired(extruderIndex)"  is complex.
Complex Conditional,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The conditional expression  "insetCount == 0  							&& config.ExpandThinWalls  							&& island.IslandOutline.Count > 0  							&& island.IslandOutline[0].Count > 0"  is complex.
Complex Conditional,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,MoveToIsland,The conditional expression  "(layer.Islands.Count == 1 && config.ExtruderCount == 1)  					|| layer.PathFinder.OutlineData?.Polygons.Count < 3  					|| island.PathFinder.OutlineData.Polygons.PointIsInside(layerGcodePlanner.LastPosition' island.PathFinder.OutlineData.EdgeQuadTrees' island.PathFinder.OutlineData.PointQuadTrees) == true"  is complex.
Complex Conditional,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The conditional expression  "config.RetractionOnTravel > 0  				&& !isRetracted  				&& (forceRetraction || extrusionAmountAtPreviousRetraction_mm + config.MinimumExtrusionBeforeRetraction < extrusionAmount_mm)"  is complex.
Complex Conditional,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,HaveWipeTower,The conditional expression  "WipeTower == null  				|| WipeTower.Count == 0  				|| WipeTower[0].Count == 0  				|| layerIndex > LastLayerWithChange(config) + 1"  is complex.
Complex Conditional,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,LastLayerWithChange,The conditional expression  "(extruderToCheck < Extruders.Count && Extruders[extruderToCheck].Layers[checkLayer].AllOutlines.Count > 0)  						|| (config.SupportExtruder == extruderToCheck && Support != null && Support.HasNormalSupport(checkLayer))  						|| (config.SupportInterfaceExtruder == extruderToCheck && Support != null && Support.HasInterfaceSupport(checkLayer))"  is complex.
Complex Conditional,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,GetLatestPathWithConfig,The conditional expression  "!forceUniquePath  				&& paths.Count > 0  				&& paths[paths.Count - 1].Config == config  				&& !paths[paths.Count - 1].Done"  is complex.
Empty Catch Block,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetSetting,The method has an empty catch block.
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetSetting,The following statement contains a magic number: switch (property.PropertyType.Name)  					{  						case "Int32":  							property.SetValue(this' (int)double.Parse(valueToSetTo));  							break;    						case "Double":  							property.SetValue(this' double.Parse(valueToSetTo));  							break;    						case "Boolean":  							property.SetValue(this' bool.Parse(valueToSetTo));  							break;    						case "FMatrix3x3":  							{  								property.SetValue(this' new DMatrix3x3(valueToSetTo));  							}    							break;    						case "DoublePoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new DoublePoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}    							break;    						case "IntPoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new IntPoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}    							break;    						case "IntPoint[]":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								List<IntPoint> points = new List<IntPoint>();    								string intPointString;  								int nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' 0);  								do  								{  									string[] xyValues = intPointString.Split(''');  									points.Add(new IntPoint(double.Parse(xyValues[0]) * 1000' double.Parse(xyValues[1]) * 1000));    									nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' nextIndex);  								}  								while (nextIndex != -1);  								property.SetValue(this' points.ToArray());  							}    							break;    						case "String":  							if (keyToSet == "additionalArgsToProcess")  							{  								property.SetValue(this' valueToSetTo);  							}  							else  							{  								property.SetValue(this' valueToSetTo.Replace("\\n"' "\n"));  							}    							break;    						case "REPAIR_OVERLAPS":  						case "REPAIR_OUTLINES":  						case "SUPPORT_TYPE":  						case "INFILL_TYPE":  						case "OUTPUT_TYPE":  							try  							{  								valueToSetTo = valueToSetTo.Replace('|'' ''');  								property.SetValue(this' Enum.Parse(property.PropertyType' valueToSetTo));  							}  							catch (Exception)  							{  							}    							break;    						default:  							throw new NotImplementedException("unknown type");  					}
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetSetting,The following statement contains a magic number: switch (property.PropertyType.Name)  					{  						case "Int32":  							property.SetValue(this' (int)double.Parse(valueToSetTo));  							break;    						case "Double":  							property.SetValue(this' double.Parse(valueToSetTo));  							break;    						case "Boolean":  							property.SetValue(this' bool.Parse(valueToSetTo));  							break;    						case "FMatrix3x3":  							{  								property.SetValue(this' new DMatrix3x3(valueToSetTo));  							}    							break;    						case "DoublePoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new DoublePoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}    							break;    						case "IntPoint":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								string[] xyValues = bracketContents.Split(''');  								property.SetValue(this' new IntPoint(double.Parse(xyValues[0])' double.Parse(xyValues[1])));  							}    							break;    						case "IntPoint[]":  							{  								string bracketContents = GetInsides(valueToSetTo' '['' ']');  								List<IntPoint> points = new List<IntPoint>();    								string intPointString;  								int nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' 0);  								do  								{  									string[] xyValues = intPointString.Split(''');  									points.Add(new IntPoint(double.Parse(xyValues[0]) * 1000' double.Parse(xyValues[1]) * 1000));    									nextIndex = GetInsides(out intPointString' bracketContents' '['' ']'' nextIndex);  								}  								while (nextIndex != -1);  								property.SetValue(this' points.ToArray());  							}    							break;    						case "String":  							if (keyToSet == "additionalArgsToProcess")  							{  								property.SetValue(this' valueToSetTo);  							}  							else  							{  								property.SetValue(this' valueToSetTo.Replace("\\n"' "\n"));  							}    							break;    						case "REPAIR_OVERLAPS":  						case "REPAIR_OUTLINES":  						case "SUPPORT_TYPE":  						case "INFILL_TYPE":  						case "OUTPUT_TYPE":  							try  							{  								valueToSetTo = valueToSetTo.Replace('|'' ''');  								property.SetValue(this' Enum.Parse(property.PropertyType' valueToSetTo));  							}  							catch (Exception)  							{  							}    							break;    						default:  							throw new NotImplementedException("unknown type");  					}
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FilamentDiameter = 2.89;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerThickness = .3;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: LayerThickness = .1;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerExtrusionWidth = .8;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: ExtrusionWidth = .4;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: NumberOfPerimeters = 2;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: NumberOfBottomLayers = 6;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: NumberOfTopLayers = 6;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: TopInfillSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: BottomInfillSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportMaterialSpeed = 40;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InterfaceLayerSpeed = 40;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillSpeed = 50;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: BridgeSpeed = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: AirGapSpeed = 15;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: BridgeFanSpeedPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: OutsidePerimeterSpeed = 50;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InsidePerimetersSpeed = 50;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: TravelSpeed = 200;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FirstLayerToAllowFan = 2;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SkirtDistanceFromObject = 6;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillPercent = 20;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillExtendIntoPerimeter = .06;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: InfillStartingAngle = 45;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RaftAirGap = .2;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportAirGap = .3;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RaftExtraDistanceAroundPart = 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportLineSpacing = ExtrusionWidth * 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportXYDistanceFromObject = .7;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: SupportInterfaceLayers = 3;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RetractionOnTravel = 4.5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RetractionSpeed = 45;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: RetractionOnExtruderSwitch = 14.5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MinimumTravelToCauseRetraction = 10;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: WipeTowerSize = 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MinimumLayerTimeSeconds = 5;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MinimumPrintingSpeed = 10;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FanSpeedMinPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MinFanSpeedLayerTime = 300;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: FanSpeedMaxPercent = 100;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,SetToDefault,The following statement contains a magic number: MaxFanSpeedLayerTime = 300;
Magic Number,MatterHackers.MatterSlice,ConfigSettings,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ConfigSettings.cs,GetEnumHelpText,The following statement contains a magic number: names.Length == 2 && names[0] == enumName
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,GenerateTopAndBottoms,The following statement contains a magic number: var clippingOffset = infillExtendIntoPerimeter_um * 2;
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,InitializeLayerPathing,The following statement contains a magic number: long avoidInset = config.ExtrusionWidth_um * 3 / 2;
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,InitializeLayerPathing,The following statement contains a magic number: long avoidInset = config.ExtrusionWidth_um * 3 / 2;
Magic Number,MatterHackers.MatterSlice,ExtruderLayers,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\ExtruderLayers.cs,InitializeLayerPathing,The following statement contains a magic number: boundary.Inflate(config.ExtrusionWidth_um * 10);
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,ProcessSliceData,The following statement contains a magic number: supportIslands.Add(new LayerIsland(island)  						{  							PathFinder = new PathFinder(island' config.ExtrusionWidth_um * 3 / 2' useInsideCache: config.AvoidCrossingPerimeters)'  						});
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,ProcessSliceData,The following statement contains a magic number: supportIslands.Add(new LayerIsland(island)  						{  							PathFinder = new PathFinder(island' config.ExtrusionWidth_um * 3 / 2' useInsideCache: config.AvoidCrossingPerimeters)'  						});
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,WriteGCode,The following statement contains a magic number: gcodeExport.WriteComment("firstLayerThickness = {0}".FormatWith(config.RaftBaseThickness_um / 1000.0));
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,The following statement contains a magic number: SliceLayer previousLayer = slicingData.Extruders[extruderIndex].Layers[startIndex - 2];
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CreateRequiredInsets,The following statement contains a magic number: config.ContinuousSpiralOuterPerimeter && (int)layerIndex < config.NumberOfBottomLayers && layerIndex % 2 == 1
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePerimeterWithMergeOverlaps,The following statement contains a magic number: perimeterToCheckForMerge.Count > 2
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 10' out thinLines' true)
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: island.IslandOutline.Offset(-extrusionWidth_um * (1 + perimeter)).FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 10' out thinLines' true)
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: polygon.Count == 2  									&& (polygon[0] - polygon[1]).Length() < config.ExtrusionWidth_um / 4
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true)
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueExtruderLayerToGCode,The following statement contains a magic number: island.IslandOutline.FindThinLines(extrusionWidth_um + 2' extrusionWidth_um / 3' out thinLines' true)
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,MoveToIsland,The following statement contains a magic number: (layer.Islands.Count == 1 && config.ExtruderCount == 1)  					|| layer.PathFinder.OutlineData?.Polygons.Count < 3  					|| island.PathFinder.OutlineData.Polygons.PointIsInside(layerGcodePlanner.LastPosition' island.PathFinder.OutlineData.EdgeQuadTrees' island.PathFinder.OutlineData.PointQuadTrees) == true
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,MoveToIsland,The following statement contains a magic number: islandCurrentlyInside?.PathFinder?.OutlineData.Polygons.Count > 0  					&& islandCurrentlyInside?.PathFinder?.OutlineData.Polygons?[0]?.Count > 3
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueueClosestInset,The following statement contains a magic number: maxDist_um = config.ExtrusionWidth_um * 4;
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,QueuePolygonsConsideringSupport,The following statement contains a magic number: Polygons supportOutlines = slicingData.Support.GetRequiredSupportAreas(layerIndex).Offset(fillConfig.LineWidth_um / 2);
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,GetSegmentsConsideringSupport,The following statement contains a magic number: Polygons maxSupportOutlines = supportOutlines.Offset(fillConfig.LineWidth_um * 2 + config.SupportXYDistance_um);
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: alternatingInfillAngle += 90;
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: (layerIndex % 2) == 0
Magic Number,MatterHackers.MatterSlice,FffProcessor,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\fffProcessor.cs,CalculateInfillData,The following statement contains a magic number: double infillAngle = config.SupportInterfaceLayers > 0 ? config.InfillStartingAngle : config.InfillStartingAngle + 90;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,LayerChanged,The following statement contains a magic number: WriteComment($"LAYER_HEIGHT:{layerHeight_um / 1000.0:0.####}");
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)filamentDiameter / 1000.0 / 2.0) * ((double)filamentDiameter / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)filamentDiameter / 1000.0 / 2.0) * ((double)filamentDiameter / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)filamentDiameter / 1000.0 / 2.0) * ((double)filamentDiameter / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: double filamentArea = Math.PI * ((double)filamentDiameter / 1000.0 / 2.0) * ((double)filamentDiameter / 1000.0 / 2.0);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SetExtrusion,The following statement contains a magic number: extrusionPerMm = (double)layerThickness / 1000.0 / filamentArea * extrusionMultiplier;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SwitchExtruder,The following statement contains a magic number: gcodeFileStream.Write("G1 E{0:0.####} F{1} ; retract\n"' extrusionAmount_mm - config.RetractionOnExtruderSwitch' config.RetractionSpeed * 60);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SwitchExtruder,The following statement contains a magic number: var beforeX = this.currentPosition_um.X / 1000.0;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,SwitchExtruder,The following statement contains a magic number: var beforeY = this.currentPosition_um.Y / 1000.0;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteFanCommand,The following statement contains a magic number: gcodeFileStream.Write("M106 S{0}\n".FormatWith(speed * 255 / 100));
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteFanCommand,The following statement contains a magic number: gcodeFileStream.Write("M106 S{0}\n".FormatWith(speed * 255 / 100));
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: double zWritePosition = (double)currentPosition_um.Z / 1000;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: config.ResetLongExtrusion  						&& extrusionAmount_mm > 10000.0
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: lineToWrite.Append("G1 F{0} E{1:0.#####}\n".FormatWith(config.RetractionSpeed * 60' extrusionAmount_mm));
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(  						currentPosition_um.X / 1000.0'  						currentPosition_um.Y / 1000.0'  						currentPosition_um.Z / 1000.0'  						extrusionAmount_mm)'  						currentSpeed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: extrusionAmount_mm += extrusionPerMm * lineWidth_um / 1000.0 * diff.LengthMm();
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: lineToWrite.Append(" F{0}".FormatWith((int)(speed * 60)));
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: double xWritePosition = (double)movePosition_um.X / 1000.0;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: double yWritePosition = (double)movePosition_um.Y / 1000.0;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: double zWritePosition = movePosition_um.Z / 1000.0;
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteMove,The following statement contains a magic number: estimateCalculator.plan(new TimeEstimateCalculator.Position(currentPosition_um.X / 1000.0' currentPosition_um.Y / 1000.0' currentPosition_um.Z / 1000.0' extrusionAmount_mm)' speed);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: gcodeFileStream.Write("G1 F{0} E{1:0.#####}\n".FormatWith(config.RetractionSpeed * 60' extrusionAmount_mm - config.RetractionOnTravel));
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: var timePosition = new TimeEstimateCalculator.Position((double)currentPosition_um.X / 1000.0'  					currentPosition_um.Y / 1000.0'  					(double)currentPosition_um.Z / 1000.0' extrusionAmount_mm - config.RetractionOnTravel);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: var timePosition = new TimeEstimateCalculator.Position((double)currentPosition_um.X / 1000.0'  					currentPosition_um.Y / 1000.0'  					(double)currentPosition_um.Z / 1000.0' extrusionAmount_mm - config.RetractionOnTravel);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: var timePosition = new TimeEstimateCalculator.Position((double)currentPosition_um.X / 1000.0'  					currentPosition_um.Y / 1000.0'  					(double)currentPosition_um.Z / 1000.0' extrusionAmount_mm - config.RetractionOnTravel);
Magic Number,MatterHackers.MatterSlice,GCodeExport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\gcodeExport.cs,WriteRetraction,The following statement contains a magic number: double zWritePosition = currentPosition_um.Z / 1000.0 + config.RetractionZHop;
Magic Number,MatterHackers.MatterSlice,GrahamScan,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\GrahamScan.cs,GetConvexHull,The following statement contains a magic number: sorted.Count < 3
Magic Number,MatterHackers.MatterSlice,GrahamScan,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\GrahamScan.cs,AreAllCollinear,The following statement contains a magic number: points.Count < 2
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateConcentricInfill,The following statement contains a magic number: int linespacing_um = (int)(extrusionWidthOverride_um / (config.InfillPercent / 100));
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateGridInfill,The following statement contains a magic number: linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 2);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateGridInfill,The following statement contains a magic number: linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 2);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateGridInfill,The following statement contains a magic number: fillAngle += 90;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateGridInfill,The following statement contains a magic number: fillAngle -= 360;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateGridInfill,The following statement contains a magic number: fillAngle > 360
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexagonInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3 * .66);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexagonInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3 * .66);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexagonInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3 * .66);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: boundary.min.Y = ((boundary.min.Y / perIncrementOffset) - 2) * perIncrementOffset;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: IntPoint left = center + new IntPoint(-lineSpacing / 2' -perIncrementOffset / 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: IntPoint right = center + new IntPoint(lineSpacing / 2' -perIncrementOffset / 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: IntPoint top = center + new IntPoint(0' perIncrementOffset * 2 / 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclippedPattern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclippedPattern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclippedPattern.Add(new Polygon() { left' center });  									break;  							}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following statement contains a magic number: switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclippedPattern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclippedPattern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclippedPattern.Add(new Polygon() { left' center });  									break;  							}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateLineInfill,The following statement contains a magic number: linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100));
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateLinePaths,The following statement contains a magic number: PointMatrix matrix = new PointMatrix(-(rotation + 90));
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateLinePaths,The following statement contains a magic number: PointMatrix inversematrix = new PointMatrix(rotation + 90);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: int linespacing_um = (int)(config.ExtrusionWidth_um / (config.InfillPercent / 100) * 3);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: long offset = linespacing_um / 2;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle += 60;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle -= 360;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle > 360
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle += 60;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle -= 360;
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateTriangleInfill,The following statement contains a magic number: fillAngle > 360
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: int perIncrementOffset = (int)(lineSpacing * Math.Sqrt(3) / 2 + .5);
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = (yPosition / perIncrementOffset % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}    						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}    					break;    				case 1: // left to top  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;    				case 2: // top to right  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = (yPosition / perIncrementOffset % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}    						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}    					break;    				case 1: // left to top  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;    				case 2: // top to right  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = (yPosition / perIncrementOffset % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}    						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}    					break;    				case 1: // left to top  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;    				case 2: // top to right  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = (yPosition / perIncrementOffset % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}    						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}    					break;    				case 1: // left to top  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;    				case 2: // top to right  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = (yPosition / perIncrementOffset % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}    						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}    					break;    				case 1: // left to top  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;    				case 2: // top to right  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;  			}
Magic Number,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following statement contains a magic number: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = (yPosition / perIncrementOffset % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}    						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}    					break;    				case 1: // left to top  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;    				case 2: // top to right  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;  			}
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: this.WipeShield[layerIndex] = this.WipeShield[layerIndex].Offset(-1000).Offset(1000);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: this.WipeShield[layerIndex] = this.WipeShield[layerIndex].Offset(-1000).Offset(1000);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: long offsetAngle_um = (long)(Math.Tan(60.0 * Math.PI / 180) * config.LayerThickness_um);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeShield,The following statement contains a magic number: long offsetAngle_um = (long)(Math.Tan(60.0 * Math.PI / 180) * config.LayerThickness_um);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: WipeCenter_um = new IntPoint(  				wipeTowerBounds.minX + (wipeTowerBounds.maxX - wipeTowerBounds.minX) / 2'  				wipeTowerBounds.minY + (wipeTowerBounds.maxY - wipeTowerBounds.minY) / 2);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,CreateWipeTower,The following statement contains a magic number: WipeCenter_um = new IntPoint(  				wipeTowerBounds.minX + (wipeTowerBounds.maxX - wipeTowerBounds.minX) / 2'  				wipeTowerBounds.minY + (wipeTowerBounds.maxY - wipeTowerBounds.minY) / 2);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,DumpLayerparts,The following statement contains a magic number: streamToWriteTo.Write("{0}'{1} ".FormatWith((float)(part.IslandOutline[j][k].X - modelMin.X) / modelSize.X * 500' (float)(part.IslandOutline[j][k].Y - modelMin.Y) / modelSize.Y * 500));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,DumpLayerparts,The following statement contains a magic number: streamToWriteTo.Write("{0}'{1} ".FormatWith((float)(part.IslandOutline[j][k].X - modelMin.X) / modelSize.X * 500' (float)(part.IslandOutline[j][k].Y - modelMin.Y) / modelSize.Y * 500));
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GenerateRaftOutlines,The following statement contains a magic number: layer.Islands.Count == 0 && storage.Extruders[extruderIndex].Layers.Count > 2
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,GenerateSkirt,The following statement contains a magic number: long offsetDistance = distance_um + extrusionWidth_um * (skirtLoop - 1) - extrusionWidth_um / 2;
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,MaxPrimingLoops,The following statement contains a magic number: return Support != null ? config.ExtruderCount * 2 - 2 : config.ExtruderCount - 1;
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,MaxPrimingLoops,The following statement contains a magic number: return Support != null ? config.ExtruderCount * 2 - 2 : config.ExtruderCount - 1;
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: gcode.LayerChanged(-3' config.RaftBaseThickness_um);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: gcode.LayerChanged(-2' config.RaftInterfaceThicknes_um);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftInterfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' 45);
Magic Number,MatterHackers.MatterSlice,LayerDataStorage,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerDataStorage.cs,WriteRaftGCodeIfRequired,The following statement contains a magic number: Infill.GenerateLinePaths(storage.raftOutline' raftLines' config.RaftSurfaceLineSpacing_um' config.InfillExtendIntoPerimeter_um' config.InfillStartingAngle + 90);
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,CorrectLayerTimeConsideringMinimumLayerTime,The following statement contains a magic number: var currentRatio = Math.Max(gcodeExport.LayerSpeedRatio - .1' goalRatio);
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,CorrectLayerTimeConsideringMinimumLayerTime,The following statement contains a magic number: currentRatio -= .01;
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,QueuePolygon,The following statement contains a magic number: polygon.Count > 2
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: i < paths.Count && paths[i].Polygon.Count == 1 && (nextPosition - paths[i].Polygon[0]).ShorterThen(path.Config.LineWidth_um * 2)
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: IntPoint newPoint = (paths[x].Polygon[0] + paths[x + 1].Polygon[0]) / 2;
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: i > pathIndex + 2
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: path.Polygon.Count == 1  					&& path.Config != travelConfig  					&& (gcodeExport.GetPositionXY() - path.Polygon[0]).ShorterThen(path.Config.LineWidth_um * 2)
Magic Number,MatterHackers.MatterSlice,LayerGCodePlanner,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerGCodePlanner.cs,WriteQueuedGCode,The following statement contains a magic number: nextExtrusion.Z = (int)(z + layerThickness_um * length / totalLength + .5);
Magic Number,MatterHackers.MatterSlice,LayerIsland,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerIsland.cs,GenerateInsets,The following statement contains a magic number: part.PathFinder = new PathFinder(part.IslandOutline' extrusionWidth_um * 3 / 2' useInsideCache: avoidCrossingPerimeters);
Magic Number,MatterHackers.MatterSlice,LayerIsland,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\LayerIsland.cs,GenerateInsets,The following statement contains a magic number: part.PathFinder = new PathFinder(part.IslandOutline' extrusionWidth_um * 3 / 2' useInsideCache: avoidCrossingPerimeters);
Magic Number,MatterHackers.MatterSlice,LogOutput,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\logoutput.cs,logProgress,The following statement contains a magic number: verbose_level < 2
Magic Number,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,ProcessArgs,The following statement contains a magic number: switch (str[stringIndex])  						{  							case 'h':  								print_usage();  								return 0;    							case 'v':  								LogOutput.verbose_level++;  								break;    							case 'o':  								argn++;  								if (!processor.SetTargetFile(args[argn]))  								{  									LogOutput.LogError("Failed to open {0} for output.\n".FormatWith(args[argn]));  									return 1;  								}    								break;    							case 'c':  								{  									// Read a config file from the given path  									argn++;  									if (!config.ReadSettings(args[argn]))  									{  										LogOutput.LogError("Failed to read config '{0}'\n".FormatWith(args[argn]));  									}    									// process any matrix and mesh requested by config file  									List<string> commands = new List<string>();  									foreach (string command in SplitCommandLine.DoSplit(config.AdditionalArgsToProcess))  									{  										commands.Add(command);  									}    									string[] subArgs = commands.ToArray();  									ProcessArgs(subArgs' config' processor);  								}    								break;    							case 'd':  								config.DumpSettings("settings.ini");  								break;    							case 's':  								{  									argn++;  									int equalsPos = args[argn].IndexOf('=');  									if (equalsPos != -1)  									{  										string key = args[argn].Substring(0' equalsPos);  										string value = args[argn].Substring(equalsPos + 1);  										if (key.Length > 1)  										{  											if (!config.SetSetting(key' value))  											{  												LogOutput.LogError("Setting not found: {0} {1}\n".FormatWith(key' value));  											}  										}  									}  								}    								break;    							case 'm':  								argn++;  								string[] matrixValues = args[argn].Split(''');  								var loadedMatrix = Matrix4X4.Identity;  								for (int i = 0; i < 4; i++)  								{  									for (int j = 0; j < 4; j++)  									{  										string valueString = matrixValues[i * 4 + j];  										double value;  										if (double.TryParse(valueString' out value))  										{  											loadedMatrix[i' j] = value;  										}  									}  								}    								config.ModelMatrix = loadedMatrix;  								break;    							default:  								throw new NotImplementedException("Unknown option: {0}\n".FormatWith(str));  								// LogOutput.logError("Unknown option: {0}\n".FormatWith(str));  								// break;  						}
Magic Number,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,ProcessArgs,The following statement contains a magic number: switch (str[stringIndex])  						{  							case 'h':  								print_usage();  								return 0;    							case 'v':  								LogOutput.verbose_level++;  								break;    							case 'o':  								argn++;  								if (!processor.SetTargetFile(args[argn]))  								{  									LogOutput.LogError("Failed to open {0} for output.\n".FormatWith(args[argn]));  									return 1;  								}    								break;    							case 'c':  								{  									// Read a config file from the given path  									argn++;  									if (!config.ReadSettings(args[argn]))  									{  										LogOutput.LogError("Failed to read config '{0}'\n".FormatWith(args[argn]));  									}    									// process any matrix and mesh requested by config file  									List<string> commands = new List<string>();  									foreach (string command in SplitCommandLine.DoSplit(config.AdditionalArgsToProcess))  									{  										commands.Add(command);  									}    									string[] subArgs = commands.ToArray();  									ProcessArgs(subArgs' config' processor);  								}    								break;    							case 'd':  								config.DumpSettings("settings.ini");  								break;    							case 's':  								{  									argn++;  									int equalsPos = args[argn].IndexOf('=');  									if (equalsPos != -1)  									{  										string key = args[argn].Substring(0' equalsPos);  										string value = args[argn].Substring(equalsPos + 1);  										if (key.Length > 1)  										{  											if (!config.SetSetting(key' value))  											{  												LogOutput.LogError("Setting not found: {0} {1}\n".FormatWith(key' value));  											}  										}  									}  								}    								break;    							case 'm':  								argn++;  								string[] matrixValues = args[argn].Split(''');  								var loadedMatrix = Matrix4X4.Identity;  								for (int i = 0; i < 4; i++)  								{  									for (int j = 0; j < 4; j++)  									{  										string valueString = matrixValues[i * 4 + j];  										double value;  										if (double.TryParse(valueString' out value))  										{  											loadedMatrix[i' j] = value;  										}  									}  								}    								config.ModelMatrix = loadedMatrix;  								break;    							default:  								throw new NotImplementedException("Unknown option: {0}\n".FormatWith(str));  								// LogOutput.logError("Unknown option: {0}\n".FormatWith(str));  								// break;  						}
Magic Number,MatterHackers.MatterSlice,MatterSlice,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MatterSlice.cs,ProcessArgs,The following statement contains a magic number: switch (str[stringIndex])  						{  							case 'h':  								print_usage();  								return 0;    							case 'v':  								LogOutput.verbose_level++;  								break;    							case 'o':  								argn++;  								if (!processor.SetTargetFile(args[argn]))  								{  									LogOutput.LogError("Failed to open {0} for output.\n".FormatWith(args[argn]));  									return 1;  								}    								break;    							case 'c':  								{  									// Read a config file from the given path  									argn++;  									if (!config.ReadSettings(args[argn]))  									{  										LogOutput.LogError("Failed to read config '{0}'\n".FormatWith(args[argn]));  									}    									// process any matrix and mesh requested by config file  									List<string> commands = new List<string>();  									foreach (string command in SplitCommandLine.DoSplit(config.AdditionalArgsToProcess))  									{  										commands.Add(command);  									}    									string[] subArgs = commands.ToArray();  									ProcessArgs(subArgs' config' processor);  								}    								break;    							case 'd':  								config.DumpSettings("settings.ini");  								break;    							case 's':  								{  									argn++;  									int equalsPos = args[argn].IndexOf('=');  									if (equalsPos != -1)  									{  										string key = args[argn].Substring(0' equalsPos);  										string value = args[argn].Substring(equalsPos + 1);  										if (key.Length > 1)  										{  											if (!config.SetSetting(key' value))  											{  												LogOutput.LogError("Setting not found: {0} {1}\n".FormatWith(key' value));  											}  										}  									}  								}    								break;    							case 'm':  								argn++;  								string[] matrixValues = args[argn].Split(''');  								var loadedMatrix = Matrix4X4.Identity;  								for (int i = 0; i < 4; i++)  								{  									for (int j = 0; j < 4; j++)  									{  										string valueString = matrixValues[i * 4 + j];  										double value;  										if (double.TryParse(valueString' out value))  										{  											loadedMatrix[i' j] = value;  										}  									}  								}    								config.ModelMatrix = loadedMatrix;  								break;    							default:  								throw new NotImplementedException("Unknown option: {0}\n".FormatWith(str));  								// LogOutput.logError("Unknown option: {0}\n".FormatWith(str));  								// break;  						}
Magic Number,MatterHackers.MatterSlice,MultiExtruders,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: extruders.Count < 2 || overlapUm <= 0
Magic Number,MatterHackers.MatterSlice,MultiExtruders,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: fullLayer = fullLayer.CreateUnion(layer1.AllOutlines.Offset(20));
Magic Number,MatterHackers.MatterSlice,MultiExtruders,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: fullLayer = fullLayer.Offset(-20);
Magic Number,MatterHackers.MatterSlice,MultiExtruders,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,OverlapMultipleExtrudersSlightly,The following statement contains a magic number: layer1.AllOutlines = fullLayer.CreateIntersection(layer1.AllOutlines.Offset(overlapUm / 2));
Magic Number,MatterHackers.MatterSlice,BooleanProcessing,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,Process,The following statement contains a magic number: int removeExtruderIndex = meshesToProcess[meshesToProcess.Count - 2];
Magic Number,MatterHackers.MatterSlice,BooleanProcessing,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,Process,The following statement contains a magic number: meshesToProcess.RemoveAt(meshesToProcess.Count - 2);
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,NewSupport,The following statement contains a magic number: cleanDistance_um = config.ExtrusionWidth_um / 10;
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,NewSupport,The following statement contains a magic number: _InsetPartOutlines = CreateInsetPartOutlines(allPartOutlines' config.ExtrusionWidth_um / 2);
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueAirGappedBottomLayer,The following statement contains a magic number: gcodeLayer.QueuePolygonsByOptimizer(supportIsland.Offset(-config.ExtrusionWidth_um / 2)' null' supportNormalConfig' 0);
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueAirGappedBottomLayer,The following statement contains a magic number: infillOffset = config.ExtrusionWidth_um * -2 + config.InfillExtendIntoPerimeter_um;
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueAirGappedBottomLayer,The following statement contains a magic number: pathFinder = new PathFinder(infillOutline' -config.ExtrusionWidth_um / 2' useInsideCache: config.AvoidCrossingPerimeters);
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueInterfaceSupportLayer,The following statement contains a magic number: gcodeLayer.QueuePolygonsByOptimizer(interfaceIsland.Offset(-config.ExtrusionWidth_um / 2)' null' supportInterfaceConfig' 0)
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueInterfaceSupportLayer,The following statement contains a magic number: infillOffset = config.ExtrusionWidth_um * -2 + config.InfillExtendIntoPerimeter_um;
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueInterfaceSupportLayer,The following statement contains a magic number: Infill.GenerateLineInfill(config' interfaceIsland.Offset(infillOffset)' supportLines' config.InfillStartingAngle + 90' config.ExtrusionWidth_um);
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The following statement contains a magic number: gcodeLayer.QueuePolygonsByOptimizer(supportIsland.Offset(-config.ExtrusionWidth_um / 2)' null' supportNormalConfig' 0)
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The following statement contains a magic number: infillOffset = config.ExtrusionWidth_um * -2 + config.InfillExtendIntoPerimeter_um;
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The following statement contains a magic number: pathFinder = new PathFinder(infillOutline' -config.ExtrusionWidth_um / 2' useInsideCache: config.AvoidCrossingPerimeters);
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,ClipToXyDistance,The following statement contains a magic number: Polygons expandedlayerPolys = allPartOutlines[layerIndex].Offset(config.SupportXYDistance_um + config.ExtrusionWidth_um / 2);
Magic Number,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,CreateInsetPartOutlines,The following statement contains a magic number: insetOutline.RemoveSmallAreas(insetAmount_um * 2);
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: vertices.Capacity = simpleMesh.faceTriangles.Count * 3;
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: (faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: (faceIndex % 1000 == 0) && t.Elapsed.TotalSeconds > 2
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: long hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 20) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 40));
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: long hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 20) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 40));
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: long hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 20) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 40));
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: long hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 20) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 40));
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: long hash = (int)(((p.X + MELD_DIST / 2) / MELD_DIST) ^ (((p.Y + MELD_DIST / 2) / MELD_DIST) << 20) ^ (((p.Z + MELD_DIST / 2) / MELD_DIST) << 40));
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: vertexIndex < 3
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[1]].usedByFacesList[_idx1] && vertices[optimizedFace.vertexIndex[0]].usedByFacesList[_idx0] == vertices[optimizedFace.vertexIndex[2]].usedByFacesList[_idx2]
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: _idx2 < vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Count
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: vertices[optimizedFace.vertexIndex[2]].usedByFacesList.Add(facesTriangle.Count);
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2]
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[1] && optimizedFace.vertexIndex[0] != optimizedFace.vertexIndex[2] && optimizedFace.vertexIndex[1] != optimizedFace.vertexIndex[2]
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: optimizedFace.touchingFaces[1] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[1]' optimizedFace.vertexIndex[2]' faceIndex);
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: optimizedFace.touchingFaces[2] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[2]' optimizedFace.vertexIndex[0]' faceIndex);
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: optimizedFace.touchingFaces[2] = getOtherFaceIndexContainingVertices(optimizedFace.vertexIndex[2]' optimizedFace.vertexIndex[0]' faceIndex);
Magic Number,MatterHackers.MatterSlice,OptimizedMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,OptimizedMesh,The following statement contains a magic number: optimizedFace.touchingFaces[2] == -1
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: Byte[] header = new Byte[80];
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.X / 1000.0));
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Y / 1000.0));
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: f.Write((float)(vol.vertices[vol.facesTriangle[i].vertexIndex[vert]].position.Z / 1000.0));
Magic Number,MatterHackers.MatterSlice,OptimizedMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\OptimizedMesh.cs,saveDebugSTL,The following statement contains a magic number: vert < 3
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: canTravelForwardOrBackward || currentPolygon.Count < 3
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: polygons[polygonIndex].Count == 2 || canTravelForwardOrBackward
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: polygons[bestPolygonIndex].Count == 2 || canTravelForwardOrBackward
Magic Number,MatterHackers.MatterSlice,PathOrderOptimizer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\PathOrderOptimizer.cs,Optimize,The following statement contains a magic number: polygons[bestPolygonIndex].Count == 2 || canTravelForwardOrBackward
Magic Number,MatterHackers.MatterSlice,SimpleFace,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,SimpleFace,The following statement contains a magic number: vertices[2] = v2;
Magic Number,MatterHackers.MatterSlice,SimpleMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,maxXYZ_um,The following statement contains a magic number: SET_MAX(ref ret.X' faceTriangles[i].vertices[2].X);
Magic Number,MatterHackers.MatterSlice,SimpleMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,maxXYZ_um,The following statement contains a magic number: SET_MAX(ref ret.Y' faceTriangles[i].vertices[2].Y);
Magic Number,MatterHackers.MatterSlice,SimpleMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,maxXYZ_um,The following statement contains a magic number: SET_MAX(ref ret.Z' faceTriangles[i].vertices[2].Z);
Magic Number,MatterHackers.MatterSlice,SimpleMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,minXYZ_um,The following statement contains a magic number: SET_MIN(ref ret.X' faceTriangles[faceIndex].vertices[2].X);
Magic Number,MatterHackers.MatterSlice,SimpleMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,minXYZ_um,The following statement contains a magic number: SET_MIN(ref ret.Y' faceTriangles[faceIndex].vertices[2].Y);
Magic Number,MatterHackers.MatterSlice,SimpleMesh,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,minXYZ_um,The following statement contains a magic number: SET_MIN(ref ret.Z' faceTriangles[faceIndex].vertices[2].Z);
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: lineCount++ > 100 && vol.faceTriangles.Count == 0
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: vertex.Y = Convert.ToDouble(parts[2]);
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: vertex.Z = Convert.ToDouble(parts[3]);
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: switch (n)  						{  							case 1:  								var new0 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v0 = new IntPoint(new0.X' new0.Y' new0.Z);  								break;    							case 2:  								var new1 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v1 = new IntPoint(new1.X' new1.Y' new1.Z);  								break;    							case 3:  								var new2 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v2 = new IntPoint(new2.X' new2.Y' new2.Z);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: switch (n)  						{  							case 1:  								var new0 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v0 = new IntPoint(new0.X' new0.Y' new0.Z);  								break;    							case 2:  								var new1 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v1 = new IntPoint(new1.X' new1.Y' new1.Z);  								break;    							case 3:  								var new2 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v2 = new IntPoint(new2.X' new2.Y' new2.Z);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: switch (n)  						{  							case 1:  								var new0 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v0 = new IntPoint(new0.X' new0.Y' new0.Z);  								break;    							case 2:  								var new1 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v1 = new IntPoint(new1.X' new1.Y' new1.Z);  								break;    							case 3:  								var new2 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v2 = new IntPoint(new2.X' new2.Y' new2.Z);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: switch (n)  						{  							case 1:  								var new0 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v0 = new IntPoint(new0.X' new0.Y' new0.Z);  								break;    							case 2:  								var new1 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v1 = new IntPoint(new1.X' new1.Y' new1.Z);  								break;    							case 3:  								var new2 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v2 = new IntPoint(new2.X' new2.Y' new2.Z);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: switch (n)  						{  							case 1:  								var new0 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v0 = new IntPoint(new0.X' new0.Y' new0.Z);  								break;    							case 2:  								var new1 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v1 = new IntPoint(new1.X' new1.Y' new1.Z);  								break;    							case 3:  								var new2 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v2 = new IntPoint(new2.X' new2.Y' new2.Z);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following statement contains a magic number: vol.faceTriangles.Count > 3
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: int currentPosition = 80;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: long bytesForNormals = numTriangles * 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: long bytesForNormals = numTriangles * 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: long bytesForVertices = numTriangles * 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: long bytesForVertices = numTriangles * 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: long bytesForAttributs = numTriangles * 2;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: currentPosition += 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: IntPoint[] vector = new IntPoint[3];
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: currentPosition += 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: currentPosition += 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: var vertex = new MatterHackers.VectorMath.Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: var vertex = new MatterHackers.VectorMath.Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: var vertex = new MatterHackers.VectorMath.Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: var vertex = new MatterHackers.VectorMath.Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: vector[j] = new IntPoint(new0.X * 1000' new0.Y * 1000' new0.Z * 1000);
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: vector[j] = new IntPoint(new0.X * 1000' new0.Y * 1000' new0.Z * 1000);
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: vector[j] = new IntPoint(new0.X * 1000' new0.Y * 1000' new0.Z * 1000);
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: currentPosition += 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: currentPosition += 3 * 4;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: j < 3
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: currentPosition += 2;
Magic Number,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_binary,The following statement contains a magic number: vol.addFaceTriangle(vector[2]' vector[1]' vector[0]);
Magic Number,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,GetSingleIslandAngle,The following statement contains a magic number: bestAngle = Math.Atan2(sideDelta.Y' sideDelta.X) * 180 / Math.PI;
Magic Number,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,BridgeAngle,The following statement contains a magic number: islandsToRestOn.Count > 5 || islandsToRestOn.Count < 1
Magic Number,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,BridgeAngle,The following statement contains a magic number: bridgeAngle = Math.Atan2(center2.Y - center1.Y' center2.X - center1.X) / Math.PI * 180;
Magic Number,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,Range0To360,The following statement contains a magic number: angle += 360;
Magic Number,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,Range0To360,The following statement contains a magic number: angle -= 360;
Magic Number,MatterHackers.MatterSlice,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SliceLayer.cs,Range0To360,The following statement contains a magic number: angle > 360
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,ExtruderData,The following statement contains a magic number: int countOfNormalThicknessLayers = Math.Max(0' (int)((heightWithoutFirstLayer / (double)layerThickness_um) + .5));
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,ExtruderData,The following statement contains a magic number: z = initialLayerThickness_um / 2;
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,ExtruderData,The following statement contains a magic number: IntPoint p2 = ov.vertices[ov.facesTriangle[faceIndex].vertexIndex[2]].position;
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,DumpPolygonsToGcode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,DumpSegmentsToGcode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.start.X = (long)(singlePointOnSide.X + (double)(otherSide1.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.start.Y = (long)(singlePointOnSide.Y + (double)(otherSide1.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide1.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.end.X = (long)(singlePointOnSide.X + (double)(otherSide2.X - singlePointOnSide.X) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,ExtruderData,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\Slicer.cs,GetCrossingAtZ,The following statement contains a magic number: seg.end.Y = (long)(singlePointOnSide.Y + (double)(otherSide2.Y - singlePointOnSide.Y) * (double)(z - singlePointOnSide.Z) / (double)(otherSide2.Z - singlePointOnSide.Z) + .5);
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,CreateSegmentListFromString,The following statement contains a magic number: outPoints.Add(new IntPoint(int.Parse(elementX.Substring(xIndex + 2))' int.Parse(elementY.Substring(yIndex + 2))));
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,CreateSegmentListFromString,The following statement contains a magic number: outPoints.Add(new IntPoint(int.Parse(elementX.Substring(xIndex + 2))' int.Parse(elementY.Substring(yIndex + 2))));
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: int minimumPerimeter = 1000;
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,MakePolygons,The following statement contains a magic number: double minimumDistanceToCreateNewPosition = 10;
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,FindPolygonPointClosestTo,The following statement contains a magic number: (q - input).ShorterThen(100)
Magic Number,MatterHackers.MatterSlice,MeshProcessingLayer,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\Slicer\SlicerLayer.cs,GetPositionKey,The following statement contains a magic number: return intPoint.X + (intPoint.Y << 31);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 0] = 0.0;
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 1] = 0.0;
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[0' 2] = 0.0;
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[1' 2] = 0.0;
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 2] = 1.0;
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 2] = 1.0;
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 0] = double.Parse(values[2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 0] = double.Parse(values[2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[0' 1] = double.Parse(values[3]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[1' 1] = double.Parse(values[4]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 1] = double.Parse(values[5]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 1] = double.Parse(values[5]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[0' 2] = double.Parse(values[6]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[0' 2] = double.Parse(values[6]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[1' 2] = double.Parse(values[7]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[1' 2] = double.Parse(values[7]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 2] = double.Parse(values[8]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 2] = double.Parse(values[8]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,DMatrix3x3,The following statement contains a magic number: m[2' 2] = double.Parse(values[8]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,apply,The following statement contains a magic number: return new IntPoint(  				p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0]'  				p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1]'  				p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,apply,The following statement contains a magic number: return new IntPoint(  				p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0]'  				p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1]'  				p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,apply,The following statement contains a magic number: return new IntPoint(  				p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0]'  				p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1]'  				p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,apply,The following statement contains a magic number: return new IntPoint(  				p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0]'  				p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1]'  				p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,apply,The following statement contains a magic number: return new IntPoint(  				p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0]'  				p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1]'  				p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,apply,The following statement contains a magic number: return new IntPoint(  				p.x * m[0' 0] + p.y * m[1' 0] + p.z * m[2' 0]'  				p.x * m[0' 1] + p.y * m[1' 1] + p.z * m[2' 1]'  				p.x * m[0' 2] + p.y * m[1' 2] + p.z * m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,DMatrix3x3,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\DMatrix3x3.cs,ToString,The following statement contains a magic number: return "[[{0}'{1}'{2}]'[{3}'{4}'{5}]'[{6}'{7}'{8}]]".FormatWith(  				m[0' 0]' m[1' 0]' m[2' 0]'  				m[0' 1]' m[1' 1]' m[2' 1]'  				m[0' 2]' m[1' 2]' m[2' 2]);
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[2] = 0;
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[3] = 1;
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: rotation = rotation / 180 * Math.PI;
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[2] = -matrix[1];
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[3] = matrix[0];
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[2] = -matrix[1];
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,PointMatrix,The following statement contains a magic number: matrix[3] = matrix[0];
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,apply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[1]' p.X * matrix[2] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,apply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[1]' p.X * matrix[2] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,unapply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[2]' p.X * matrix[1] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,PointMatrix,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,unapply,The following statement contains a magic number: return new IntPoint(p.X * matrix[0] + p.Y * matrix[2]' p.X * matrix[1] + p.Y * matrix[3]);
Magic Number,MatterHackers.MatterSlice,IntPointHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,LengthMm,The following statement contains a magic number: double fx = (double)thisPoint.X / 1000.0;
Magic Number,MatterHackers.MatterSlice,IntPointHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,LengthMm,The following statement contains a magic number: double fy = (double)thisPoint.Y / 1000.0;
Magic Number,MatterHackers.MatterSlice,IntPointHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,LengthMm,The following statement contains a magic number: double fz = (double)thisPoint.Z / 1000.0;
Magic Number,MatterHackers.MatterSlice,IntPointHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,OutputInMm,The following statement contains a magic number: return string.Format("[{0}'{1}'{2}]"' thisPoint.X / 1000.0' thisPoint.Y / 1000.0' thisPoint.Z / 1000.0);
Magic Number,MatterHackers.MatterSlice,IntPointHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,OutputInMm,The following statement contains a magic number: return string.Format("[{0}'{1}'{2}]"' thisPoint.X / 1000.0' thisPoint.Y / 1000.0' thisPoint.Z / 1000.0);
Magic Number,MatterHackers.MatterSlice,IntPointHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\IntpointHelper.cs,OutputInMm,The following statement contains a magic number: return string.Format("[{0}'{1}'{2}]"' thisPoint.X / 1000.0' thisPoint.Y / 1000.0' thisPoint.Z / 1000.0);
Magic Number,MatterHackers.MatterSlice,PolygonHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonHelper.cs,getBoundaryPointWithOffset,The following statement contains a magic number: IntPoint off0 = (p1 - p0).Normal(1000).CrossZ();
Magic Number,MatterHackers.MatterSlice,PolygonHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonHelper.cs,getBoundaryPointWithOffset,The following statement contains a magic number: IntPoint off1 = (p2 - p1).Normal(1000).CrossZ();
Magic Number,MatterHackers.MatterSlice,PolygonHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonHelper.cs,OptimizePolygon,The following statement contains a magic number: (previousPoint - currentPoint).IsShorterThen(10)
Magic Number,MatterHackers.MatterSlice,PolygonHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonHelper.cs,SaveToGCode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,ConvertToLines,The following statement contains a magic number: polygon.Count > 2
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.minX -= 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.minY -= 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.maxY += 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,GetCorrectedWinding,The following statement contains a magic number: bounds.maxX += 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,OptimizePolygons,The following statement contains a magic number: polygons[n].Count < 3
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double areaOfExtrusion = extrusionWidth / 1000.0 * (extrusionWidth / 1000.0);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double areaOfExtrusion = extrusionWidth / 1000.0 * (extrusionWidth / 1000.0);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double minAreaSize = areaOfExtrusion / 2;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double area = Math.Abs(polygons[outlineIndex].Area()) / 1000.0 / 1000.0;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,RemoveSmallAreas,The following statement contains a magic number: double area = Math.Abs(polygons[outlineIndex].Area()) / 1000.0 / 1000.0;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToGCode,The following statement contains a magic number: double scale = 1000;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: double scaleDenominator = 150;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: scaledWidth += 10 - scaledWidth % 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: scaledWidth += 10 - scaledWidth % 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: scaledHeight += 10 - scaledHeight % 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: scaledHeight += 10 - scaledHeight % 10;
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: stream.WriteLine("    <text x='{0}' y='-1' style='fill: #bbb; font-size: 0.13em;'>{1}</text>"' i * 10 - 1' i * 10);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: stream.WriteLine("    <text x='{0}' y='-1' style='fill: #bbb; font-size: 0.13em;'>{1}</text>"' i * 10 - 1' i * 10);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: i <= scaledWidth / 10
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: stream.WriteLine("    <text x='-4.5' y='{0}' style='fill: #bbb; font-size: 0.13em;'>{1}</text>"' i * 10' i * 10);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: stream.WriteLine("    <text x='-4.5' y='{0}' style='fill: #bbb; font-size: 0.13em;'>{1}</text>"' i * 10' i * 10);
Magic Number,MatterHackers.MatterSlice,PolygonsHelper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\PolygonsHelper.cs,SaveToSvg,The following statement contains a magic number: i <= scaledHeight / 10
Magic Number,MatterHackers.MatterSlice,SplitCommandLine,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\SplitCommandLine.cs,TrimMatchingQuotes,The following statement contains a magic number: return input.Substring(1' input.Length - 2);
Magic Number,MatterHackers.MatterSlice,SplitCommandLine,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\utils\SplitCommandLine.cs,TrimMatchingQuotes,The following statement contains a magic number: (input.Length >= 2)  				&& (input[0] == quote)  				&& (input[input.Length - 1] == quote)
Duplicate Code,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 49)' (55' 75))
Missing Default,MatterHackers.MatterSlice,GrahamScan,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\GrahamScan.cs,GetConvexHull,The following switch statement is missing a default case: switch (turn)  				{  					case Turn.CounterClockwise:  						stack.Push(middle);  						stack.Push(head);  						break;    					case Turn.Clockwise:  						i--;  						break;    					case Turn.Collinear:  						stack.Push(head);  						break;  				}
Missing Default,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,GenerateHexLinePaths,The following switch statement is missing a default case: switch (layerIndex % 3)  							{  								case 0: // left to right  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclippedPattern.Add(new Polygon() { top' center });  									break;    								case 1: // left to top  									attachedLine.Add(left); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(top);  									unclippedPattern.Add(new Polygon() { center' right });  									break;    								case 2: // top to right  									attachedLine.Add(top); attachedLine.Add(center);  									attachedLine.Add(center); attachedLine.Add(right);  									unclippedPattern.Add(new Polygon() { left' center });  									break;  							}
Missing Default,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,IncrementPositionIterator,The following switch statement is missing a default case: switch (layerIndex % 3)  			{  				case 0: // left to right  					positionAdd = new IntPoint(lineSpacing' 0);  					break;    				case 1: // left to top  					positionAdd = new IntPoint(lineSpacing / 2' perIncrementOffset);  					break;    				case 2: // top to right  					positionAdd = new IntPoint(lineSpacing / 2' -perIncrementOffset);  					break;  			}
Missing Default,MatterHackers.MatterSlice,Infill,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\infill.cs,StartPositionIterator,The following switch statement is missing a default case: switch (layerIndex % 3)  			{  				case 0: // left to right  					for (int yIndex = 0; yIndex < yLineCount; yIndex++)  					{  						long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  						bool removeXOffset = (yPosition / perIncrementOffset % 2) == 0;  						long xOffsetForY = lineSpacing / 2;  						if (removeXOffset) // if we are at every other y  						{  							xOffsetForY = 0;  						}    						long firstX = boundary.min.X + xOffsetForY;    						yield return new IntPoint(firstX' yPosition);  					}    					break;    				case 1: // left to top  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = yLineCount; yIndex >= 0; yIndex--)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;    				case 2: // top to right  					{  						IntPoint nextPoint = default(IntPoint);  						for (int yIndex = 0; yIndex < yLineCount; yIndex++)  						{  							long yPosition = boundary.min.Y + yIndex * perIncrementOffset;  							bool createLineSegment = (yPosition / perIncrementOffset % 2) == 0;  							if (createLineSegment)  							{  								nextPoint = new IntPoint(boundary.min.X' yPosition);  								yield return nextPoint;  							}  						}    						IntPoint positionAdd = new IntPoint(lineSpacing' 0);  						nextPoint += positionAdd;  						while (nextPoint.X > boundary.min.X  							&& nextPoint.X < boundary.max.X)  						{  							yield return nextPoint;  							nextPoint += positionAdd;  						}  					}    					break;  			}
Missing Default,MatterHackers.MatterSlice,BooleanProcessing,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\MultiExtruders.cs,DoLayerBooleans,The following switch statement is missing a default case: switch (booleanType)  			{  				case BooleanType.Union:  					if (layersB.AllOutlines.Count == 0)  					{  						// do nothing we will keep the content of A  					}  					else if (layersA.AllOutlines.Count == 0)  					{  						// there is nothing in A so set it to the content of B  						layersA.AllOutlines = layersB.AllOutlines;  					}  					else  					{  						layersA.AllOutlines = layersA.AllOutlines.CreateUnion(layersB.AllOutlines);  					}    					break;    				case BooleanType.Difference:  					layersA.AllOutlines = layersA.AllOutlines.CreateDifference(layersB.AllOutlines);  					break;    				case BooleanType.Intersection:  					layersA.AllOutlines = layersA.AllOutlines.CreateIntersection(layersB.AllOutlines);  					break;  			}
Missing Default,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueAirGappedBottomLayer,The following switch statement is missing a default case: switch (config.SupportType)  				{  					case ConfigConstants.SUPPORT_TYPE.GRID:  						Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;    					case ConfigConstants.SUPPORT_TYPE.LINES:  						Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  						break;  				}
Missing Default,MatterHackers.MatterSlice,NewSupport,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\NewSupport.cs,QueueNormalSupportLayer,The following switch statement is missing a default case: switch (config.SupportType)  					{  						case ConfigConstants.SUPPORT_TYPE.GRID:  							Infill.GenerateGridInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;    						case ConfigConstants.SUPPORT_TYPE.LINES:  							Infill.GenerateLineInfill(config' infillOutline' islandInfillLines' config.SupportInfillStartingAngle' config.SupportLineSpacing_um);  							break;  					}
Missing Default,MatterHackers.MatterSlice,SimpleMeshCollection,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MatterSliceLib\SimpleMesh.cs,loadModelSTL_ascii,The following switch statement is missing a default case: switch (n)  						{  							case 1:  								var new0 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v0 = new IntPoint(new0.X' new0.Y' new0.Z);  								break;    							case 2:  								var new1 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v1 = new IntPoint(new1.X' new1.Y' new1.Z);  								break;    							case 3:  								var new2 = VectorMath.Vector3Ex.Transform(vertex' matrix) * 1000;  								v2 = new IntPoint(new2.X' new2.Y' new2.Z);  								vol.addFaceTriangle(v0' v1' v2);  								n = 0;  								break;  						}
