Implementation smell,Namespace,Class,File,Method,Description
Long Method,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessBound,The method has 115 lines of code.
Long Method,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The method has 150 lines of code.
Long Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The method has 190 lines of code.
Long Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The method has 113 lines of code.
Long Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinPoints,The method has 154 lines of code.
Long Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The method has 110 lines of code.
Long Method,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The method has 162 lines of code.
Complex Method,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,FindNextLocMin,Cyclomatic complexity of the method is 8
Complex Method,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessBound,Cyclomatic complexity of the method is 35
Complex Method,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,Cyclomatic complexity of the method is 35
Complex Method,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,GetBounds,Cyclomatic complexity of the method is 9
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ExecuteInternal,Cyclomatic complexity of the method is 8
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,Cyclomatic complexity of the method is 18
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IsContributing,Cyclomatic complexity of the method is 24
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,SetWindingCount,Cyclomatic complexity of the method is 17
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,SwapPositionsInAEL,Cyclomatic complexity of the method is 14
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,SwapPositionsInSEL,Cyclomatic complexity of the method is 15
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,GetBottomPt,Cyclomatic complexity of the method is 10
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,GetLowermostRec,Cyclomatic complexity of the method is 10
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AppendPolygon,Cyclomatic complexity of the method is 10
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,Cyclomatic complexity of the method is 45
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,Cyclomatic complexity of the method is 22
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectPoint,Cyclomatic complexity of the method is 12
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,Cyclomatic complexity of the method is 14
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoMaxima,Cyclomatic complexity of the method is 10
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult2,Cyclomatic complexity of the method is 8
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinHorz,Cyclomatic complexity of the method is 17
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinPoints,Cyclomatic complexity of the method is 28
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,PointInPolygon,Cyclomatic complexity of the method is 13
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinCommonEdges,Cyclomatic complexity of the method is 21
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,Cyclomatic complexity of the method is 17
Complex Method,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Minkowski,Cyclomatic complexity of the method is 9
Complex Method,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,Cyclomatic complexity of the method is 11
Complex Method,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,Cyclomatic complexity of the method is 31
Complex Method,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,OffsetPoint,Cyclomatic complexity of the method is 9
Complex Method,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,Cyclomatic complexity of the method is 11
Complex Method,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CleanClosedPolygon,Cyclomatic complexity of the method is 9
Complex Method,MSClipperLib,CandidateGroup,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,ConditionalAdd,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.MatterSlice,SortedIntPoint,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\IntPointSorter.cs,FindClosetIndex,Cyclomatic complexity of the method is 9
Long Parameter List,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,SlopesEqual,The method has 5 parameters. Parameters: pt1' pt2' pt3' pt4' UseFullRange
Long Parameter List,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,FillTheZ,The method has 5 parameters. Parameters: bot1' top1' bot2' top2' pt
Long Parameter List,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,GetOverlap,The method has 6 parameters. Parameters: a1' a2' b1' b2' Left' Right
Long Parameter List,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinHorz,The method has 6 parameters. Parameters: op1' op1b' op2' op2b' Pt' DiscardLeft
Long Identifier,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The length of the parameter minSegmentLengthToConsiderSquared is 33.
Long Statement,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The length of the statement  "			// We can't just merge each point in order or we can collapse curves that have small enough inter point deltas but large total curve. " is 133.
Long Statement,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The length of the statement  "			// Imagine a very tessellated circle. As we walk the edge each triple can be collinear within our error and so we remove the middle point and move on to " is 152.
Long Statement,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The length of the statement  "			// the next point. The new middle point is very close to the new third point and so we collapse and remove the second point. We can remove and create " is 149.
Long Statement,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The length of the statement  "				IntPoint nextIntPoint = new IntPoint(int.Parse(elementX.Substring(elementX.IndexOf(':') + 1))' int.Parse(elementY.Substring(3))); " is 129.
Long Statement,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnIndex,The length of the statement  "			// because FindGreatestTurnPosition cleans the polygon we need to see what the cleaned position is closest to on the actual polygon " is 131.
Long Statement,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The length of the statement  "				bool distanceLongeEnough = lengthCurToNextSquared > minSegmentLengthToConsiderSquared && lengthPrevToCurSquared > minSegmentLengthToConsiderSquared; " is 148.
Complex Conditional,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,RangeTest,The conditional expression  "Pt.X > hiRange || Pt.Y > hiRange || -Pt.X > hiRange || -Pt.Y > hiRange"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,RangeTest,The conditional expression  "Pt.X > loRange || Pt.Y > loRange || -Pt.X > loRange || -Pt.Y > loRange"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The conditional expression  "(Closed && highI < 2) || (!Closed && highI < 1)"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The conditional expression  "Closed &&  				  SlopesEqual(E.Prev.Curr' E.Curr' E.Next.Curr' m_UseFullRange) &&  				  (!PreserveCollinear ||  				  !Pt2IsBetweenPt1AndPt3(E.Prev.Curr' E.Curr' E.Next.Curr))"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The conditional expression  "(!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next))"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "Op1 != null && IsHorizontal(rb) &&  				  m_GhostJoins.Count > 0 && rb.WindDelta != 0"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "lb.OutIdx >= 0 && lb.PrevInAEL != null &&  				  lb.PrevInAEL.Curr.X == lb.Bot.X &&  				  lb.PrevInAEL.OutIdx >= 0 &&  				  SlopesEqual(lb.PrevInAEL' lb' m_UseFullRange) &&  				  lb.WindDelta != 0 && lb.PrevInAEL.WindDelta != 0"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&  					  SlopesEqual(rb.PrevInAEL' rb' m_UseFullRange) &&  					  rb.WindDelta != 0 && rb.PrevInAEL.WindDelta != 0"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddLocalMinPoly,The conditional expression  "prevE != null && prevE.OutIdx >= 0 &&  				(TopX(prevE' pt.Y) == TopX(e' pt.Y)) &&  				SlopesEqual(e' prevE' m_UseFullRange) &&  				(e.WindDelta != 0) && (prevE.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e1.WindDelta == 0) && Math.Abs(e2.WindCnt) == 1 &&  					  (m_ClipType != ClipType.ctUnion || e2.WindCnt2 == 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e2.WindDelta == 0) && (Math.Abs(e1.WindCnt) == 1) &&  					  (m_ClipType != ClipType.ctUnion || e1.WindCnt2 == 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||  				  (e1.PolyTyp != e2.PolyTyp && m_ClipType != ClipType.ctXor)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "((e1.PolyTyp == PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||  								((e1.PolyTyp == PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0))"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "(dir == Direction.dLeftToRight && e.Curr.X <= horzRight) ||  					  (dir == Direction.dRightToLeft && e.Curr.X >= horzLeft)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "(dir == Direction.dLeftToRight && e.Curr.X >= horzRight) ||  					  (dir == Direction.dRightToLeft && e.Curr.X <= horzLeft)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "ePrev != null && ePrev.Curr.X == horzEdge.Bot.X &&  					  ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta != 0 &&  					  (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&  					  SlopesEqual(horzEdge' ePrev' m_UseFullRange))"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "eNext != null && eNext.Curr.X == horzEdge.Bot.X &&  					  eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta != 0 &&  					  eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&  					  SlopesEqual(horzEdge' eNext' m_UseFullRange)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,GetMaximaPair,The conditional expression  "result != null && (result.OutIdx == Skip ||  			  (result.NextInAEL == result.PrevInAEL && !IsHorizontal(result)))"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "(e.OutIdx >= 0) && (e.WindDelta != 0) && ePrev != null &&  						  (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&  						  (ePrev.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "ePrev != null && ePrev.Curr.X == e.Bot.X &&  					  ePrev.Curr.Y == e.Bot.Y && op != null &&  					  ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&  					  SlopesEqual(e' ePrev' m_UseFullRange) &&  					  (e.WindDelta != 0) && (ePrev.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "eNext != null && eNext.Curr.X == e.Bot.X &&  					  eNext.Curr.Y == e.Bot.Y && op != null &&  					  eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&  					  SlopesEqual(e' eNext' m_UseFullRange) &&  					  (e.WindDelta != 0) && (eNext.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult2,The conditional expression  "(outRec.IsOpen && cnt < 2) ||  				  (!outRec.IsOpen && cnt < 3)"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,FixupOutPolygon,The conditional expression  "(pp.Pt == pp.Next.Pt) || (pp.Pt == pp.Prev.Pt) ||  				  (SlopesEqual(pp.Prev.Pt' pp.Pt' pp.Next.Pt' m_UseFullRange) &&  				  (!PreserveCollinear || !Pt2IsBetweenPt1AndPt3(pp.Prev.Pt' pp.Pt' pp.Next.Pt)))"  is complex.
Complex Conditional,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinPoints,The conditional expression  "(op1b == op1) || (op2b == op2) || (op1b == op2b) ||  				  ((outRec1 == outRec2) && (Reverse1 == Reverse2))"  is complex.
Complex Conditional,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The conditional expression  "len == 0 || (delta <= 0 && (len < 3 ||  				  node.m_endtype != EndType.etClosedPolygon))"  is complex.
Complex Conditional,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The conditional expression  "positiveGroup.Count > 0  					// the negative group is a small turn and the positive group is a big turn  					&& ((Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 4  							&& Math.Abs(positiveGroup[0].turnAmount) > Math.PI / 4)  						// the negative turn amount is very small  						|| Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 8)"  is complex.
Magic Number,MSClipperLib,Int128,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: UInt64 int1Hi = (UInt64)lhs >> 32;
Magic Number,MSClipperLib,Int128,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: UInt64 int2Hi = (UInt64)rhs >> 32;
Magic Number,MSClipperLib,Int128,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: hi = (Int64)(a + (c >> 32));
Magic Number,MSClipperLib,Int128,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: lo = (c << 32) + b;
Magic Number,MSClipperLib,ClipperBase,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The following statement contains a magic number: (Closed && highI < 2) || (!Closed && highI < 1)
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult,The following statement contains a magic number: cnt < 2
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult2,The following statement contains a magic number: (outRec.IsOpen && cnt < 2) ||  				  (!outRec.IsOpen && cnt < 3)
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult2,The following statement contains a magic number: (outRec.IsOpen && cnt < 2) ||  				  (!outRec.IsOpen && cnt < 3)
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,PointInPolygon,The following statement contains a magic number: cnt < 3
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Area,The following statement contains a magic number: cnt < 3
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Area,The following statement contains a magic number: return -a * 0.5;
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Area,The following statement contains a magic number: return a * 0.5;
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The following statement contains a magic number: cnt < 3
Magic Number,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Minkowski,The following statement contains a magic number: Path quad = new Path(4);
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The following statement contains a magic number: endType == EndType.etClosedPolygon && j < 2
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: m_miterLim = 2 / (MiterLimit * MiterLimit);
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: MiterLimit > 2
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: m_destPolys.Capacity = m_polyNodes.ChildCount * 2;
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: len == 0 || (delta <= 0 && (len < 3 ||  				  node.m_endtype != EndType.etClosedPolygon))
Magic Number,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoSquare,The following statement contains a magic number: double dx = Math.Tan(Math.Atan2(m_sinA'  				m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y) / 4);
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The following statement contains a magic number: int increment = 2;
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The following statement contains a magic number: increment = 4;
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The following statement contains a magic number: IntPoint nextIntPoint = new IntPoint(int.Parse(elementX.Substring(elementX.IndexOf(':') + 1))' int.Parse(elementY.Substring(3)));
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,DegreesToRadians,The following statement contains a magic number: const double degToRad = System.Math.PI / 180.0f;
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: Polygon currentPolygon = Clipper.CleanPolygon(inputPolygon' considerAsSameY / 8);
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: CandidateGroup positiveGroup = new CandidateGroup(DegreesToRadians(35));
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: CandidateGroup negativeGroup = new CandidateGroup(DegreesToRadians(10));
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: long minSegmentLengthToConsiderSquared = 50 * 50;
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: long minSegmentLengthToConsiderSquared = 50 * 50;
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: positiveGroup.Count > 0  					// the negative group is a small turn and the positive group is a big turn  					&& ((Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 4  							&& Math.Abs(positiveGroup[0].turnAmount) > Math.PI / 4)  						// the negative turn amount is very small  						|| Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 8)
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: positiveGroup.Count > 0  					// the negative group is a small turn and the positive group is a big turn  					&& ((Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 4  							&& Math.Abs(positiveGroup[0].turnAmount) > Math.PI / 4)  						// the negative turn amount is very small  						|| Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 8)
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: positiveGroup.Count > 0  					// the negative group is a small turn and the positive group is a big turn  					&& ((Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 4  							&& Math.Abs(positiveGroup[0].turnAmount) > Math.PI / 4)  						// the negative turn amount is very small  						|| Math.Abs(negativeGroup[0].turnAmount) < Math.PI / 8)
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CleanClosedPolygon,The following statement contains a magic number: startIndex < result.Count - 2
Magic Number,MSClipperLib,CLPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,GetPositionAllongPath,The following statement contains a magic number: var distanceToGoal = (long)(totalLength * ratioAlongPath + .5);
Magic Number,MSClipperLib,CandidateGroup,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,GetBestIndex,The following statement contains a magic number: bool shallowTurn = Math.Abs(this[this.Count - 1].turnAmount) < .3;
Magic Number,MSClipperLib,CandidateGroup,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,GetBestIndex,The following statement contains a magic number: int seemShift = layerIndex % 3;
Magic Number,MSClipperLib,CandidateGroup,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,GetBestIndex,The following statement contains a magic number: seemShift = layerIndex % 5;
Magic Number,MSClipperLib,CandidateGroup,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,ConditionalAdd,The following statement contains a magic number: Math.Abs(this[i].turnAmount)  < Math.PI / 2
Magic Number,MSClipperLib,CandidateGroup,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,ConditionalAdd,The following statement contains a magic number: Math.Abs(point.turnAmount) > Math.PI/2
Magic Number,MatterHackers.MatterSlice,SortedIntPoint,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\IntPointSorter.cs,FindClosetIndex,The following statement contains a magic number: currentIndex < sorted.Count  					&& Math.Pow(Math.Abs(sorted[currentIndex].Position.X - position.X)' 2) <= bestDistanceSquared
Magic Number,MatterHackers.MatterSlice,SortedIntPoint,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\IntPointSorter.cs,FindClosetIndex,The following statement contains a magic number: prevIndex >= 0  					&& Math.Pow(Math.Abs(sorted[prevIndex].Position.X - position.X)' 2) <= bestDistanceSquared
Duplicate Code,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinPoints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 51)' (138' 161))
Missing Default,MSClipperLib,Clipper,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The following switch statement is missing a default case: switch (m_ClipType)  					{  						case ClipType.ctIntersection:  							if (e1Wc2 > 0 && e2Wc2 > 0)  								AddLocalMinPoly(e1' e2' pt);  							break;  						case ClipType.ctUnion:  							if (e1Wc2 <= 0 && e2Wc2 <= 0)  								AddLocalMinPoly(e1' e2' pt);  							break;  						case ClipType.ctDifference:  							if (((e1.PolyTyp == PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||  								((e1.PolyTyp == PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))  								AddLocalMinPoly(e1' e2' pt);  							break;  						case ClipType.ctXor:  							AddLocalMinPoly(e1' e2' pt);  							break;  					}
Missing Default,MSClipperLib,ClipperOffset,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,OffsetPoint,The following switch statement is missing a default case: switch (jointype)  				{  					case JoinType.jtMiter:  						{  							double r = 1 + (m_normals[j].X * m_normals[k].X +  							  m_normals[j].Y * m_normals[k].Y);  							if (r >= m_miterLim) DoMiter(j' k' r); else DoSquare(j' k);  							break;  						}  					case JoinType.jtSquare: DoSquare(j' k); break;  					case JoinType.jtRound: DoRound(j' k); break;  				}
