Implementation smell,Namespace,Class,File,Method,Description
Long Method,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessBound,The method has 115 lines of code.
Long Method,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The method has 150 lines of code.
Long Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The method has 190 lines of code.
Long Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The method has 113 lines of code.
Long Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinPoints,The method has 154 lines of code.
Long Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The method has 110 lines of code.
Long Method,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The method has 162 lines of code.
Long Method,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The method has 111 lines of code.
Complex Method,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,FindNextLocMin,Cyclomatic complexity of the method is 8
Complex Method,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessBound,Cyclomatic complexity of the method is 21
Complex Method,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,Cyclomatic complexity of the method is 30
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ExecuteInternal,Cyclomatic complexity of the method is 8
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,Cyclomatic complexity of the method is 15
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AppendPolygon,Cyclomatic complexity of the method is 8
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,Cyclomatic complexity of the method is 11
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,Cyclomatic complexity of the method is 18
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectPoint,Cyclomatic complexity of the method is 9
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,Cyclomatic complexity of the method is 9
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinHorz,Cyclomatic complexity of the method is 11
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,PointInPolygon,Cyclomatic complexity of the method is 8
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinCommonEdges,Cyclomatic complexity of the method is 13
Complex Method,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,Cyclomatic complexity of the method is 16
Complex Method,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,Cyclomatic complexity of the method is 10
Complex Method,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,Cyclomatic complexity of the method is 16
Complex Method,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,Cyclomatic complexity of the method is 13
Long Parameter List,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,SlopesEqual,The method has 5 parameters. Parameters: pt1' pt2' pt3' pt4' UseFullRange
Long Parameter List,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,FillTheZ,The method has 5 parameters. Parameters: bot1' top1' bot2' top2' pt
Long Parameter List,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,GetOverlap,The method has 6 parameters. Parameters: a1' a2' b1' b2' Left' Right
Long Parameter List,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinHorz,The method has 6 parameters. Parameters: op1' op1b' op2' op2b' Pt' DiscardLeft
Long Identifier,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The length of the parameter minSegmentLengthToConsiderSquared is 33.
Long Statement,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The length of the statement  "			// We can't just merge each point in order or we can collapse curves that have small enough inter point deltas but large total curve. " is 133.
Long Statement,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The length of the statement  "			// Imagine a very tessellated circle. As we walk the edge each triple can be collinear within our error and so we remove the middle point and move on to " is 152.
Long Statement,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The length of the statement  "			// the next point. The new middle point is very close to the new third point and so we collapse and remove the second point. We can remove and create " is 149.
Long Statement,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The length of the statement  "				IntPoint nextIntPoint = new IntPoint(int.Parse(elementX.Substring(elementX.IndexOf(':') + 1))' int.Parse(elementY.Substring(3))); " is 129.
Long Statement,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The length of the statement  "				bool distanceLongeEnough = lengthCurToNextSquared > minSegmentLengthToConsiderSquared && lengthPrevToCurSquared > minSegmentLengthToConsiderSquared; " is 148.
Complex Conditional,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,RangeTest,The conditional expression  "Pt.X > hiRange || Pt.Y > hiRange || -Pt.X > hiRange || -Pt.Y > hiRange"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,RangeTest,The conditional expression  "Pt.X > loRange || Pt.Y > loRange || -Pt.X > loRange || -Pt.Y > loRange"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The conditional expression  "(Closed && highI < 2) || (!Closed && highI < 1)"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The conditional expression  "Closed &&  				  SlopesEqual(E.Prev.Curr' E.Curr' E.Next.Curr' m_UseFullRange) &&  				  (!PreserveCollinear ||  				  !Pt2IsBetweenPt1AndPt3(E.Prev.Curr' E.Curr' E.Next.Curr))"  is complex.
Complex Conditional,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The conditional expression  "(!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next))"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "Op1 != null && IsHorizontal(rb) &&  				  m_GhostJoins.Count > 0 && rb.WindDelta != 0"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "lb.OutIdx >= 0 && lb.PrevInAEL != null &&  				  lb.PrevInAEL.Curr.X == lb.Bot.X &&  				  lb.PrevInAEL.OutIdx >= 0 &&  				  SlopesEqual(lb.PrevInAEL' lb' m_UseFullRange) &&  				  lb.WindDelta != 0 && lb.PrevInAEL.WindDelta != 0"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&  					  SlopesEqual(rb.PrevInAEL' rb' m_UseFullRange) &&  					  rb.WindDelta != 0 && rb.PrevInAEL.WindDelta != 0"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddLocalMinPoly,The conditional expression  "prevE != null && prevE.OutIdx >= 0 &&  				(TopX(prevE' pt.Y) == TopX(e' pt.Y)) &&  				SlopesEqual(e' prevE' m_UseFullRange) &&  				(e.WindDelta != 0) && (prevE.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e1.WindDelta == 0) && Math.Abs(e2.WindCnt) == 1 &&  					  (m_ClipType != ClipType.ctUnion || e2.WindCnt2 == 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e2.WindDelta == 0) && (Math.Abs(e1.WindCnt) == 1) &&  					  (m_ClipType != ClipType.ctUnion || e1.WindCnt2 == 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||  				  (e1.PolyTyp != e2.PolyTyp && m_ClipType != ClipType.ctXor)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "(e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The conditional expression  "((e1.PolyTyp == PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||  								((e1.PolyTyp == PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0))"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "(dir == Direction.dLeftToRight && e.Curr.X <= horzRight) ||  					  (dir == Direction.dRightToLeft && e.Curr.X >= horzLeft)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "(dir == Direction.dLeftToRight && e.Curr.X >= horzRight) ||  					  (dir == Direction.dRightToLeft && e.Curr.X <= horzLeft)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "ePrev != null && ePrev.Curr.X == horzEdge.Bot.X &&  					  ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta != 0 &&  					  (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&  					  SlopesEqual(horzEdge' ePrev' m_UseFullRange))"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessHorizontal,The conditional expression  "eNext != null && eNext.Curr.X == horzEdge.Bot.X &&  					  eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta != 0 &&  					  eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&  					  SlopesEqual(horzEdge' eNext' m_UseFullRange)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,GetMaximaPair,The conditional expression  "result != null && (result.OutIdx == Skip ||  			  (result.NextInAEL == result.PrevInAEL && !IsHorizontal(result)))"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "(e.OutIdx >= 0) && (e.WindDelta != 0) && ePrev != null &&  						  (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&  						  (ePrev.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "ePrev != null && ePrev.Curr.X == e.Bot.X &&  					  ePrev.Curr.Y == e.Bot.Y && op != null &&  					  ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&  					  SlopesEqual(e' ePrev' m_UseFullRange) &&  					  (e.WindDelta != 0) && (ePrev.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "eNext != null && eNext.Curr.X == e.Bot.X &&  					  eNext.Curr.Y == e.Bot.Y && op != null &&  					  eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&  					  SlopesEqual(e' eNext' m_UseFullRange) &&  					  (e.WindDelta != 0) && (eNext.WindDelta != 0)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult2,The conditional expression  "(outRec.IsOpen && cnt < 2) ||  				  (!outRec.IsOpen && cnt < 3)"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,FixupOutPolygon,The conditional expression  "(pp.Pt == pp.Next.Pt) || (pp.Pt == pp.Prev.Pt) ||  				  (SlopesEqual(pp.Prev.Pt' pp.Pt' pp.Next.Pt' m_UseFullRange) &&  				  (!PreserveCollinear || !Pt2IsBetweenPt1AndPt3(pp.Prev.Pt' pp.Pt' pp.Next.Pt)))"  is complex.
Complex Conditional,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinPoints,The conditional expression  "(op1b == op1) || (op2b == op2) || (op1b == op2b) ||  				  ((outRec1 == outRec2) && (Reverse1 == Reverse2))"  is complex.
Complex Conditional,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The conditional expression  "len == 0 || (delta <= 0 && (len < 3 ||  				  node.m_endtype != EndType.etClosedPolygon))"  is complex.
Magic Number,MSClipperLib,Int128,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: UInt64 int1Hi = (UInt64)lhs >> 32;
Magic Number,MSClipperLib,Int128,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: UInt64 int2Hi = (UInt64)rhs >> 32;
Magic Number,MSClipperLib,Int128,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: hi = (Int64)(a + (c >> 32));
Magic Number,MSClipperLib,Int128,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Int128Mul,The following statement contains a magic number: unchecked { lo = (c << 32) + b; }
Magic Number,MSClipperLib,ClipperBase,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The following statement contains a magic number: if ((Closed && highI < 2) || (!Closed && highI < 1)) return false;
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult,The following statement contains a magic number: for (int i = 0; i < m_PolyOuts.Count; i++)  			{  				OutRec outRec = m_PolyOuts[i];  				if (outRec.Pts == null) continue;  				OutPt p = outRec.Pts.Prev;  				int cnt = PointCount(p);  				if (cnt < 2) continue;  				Path pg = new Path(cnt);  				for (int j = 0; j < cnt; j++)  				{  					pg.Add(p.Pt);  					p = p.Prev;  				}  				polyg.Add(pg);  			}
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult2,The following statement contains a magic number: for (int i = 0; i < m_PolyOuts.Count; i++)  			{  				OutRec outRec = m_PolyOuts[i];  				int cnt = PointCount(outRec.Pts);  				if ((outRec.IsOpen && cnt < 2) ||  				  (!outRec.IsOpen && cnt < 3))  					continue;  				FixHoleLinkage(outRec);  				PolyNode pn = new PolyNode();  				polytree.m_AllPolys.Add(pn);  				outRec.PolyNode = pn;  				pn.m_polygon.Capacity = cnt;  				OutPt op = outRec.Pts.Prev;  				for (int j = 0; j < cnt; j++)  				{  					pn.m_polygon.Add(op.Pt);  					op = op.Prev;  				}  			}
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,BuildResult2,The following statement contains a magic number: for (int i = 0; i < m_PolyOuts.Count; i++)  			{  				OutRec outRec = m_PolyOuts[i];  				int cnt = PointCount(outRec.Pts);  				if ((outRec.IsOpen && cnt < 2) ||  				  (!outRec.IsOpen && cnt < 3))  					continue;  				FixHoleLinkage(outRec);  				PolyNode pn = new PolyNode();  				polytree.m_AllPolys.Add(pn);  				outRec.PolyNode = pn;  				pn.m_polygon.Capacity = cnt;  				OutPt op = outRec.Pts.Prev;  				for (int j = 0; j < cnt; j++)  				{  					pn.m_polygon.Add(op.Pt);  					op = op.Prev;  				}  			}
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,PointInPolygon,The following statement contains a magic number: if (cnt < 3) return 0;
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Area,The following statement contains a magic number: if (cnt < 3) return 0;
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Area,The following statement contains a magic number: return -a * 0.5;
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Area,The following statement contains a magic number: return a * 0.5;
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The following statement contains a magic number: while (currentOutPoint.Idx == 0 && currentOutPoint.Next != currentOutPoint.Prev)  			{  				if (PointsAreClose(currentOutPoint.Pt' currentOutPoint.Prev.Pt' distSqrd))  				{  					currentOutPoint = ExcludeOp(currentOutPoint);  					cnt--;  				}  				else if (PointsAreClose(currentOutPoint.Prev.Pt' currentOutPoint.Next.Pt' distSqrd))  				{  					ExcludeOp(currentOutPoint.Next);  					currentOutPoint = ExcludeOp(currentOutPoint);  					cnt -= 2;  				}  				else  				{  					currentOutPoint.Idx = 1;  					currentOutPoint = currentOutPoint.Next;  				}  			}
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,CleanPolygon,The following statement contains a magic number: if (cnt < 3) cnt = 0;
Magic Number,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Minkowski,The following statement contains a magic number: for (int i = 0; i < pathCnt - 1 + delta; i++)  				for (int j = 0; j < polyCnt; j++)  				{  					Path quad = new Path(4);  					quad.Add(result[i % pathCnt][j % polyCnt]);  					quad.Add(result[(i + 1) % pathCnt][j % polyCnt]);  					quad.Add(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);  					quad.Add(result[i % pathCnt][(j + 1) % polyCnt]);  					if (!Orientation(quad)) quad.Reverse();  					quads.Add(quad);  				}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,AddPath,The following statement contains a magic number: if (endType == EndType.etClosedPolygon && j < 2) return;
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: if (MiterLimit > 2) m_miterLim = 2 / (MiterLimit * MiterLimit);  			else m_miterLim = 0.5;
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: if (MiterLimit > 2) m_miterLim = 2 / (MiterLimit * MiterLimit);  			else m_miterLim = 0.5;
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: if (MiterLimit > 2) m_miterLim = 2 / (MiterLimit * MiterLimit);  			else m_miterLim = 0.5;
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: m_destPolys.Capacity = m_polyNodes.ChildCount * 2;
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)  			{  				PolyNode node = m_polyNodes.Childs[i];  				m_srcPoly = node.m_polygon;    				int len = m_srcPoly.Count;    				if (len == 0 || (delta <= 0 && (len < 3 ||  				  node.m_endtype != EndType.etClosedPolygon)))  					continue;    				m_destPoly = new Path();    				if (len == 1)  				{  					if (node.m_jointype == JoinType.jtRound)  					{  						double X = 1.0' Y = 0.0;  						for (int j = 1; j <= steps; j++)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							double X2 = X;  							X = X * m_cos - m_sin * Y;  							Y = X2 * m_sin + Y * m_cos;  						}  					}  					else  					{  						double X = -1.0' Y = -1.0;  						for (int j = 0; j < 4; ++j)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							if (X < 0) X = 1;  							else if (Y < 0) Y = 1;  							else X = -1;  						}  					}  					m_destPolys.Add(m_destPoly);  					continue;  				}    				//build m_normals ...  				m_normals.Clear();  				m_normals.Capacity = len;  				for (int j = 0; j < len - 1; j++)  					m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));  				if (node.m_endtype == EndType.etClosedLine ||  				  node.m_endtype == EndType.etClosedPolygon)  					m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));  				else  					m_normals.Add(new DoublePoint(m_normals[len - 2]));    				if (node.m_endtype == EndType.etClosedPolygon)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else if (node.m_endtype == EndType.etClosedLine)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  					m_destPoly = new Path();  					//re-build m_normals ...  					DoublePoint n = m_normals[len - 1];  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);  					m_normals[0] = new DoublePoint(-n.X' -n.Y);  					k = 0;  					for (int j = len - 1; j >= 0; j--)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else  				{  					int k = 0;  					for (int j = 1; j < len - 1; ++j)  						OffsetPoint(j' ref k' node.m_jointype);    					IntPoint pt1;  					if (node.m_endtype == EndType.etOpenButt)  					{  						int j = len - 1;  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						int j = len - 1;  						k = len - 2;  						m_sinA = 0;  						m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(j' k);  						else  							DoRound(j' k);  					}    					//re-build m_normals ...  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);    					m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);    					k = len - 1;  					for (int j = k - 1; j > 0; --j)  						OffsetPoint(j' ref k' node.m_jointype);    					if (node.m_endtype == EndType.etOpenButt)  					{  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						k = 1;  						m_sinA = 0;  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(0' 1);  						else  							DoRound(0' 1);  					}  					m_destPolys.Add(m_destPoly);  				}  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)  			{  				PolyNode node = m_polyNodes.Childs[i];  				m_srcPoly = node.m_polygon;    				int len = m_srcPoly.Count;    				if (len == 0 || (delta <= 0 && (len < 3 ||  				  node.m_endtype != EndType.etClosedPolygon)))  					continue;    				m_destPoly = new Path();    				if (len == 1)  				{  					if (node.m_jointype == JoinType.jtRound)  					{  						double X = 1.0' Y = 0.0;  						for (int j = 1; j <= steps; j++)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							double X2 = X;  							X = X * m_cos - m_sin * Y;  							Y = X2 * m_sin + Y * m_cos;  						}  					}  					else  					{  						double X = -1.0' Y = -1.0;  						for (int j = 0; j < 4; ++j)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							if (X < 0) X = 1;  							else if (Y < 0) Y = 1;  							else X = -1;  						}  					}  					m_destPolys.Add(m_destPoly);  					continue;  				}    				//build m_normals ...  				m_normals.Clear();  				m_normals.Capacity = len;  				for (int j = 0; j < len - 1; j++)  					m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));  				if (node.m_endtype == EndType.etClosedLine ||  				  node.m_endtype == EndType.etClosedPolygon)  					m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));  				else  					m_normals.Add(new DoublePoint(m_normals[len - 2]));    				if (node.m_endtype == EndType.etClosedPolygon)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else if (node.m_endtype == EndType.etClosedLine)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  					m_destPoly = new Path();  					//re-build m_normals ...  					DoublePoint n = m_normals[len - 1];  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);  					m_normals[0] = new DoublePoint(-n.X' -n.Y);  					k = 0;  					for (int j = len - 1; j >= 0; j--)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else  				{  					int k = 0;  					for (int j = 1; j < len - 1; ++j)  						OffsetPoint(j' ref k' node.m_jointype);    					IntPoint pt1;  					if (node.m_endtype == EndType.etOpenButt)  					{  						int j = len - 1;  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						int j = len - 1;  						k = len - 2;  						m_sinA = 0;  						m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(j' k);  						else  							DoRound(j' k);  					}    					//re-build m_normals ...  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);    					m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);    					k = len - 1;  					for (int j = k - 1; j > 0; --j)  						OffsetPoint(j' ref k' node.m_jointype);    					if (node.m_endtype == EndType.etOpenButt)  					{  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						k = 1;  						m_sinA = 0;  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(0' 1);  						else  							DoRound(0' 1);  					}  					m_destPolys.Add(m_destPoly);  				}  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)  			{  				PolyNode node = m_polyNodes.Childs[i];  				m_srcPoly = node.m_polygon;    				int len = m_srcPoly.Count;    				if (len == 0 || (delta <= 0 && (len < 3 ||  				  node.m_endtype != EndType.etClosedPolygon)))  					continue;    				m_destPoly = new Path();    				if (len == 1)  				{  					if (node.m_jointype == JoinType.jtRound)  					{  						double X = 1.0' Y = 0.0;  						for (int j = 1; j <= steps; j++)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							double X2 = X;  							X = X * m_cos - m_sin * Y;  							Y = X2 * m_sin + Y * m_cos;  						}  					}  					else  					{  						double X = -1.0' Y = -1.0;  						for (int j = 0; j < 4; ++j)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							if (X < 0) X = 1;  							else if (Y < 0) Y = 1;  							else X = -1;  						}  					}  					m_destPolys.Add(m_destPoly);  					continue;  				}    				//build m_normals ...  				m_normals.Clear();  				m_normals.Capacity = len;  				for (int j = 0; j < len - 1; j++)  					m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));  				if (node.m_endtype == EndType.etClosedLine ||  				  node.m_endtype == EndType.etClosedPolygon)  					m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));  				else  					m_normals.Add(new DoublePoint(m_normals[len - 2]));    				if (node.m_endtype == EndType.etClosedPolygon)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else if (node.m_endtype == EndType.etClosedLine)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  					m_destPoly = new Path();  					//re-build m_normals ...  					DoublePoint n = m_normals[len - 1];  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);  					m_normals[0] = new DoublePoint(-n.X' -n.Y);  					k = 0;  					for (int j = len - 1; j >= 0; j--)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else  				{  					int k = 0;  					for (int j = 1; j < len - 1; ++j)  						OffsetPoint(j' ref k' node.m_jointype);    					IntPoint pt1;  					if (node.m_endtype == EndType.etOpenButt)  					{  						int j = len - 1;  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						int j = len - 1;  						k = len - 2;  						m_sinA = 0;  						m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(j' k);  						else  							DoRound(j' k);  					}    					//re-build m_normals ...  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);    					m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);    					k = len - 1;  					for (int j = k - 1; j > 0; --j)  						OffsetPoint(j' ref k' node.m_jointype);    					if (node.m_endtype == EndType.etOpenButt)  					{  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						k = 1;  						m_sinA = 0;  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(0' 1);  						else  							DoRound(0' 1);  					}  					m_destPolys.Add(m_destPoly);  				}  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)  			{  				PolyNode node = m_polyNodes.Childs[i];  				m_srcPoly = node.m_polygon;    				int len = m_srcPoly.Count;    				if (len == 0 || (delta <= 0 && (len < 3 ||  				  node.m_endtype != EndType.etClosedPolygon)))  					continue;    				m_destPoly = new Path();    				if (len == 1)  				{  					if (node.m_jointype == JoinType.jtRound)  					{  						double X = 1.0' Y = 0.0;  						for (int j = 1; j <= steps; j++)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							double X2 = X;  							X = X * m_cos - m_sin * Y;  							Y = X2 * m_sin + Y * m_cos;  						}  					}  					else  					{  						double X = -1.0' Y = -1.0;  						for (int j = 0; j < 4; ++j)  						{  							m_destPoly.Add(new IntPoint(  							  Round(m_srcPoly[0].X + X * delta)'  							  Round(m_srcPoly[0].Y + Y * delta)));  							if (X < 0) X = 1;  							else if (Y < 0) Y = 1;  							else X = -1;  						}  					}  					m_destPolys.Add(m_destPoly);  					continue;  				}    				//build m_normals ...  				m_normals.Clear();  				m_normals.Capacity = len;  				for (int j = 0; j < len - 1; j++)  					m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));  				if (node.m_endtype == EndType.etClosedLine ||  				  node.m_endtype == EndType.etClosedPolygon)  					m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));  				else  					m_normals.Add(new DoublePoint(m_normals[len - 2]));    				if (node.m_endtype == EndType.etClosedPolygon)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else if (node.m_endtype == EndType.etClosedLine)  				{  					int k = len - 1;  					for (int j = 0; j < len; j++)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  					m_destPoly = new Path();  					//re-build m_normals ...  					DoublePoint n = m_normals[len - 1];  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);  					m_normals[0] = new DoublePoint(-n.X' -n.Y);  					k = 0;  					for (int j = len - 1; j >= 0; j--)  						OffsetPoint(j' ref k' node.m_jointype);  					m_destPolys.Add(m_destPoly);  				}  				else  				{  					int k = 0;  					for (int j = 1; j < len - 1; ++j)  						OffsetPoint(j' ref k' node.m_jointype);    					IntPoint pt1;  					if (node.m_endtype == EndType.etOpenButt)  					{  						int j = len - 1;  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *  						  delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						int j = len - 1;  						k = len - 2;  						m_sinA = 0;  						m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(j' k);  						else  							DoRound(j' k);  					}    					//re-build m_normals ...  					for (int j = len - 1; j > 0; j--)  						m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);    					m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);    					k = len - 1;  					for (int j = k - 1; j > 0; --j)  						OffsetPoint(j' ref k' node.m_jointype);    					if (node.m_endtype == EndType.etOpenButt)  					{  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  						pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'  						  (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));  						m_destPoly.Add(pt1);  					}  					else  					{  						k = 1;  						m_sinA = 0;  						if (node.m_endtype == EndType.etOpenSquare)  							DoSquare(0' 1);  						else  							DoRound(0' 1);  					}  					m_destPolys.Add(m_destPoly);  				}  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				if (solution.Count > 0) solution.RemoveAt(0);  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)  			{  				clpr.Execute(ClipType.ctUnion' solution'  				  PolyFillType.pftPositive' PolyFillType.pftPositive);  			}  			else  			{  				IntRect r = Clipper.GetBounds(m_destPolys);  				Path outer = new Path(4);    				outer.Add(new IntPoint(r.minX - 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.maxY + 10));  				outer.Add(new IntPoint(r.maxX + 10' r.minY - 10));  				outer.Add(new IntPoint(r.minX - 10' r.minY - 10));    				clpr.AddPath(outer' PolyType.ptSubject' true);  				clpr.ReverseSolution = true;  				clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);  				//remove the outer PolyNode rectangle ...  				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)  				{  					PolyNode outerNode = solution.Childs[0];  					solution.Childs.Capacity = outerNode.ChildCount;  					solution.Childs[0] = outerNode.Childs[0];  					solution.Childs[0].m_Parent = solution;  					for (int i = 1; i < outerNode.ChildCount; i++)  						solution.AddChild(outerNode.Childs[i]);  				}  				else  					solution.Clear();  			}
Magic Number,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,DoSquare,The following statement contains a magic number: double dx = Math.Tan(Math.Atan2(m_sinA'  				m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y) / 4);
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The following statement contains a magic number: int increment = 2;
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The following statement contains a magic number: if (polygonString.Contains("width"))  			{  				increment = 4;  			}
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,CreateFromString,The following statement contains a magic number: for (int i = 0; i < intPointData.Length - 1; i += increment)  			{  				string elementX = intPointData[i];  				string elementY = intPointData[i + 1];  				IntPoint nextIntPoint = new IntPoint(int.Parse(elementX.Substring(elementX.IndexOf(':') + 1))' int.Parse(elementY.Substring(3)));  				output.Add(nextIntPoint);  			}
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: Polygon currentPolygon = Clipper.CleanPolygon(inputPolygon' considerAsSameY / 4);
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: CandidateGroup positiveGroup = new CandidateGroup(DegreesToRadians(35));
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: CandidateGroup negativeGroup = new CandidateGroup(DegreesToRadians(10));
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: long minSegmentLengthToConsiderSquared = 50 * 50;
Magic Number,MSClipperLib,CLPolygonExtensions,C:\repos\MatterHackers_MatterSlice\MSClipperLib\PolygonExtensions.cs,FindGreatestTurnPosition,The following statement contains a magic number: long minSegmentLengthToConsiderSquared = 50 * 50;
Duplicate Code,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,JoinPoints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 51)' (138' 161))
Missing Default,MSClipperLib,Clipper,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,IntersectEdges,The following switch statement is missing a default case: switch (m_ClipType)  					{  						case ClipType.ctIntersection:  							if (e1Wc2 > 0 && e2Wc2 > 0)  								AddLocalMinPoly(e1' e2' pt);  							break;  						case ClipType.ctUnion:  							if (e1Wc2 <= 0 && e2Wc2 <= 0)  								AddLocalMinPoly(e1' e2' pt);  							break;  						case ClipType.ctDifference:  							if (((e1.PolyTyp == PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||  								((e1.PolyTyp == PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))  								AddLocalMinPoly(e1' e2' pt);  							break;  						case ClipType.ctXor:  							AddLocalMinPoly(e1' e2' pt);  							break;  					}
Missing Default,MSClipperLib,ClipperOffset,C:\repos\MatterHackers_MatterSlice\MSClipperLib\clipper.cs,OffsetPoint,The following switch statement is missing a default case: switch (jointype)  				{  					case JoinType.jtMiter:  						{  							double r = 1 + (m_normals[j].X * m_normals[k].X +  							  m_normals[j].Y * m_normals[k].Y);  							if (r >= m_miterLim) DoMiter(j' k' r); else DoSquare(j' k);  							break;  						}  					case JoinType.jtSquare: DoSquare(j' k); break;  					case JoinType.jtRound: DoRound(j' k); break;  				}
