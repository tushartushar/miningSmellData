Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MovePointInsideBoundary,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,FindCollisions,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.QuadTree,Segment,C:\repos\MatterHackers_MatterSlice\QuadTree\Segment.cs,GetSplitSegmentForVertecies,Cyclomatic complexity of the method is 8
Long Parameter List,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,CalcIntersection,The method has 5 parameters. Parameters: a1' a2' b1' b2' position
Long Parameter List,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,FindThinLines,The method has 5 parameters. Parameters: polygon' overlapMergeAmount_um' minimumRequiredWidth_um' onlyMergeLines' pathIsClosed
Long Parameter List,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The method has 5 parameters. Parameters: polygons' overlapMergeAmount' minimumRequiredWidth' onlyMergeLines' pathIsClosed
Long Parameter List,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MovePointInsideBoundary,The method has 5 parameters. Parameters: boundaryPolygons' startPosition' polyPointPosition' edgeQuadTrees' pointQuadTrees
Long Parameter List,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,QuadTree,The method has 5 parameters. Parameters: splitCount' minX' minY' maxX' maxY
Long Parameter List,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,Insert,The method has 5 parameters. Parameters: value' minX' minY' maxX' maxY
Long Parameter List,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,SearchArea,The method has 5 parameters. Parameters: x' y' width' height' output
Long Statement,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,FindThinLines,The length of the statement  "			return QTPolygonsExtensions.FindThinLines(new Polygons { polygon }' overlapMergeAmount_um' minimumRequiredWidth_um' out onlyMergeLines' pathIsClosed); " is 150.
Long Statement,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,GetPointQuadTree,The length of the statement  "				quadTree.Insert(i' polygon[i].X - expandDist' polygon[i].Y - expandDist' polygon[i].X + expandDist' polygon[i].Y + expandDist); " is 127.
Long Statement,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The length of the statement  "							polySegments[firstSegmentIndex].Start = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2; // the start " is 135.
Long Statement,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The length of the statement  "							polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2; // the end " is 131.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindCrossingPoints,The length of the statement  "				foreach (var crossing in polygons[polyIndex].FindCrossingPoints(start' end' edgeQuadTrees == null ? null : edgeQuadTrees[polyIndex])) " is 133.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "								// We need to check if the new start position is on the inside of the curve. We can only add thin lines on the insides of our exisiting curves. " is 143.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "								IntPoint newStartPosition = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2; // the start; " is 124.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "								IntPoint normalLeft = (polySegments[firstSegmentIndex].End - polySegments[firstSegmentIndex].Start).GetPerpendicularLeft(); " is 123.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "									polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2; // the end " is 131.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MakeCloseSegmentsMergable,The length of the statement  "					accumulatedSplits = QTPolygonExtensions.MakeCloseSegmentsMergable(accumulatedSplits' polygonsToSplit[j]' distanceNeedingAdd' pathsAreClosed); " is 141.
Complex Conditional,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,FindIntersection,The conditional expression  "start == edgeStart || start == edgeEnd || end == edgeStart || end == edgeEnd  					|| start == polygon[i] || end == polygon[i]"  is complex.
Complex Conditional,MatterHackers.QuadTree,Quad,C:\repos\MatterHackers_MatterSlice\QuadTree\Quad.cs,Contains,The conditional expression  "MinX < other.MinX  				&& MinY < other.MinY  				&& MaxX > other.MaxX  				&& MaxY > other.MaxY"  is complex.
Complex Conditional,MatterHackers.QuadTree,Quad,C:\repos\MatterHackers_MatterSlice\QuadTree\Quad.cs,Contains,The conditional expression  "x > MinX  				&& y > MinY  				&& x < MaxX  				&& y < MaxY"  is complex.
Complex Conditional,MatterHackers.QuadTree,Quad,C:\repos\MatterHackers_MatterSlice\QuadTree\Quad.cs,Intersects,The conditional expression  "MinX < other.MaxX  				&& MinY < other.MaxY  				&& MaxX > other.MinX  				&& MaxY > other.MinY"  is complex.
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: long cleanDistance_um = overlapMergeAmount_um / 40;
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: for (int firstSegmentIndex = 0; firstSegmentIndex < segmentCount; firstSegmentIndex++)  			{  				foreach (int checkSegmentIndex in touchingEnumerator.GetTouching(firstSegmentIndex' segmentCount))  				{  					// The first point of start and the last point of check (the path will be coming back on itself).  					long startDelta = (polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length();  					// if the segments are similar enough  					if (startDelta < overlapMergeAmount_um)  					{  						// The last point of start and the first point of check (the path will be coming back on itself).  						long endDelta = (polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length();  						if (endDelta < overlapMergeAmount_um)  						{  							// only considre the merge if the directions of the lines are towards eachother  							var firstSegmentDirection = polySegments[firstSegmentIndex].End - polySegments[firstSegmentIndex].Start;  							var checkSegmentDirection = polySegments[checkSegmentIndex].End - polySegments[checkSegmentIndex].Start;  							if (firstSegmentDirection.Dot(checkSegmentDirection) > 0)  							{  								continue;  							}  							pathWasOptomized = true;  							// move the first segments points to the average of the merge positions  							long startEndWidth = Math.Abs((polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length());  							long endStartWidth = Math.Abs((polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length());  							long width = Math.Min(startEndWidth' endStartWidth) + overlapMergeAmount_um;  							polySegments[firstSegmentIndex].Start = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2; // the start  							polySegments[firstSegmentIndex].Start.Width = width;  							polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2; // the end  							polySegments[firstSegmentIndex].End.Width = width;    							markedAltered[firstSegmentIndex] = Altered.merged;  							// mark this segment for removal  							markedAltered[checkSegmentIndex] = Altered.remove;  							// We only expect to find one match for each segment' so move on to the next segment  							break;  						}  					}  				}  			}
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: for (int firstSegmentIndex = 0; firstSegmentIndex < segmentCount; firstSegmentIndex++)  			{  				foreach (int checkSegmentIndex in touchingEnumerator.GetTouching(firstSegmentIndex' segmentCount))  				{  					// The first point of start and the last point of check (the path will be coming back on itself).  					long startDelta = (polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length();  					// if the segments are similar enough  					if (startDelta < overlapMergeAmount_um)  					{  						// The last point of start and the first point of check (the path will be coming back on itself).  						long endDelta = (polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length();  						if (endDelta < overlapMergeAmount_um)  						{  							// only considre the merge if the directions of the lines are towards eachother  							var firstSegmentDirection = polySegments[firstSegmentIndex].End - polySegments[firstSegmentIndex].Start;  							var checkSegmentDirection = polySegments[checkSegmentIndex].End - polySegments[checkSegmentIndex].Start;  							if (firstSegmentDirection.Dot(checkSegmentDirection) > 0)  							{  								continue;  							}  							pathWasOptomized = true;  							// move the first segments points to the average of the merge positions  							long startEndWidth = Math.Abs((polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length());  							long endStartWidth = Math.Abs((polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length());  							long width = Math.Min(startEndWidth' endStartWidth) + overlapMergeAmount_um;  							polySegments[firstSegmentIndex].Start = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2; // the start  							polySegments[firstSegmentIndex].Start.Width = width;  							polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2; // the end  							polySegments[firstSegmentIndex].End.Width = width;    							markedAltered[firstSegmentIndex] = Altered.merged;  							// mark this segment for removal  							markedAltered[checkSegmentIndex] = Altered.remove;  							// We only expect to find one match for each segment' so move on to the next segment  							break;  						}  					}  				}  			}
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,Orientation,The following statement contains a magic number: return (val > 0) ? 1 : 2;
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The following statement contains a magic number: for (int firstSegmentIndex = 0; firstSegmentIndex < segmentCount; firstSegmentIndex++)  			{  				foreach (int checkSegmentIndex in touchingEnumerator.GetTouching(firstSegmentIndex' segmentCount))  				{  					// The first point of start and the last point of check (the path will be coming back on itself).  					long startDelta = (polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length();  					// if the segments are similar enough  					if (startDelta < overlapMergeAmount)  					{  						// The last point of start and the first point of check (the path will be coming back on itself).  						long endDelta = (polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length();  						if (endDelta < overlapMergeAmount)  						{  							// move the first segments points to the average of the merge positions  							long startEndWidth = Math.Abs((polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length());  							long endStartWidth = Math.Abs((polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length());  							long width = Math.Min(startEndWidth' endStartWidth);    							if (width > minimumRequiredWidth)  							{  								// We need to check if the new start position is on the inside of the curve. We can only add thin lines on the insides of our exisiting curves.  								IntPoint newStartPosition = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2; // the start;  								IntPoint newStartDirection = newStartPosition - polySegments[firstSegmentIndex].Start;  								IntPoint normalLeft = (polySegments[firstSegmentIndex].End - polySegments[firstSegmentIndex].Start).GetPerpendicularLeft();  								long dotProduct = normalLeft.Dot(newStartDirection);  								if (dotProduct > 0)  								{  									pathHasMergeLines = true;    									polySegments[firstSegmentIndex].Start = newStartPosition;  									polySegments[firstSegmentIndex].Start.Width = width;  									polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2; // the end  									polySegments[firstSegmentIndex].End.Width = width;    									markedAltered[firstSegmentIndex] = Altered.merged;  									// mark this segment for removal  									markedAltered[checkSegmentIndex] = Altered.remove;  									// We only expect to find one match for each segment' so move on to the next segment  									break;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The following statement contains a magic number: for (int firstSegmentIndex = 0; firstSegmentIndex < segmentCount; firstSegmentIndex++)  			{  				foreach (int checkSegmentIndex in touchingEnumerator.GetTouching(firstSegmentIndex' segmentCount))  				{  					// The first point of start and the last point of check (the path will be coming back on itself).  					long startDelta = (polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length();  					// if the segments are similar enough  					if (startDelta < overlapMergeAmount)  					{  						// The last point of start and the first point of check (the path will be coming back on itself).  						long endDelta = (polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length();  						if (endDelta < overlapMergeAmount)  						{  							// move the first segments points to the average of the merge positions  							long startEndWidth = Math.Abs((polySegments[firstSegmentIndex].Start - polySegments[checkSegmentIndex].End).Length());  							long endStartWidth = Math.Abs((polySegments[firstSegmentIndex].End - polySegments[checkSegmentIndex].Start).Length());  							long width = Math.Min(startEndWidth' endStartWidth);    							if (width > minimumRequiredWidth)  							{  								// We need to check if the new start position is on the inside of the curve. We can only add thin lines on the insides of our exisiting curves.  								IntPoint newStartPosition = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2; // the start;  								IntPoint newStartDirection = newStartPosition - polySegments[firstSegmentIndex].Start;  								IntPoint normalLeft = (polySegments[firstSegmentIndex].End - polySegments[firstSegmentIndex].Start).GetPerpendicularLeft();  								long dotProduct = normalLeft.Dot(newStartDirection);  								if (dotProduct > 0)  								{  									pathHasMergeLines = true;    									polySegments[firstSegmentIndex].Start = newStartPosition;  									polySegments[firstSegmentIndex].Start.Width = width;  									polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2; // the end  									polySegments[firstSegmentIndex].End.Width = width;    									markedAltered[firstSegmentIndex] = Altered.merged;  									// mark this segment for removal  									markedAltered[checkSegmentIndex] = Altered.remove;  									// We only expect to find one match for each segment' so move on to the next segment  									break;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MovePointInsideBoundary,The following statement contains a magic number: for (int polygonIndex = 0; polygonIndex < boundaryPolygons.Count; polygonIndex++)  			{  				var boundaryPolygon = boundaryPolygons[polygonIndex];  				if (boundaryPolygon.Count < 3)  				{  					continue;  				}    				for (int pointIndex = 0; pointIndex < boundaryPolygon.Count; pointIndex++)  				{  					IntPoint segmentStart = boundaryPolygon[pointIndex];    					IntPoint pointRelStart = startPosition - segmentStart;  					long distFromStart = pointRelStart.Length();  					if (distFromStart < bestDist)  					{  						bestDist = distFromStart;  						bestPolyPointPosition = new Tuple<int' int' IntPoint>(polygonIndex' pointIndex' segmentStart);  					}    					IntPoint segmentEnd = boundaryPolygon[(pointIndex + 1) % boundaryPolygon.Count];    					IntPoint segmentDelta = segmentEnd - segmentStart;  					long segmentLength = segmentDelta.Length();  					IntPoint segmentLeft = segmentDelta.GetPerpendicularLeft();  					long segmentLeftLength = segmentLeft.Length();    					long distanceFromStart = segmentDelta.Dot(pointRelStart) / segmentLength;    					if (distanceFromStart >= 0 && distanceFromStart <= segmentDelta.Length())  					{  						long distToBoundarySegment = segmentLeft.Dot(pointRelStart) / segmentLeftLength;    						if (Math.Abs(distToBoundarySegment) < bestDist)  						{  							IntPoint pointAlongCurrentSegment = startPosition;  							if (distToBoundarySegment != 0)  							{  								pointAlongCurrentSegment = startPosition - segmentLeft * distToBoundarySegment / segmentLeftLength;  							}    							bestDist = Math.Abs(distToBoundarySegment);  							bestPolyPointPosition = new Tuple<int' int' IntPoint>(polygonIndex' pointIndex' pointAlongCurrentSegment);  							bestMoveDelta = segmentLeft;  						}  					}    					segmentStart = segmentEnd;  				}  			}
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,C:\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,PointIsInside,The following statement contains a magic number: return (insideCount % 2 == 1);
Magic Number,MatterHackers.QuadTree,Branch<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				if (Branches[i] != null)  				{  					QuadTree<T>.branchPool.Push(Branches[i]);  					Branches[i].Clear();  					Branches[i] = null;  				}  			}
Magic Number,MatterHackers.QuadTree,Branch<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,Insert,The following statement contains a magic number: if (Split)  			{  				for (int i = 0; i < 4; ++i)  				{  					if (Quads[i].Contains(ref leaf.Quad))  					{  						if (Branches[i] == null)  						{  							Branches[i] = QuadTree<T>.CreateBranch(Tree' this' ref Quads[i]);  						}  						Branches[i].Insert(leaf);  						return;  					}  				}    				Leaves.Add(leaf);  				leaf.ContainingBranch = this;  			}  			else  			{  				//Add the leaf to this node  				Leaves.Add(leaf);  				leaf.ContainingBranch = this;    				//Once I have reached capacity' split the node  				if (Leaves.Count >= Tree.splitCount)  				{  					if (Quads[0].MinX + 2 < Quads[0].MaxX  						&& Quads[0].MinY + 2 < Quads[0].MaxY)  					{  						var temp = tempPool.Count > 0 ? tempPool.Pop() : new List<Leaf<T>>();  						temp.AddRange(Leaves);  						Leaves.Clear();  						Split = true;  						for (int i = 0; i < temp.Count; ++i)  						{  							Insert(temp[i]);  						}  						temp.Clear();  						tempPool.Push(temp);  					}  				}  			}
Magic Number,MatterHackers.QuadTree,Branch<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,Insert,The following statement contains a magic number: if (Split)  			{  				for (int i = 0; i < 4; ++i)  				{  					if (Quads[i].Contains(ref leaf.Quad))  					{  						if (Branches[i] == null)  						{  							Branches[i] = QuadTree<T>.CreateBranch(Tree' this' ref Quads[i]);  						}  						Branches[i].Insert(leaf);  						return;  					}  				}    				Leaves.Add(leaf);  				leaf.ContainingBranch = this;  			}  			else  			{  				//Add the leaf to this node  				Leaves.Add(leaf);  				leaf.ContainingBranch = this;    				//Once I have reached capacity' split the node  				if (Leaves.Count >= Tree.splitCount)  				{  					if (Quads[0].MinX + 2 < Quads[0].MaxX  						&& Quads[0].MinY + 2 < Quads[0].MaxY)  					{  						var temp = tempPool.Count > 0 ? tempPool.Pop() : new List<Leaf<T>>();  						temp.AddRange(Leaves);  						Leaves.Clear();  						Split = true;  						for (int i = 0; i < temp.Count; ++i)  						{  							Insert(temp[i]);  						}  						temp.Clear();  						tempPool.Push(temp);  					}  				}  			}
Magic Number,MatterHackers.QuadTree,Branch<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,Insert,The following statement contains a magic number: if (Split)  			{  				for (int i = 0; i < 4; ++i)  				{  					if (Quads[i].Contains(ref leaf.Quad))  					{  						if (Branches[i] == null)  						{  							Branches[i] = QuadTree<T>.CreateBranch(Tree' this' ref Quads[i]);  						}  						Branches[i].Insert(leaf);  						return;  					}  				}    				Leaves.Add(leaf);  				leaf.ContainingBranch = this;  			}  			else  			{  				//Add the leaf to this node  				Leaves.Add(leaf);  				leaf.ContainingBranch = this;    				//Once I have reached capacity' split the node  				if (Leaves.Count >= Tree.splitCount)  				{  					if (Quads[0].MinX + 2 < Quads[0].MaxX  						&& Quads[0].MinY + 2 < Quads[0].MaxY)  					{  						var temp = tempPool.Count > 0 ? tempPool.Pop() : new List<Leaf<T>>();  						temp.AddRange(Leaves);  						Leaves.Clear();  						Split = true;  						for (int i = 0; i < temp.Count; ++i)  						{  							Insert(temp[i]);  						}  						temp.Clear();  						tempPool.Push(temp);  					}  				}  			}
Magic Number,MatterHackers.QuadTree,Branch<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,SearchPoint,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				if (Branches[i] != null)  				{  					Branches[i].SearchPoint(x' y' output);  				}  			}
Magic Number,MatterHackers.QuadTree,Branch<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,SearchQuad,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				if (Branches[i] != null)  				{  					Branches[i].SearchQuad(quad' output);  				}  			}
Magic Number,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,FindCollisions,The following statement contains a magic number: if (leafLookup.TryGetValue(value' out leaf))  			{  				var branch = leaf.ContainingBranch;    				//Add the leaf's siblings (prevent it from colliding with itself)  				if (branch.Leaves.Count > 0)  				{  					for (int i = 0; i < branch.Leaves.Count; ++i)  					{  						if (leaf != branch.Leaves[i] && leaf.Quad.Intersects(ref branch.Leaves[i].Quad))  						{  							QueryResults.Add(branch.Leaves[i].Value);  						}  					}  				}    				//Add the branch's children  				if (branch.Split)  				{  					for (int i = 0; i < 4; ++i)  					{  						if (branch.Branches[i] != null)  						{  							branch.Branches[i].SearchQuad(leaf.Quad' QueryResults);  						}  					}  				}    				//Add all leaves back to the root  				branch = branch.Parent;  				while (branch != null)  				{  					if (branch.Leaves.Count > 0)  					{  						for (int i = 0; i < branch.Leaves.Count; ++i)  						{  							if (leaf.Quad.Intersects(ref branch.Leaves[i].Quad))  							{  								QueryResults.Add(branch.Leaves[i].Value);  							}  						}  					}  					branch = branch.Parent;  				}  			}
Magic Number,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: long midX = quad.MinX + (quad.MaxX - quad.MinX) / 2;
Magic Number,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: long midY = quad.MinY + (quad.MaxY - quad.MinY) / 2;
Magic Number,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: branch.Quads[2].Set(midX' midY' quad.MaxX' quad.MaxY);
Magic Number,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: branch.Quads[3].Set(quad.MinX' midY' midX' quad.MaxY);
Magic Number,MatterHackers.QuadTree,QuadTree<T>,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CountBranches,The following statement contains a magic number: if (branch.Split)  			{  				for (int i = 0; i < 4; ++i)  				{  					if (branch.Branches[i] != null)  					{  						CountBranches(branch.Branches[i]' ref count);  					}  				}  			}
Magic Number,MatterHackers.QuadTree,CloseSegmentsIterator,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTreeAccelerators.cs,CloseSegmentsIterator,The following statement contains a magic number: if (useQuadTree)  			{  				IntRect bounds = new IntRect();  				List<Quad> quads = new List<Quad>(polySegments.Count);  				for (int i = 0; i < polySegments.Count; i++)  				{  					var quad = new Quad(polySegments[i].Left - overlapAmount'  						polySegments[i].Bottom - overlapAmount'  						polySegments[i].Right + overlapAmount'  						polySegments[i].Top + overlapAmount);    					if (i == 0)  					{  						bounds = new IntRect(quad.MinX' quad.MinY' quad.MaxX' quad.MaxY);  					}  					else  					{  						bounds.ExpandToInclude(new IntRect(quad.MinX' quad.MinY' quad.MaxX' quad.MaxY));  					}    					quads.Add(quad);  				}    				tree = new QuadTree<int>(5' new Quad(bounds.minX' bounds.minY' bounds.maxX' bounds.maxY));  				for (int i = 0; i < quads.Count; i++)  				{  					tree.Insert(i' quads[i]);  				}  			}
Magic Number,MatterHackers.QuadTree,PolygonEdgeIterator,C:\repos\MatterHackers_MatterSlice\QuadTree\QuadTreeAccelerators.cs,PolygonEdgeIterator,The following statement contains a magic number: if (newMethod)  			{  				tree = treeToUse;  				if (tree == null)  				{  					tree = sourcePoints.GetEdgeQuadTree(5' overlapAmount);  				}  			}
