Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The method has 103 lines of code.
Complex Method,MatterHackers.QuadTree,Branch<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,Insert,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MovePointInsideBoundary,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,PointIsInside,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,FindCollisions,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.QuadTree,Segment,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Segment.cs,GetSplitSegmentForVertecies,Cyclomatic complexity of the method is 8
Long Parameter List,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,CalcIntersection,The method has 5 parameters. Parameters: a1' a2' b1' b2' position
Long Parameter List,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,FindThinLines,The method has 5 parameters. Parameters: polygon' overlapMergeAmount_um' minimumRequiredWidth_um' onlyMergeLines' pathIsClosed
Long Parameter List,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The method has 5 parameters. Parameters: polygons' overlapMergeAmount' minimumRequiredWidth' onlyMergeLines' pathIsClosed
Long Parameter List,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MovePointInsideBoundary,The method has 6 parameters. Parameters: boundaryPolygons' startPosition' polyPointPosition' edgeQuadTrees' pointQuadTrees' fastInsideCheck
Long Parameter List,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,PointIsInside,The method has 5 parameters. Parameters: polygons' testPoint' edgeQuadTrees' pointQuadTrees' fastInsideCheck
Long Parameter List,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,QuadTree,The method has 5 parameters. Parameters: splitCount' minX' minY' maxX' maxY
Long Parameter List,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,Insert,The method has 5 parameters. Parameters: value' minX' minY' maxX' maxY
Long Statement,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,FindThinLines,The length of the statement  "			return QTPolygonsExtensions.FindThinLines(new Polygons { polygon }' overlapMergeAmount_um' minimumRequiredWidth_um' out onlyMergeLines' pathIsClosed); " is 150.
Long Statement,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,GetPointQuadTree,The length of the statement  "				quadTree.Insert(i' polygon[i].X - expandDist' polygon[i].Y - expandDist' polygon[i].X + expandDist' polygon[i].Y + expandDist); " is 127.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindCrossingPoints,The length of the statement  "				foreach (var crossing in polygons[polyIndex].FindCrossingPoints(start' end' edgeQuadTrees == null ? null : edgeQuadTrees[polyIndex])) " is 133.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "								// We need to check if the new start position is on the inside of the curve. We can only add thin lines on the insides of our existing curves. " is 142.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "								IntPoint newStartPosition = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2; // the start; " is 124.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "								IntPoint normalLeft = (polySegments[firstSegmentIndex].End - polySegments[firstSegmentIndex].Start).GetPerpendicularLeft(); " is 123.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The length of the statement  "									polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2; // the end " is 131.
Long Statement,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MakeCloseSegmentsMergable,The length of the statement  "					accumulatedSplits = QTPolygonExtensions.MakeCloseSegmentsMergable(accumulatedSplits' polygonsToSplit[j]' distanceNeedingAdd' pathsAreClosed); " is 141.
Complex Conditional,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,FindIntersection,The conditional expression  "start == edgeStart || start == edgeEnd || end == edgeStart || end == edgeEnd  					|| start == polygon[i] || end == polygon[i]"  is complex.
Complex Conditional,MatterHackers.QuadTree,Quad,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Quad.cs,Contains,The conditional expression  "MinX < other.MinX  				&& MinY < other.MinY  				&& MaxX > other.MaxX  				&& MaxY > other.MaxY"  is complex.
Complex Conditional,MatterHackers.QuadTree,Quad,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Quad.cs,Contains,The conditional expression  "x > MinX  				&& y > MinY  				&& x < MaxX  				&& y < MaxY"  is complex.
Complex Conditional,MatterHackers.QuadTree,Quad,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Quad.cs,Intersects,The conditional expression  "MinX < other.MaxX  				&& MinY < other.MaxY  				&& MaxX > other.MinX  				&& MaxY > other.MinY"  is complex.
Magic Number,MatterHackers.QuadTree,Branch<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,Clear,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.QuadTree,Branch<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,Insert,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.QuadTree,Branch<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,SearchPoint,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.QuadTree,Branch<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\Branch.cs,SearchQuad,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,CutToLength,The following statement contains a magic number: newLength > 50
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: long cleanDistance_um = overlapMergeAmount_um / 40;
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: perimeter = QTPolygonExtensions.MakeCloseSegmentsMergable(perimeter' overlapMergeAmount_um * 3 / 4' pathIsClosed);
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: perimeter = QTPolygonExtensions.MakeCloseSegmentsMergable(perimeter' overlapMergeAmount_um * 3 / 4' pathIsClosed);
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: var minimumLengthToCreateSquared = overlapMergeAmount_um / 10;
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: var segmentStart = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2;
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,MergePerimeterOverlaps,The following statement contains a magic number: var segmentEnd = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2;
Magic Number,MatterHackers.QuadTree,QTPolygonExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonExtensions.cs,Orientation,The following statement contains a magic number: return (val > 0) ? 1 : 2;
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The following statement contains a magic number: polygons = Clipper.CleanPolygons(polygons' overlapMergeAmount / 8);
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The following statement contains a magic number: IntPoint newStartPosition = (polySegments[firstSegmentIndex].Start + polySegments[checkSegmentIndex].End) / 2;
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The following statement contains a magic number: polySegments[firstSegmentIndex].End = (polySegments[firstSegmentIndex].End + polySegments[checkSegmentIndex].Start) / 2;
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,FindThinLines,The following statement contains a magic number: long cleanDistance = overlapMergeAmount / 40;
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,MovePointInsideBoundary,The following statement contains a magic number: boundaryPolygon.Count < 3
Magic Number,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,PointIsInside,The following statement contains a magic number: return (insideCount % 2 == 1);
Magic Number,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,FindCollisions,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: long midX = quad.MinX + (quad.MaxX - quad.MinX) / 2;
Magic Number,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: long midY = quad.MinY + (quad.MaxY - quad.MinY) / 2;
Magic Number,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: branch.Quads[2].Set(midX' midY' quad.MaxX' quad.MaxY);
Magic Number,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CreateBranch,The following statement contains a magic number: branch.Quads[3].Set(quad.MinX' midY' midX' quad.MaxY);
Magic Number,MatterHackers.QuadTree,QuadTree<T>,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTree.cs,CountBranches,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.QuadTree,CloseSegmentsIterator,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTreeAccelerators.cs,CloseSegmentsIterator,The following statement contains a magic number: tree = new QuadTree<int>(5' new Quad(bounds.minX' bounds.minY' bounds.maxX' bounds.maxY));
Magic Number,MatterHackers.QuadTree,PolygonEdgeIterator,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\QuadTreeAccelerators.cs,PolygonEdgeIterator,The following statement contains a magic number: tree = sourcePoints.GetEdgeQuadTree(5' overlapAmount);
Missing Default,MatterHackers.QuadTree,QTPolygonsExtensions,D:\research\architectureSmells\repos\MatterHackers_MatterSlice\QuadTree\PolygonsExtensions.cs,PointIsInside,The following switch statement is missing a default case: switch (fastInsideCheck(testPoint))  					{  						case InsideState.Inside:  							return true;  						case InsideState.Outside:  							return false;  						case InsideState.Unknown:  							if(polygon.PointIsInside(testPoint' pointQuadTrees == null ? null : pointQuadTrees[i]) != 0)  							{  								insideCount++;  							}  							break;  					}
