Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,PathFinder,The method has 124 lines of code.
Complex Method,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,PathFinder,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,CreatePathInsideBoundary,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,OptomizePathPoints,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Pathfinding,IntPointPathNetwork,C:\repos\MatterHackers_MatterSlice\Pathfinding\IntPointPathing\IntPointPathNetwork.cs,FindPath,Cyclomatic complexity of the method is 10
Long Parameter List,MatterHackers.Pathfinding,IntPointPathNetwork,C:\repos\MatterHackers_MatterSlice\Pathfinding\IntPointPathing\IntPointPathNetwork.cs,FindPath,The method has 6 parameters. Parameters: startPosition' startLinkA' startLinkB' endPosition' endLinkA' endLinkB
Long Statement,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,CreatePathInsideBoundary,The length of the statement  "			var crossings = new List<Tuple<int' int' IntPoint>>(BoundaryPolygons.FindCrossingPoints(lastAddedNode.Position' lastToAddNode.Position' BoundaryEdgeQuadTrees)); " is 160.
Long Statement,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,CreatePathInsideBoundary,The length of the statement  "					&& BoundaryPolygons.PointIsInside((lastAddedNode.Position + crossingNode.Position) / 2' BoundaryEdgeQuadTrees' BoundaryPointQuadTrees)) " is 135.
Long Statement,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,GetWayPointInside,The length of the statement  "			BoundaryPolygons.MovePointInsideBoundary(position' out foundPolyPointPosition' BoundaryEdgeQuadTrees' BoundaryPointQuadTrees); " is 126.
Long Statement,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,OptomizePathPoints,The length of the statement  "					var crossings = new List<Tuple<int' int' IntPoint>>(BoundaryPolygons.FindCrossingPoints(startPosition' endPosition' BoundaryEdgeQuadTrees)); " is 140.
Long Statement,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,WriteErrorForTesting,The length of the statement  "                    sw.WriteLine($"// startOverride = new MSIntPoint({startPoint.X}' {startPoint.Y}); endOverride = new MSIntPoint({endPoint.X}' {endPoint.Y});"); " is 142.
Long Statement,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,WriteErrorForTesting,The length of the statement  "					sw.WriteLine($"TestSinglePathIsInside(polyPath' new IntPoint({startPoint.X}' {startPoint.Y})' new IntPoint({endPoint.X}' {endPoint.Y}));"); " is 139.
Complex Conditional,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The conditional expression  "start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint"  is complex.
Complex Conditional,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The conditional expression  "!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000"  is complex.
Complex Conditional,MatterHackers.Pathfinding,IntPointPathNetwork,C:\repos\MatterHackers_MatterSlice\Pathfinding\IntPointPathing\IntPointPathNetwork.cs,FindPath,The conditional expression  "(startLinkA == endLinkA && startLinkB == endLinkB)  					|| (startLinkA == endLinkB && startLinkB == endLinkA)"  is complex.
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,PathFinder,The following statement contains a magic number: OutlinePolygons = Clipper.CleanPolygons(OutlinePolygons' avoidInset / 60);
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,PathFinder,The following statement contains a magic number: BoundaryPolygons = OutlinePolygons.Offset(stayInsideBounds == null ? -avoidInset : -2 * avoidInset);
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,PathFinder,The following statement contains a magic number: if (simpleHookup) // do a simple hookup  			{  				for (int indexA = 0; indexA < BoundaryPolygons.Count; indexA++)  				{  					var polyA = BoundaryPolygons[indexA];  					if (polyA.GetWindingDirection() > 0)  					{  						Func<int' Polygon' bool> ConsiderPolygon = (polyIndex' poly) =>  						{  							return polyIndex != indexA  								&& poly.GetWindingDirection() > 0;  						};    						// find the closest two points between A and any other polygon  						IntPoint bestAPos = polyA.Center();  						Func<int' IntPoint' bool> ConsiderPoint = (polyIndex' edgeEnd) =>  						{  							if (OutlinePolygons.PointIsInside((bestAPos + edgeEnd) / 2' OutlineEdgeQuadTrees' OutlinePointQuadTrees))  							{  								return true;  							}  							return false;  						};    						var bestBPoly = BoundaryPolygons.FindClosestPoint(bestAPos' ConsiderPolygon' ConsiderPoint);  						if (bestBPoly.polyIndex == -1)  						{  							// find one that intersects  							bestBPoly = BoundaryPolygons.FindClosestPoint(bestAPos' ConsiderPolygon);  						}  						if (bestBPoly.polyIndex != -1)  						{  							bestAPos = polyA.FindClosestPoint(bestBPoly.Item3).Item2;  							var bestBResult = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos' ConsiderPoint);  							IntPoint bestBPos = new IntPoint();  							if (bestBResult.index != -1)  							{  								bestBPos = bestBResult.Item2;  							}  							else  							{  								// find one that intersects  								bestBPos = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos).Item2;  							}  							bestAPos = polyA.FindClosestPoint(bestBPos).Item2;  							bestBPos = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos).Item2;    							// hook the polygons up along this connection  							IntPointNode nodeA = Waypoints.FindNode(bestAPos);  							IntPointNode nodeB = Waypoints.FindNode(bestBPos);  							Waypoints.AddPathLink(nodeA' nodeB);  						}  					}  				}  			}  			else // hook up using thin lines code  			{  				// this is done with merge close edges and finding candidates  				// then joining the ends of the merged segments with the closest points  				Polygons thinLines;  				if (OutlinePolygons.FindThinLines(avoidInset * 2' 0' out thinLines))  				{  					ThinLinePolygons = thinLines;  					for (int thinIndex = 0; thinIndex < thinLines.Count; thinIndex++)  					{  						var thinPolygon = thinLines[thinIndex];  						if (thinPolygon.Count > 1)  						{  							Waypoints.AddPolygon(thinPolygon' false);  						}  					}    					Polygons allPolygons = new Polygons(thinLines);  					allPolygons.AddRange(BoundaryPolygons);  					for (int thinIndex = 0; thinIndex < thinLines.Count; thinIndex++)  					{  						var thinPolygon = thinLines[thinIndex];  						if (thinPolygon.Count > 1)  						{  							// now hook up the start and end of this polygon to the existing way points  							var closestStart = allPolygons.FindClosestPoint(thinPolygon[0]' (polyIndex' poly) => { return polyIndex == thinIndex; });  							var closestEnd = allPolygons.FindClosestPoint(thinPolygon[thinPolygon.Count - 1]' (polyIndex' poly) => { return polyIndex == thinIndex; }); // last point  							if (OutlinePolygons.PointIsInside((closestStart.Item3 + closestEnd.Item3) / 2' OutlineEdgeQuadTrees))  							{  								IntPointNode nodeA = Waypoints.FindNode(closestStart.Item3);  								IntPointNode nodeB = Waypoints.FindNode(closestEnd.Item3);  								if (nodeA != null && nodeB != null)  								{  									Waypoints.AddPathLink(nodeA' nodeB);  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,PathFinder,The following statement contains a magic number: if (simpleHookup) // do a simple hookup  			{  				for (int indexA = 0; indexA < BoundaryPolygons.Count; indexA++)  				{  					var polyA = BoundaryPolygons[indexA];  					if (polyA.GetWindingDirection() > 0)  					{  						Func<int' Polygon' bool> ConsiderPolygon = (polyIndex' poly) =>  						{  							return polyIndex != indexA  								&& poly.GetWindingDirection() > 0;  						};    						// find the closest two points between A and any other polygon  						IntPoint bestAPos = polyA.Center();  						Func<int' IntPoint' bool> ConsiderPoint = (polyIndex' edgeEnd) =>  						{  							if (OutlinePolygons.PointIsInside((bestAPos + edgeEnd) / 2' OutlineEdgeQuadTrees' OutlinePointQuadTrees))  							{  								return true;  							}  							return false;  						};    						var bestBPoly = BoundaryPolygons.FindClosestPoint(bestAPos' ConsiderPolygon' ConsiderPoint);  						if (bestBPoly.polyIndex == -1)  						{  							// find one that intersects  							bestBPoly = BoundaryPolygons.FindClosestPoint(bestAPos' ConsiderPolygon);  						}  						if (bestBPoly.polyIndex != -1)  						{  							bestAPos = polyA.FindClosestPoint(bestBPoly.Item3).Item2;  							var bestBResult = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos' ConsiderPoint);  							IntPoint bestBPos = new IntPoint();  							if (bestBResult.index != -1)  							{  								bestBPos = bestBResult.Item2;  							}  							else  							{  								// find one that intersects  								bestBPos = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos).Item2;  							}  							bestAPos = polyA.FindClosestPoint(bestBPos).Item2;  							bestBPos = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos).Item2;    							// hook the polygons up along this connection  							IntPointNode nodeA = Waypoints.FindNode(bestAPos);  							IntPointNode nodeB = Waypoints.FindNode(bestBPos);  							Waypoints.AddPathLink(nodeA' nodeB);  						}  					}  				}  			}  			else // hook up using thin lines code  			{  				// this is done with merge close edges and finding candidates  				// then joining the ends of the merged segments with the closest points  				Polygons thinLines;  				if (OutlinePolygons.FindThinLines(avoidInset * 2' 0' out thinLines))  				{  					ThinLinePolygons = thinLines;  					for (int thinIndex = 0; thinIndex < thinLines.Count; thinIndex++)  					{  						var thinPolygon = thinLines[thinIndex];  						if (thinPolygon.Count > 1)  						{  							Waypoints.AddPolygon(thinPolygon' false);  						}  					}    					Polygons allPolygons = new Polygons(thinLines);  					allPolygons.AddRange(BoundaryPolygons);  					for (int thinIndex = 0; thinIndex < thinLines.Count; thinIndex++)  					{  						var thinPolygon = thinLines[thinIndex];  						if (thinPolygon.Count > 1)  						{  							// now hook up the start and end of this polygon to the existing way points  							var closestStart = allPolygons.FindClosestPoint(thinPolygon[0]' (polyIndex' poly) => { return polyIndex == thinIndex; });  							var closestEnd = allPolygons.FindClosestPoint(thinPolygon[thinPolygon.Count - 1]' (polyIndex' poly) => { return polyIndex == thinIndex; }); // last point  							if (OutlinePolygons.PointIsInside((closestStart.Item3 + closestEnd.Item3) / 2' OutlineEdgeQuadTrees))  							{  								IntPointNode nodeA = Waypoints.FindNode(closestStart.Item3);  								IntPointNode nodeB = Waypoints.FindNode(closestEnd.Item3);  								if (nodeA != null && nodeB != null)  								{  									Waypoints.AddPathLink(nodeA' nodeB);  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,PathFinder,The following statement contains a magic number: if (simpleHookup) // do a simple hookup  			{  				for (int indexA = 0; indexA < BoundaryPolygons.Count; indexA++)  				{  					var polyA = BoundaryPolygons[indexA];  					if (polyA.GetWindingDirection() > 0)  					{  						Func<int' Polygon' bool> ConsiderPolygon = (polyIndex' poly) =>  						{  							return polyIndex != indexA  								&& poly.GetWindingDirection() > 0;  						};    						// find the closest two points between A and any other polygon  						IntPoint bestAPos = polyA.Center();  						Func<int' IntPoint' bool> ConsiderPoint = (polyIndex' edgeEnd) =>  						{  							if (OutlinePolygons.PointIsInside((bestAPos + edgeEnd) / 2' OutlineEdgeQuadTrees' OutlinePointQuadTrees))  							{  								return true;  							}  							return false;  						};    						var bestBPoly = BoundaryPolygons.FindClosestPoint(bestAPos' ConsiderPolygon' ConsiderPoint);  						if (bestBPoly.polyIndex == -1)  						{  							// find one that intersects  							bestBPoly = BoundaryPolygons.FindClosestPoint(bestAPos' ConsiderPolygon);  						}  						if (bestBPoly.polyIndex != -1)  						{  							bestAPos = polyA.FindClosestPoint(bestBPoly.Item3).Item2;  							var bestBResult = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos' ConsiderPoint);  							IntPoint bestBPos = new IntPoint();  							if (bestBResult.index != -1)  							{  								bestBPos = bestBResult.Item2;  							}  							else  							{  								// find one that intersects  								bestBPos = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos).Item2;  							}  							bestAPos = polyA.FindClosestPoint(bestBPos).Item2;  							bestBPos = BoundaryPolygons[bestBPoly.Item1].FindClosestPoint(bestAPos).Item2;    							// hook the polygons up along this connection  							IntPointNode nodeA = Waypoints.FindNode(bestAPos);  							IntPointNode nodeB = Waypoints.FindNode(bestBPos);  							Waypoints.AddPathLink(nodeA' nodeB);  						}  					}  				}  			}  			else // hook up using thin lines code  			{  				// this is done with merge close edges and finding candidates  				// then joining the ends of the merged segments with the closest points  				Polygons thinLines;  				if (OutlinePolygons.FindThinLines(avoidInset * 2' 0' out thinLines))  				{  					ThinLinePolygons = thinLines;  					for (int thinIndex = 0; thinIndex < thinLines.Count; thinIndex++)  					{  						var thinPolygon = thinLines[thinIndex];  						if (thinPolygon.Count > 1)  						{  							Waypoints.AddPolygon(thinPolygon' false);  						}  					}    					Polygons allPolygons = new Polygons(thinLines);  					allPolygons.AddRange(BoundaryPolygons);  					for (int thinIndex = 0; thinIndex < thinLines.Count; thinIndex++)  					{  						var thinPolygon = thinLines[thinIndex];  						if (thinPolygon.Count > 1)  						{  							// now hook up the start and end of this polygon to the existing way points  							var closestStart = allPolygons.FindClosestPoint(thinPolygon[0]' (polyIndex' poly) => { return polyIndex == thinIndex; });  							var closestEnd = allPolygons.FindClosestPoint(thinPolygon[thinPolygon.Count - 1]' (polyIndex' poly) => { return polyIndex == thinIndex; }); // last point  							if (OutlinePolygons.PointIsInside((closestStart.Item3 + closestEnd.Item3) / 2' OutlineEdgeQuadTrees))  							{  								IntPointNode nodeA = Waypoints.FindNode(closestStart.Item3);  								IntPointNode nodeB = Waypoints.FindNode(closestEnd.Item3);  								if (nodeA != null && nodeB != null)  								{  									Waypoints.AddPathLink(nodeA' nodeB);  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,AllPathSegmentsAreInsideOutlines,The following statement contains a magic number: for (int i = 0; i < pathThatIsInside.Count - 1; i++)  			{  				var start = pathThatIsInside[i];  				var end = pathThatIsInside[i + 1];    				if (start != startPoint  					&& start != endPoint  					&& end != endPoint  					&& end != startPoint)  				{  					if (!ValidPoint(start + (end - start) / 4)  						|| !ValidPoint(start + (end - start) / 2)  						|| !ValidPoint(start + (end - start) * 3 / 4)  						|| !ValidPoint(start + (end - start) / 10)  						|| !ValidPoint(start + (end - start) * 9 / 10)  						|| (start - end).Length() > 1000000)  					{  						// an easy way to get the path  						if (writeErrors)  						{  							WriteErrorForTesting(startPoint' endPoint' (end - start).Length());  						}    						return false;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,CreatePathInsideBoundary,The following statement contains a magic number: if (BoundaryPolygons.FindIntersection(startPointIn' endPointIn' BoundaryEdgeQuadTrees) == Intersection.None  				&& BoundaryPolygons.PointIsInside((startPointIn + endPointIn) / 2' BoundaryEdgeQuadTrees' BoundaryPointQuadTrees))  			{  				return true;  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,CreatePathInsideBoundary,The following statement contains a magic number: foreach (var crossing in crossings.SkipSame())  			{  				IntPointNode crossingNode = Waypoints.FindNode(crossing.Item3' findNodeDist);  				// for every crossing try to connect it up in the waypoint data  				if (crossingNode == null)  				{  					crossingNode = AddTempWayPoint(removePointList' crossing.Item3);  					// also connect it to the next and prev points on the polygon it came from  					HookUpToEdge(crossingNode' crossing.Item1' crossing.Item2);  				}    				if (lastAddedNode != crossingNode  					&& BoundaryPolygons.PointIsInside((lastAddedNode.Position + crossingNode.Position) / 2' BoundaryEdgeQuadTrees' BoundaryPointQuadTrees))  				{  					Waypoints.AddPathLink(lastAddedNode' crossingNode);  				}  				else if(crossingNode.Links.Count == 0)  				{  					// link it to the edge it is on  					HookUpToEdge(crossingNode' crossing.Item1' crossing.Item2);  				}  				lastAddedNode = crossingNode;  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,CreatePathInsideBoundary,The following statement contains a magic number: if (lastAddedNode != lastToAddNode   				&& BoundaryPolygons.PointIsInside((lastAddedNode.Position + lastToAddNode.Position) / 2' BoundaryEdgeQuadTrees))  			{  				// connect the last crossing to the end node  				Waypoints.AddPathLink(lastAddedNode' lastToAddNode);  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,FixWinding,The following statement contains a magic number: bounds.minX -= 10;
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,FixWinding,The following statement contains a magic number: bounds.maxY += 10;
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,FixWinding,The following statement contains a magic number: bounds.maxX += 10;
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,FixWinding,The following statement contains a magic number: bounds.minY -= 10;
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,OptomizePathPoints,The following statement contains a magic number: for (int startIndex = 0; startIndex < pathThatIsInside.Count - 2; startIndex++)  			{  				var startPosition = pathThatIsInside[startIndex];  				if(startPosition.X < -10000)  				{  					int a = 0;  				}  				for (int endIndex = pathThatIsInside.Count - 1; endIndex > startIndex + 1; endIndex--)  				{  					var endPosition = pathThatIsInside[endIndex];    					var crossings = new List<Tuple<int' int' IntPoint>>(BoundaryPolygons.FindCrossingPoints(startPosition' endPosition' BoundaryEdgeQuadTrees));    					bool isCrossingEdge = false;  					foreach (var cross in crossings)  					{  						if (cross.Item3 != startPosition  							&& cross.Item3 != endPosition)  						{  							isCrossingEdge = true;  							break;  						}  					}    					if (!isCrossingEdge   						&& BoundaryPolygons.PointIsInside((startPosition + endPosition) / 2' BoundaryEdgeQuadTrees' BoundaryPointQuadTrees))  					{  						// remove A+1 - B-1  						for (int removeIndex = endIndex - 1; removeIndex > startIndex; removeIndex--)  						{  							pathThatIsInside.RemoveAt(removeIndex);  						}    						endIndex = pathThatIsInside.Count - 1;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,OptomizePathPoints,The following statement contains a magic number: for (int startIndex = 0; startIndex < pathThatIsInside.Count - 2; startIndex++)  			{  				var startPosition = pathThatIsInside[startIndex];  				if(startPosition.X < -10000)  				{  					int a = 0;  				}  				for (int endIndex = pathThatIsInside.Count - 1; endIndex > startIndex + 1; endIndex--)  				{  					var endPosition = pathThatIsInside[endIndex];    					var crossings = new List<Tuple<int' int' IntPoint>>(BoundaryPolygons.FindCrossingPoints(startPosition' endPosition' BoundaryEdgeQuadTrees));    					bool isCrossingEdge = false;  					foreach (var cross in crossings)  					{  						if (cross.Item3 != startPosition  							&& cross.Item3 != endPosition)  						{  							isCrossingEdge = true;  							break;  						}  					}    					if (!isCrossingEdge   						&& BoundaryPolygons.PointIsInside((startPosition + endPosition) / 2' BoundaryEdgeQuadTrees' BoundaryPointQuadTrees))  					{  						// remove A+1 - B-1  						for (int removeIndex = endIndex - 1; removeIndex > startIndex; removeIndex--)  						{  							pathThatIsInside.RemoveAt(removeIndex);  						}    						endIndex = pathThatIsInside.Count - 1;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,PathFinder,C:\repos\MatterHackers_MatterSlice\Pathfinding\PathFinder.cs,OptomizePathPoints,The following statement contains a magic number: for (int startIndex = 0; startIndex < pathThatIsInside.Count - 2; startIndex++)  			{  				var startPosition = pathThatIsInside[startIndex];  				if(startPosition.X < -10000)  				{  					int a = 0;  				}  				for (int endIndex = pathThatIsInside.Count - 1; endIndex > startIndex + 1; endIndex--)  				{  					var endPosition = pathThatIsInside[endIndex];    					var crossings = new List<Tuple<int' int' IntPoint>>(BoundaryPolygons.FindCrossingPoints(startPosition' endPosition' BoundaryEdgeQuadTrees));    					bool isCrossingEdge = false;  					foreach (var cross in crossings)  					{  						if (cross.Item3 != startPosition  							&& cross.Item3 != endPosition)  						{  							isCrossingEdge = true;  							break;  						}  					}    					if (!isCrossingEdge   						&& BoundaryPolygons.PointIsInside((startPosition + endPosition) / 2' BoundaryEdgeQuadTrees' BoundaryPointQuadTrees))  					{  						// remove A+1 - B-1  						for (int removeIndex = endIndex - 1; removeIndex > startIndex; removeIndex--)  						{  							pathThatIsInside.RemoveAt(removeIndex);  						}    						endIndex = pathThatIsInside.Count - 1;  					}  				}  			}
Magic Number,MatterHackers.Pathfinding,IntPointNode,C:\repos\MatterHackers_MatterSlice\Pathfinding\IntPointPathing\IntPointNode.cs,GetHashCode,The following statement contains a magic number: return (int)Position.X + (int)(Position.Y * 1000);
