Implementation smell,Namespace,Class,File,Method,Description
Long Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisect,The method has 136 lines of code.
Long Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupSemantic,The method has 122 lines of code.
Long Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupMerge,The method has 150 lines of code.
Long Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,match_bitap,The method has 111 lines of code.
Long Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_apply,The method has 122 lines of code.
Long Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_splitMax,The method has 116 lines of code.
Long Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_fromText,The method has 101 lines of code.
Complex Method,EnergyProjects.Tests.Utils,Patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisect,Cyclomatic complexity of the method is 20
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_commonOverlap,Cyclomatic complexity of the method is 8
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupSemantic,Cyclomatic complexity of the method is 12
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupSemanticLossless,Cyclomatic complexity of the method is 9
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupEfficiency,Cyclomatic complexity of the method is 9
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupMerge,Cyclomatic complexity of the method is 18
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_fromDelta,Cyclomatic complexity of the method is 8
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,match_bitap,Cyclomatic complexity of the method is 13
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_make,Cyclomatic complexity of the method is 12
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_apply,Cyclomatic complexity of the method is 15
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_splitMax,Cyclomatic complexity of the method is 14
Complex Method,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_fromText,Cyclomatic complexity of the method is 13
Long Parameter List,d60.Cirqus.Testing,SynchronousViewManagerEventDispatcher,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\SynchronousViewManagerEventDispatcher.cs,SynchronousViewManagerEventDispatcher,The method has 5 parameters. Parameters: eventStore' aggregateRootRepository' domainEventSerializer' domainTypeNameMapper' viewManagers
Long Parameter List,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisectSplit,The method has 5 parameters. Parameters: text1' text2' x' y' deadline
Long Identifier,d60.Cirqus.Testing,TestingConfigurationExtensions,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\TestingConfigurationExtensions.cs,UseSynchronousViewManangerEventDispatcher,The length of the parameter viewManagerConfigurationContainer is 33.
Complex Conditional,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupEfficiency,The conditional expression  "(lastequality.Length != 0)                          && ((pre_ins && pre_del && post_ins && post_del)                          || ((lastequality.Length < this.Diff_EditCost / 2)                          && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0)                          + (post_del ? 1 : 0)) == 3))"  is complex.
Complex Conditional,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_splitMax,The conditional expression  "diff_type == Operation.DELETE && patch.diffs.Count == 1                            && patch.diffs.First().operation == Operation.EQUAL                            && diff_text.Length > 2 * patch_size"  is complex.
Magic Number,d60.Cirqus.Testing,SynchronousViewManagerEventDispatcher,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\SynchronousViewManagerEventDispatcher.cs,Initialize,The following statement contains a magic number: _eventStore.Stream().Batch(1000)
Magic Number,d60.Cirqus.Testing,TextFormatter,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\TextFormatter.cs,Block,The following statement contains a magic number: margin < 2
Magic Number,EnergyProjects.Tests.Utils,Differ,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\Differ.cs,LineByLine,The following statement contains a magic number: var lineArray = (List<string>)a[2];
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: string text2_a = hm[2];
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: string text2_b = hm[3];
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: string mid_common = hm[4];
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: checklines && text1.Length > 100 && text2.Length > 100
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: checklines && text1.Length > 100 && text2.Length > 100
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_lineMode,The following statement contains a magic number: List<string> linearray = (List<string>)b[2];
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int max_d = (text1_length + text2_length + 1) / 2;
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int v_length = 2 * max_d;
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: bool front = (delta % 2 != 0);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k1end += 2;
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k2end += 2;
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: longtext.Length < 4 || shorttext.Length * 2 < longtext.Length
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: longtext.Length < 4 || shorttext.Length * 2 < longtext.Length
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext'                                             (longtext.Length + 3) / 4);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext'                                             (longtext.Length + 3) / 4);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm2 = diff_halfMatchI(longtext' shorttext'                                             (longtext.Length + 1) / 2);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: string seed = longtext.Substring(i' longtext.Length / 4);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: best_common.Length * 2 >= longtext.Length
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: overlap_length1 >= deletion.Length / 2.0 ||                              overlap_length1 >= insertion.Length / 2.0
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: overlap_length1 >= deletion.Length / 2.0 ||                              overlap_length1 >= insertion.Length / 2.0
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: return 6;
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: return 5;
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: bin_mid = (bin_max - bin_min) / 2 + bin_min;
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: int[] rd = new int[finish + 2];
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: start = Math.Max(1' 2 * loc - best_loc);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: diffs.Count > 2
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: switch (aDiff.operation)                  {                      case Operation.INSERT:                          patch.diffs.Add(aDiff);                          patch.length2 += aDiff.text.Length;                          postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                          break;                      case Operation.DELETE:                          patch.length1 += aDiff.text.Length;                          patch.diffs.Add(aDiff);                          postpatch_text = postpatch_text.Remove(char_count2'                              aDiff.text.Length);                          break;                      case Operation.EQUAL:                          if (aDiff.text.Length <= 2 * Patch_Margin                              && patch.diffs.Count() != 0 && aDiff != diffs.Last())                          {                              // Small equality inside a patch.                              patch.diffs.Add(aDiff);                              patch.length1 += aDiff.text.Length;                              patch.length2 += aDiff.text.Length;                          }                            if (aDiff.text.Length >= 2 * Patch_Margin)                          {                              // Time for a new patch.                              if (patch.diffs.Count != 0)                              {                                  patch_addContext(patch' prepatch_text);                                  patches.Add(patch);                                  patch = new Patch();                                  // Unlike Unidiff' our patch lists have a rolling context.                                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                                  // Update prepatch text & pos to reflect the application of the                                  // just completed patch.                                  prepatch_text = postpatch_text;                                  char_count1 = char_count2;                              }                          }                          break;                  }
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: switch (aDiff.operation)                  {                      case Operation.INSERT:                          patch.diffs.Add(aDiff);                          patch.length2 += aDiff.text.Length;                          postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                          break;                      case Operation.DELETE:                          patch.length1 += aDiff.text.Length;                          patch.diffs.Add(aDiff);                          postpatch_text = postpatch_text.Remove(char_count2'                              aDiff.text.Length);                          break;                      case Operation.EQUAL:                          if (aDiff.text.Length <= 2 * Patch_Margin                              && patch.diffs.Count() != 0 && aDiff != diffs.Last())                          {                              // Small equality inside a patch.                              patch.diffs.Add(aDiff);                              patch.length1 += aDiff.text.Length;                              patch.length2 += aDiff.text.Length;                          }                            if (aDiff.text.Length >= 2 * Patch_Margin)                          {                              // Time for a new patch.                              if (patch.diffs.Count != 0)                              {                                  patch_addContext(patch' prepatch_text);                                  patches.Add(patch);                                  patch = new Patch();                                  // Unlike Unidiff' our patch lists have a rolling context.                                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                                  // Update prepatch text & pos to reflect the application of the                                  // just completed patch.                                  prepatch_text = postpatch_text;                                  char_count1 = char_count2;                              }                          }                          break;                  }
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_apply,The following statement contains a magic number: text = text.Substring(nullPadding.Length' text.Length                  - 2 * nullPadding.Length);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: m.Groups[2].Length == 0
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: patch.start2 = Convert.ToInt32(m.Groups[3].Value);
Magic Number,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: m.Groups[4].Length == 0
Missing Default,EnergyProjects.Tests.Utils,Differ,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\Differ.cs,PrettyLineByLine,The following switch statement is missing a default case: switch (aDiff.operation)                      {                          case Operation.INSERT:                              s.Append("+ ").AppendLine(line);                              break;                          case Operation.DELETE:                              s.Append("- ").AppendLine(line);                              break;                          case Operation.EQUAL:                              s.Append("  ").AppendLine(line);                              break;                      }
Missing Default,EnergyProjects.Tests.Utils,Patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,ToString,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          text.Append('+');                          break;                      case Operation.DELETE:                          text.Append('-');                          break;                      case Operation.EQUAL:                          text.Append(' ');                          break;                  }
Missing Default,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_lineMode,The following switch statement is missing a default case: switch (diffs[pointer].operation)                  {                      case Operation.INSERT:                          count_insert++;                          text_insert += diffs[pointer].text;                          break;                      case Operation.DELETE:                          count_delete++;                          text_delete += diffs[pointer].text;                          break;                      case Operation.EQUAL:                          // Upon reaching an equality' check for prior redundancies.                          if (count_delete >= 1 && count_insert >= 1)                          {                              // Delete the offending records and add the merged ones.                              diffs.RemoveRange(pointer - count_delete - count_insert'                                  count_delete + count_insert);                              pointer = pointer - count_delete - count_insert;                              List<Diff> a =                                  this.diff_main(text_delete' text_insert' false' deadline);                              diffs.InsertRange(pointer' a);                              pointer = pointer + a.Count;                          }                          count_insert = 0;                          count_delete = 0;                          text_delete = string.Empty;                          text_insert = string.Empty;                          break;                  }
Missing Default,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_cleanupMerge,The following switch statement is missing a default case: switch (diffs[pointer].operation)                  {                      case Operation.INSERT:                          count_insert++;                          text_insert += diffs[pointer].text;                          pointer++;                          break;                      case Operation.DELETE:                          count_delete++;                          text_delete += diffs[pointer].text;                          pointer++;                          break;                      case Operation.EQUAL:                          // Upon reaching an equality' check for prior redundancies.                          if (count_delete + count_insert > 1)                          {                              if (count_delete != 0 && count_insert != 0)                              {                                  // Factor out any common prefixies.                                  commonlength = this.diff_commonPrefix(text_insert' text_delete);                                  if (commonlength != 0)                                  {                                      if ((pointer - count_delete - count_insert) > 0 &&                                        diffs[pointer - count_delete - count_insert - 1].operation                                            == Operation.EQUAL)                                      {                                          diffs[pointer - count_delete - count_insert - 1].text                                              += text_insert.Substring(0' commonlength);                                      }                                      else                                      {                                          diffs.Insert(0' new Diff(Operation.EQUAL'                                              text_insert.Substring(0' commonlength)));                                          pointer++;                                      }                                      text_insert = text_insert.Substring(commonlength);                                      text_delete = text_delete.Substring(commonlength);                                  }                                  // Factor out any common suffixies.                                  commonlength = this.diff_commonSuffix(text_insert' text_delete);                                  if (commonlength != 0)                                  {                                      diffs[pointer].text = text_insert.Substring(text_insert.Length                                          - commonlength) + diffs[pointer].text;                                      text_insert = text_insert.Substring(0' text_insert.Length                                          - commonlength);                                      text_delete = text_delete.Substring(0' text_delete.Length                                          - commonlength);                                  }                              }                              // Delete the offending records and add the merged ones.                              if (count_delete == 0)                              {                                  diffs.Splice(pointer - count_insert'                                      count_delete + count_insert'                                      new Diff(Operation.INSERT' text_insert));                              }                              else if (count_insert == 0)                              {                                  diffs.Splice(pointer - count_delete'                                      count_delete + count_insert'                                      new Diff(Operation.DELETE' text_delete));                              }                              else                              {                                  diffs.Splice(pointer - count_delete - count_insert'                                      count_delete + count_insert'                                      new Diff(Operation.DELETE' text_delete)'                                      new Diff(Operation.INSERT' text_insert));                              }                              pointer = pointer - count_delete - count_insert +                                  (count_delete != 0 ? 1 : 0) + (count_insert != 0 ? 1 : 0) + 1;                          }                          else if (pointer != 0                            && diffs[pointer - 1].operation == Operation.EQUAL)                          {                              // Merge this equality with the previous one.                              diffs[pointer - 1].text += diffs[pointer].text;                              diffs.RemoveAt(pointer);                          }                          else                          {                              pointer++;                          }                          count_insert = 0;                          count_delete = 0;                          text_delete = string.Empty;                          text_insert = string.Empty;                          break;                  }
Missing Default,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_prettyHtml,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          html.Append("<ins style=\"background:#e6ffe6;\">").Append(text)                              .Append("</ins>");                          break;                      case Operation.DELETE:                          html.Append("<del style=\"background:#ffe6e6;\">").Append(text)                              .Append("</del>");                          break;                      case Operation.EQUAL:                          html.Append("<span>").Append(text).Append("</span>");                          break;                  }
Missing Default,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_levenshtein,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          insertions += aDiff.text.Length;                          break;                      case Operation.DELETE:                          deletions += aDiff.text.Length;                          break;                      case Operation.EQUAL:                          // A deletion and an insertion is one substitution.                          levenshtein += Math.Max(insertions' deletions);                          insertions = 0;                          deletions = 0;                          break;                  }
Missing Default,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,diff_toDelta,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          text.Append("+").Append(HttpUtility.UrlEncode(aDiff.text'                              new UTF8Encoding()).Replace('+'' ' ')).Append("\t");                          break;                      case Operation.DELETE:                          text.Append("-").Append(aDiff.text.Length).Append("\t");                          break;                      case Operation.EQUAL:                          text.Append("=").Append(aDiff.text.Length).Append("\t");                          break;                  }
Missing Default,EnergyProjects.Tests.Utils,diff_match_patch,D:\research\architectureSmells\repos\d60_Cirqus\d60.Cirqus.Testing\DiffMatchPatch.cs,patch_make,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          patch.diffs.Add(aDiff);                          patch.length2 += aDiff.text.Length;                          postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                          break;                      case Operation.DELETE:                          patch.length1 += aDiff.text.Length;                          patch.diffs.Add(aDiff);                          postpatch_text = postpatch_text.Remove(char_count2'                              aDiff.text.Length);                          break;                      case Operation.EQUAL:                          if (aDiff.text.Length <= 2 * Patch_Margin                              && patch.diffs.Count() != 0 && aDiff != diffs.Last())                          {                              // Small equality inside a patch.                              patch.diffs.Add(aDiff);                              patch.length1 += aDiff.text.Length;                              patch.length2 += aDiff.text.Length;                          }                            if (aDiff.text.Length >= 2 * Patch_Margin)                          {                              // Time for a new patch.                              if (patch.diffs.Count != 0)                              {                                  patch_addContext(patch' prepatch_text);                                  patches.Add(patch);                                  patch = new Patch();                                  // Unlike Unidiff' our patch lists have a rolling context.                                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                                  // Update prepatch text & pos to reflect the application of the                                  // just completed patch.                                  prepatch_text = postpatch_text;                                  char_count1 = char_count2;                              }                          }                          break;                  }
