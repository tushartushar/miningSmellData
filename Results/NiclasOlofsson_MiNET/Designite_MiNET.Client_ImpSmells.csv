Implementation smell,Namespace,Class,File,Method,Description
Long Method,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The method has 101 lines of code.
Long Method,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessMessage,The method has 101 lines of code.
Long Method,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,HandlePackage,The method has 258 lines of code.
Long Method,MiNET.Client,ObjectDumper,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ObjectDumper.cs,WriteObject,The method has 101 lines of code.
Complex Method,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeCraftingData,Cyclomatic complexity of the method is 11
Long Identifier,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,,The length of the parameter FirstEncryptedPacketWaitHandle is 30.
Long Statement,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,DoSendCommand,The length of the statement  "				////commandStep.commandInputJson = "{\n   \"tileName\" : \"dirt\"'\n   \"from\" : {\n      \"x\" : 0'\n      \"xrelative\" : false'\n      \"y\" : 10'\n      \"yrelative\" : false'\n      \"z\" : 0'\n      \"zrelative\" : false\n   }'\n   \"to\" : {\n      \"x\" : 10'\n      \"xrelative\" : false'\n      \"y\" : 10'\n      \"yrelative\" : false'\n      \"z\" : 10'\n      \"zrelative\" : false\n   }\n}\n"; " is 408.
Long Statement,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,DoSendCommand,The length of the statement  "				//commandStep.commandInputJson = "{\n   \"from\" : {\n      \"x\" : 0'\n      \"xrelative\" : false'\n      \"y\" : 10'\n      \"yrelative\" : false'\n      \"z\" : 0'\n      \"zrelative\" : false\n   }'\n   \"tileName\" : \"dirt\"'\n   \"to\" : {\n      \"x\" : 10'\n      \"xrelative\" : false'\n      \"y\" : 10'\n      \"yrelative\" : false'\n      \"z\" : 10'\n      \"zrelative\" : false\n   }\n}\n"; " is 406.
Long Statement,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,DoSendCommand,The length of the statement  "				////   "commandInputJson": "{\n   \"from\" : {\n      \"x\" : 0'\n      \"xrelative\" : false'\n      \"y\" : 10'\n      \"yrelative\" : false'\n      \"z\" : 0'\n      \"zrelative\" : false\n   }'\n   \"tileName\" : \"dirt\"'\n   \"to\" : {\n      \"x\" : 10'\n      \"xrelative\" : false'\n      \"y\" : 10'\n      \"yrelative\" : false'\n      \"z\" : 10'\n      \"zrelative\" : false\n   }\n}\n"' " is 400.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(null' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 134.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(null' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 134.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(new IPEndPoint(IPAddress.Parse("192.168.0.5")' 19132)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 183.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(new IPEndPoint(IPAddress.Parse("192.168.0.3")' 19132)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 183.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(new IPEndPoint(IPAddress.Parse("173.208.195.250")' 19132)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 187.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(new IPEndPoint(Dns.GetHostEntry("true-games.org").AddressList[0]' 2222)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 201.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			var client = new MiNetClient(new IPEndPoint(Dns.GetHostEntry("yodamine.com").AddressList[0]' 19132)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 198.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(new IPEndPoint(IPAddress.Loopback' 19132)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 171.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "			//var client = new MiNetClient(new IPEndPoint(IPAddress.Parse("54.229.52.56")' 27212)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount))); " is 184.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The length of the statement  "				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180))) " is 146.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessMessage,The length of the statement  "					//Log.Debug($"> Datagram #{header.datagramSequenceNumber}' {package._hasSplit}' {package._splitPacketId}' {package._reliability}' {package._reliableMessageNumber}' {package._sequencingIndex}' {package._orderingChannel}' {package._orderingIndex}"); " is 247.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,AddToProcessing,The length of the statement  "			if (Session.CryptoContext == null || Session.CryptoContext.UseEncryption == false || message.Reliability != Reliability.ReliableOrdered) " is 136.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessQueue,The length of the statement  "						if (Log.IsDebugEnabled) Log.Warn($"{Username} - Wrong sequence. Expected {_lastSequenceNumber + 1}' but was {pair.Key}."); " is 122.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,HandleSplitMessage,The length of the statement  "					Package fullMessage = PackageFactory.CreatePackage(buffer[0]' buffer' "raknet") ?? new UnknownPackage(buffer[0]' buffer); " is 121.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,HandleSplitMessage,The length of the statement  "					Log.Debug($"Assembled split package {newPackage._reliability} message #{newPackage._reliableMessageNumber}' Chan: #{newPackage._orderingChannel}' OrdIdx: #{newPackage._orderingIndex}"); " is 185.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,HandlePackage,The length of the statement  "				if (Log.IsDebugEnabled) Log.Warn($"Unhandled package 0x{message.Id:X2} {message.GetType().Name}\n{Package.HexDump(message.Bytes)}"); " is 132.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpePlayerList,The length of the statement  "				Log.Warn($"{playerRecord.GetType()} Player: {playerRecord.DisplayName}' {playerRecord.EntityId}' {playerRecord.ClientUuid}"); " is 125.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendLogin,The length of the statement  "			byte[] data = CryptoUtils.CompressJwtBytes(CryptoUtils.EncodeJwt(Username' clientKey' IsEmulator)' CryptoUtils.EncodeSkinJwt(clientKey)' CompressionLevel.Fastest); " is 163.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpePlayerEquipment,The length of the statement  "			if (Log.IsDebugEnabled) Log.Debug($"PlayerEquipment: Entity ID: {message.runtimeEntityId}' Selected Slot: {message.selectedSlot}' Slot: {message.slot}' Item ID: {message.item.Id}"); " is 181.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeCraftingData,The length of the statement  "					writer.WriteLine($"new ShapelessRecipe(new Item({shapelessRecipe.Result.Id}' {shapelessRecipe.Result.Metadata}' {shapelessRecipe.Result.Count})'"); " is 147.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeCraftingData,The length of the statement  "					writer.WriteLine($"new ShapedRecipe({shapedRecipe.Width}' {shapedRecipe.Height}' new Item({shapedRecipe.Result.Id}' {shapedRecipe.Result.Metadata}' {shapedRecipe.Result.Count})'"); " is 180.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeCraftingData,The length of the statement  "					writer.WriteLine($"new SmeltingRecipe(new Item({smeltingRecipe.Result.Id}' {smeltingRecipe.Result.Metadata}' {smeltingRecipe.Result.Count})' new Item({smeltingRecipe.Input.Id}' {smeltingRecipe.Input.Metadata}))'"); " is 214.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeContainerSetData,The length of the statement  "			if (Log.IsDebugEnabled) Log.Debug($"Set container data window 0x{message.windowId:X2} with property ID: {message.property} value: {message.value}"); " is 148.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,WriteInventoryToFile,The length of the statement  "						writer.WriteLine($"new Item({slot.Id}' {slot.Metadata}' {slot.Count}){{ExtraData = new NbtCompound {{new NbtList(\"ench\") {{new NbtCompound {{new NbtShort(\"id\"' {id})' new NbtShort(\"lvl\"' {lvl}) }} }} }} }}'"); " is 215.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,WriteInventoryToFile,The length of the statement  "							writer.WriteLine($"new Item({slot.Id}' {slot.Metadata}' {slot.Count}){{ExtraData = new NbtCompound {{ new NbtCompound(\"Fireworks\") {{ new NbtList(\"Explosions\") {{ new NbtCompound {{ new NbtByteArray(\"FireworkColor\"' new byte[]{{{fireworkColor[0]}}})' new NbtByteArray(\"FireworkFade\"' new byte[0])' new NbtByte(\"FireworkFlicker\"' {fireworkFlicker})' new NbtByte(\"FireworkTrail\"' {fireworkTrail})' new NbtByte(\"FireworkType\"' {fireworkType})  }} }}' new NbtByte(\"Flight\"' {flight}) }} }} }}'"); " is 508.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,WriteInventoryToFile,The length of the statement  "							writer.WriteLine($"new Item({slot.Id}' {slot.Metadata}' {slot.Count}){{ExtraData = new NbtCompound {{new NbtCompound(\"Fireworks\") {{new NbtList(\"Explosions\"' NbtTagType.Compound)' new NbtByte(\"Flight\"' {flight}) }} }} }}'"); " is 230.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,WriteInventoryToFile,The length of the statement  "			new ItemAir {ExtraData = new NbtCompound {new NbtList("ench") {new NbtCompound {new NbtShort("id"' 0)' new NbtShort("lvl"' 0)}}}}; " is 130.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,WriteInventoryToFile,The length of the statement  "			//var compound = new NbtCompound(string.Empty) { new NbtList("ench"' new NbtCompound()) {new NbtShort("id"' 0)'new NbtShort("lvl"' 0)'}' }; " is 139.
Long Statement,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnBatch,The length of the statement  "							//if (!(package is McpeFullChunkData)) Log.Debug($"Batch: {package.GetType().Name} 0x{package.Id:x2} \n{Package.HexDump(internalBuffer)}"); " is 139.
Magic Number,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,LookAt,The following statement contains a magic number: if (dx > 0 || dz > 0)  			{  				double tanOutput = 90 - RadianToDegree(Math.Atan(dx/(dz)));  				double thetaOffset = 270d;  				if (dz < 0)  				{  					thetaOffset = 90;  				}  				var yaw = thetaOffset + tanOutput;    				double bDiff = Math.Sqrt((dx*dx) + (dz*dz));  				var dy = (sourceLocation.Y) - (targetLocation.Y);  				double pitch = RadianToDegree(Math.Atan(dy/(bDiff)));    				pos.Yaw = (float) yaw;  				pos.HeadYaw = (float) yaw;  				pos.Pitch = (float) pitch;  			}
Magic Number,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,LookAt,The following statement contains a magic number: if (dx > 0 || dz > 0)  			{  				double tanOutput = 90 - RadianToDegree(Math.Atan(dx/(dz)));  				double thetaOffset = 270d;  				if (dz < 0)  				{  					thetaOffset = 90;  				}  				var yaw = thetaOffset + tanOutput;    				double bDiff = Math.Sqrt((dx*dx) + (dz*dz));  				var dy = (sourceLocation.Y) - (targetLocation.Y);  				double pitch = RadianToDegree(Math.Atan(dy/(bDiff)));    				pos.Yaw = (float) yaw;  				pos.HeadYaw = (float) yaw;  				pos.Pitch = (float) pitch;  			}
Magic Number,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,RadianToDegree,The following statement contains a magic number: return angle*(180.0/Math.PI);
Magic Number,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,DoWaitForSpawn,The following statement contains a magic number: return () =>  			{  				while (!client.HasSpawned)  				{  					Thread.Sleep(50);  				}  			};
Magic Number,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,DoMobEquipment,The following statement contains a magic number: Action<Task' Item' int> doMobEquipmentTask = (t' item' selectedSlot) =>  			{  				McpeMobEquipment message = new McpeMobEquipment();  				message.runtimeEntityId = client.EntityId;  				message.item = item;  				message.selectedSlot = (byte) selectedSlot;  				message.slot = (byte) (selectedSlot + 9);  				client.SendPackage(message);  			};
Magic Number,MiNET.Client,BotHelpers,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\BotHelpers.cs,DoMoveTo,The following statement contains a magic number: Action<Task' PlayerLocation> doMoveTo = (t' loc) =>  			{  				Vector3 originalPosition = client.CurrentLocation.ToVector3();  				Vector3 targetPosition = loc.ToVector3();    				PlayerLocation lookAtPos = LookAt(originalPosition + new Vector3(0' 1.62f' 0)' targetPosition);    				{  					// First just rotate towards target pos  					McpeMovePlayer movePlayerPacket = McpeMovePlayer.CreateObject();  					movePlayerPacket.runtimeEntityId = client.EntityId;  					movePlayerPacket.x = client.CurrentLocation.X;  					movePlayerPacket.y = client.CurrentLocation.Y;  					movePlayerPacket.z = client.CurrentLocation.Z;  					movePlayerPacket.yaw = lookAtPos.Yaw;  					movePlayerPacket.pitch = lookAtPos.Pitch;  					movePlayerPacket.headYaw = lookAtPos.HeadYaw;  				}  				float lenght = Math.Abs((originalPosition - targetPosition).Length());    				float stepLen = 0.5f;  				float weight;    				while (true)  				{  					if (Math.Abs((targetPosition - client.CurrentLocation.ToVector3()).Length()) > stepLen)  					{  						float lenLeft = Math.Abs((client.CurrentLocation.ToVector3() - targetPosition).Length());  						weight = Math.Abs((float) ((lenLeft - stepLen)/lenght));    						client.CurrentLocation = new PlayerLocation(Vector3.Lerp(originalPosition' targetPosition' 1 - weight));    						McpeMovePlayer movePlayerPacket = McpeMovePlayer.CreateObject();  						movePlayerPacket.runtimeEntityId = client.EntityId;  						movePlayerPacket.x = client.CurrentLocation.X;  						movePlayerPacket.y = client.CurrentLocation.Y;  						movePlayerPacket.z = client.CurrentLocation.Z;  						movePlayerPacket.yaw = lookAtPos.Yaw;  						movePlayerPacket.pitch = lookAtPos.Pitch;  						movePlayerPacket.headYaw = lookAtPos.HeadYaw;    						client.SendPackage(movePlayerPacket);    						Thread.Sleep(50);  						continue;  					}  					{  						client.CurrentLocation = new PlayerLocation(targetPosition);    						McpeMovePlayer movePlayerPacket = McpeMovePlayer.CreateObject();  						movePlayerPacket.runtimeEntityId = client.EntityId;  						movePlayerPacket.x = client.CurrentLocation.X;  						movePlayerPacket.y = client.CurrentLocation.Y;  						movePlayerPacket.z = client.CurrentLocation.Z;  						movePlayerPacket.yaw = lookAtPos.Yaw;  						movePlayerPacket.pitch = lookAtPos.Pitch;  						movePlayerPacket.headYaw = lookAtPos.HeadYaw;    						client.SendPackage(movePlayerPacket);  					}  					break;  				}  			};
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,DecocedChunkColumn,The following statement contains a magic number: lock (_chunkRead)  			{  				MemoryStream stream = new MemoryStream(buffer);  				{  					NbtBinaryReader defStream = new NbtBinaryReader(stream' true);    					Log.Debug("New chunk column");    					int count = defStream.ReadByte();  					if (count < 1)  					{  						Log.Warn("Nothing to read");  						return null;  					}    					Log.Debug($"Reading {count} sections");    					ChunkColumn chunkColumn = new ChunkColumn();    					for (int s = 0; s < count; s++)  					{  						int idx = defStream.ReadByte();    						Log.Debug($"New section {s}' index={idx}");  						Chunk chunk = chunkColumn.chunks[s];    						int chunkSize = 16*16*16;  						defStream.Read(chunk.blocks' 0' chunkSize);  						//Log.Debug($"Blocks1:\n{Package.HexDump(chunk.blocks)}");    						if (defStream.Read(chunk.metadata.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: metadata");    						//Log.Debug($"metadata:\n{Package.HexDump(chunk.metadata.Data)}");    						//if (defStream.Read(chunk.skylight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: skylight");  						//Log.Debug($"skylight:\n{Package.HexDump(chunk.skylight.Data)}");    						//if (defStream.Read(chunk.blocklight.Data' 0' chunkSize/2) != chunkSize/2) Log.Error($"Out of data: blocklight");  						//Log.Debug($"blocklight:\n{Package.HexDump(chunk.blocklight.Data)}");    						//Log.Debug($"skylight.Data:\n{Package.HexDump(chunk.skylight.Data' 64)}");  						//Log.Debug($"blocklight.Data:\n{Package.HexDump(chunk.blocklight.Data)}");    						//byte[] ints = new byte[256*4];  						//var readLen = defStream.Read(ints' 0' ints.Length);  						//if (readLen != ints.Length) Log.Error($"Out of data biomeColors' read lenght {readLen}");  						//Log.Debug($"biomeColor (pre):\n{Package.HexDump(ints)}");    						//return null;  						//int j = 0;  						//for (int i = 0; i < ints.Length; i = i + 4)  						//{  						//	chunk.biomeId[j] = ints[i];  						//	chunk.biomeColor[j++] = BitConverter.ToInt32(new[] {(byte) 0' ints[i + 1]' ints[i + 2]' ints[i + 3]}' 0);  						//}  						//Log.Debug($"biomeId (post):\n{Package.HexDump(chunk.biomeId)}");    						//if (stream.Position >= stream.Length - 1) return chunk;    						////return chunk;    						//return chunk;  					}    					//if (stream.Position >= stream.Length - 1) continue;      					byte[] ba = new byte[512];  					if (defStream.Read(ba' 0' 256*2) != 256*2) Log.Error($"Out of data height");    					Buffer.BlockCopy(ba' 0' chunkColumn.height' 0' 512);  					//Log.Debug($"Heights:\n{Package.HexDump(ba)}");    					//if (stream.Position >= stream.Length - 1) continue;    					if (defStream.Read(chunkColumn.biomeId' 0' 256) != 256) Log.Error($"Out of data biomeId");  					//Log.Debug($"biomeId:\n{Package.HexDump(chunk.biomeId)}");    					//if (stream.Position >= stream.Length - 1) continue;      					int borderBlock = VarInt.ReadInt32(stream);  					if (borderBlock != 0)  					{  						byte[] buf = new byte[borderBlock];  						int len = defStream.Read(buf' 0' borderBlock);  						Log.Warn($"??? Got borderblock {borderBlock}. Read {len} bytes");  						Log.Debug($"{Package.HexDump(buf)}");  						for (int i = 0; i < borderBlock; i++)  						{  							int x = (buf[i] & 0xf0) >> 4;  							int z = buf[i] & 0x0f;  							Log.Debug($"x={x}' z={z}");  						}  					}    					int extraCount = VarInt.ReadSInt32(stream);  					if (extraCount != 0)  					{  						//Log.Warn($"Got extradata\n{Package.HexDump(defStream.ReadBytes(extraCount*10))}");  						for (int i = 0; i < extraCount; i++)  						{  							var hash = VarInt.ReadSInt32(stream);  							var blockData = defStream.ReadInt16();  							Log.Warn($"Got extradata: hash=0x{hash:X2}' blockdata=0x{blockData:X2}");  						}  					}    					if (stream.Position < stream.Length - 1)  					{  						//Log.Debug($"Got NBT data\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");    						while (stream.Position < stream.Length)  						{  							NbtFile file = new NbtFile() {BigEndian = false' UseVarInt = true};    							file.LoadFromStream(stream' NbtCompression.None);    							Log.Debug($"Blockentity: {file.RootTag}");  						}  					}  					if (stream.Position < stream.Length - 1)  					{  						Log.Warn($"Still have data to read\n{Package.HexDump(defStream.ReadBytes((int) (stream.Length - stream.Position)))}");  					}    					return chunkColumn;  				}  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,SetNibble4,The following statement contains a magic number: if (index%2 == 0)  			{  				arr[index/2] = (byte) ((value & 0x0F) | arr[index/2]);  			}  			else  			{  				arr[index/2] = (byte) (((value << 4) & 0xF0) | arr[index/2]);  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,SetNibble4,The following statement contains a magic number: if (index%2 == 0)  			{  				arr[index/2] = (byte) ((value & 0x0F) | arr[index/2]);  			}  			else  			{  				arr[index/2] = (byte) (((value << 4) & 0xF0) | arr[index/2]);  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,SetNibble4,The following statement contains a magic number: if (index%2 == 0)  			{  				arr[index/2] = (byte) ((value & 0x0F) | arr[index/2]);  			}  			else  			{  				arr[index/2] = (byte) (((value << 4) & 0xF0) | arr[index/2]);  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,SetNibble4,The following statement contains a magic number: if (index%2 == 0)  			{  				arr[index/2] = (byte) ((value & 0x0F) | arr[index/2]);  			}  			else  			{  				arr[index/2] = (byte) (((value << 4) & 0xF0) | arr[index/2]);  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,SetNibble4,The following statement contains a magic number: if (index%2 == 0)  			{  				arr[index/2] = (byte) ((value & 0x0F) | arr[index/2]);  			}  			else  			{  				arr[index/2] = (byte) (((value << 4) & 0xF0) | arr[index/2]);  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,SetNibble4,The following statement contains a magic number: if (index%2 == 0)  			{  				arr[index/2] = (byte) ((value & 0x0F) | arr[index/2]);  			}  			else  			{  				arr[index/2] = (byte) (((value << 4) & 0xF0) | arr[index/2]);  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,ClientUtils,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ClientUtils.cs,CreateNbtFromChunkColumn,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				NbtCompound sectionTag = new NbtCompound();  				sectionsTag.Add(sectionTag);  				sectionTag.Add(new NbtByte("Y"' (byte) i));  				int sy = i*16;    				byte[] blocks = new byte[4096];  				byte[] data = new byte[2048];  				byte[] blockLight = new byte[2048];  				byte[] skyLight = new byte[2048];    				for (int x = 0; x < 16; x++)  				{  					for (int z = 0; z < 16; z++)  					{  						for (int y = 0; y < 16; y++)  						{  							int yi = sy + y;  							if (yi < 0 || yi >= 256) continue; // ?    							int anvilIndex = (y + _waterOffsetY)*16*16 + z*16 + x;  							byte blockId = chunk.GetBlock(x' yi' z);    							// PE to Anvil friendly converstion  							if (blockId == 5) blockId = 125;  							else if (blockId == 158) blockId = 126;  							else if (blockId == 50) blockId = 75;  							else if (blockId == 50) blockId = 76;  							else if (blockId == 89) blockId = 123;  							else if (blockId == 89) blockId = 124;  							else if (blockId == 73) blockId = 152;    							blocks[anvilIndex] = blockId;  							SetNibble4(data' anvilIndex' chunk.GetMetadata(x' yi' z));  							SetNibble4(blockLight' anvilIndex' chunk.GetBlocklight(x' yi' z));  							SetNibble4(skyLight' anvilIndex' chunk.GetSkylight(x' yi' z));  						}  					}  				}    				sectionTag.Add(new NbtByteArray("Blocks"' blocks));  				sectionTag.Add(new NbtByteArray("Data"' data));  				sectionTag.Add(new NbtByteArray("BlockLight"' blockLight));  				sectionTag.Add(new NbtByteArray("SkyLight"' skyLight));  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: var client = new MiNetClient(new IPEndPoint(Dns.GetHostEntry("yodamine.com").AddressList[0]' 19132)' "TheGrey"' new DedicatedThreadPool(new DedicatedThreadPoolSettings(Environment.ProcessorCount)));
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: if (client._serverEndpoint != null)  			{  				while (!client.HaveServer)  				{  					Console.WriteLine("Sending ping...");  					client.SendUnconnectedPing();  					Thread.Sleep(500);  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,Main,The following statement contains a magic number: Task.Run(BotHelpers.DoWaitForSpawn(client))  				.ContinueWith(t => BotHelpers.DoMobEquipment(client)(t' new ItemBlock(new Cobblestone()' 0) {Count = 64}' 0))  				//.ContinueWith(t => BotHelpers.DoMoveTo(client)(t' new PlayerLocation(client.CurrentLocation.ToVector3() - new Vector3(0' 1' 0)' 180' 180' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(40' 5.62f' -20' 180' 180' 180)))  				.ContinueWith(t => doMoveTo(t' new PlayerLocation(0' 5.62' 0' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(22' 5.62' 40' 180 + 45' 180 + 45' 180)))  				//.ContinueWith(t => doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180)))  				.ContinueWith(t => doSendCommand(t' "/testfor gurunx"))  				.ContinueWith(t => Task.Delay(5000).Wait())  				//.ContinueWith(t =>  				//{  				//	Random rnd = new Random();  				//	while (true)  				//	{  				//		doMoveTo(t' new PlayerLocation(rnd.Next(10' 40)' 5.62f' rnd.Next(-50' -10)' 180' 180' 180));  				//		//doMoveTo(t' new PlayerLocation(50' 5.62f' 17' 180' 180' 180));  				//		doMoveTo(t' new PlayerLocation(rnd.Next(40' 50)' 5.62f' rnd.Next(0' 20)' 180' 180' 180));  				//	}  				//})  				;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,StartClient,The following statement contains a magic number: try  			{  				Log.Info("Initializing...");    				UdpClient = new UdpClient(_clientEndpoint)  				{  					Client =  					{  						ReceiveBufferSize = int.MaxValue'  						SendBufferSize = int.MaxValue  					}'  					DontFragment = false  				};    				// SIO_UDP_CONNRESET (opcode setting: I' T==3)  				// Windows:  Controls whether UDP PORT_UNREACHABLE messages are reported.  				// - Set to TRUE to enable reporting.  				// - Set to FALSE to disable reporting.    				uint IOC_IN = 0x80000000;  				uint IOC_VENDOR = 0x18000000;  				uint SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12;  				UdpClient.Client.IOControl((int) SIO_UDP_CONNRESET' new byte[] {Convert.ToByte(false)}' null);    				////  				////WARNING: We need to catch errors here to remove the code above.  				////    				//Task.Run(ProcessQueue);    				Session = new PlayerNetworkSession(null' null' _clientEndpoint' _mtuSize);    				//UdpClient.BeginReceive(ReceiveCallback' UdpClient);  				_mainProcessingThread = new Thread(ProcessDatagrams) {IsBackground = true};  				_mainProcessingThread.Start(UdpClient);    				_clientEndpoint = (IPEndPoint) UdpClient.Client.LocalEndPoint;    				Log.InfoFormat("Server open for business for {0}"' Username);    				return;  			}  			catch (Exception e)  			{  				Log.Error("Main loop"' e);  				StopClient();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessMessage,The following statement contains a magic number: if (msgId <= (byte) DefaultMessageIdTypes.ID_USER_PACKET_ENUM)  			{  				DefaultMessageIdTypes msgIdType = (DefaultMessageIdTypes) msgId;    				Package message = PackageFactory.CreatePackage(msgId' receiveBytes' "raknet");    				if (message == null) return;    				TraceReceive(message);    				switch (msgIdType)  				{  					case DefaultMessageIdTypes.ID_UNCONNECTED_PONG:  					{  						UnconnectedPong incoming = (UnconnectedPong) message;  						Log.Warn($"MOTD: {incoming.serverName}");  						if (!HaveServer)  						{  							_serverEndpoint = senderEndpoint;  							HaveServer = true;  							SendOpenConnectionRequest1();  						}    						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_1:  					{  						OpenConnectionReply1 incoming = (OpenConnectionReply1) message;  						if (incoming.mtuSize != _mtuSize) Log.Warn("Error' mtu differ from what we sent:" + incoming.mtuSize);  						Log.Warn($"Server with ID {incoming.serverGuid} security={incoming.serverHasSecurity}");  						_mtuSize = incoming.mtuSize;  						SendOpenConnectionRequest2();  						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_2:  					{  						OnOpenConnectionReply2((OpenConnectionReply2) message);  						break;  					}  					case DefaultMessageIdTypes.ID_NO_FREE_INCOMING_CONNECTIONS:  					{  						OnNoFreeIncomingConnections((NoFreeIncomingConnections) message);  						break;  					}  				}  			}  			else  			{  				DatagramHeader header = new DatagramHeader(receiveBytes[0]);  				if (!header.isACK && !header.isNAK && header.isValid)  				{  					if (receiveBytes[0] == 0xa0)  					{  						throw new Exception("Receive ERROR' NAK in wrong place");  					}    					if (IsEmulator && PlayerStatus == 3)  					{  						int datagramId = new Int24(new[] {receiveBytes[1]' receiveBytes[2]' receiveBytes[3]});    						//Acks ack = Acks.CreateObject();  						Acks ack = new Acks();  						ack.acks.Add(datagramId);  						byte[] data = ack.Encode();  						ack.PutPool();  						SendData(data' senderEndpoint);    						return;  					}    					ConnectedPackage package = ConnectedPackage.CreateObject();  					package.Decode(receiveBytes);  					header = package._datagramHeader;  					//Log.Debug($"> Datagram #{header.datagramSequenceNumber}' {package._hasSplit}' {package._splitPacketId}' {package._reliability}' {package._reliableMessageNumber}' {package._sequencingIndex}' {package._orderingChannel}' {package._orderingIndex}");    					{  						Acks ack = Acks.CreateObject();  						ack.acks.Add(package._datagramSequenceNumber.IntValue());  						byte[] data = ack.Encode();  						ack.PutPool();  						SendData(data' senderEndpoint);  					}    					HandleConnectedPackage(package);  					package.PutPool();  				}  				else if (header.isPacketPair)  				{  					Log.Warn("header.isPacketPair");  				}  				else if (header.isACK && header.isValid)  				{  					HandleAck(receiveBytes' senderEndpoint);  				}  				else if (header.isNAK && header.isValid)  				{  					Nak nak = new Nak();  					nak.Decode(receiveBytes);  					HandleNak(receiveBytes' senderEndpoint);  				}  				else if (!header.isValid)  				{  					Log.Warn("!!!! ERROR' Invalid header !!!!!");  				}  				else  				{  					Log.Warn("!! WHAT THE F");  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessMessage,The following statement contains a magic number: if (msgId <= (byte) DefaultMessageIdTypes.ID_USER_PACKET_ENUM)  			{  				DefaultMessageIdTypes msgIdType = (DefaultMessageIdTypes) msgId;    				Package message = PackageFactory.CreatePackage(msgId' receiveBytes' "raknet");    				if (message == null) return;    				TraceReceive(message);    				switch (msgIdType)  				{  					case DefaultMessageIdTypes.ID_UNCONNECTED_PONG:  					{  						UnconnectedPong incoming = (UnconnectedPong) message;  						Log.Warn($"MOTD: {incoming.serverName}");  						if (!HaveServer)  						{  							_serverEndpoint = senderEndpoint;  							HaveServer = true;  							SendOpenConnectionRequest1();  						}    						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_1:  					{  						OpenConnectionReply1 incoming = (OpenConnectionReply1) message;  						if (incoming.mtuSize != _mtuSize) Log.Warn("Error' mtu differ from what we sent:" + incoming.mtuSize);  						Log.Warn($"Server with ID {incoming.serverGuid} security={incoming.serverHasSecurity}");  						_mtuSize = incoming.mtuSize;  						SendOpenConnectionRequest2();  						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_2:  					{  						OnOpenConnectionReply2((OpenConnectionReply2) message);  						break;  					}  					case DefaultMessageIdTypes.ID_NO_FREE_INCOMING_CONNECTIONS:  					{  						OnNoFreeIncomingConnections((NoFreeIncomingConnections) message);  						break;  					}  				}  			}  			else  			{  				DatagramHeader header = new DatagramHeader(receiveBytes[0]);  				if (!header.isACK && !header.isNAK && header.isValid)  				{  					if (receiveBytes[0] == 0xa0)  					{  						throw new Exception("Receive ERROR' NAK in wrong place");  					}    					if (IsEmulator && PlayerStatus == 3)  					{  						int datagramId = new Int24(new[] {receiveBytes[1]' receiveBytes[2]' receiveBytes[3]});    						//Acks ack = Acks.CreateObject();  						Acks ack = new Acks();  						ack.acks.Add(datagramId);  						byte[] data = ack.Encode();  						ack.PutPool();  						SendData(data' senderEndpoint);    						return;  					}    					ConnectedPackage package = ConnectedPackage.CreateObject();  					package.Decode(receiveBytes);  					header = package._datagramHeader;  					//Log.Debug($"> Datagram #{header.datagramSequenceNumber}' {package._hasSplit}' {package._splitPacketId}' {package._reliability}' {package._reliableMessageNumber}' {package._sequencingIndex}' {package._orderingChannel}' {package._orderingIndex}");    					{  						Acks ack = Acks.CreateObject();  						ack.acks.Add(package._datagramSequenceNumber.IntValue());  						byte[] data = ack.Encode();  						ack.PutPool();  						SendData(data' senderEndpoint);  					}    					HandleConnectedPackage(package);  					package.PutPool();  				}  				else if (header.isPacketPair)  				{  					Log.Warn("header.isPacketPair");  				}  				else if (header.isACK && header.isValid)  				{  					HandleAck(receiveBytes' senderEndpoint);  				}  				else if (header.isNAK && header.isValid)  				{  					Nak nak = new Nak();  					nak.Decode(receiveBytes);  					HandleNak(receiveBytes' senderEndpoint);  				}  				else if (!header.isValid)  				{  					Log.Warn("!!!! ERROR' Invalid header !!!!!");  				}  				else  				{  					Log.Warn("!! WHAT THE F");  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessMessage,The following statement contains a magic number: if (msgId <= (byte) DefaultMessageIdTypes.ID_USER_PACKET_ENUM)  			{  				DefaultMessageIdTypes msgIdType = (DefaultMessageIdTypes) msgId;    				Package message = PackageFactory.CreatePackage(msgId' receiveBytes' "raknet");    				if (message == null) return;    				TraceReceive(message);    				switch (msgIdType)  				{  					case DefaultMessageIdTypes.ID_UNCONNECTED_PONG:  					{  						UnconnectedPong incoming = (UnconnectedPong) message;  						Log.Warn($"MOTD: {incoming.serverName}");  						if (!HaveServer)  						{  							_serverEndpoint = senderEndpoint;  							HaveServer = true;  							SendOpenConnectionRequest1();  						}    						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_1:  					{  						OpenConnectionReply1 incoming = (OpenConnectionReply1) message;  						if (incoming.mtuSize != _mtuSize) Log.Warn("Error' mtu differ from what we sent:" + incoming.mtuSize);  						Log.Warn($"Server with ID {incoming.serverGuid} security={incoming.serverHasSecurity}");  						_mtuSize = incoming.mtuSize;  						SendOpenConnectionRequest2();  						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_2:  					{  						OnOpenConnectionReply2((OpenConnectionReply2) message);  						break;  					}  					case DefaultMessageIdTypes.ID_NO_FREE_INCOMING_CONNECTIONS:  					{  						OnNoFreeIncomingConnections((NoFreeIncomingConnections) message);  						break;  					}  				}  			}  			else  			{  				DatagramHeader header = new DatagramHeader(receiveBytes[0]);  				if (!header.isACK && !header.isNAK && header.isValid)  				{  					if (receiveBytes[0] == 0xa0)  					{  						throw new Exception("Receive ERROR' NAK in wrong place");  					}    					if (IsEmulator && PlayerStatus == 3)  					{  						int datagramId = new Int24(new[] {receiveBytes[1]' receiveBytes[2]' receiveBytes[3]});    						//Acks ack = Acks.CreateObject();  						Acks ack = new Acks();  						ack.acks.Add(datagramId);  						byte[] data = ack.Encode();  						ack.PutPool();  						SendData(data' senderEndpoint);    						return;  					}    					ConnectedPackage package = ConnectedPackage.CreateObject();  					package.Decode(receiveBytes);  					header = package._datagramHeader;  					//Log.Debug($"> Datagram #{header.datagramSequenceNumber}' {package._hasSplit}' {package._splitPacketId}' {package._reliability}' {package._reliableMessageNumber}' {package._sequencingIndex}' {package._orderingChannel}' {package._orderingIndex}");    					{  						Acks ack = Acks.CreateObject();  						ack.acks.Add(package._datagramSequenceNumber.IntValue());  						byte[] data = ack.Encode();  						ack.PutPool();  						SendData(data' senderEndpoint);  					}    					HandleConnectedPackage(package);  					package.PutPool();  				}  				else if (header.isPacketPair)  				{  					Log.Warn("header.isPacketPair");  				}  				else if (header.isACK && header.isValid)  				{  					HandleAck(receiveBytes' senderEndpoint);  				}  				else if (header.isNAK && header.isValid)  				{  					Nak nak = new Nak();  					nak.Decode(receiveBytes);  					HandleNak(receiveBytes' senderEndpoint);  				}  				else if (!header.isValid)  				{  					Log.Warn("!!!! ERROR' Invalid header !!!!!");  				}  				else  				{  					Log.Warn("!! WHAT THE F");  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessQueue,The following statement contains a magic number: while (true)  			{  				KeyValuePair<int' Package> pair;    				if (_queue.TryPeek(out pair))  				{  					if (pair.Key == _lastSequenceNumber + 1)  					{  						if (_queue.TryDequeue(out pair))  						{  							_lastSequenceNumber = pair.Key;    							HandlePackage(pair.Value);    							if (_queue.Count == 0)  							{  								WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  							}  						}  					}  					else if (pair.Key <= _lastSequenceNumber)  					{  						if (Log.IsDebugEnabled) Log.Warn($"{Username} - Resent. Expected {_lastSequenceNumber + 1}' but was {pair.Key}.");  						if (_queue.TryDequeue(out pair))  						{  							pair.Value.PutPool();  						}  					}  					else  					{  						if (Log.IsDebugEnabled) Log.Warn($"{Username} - Wrong sequence. Expected {_lastSequenceNumber + 1}' but was {pair.Key}.");  						WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  					}  				}  				else  				{  					if (_queue.Count == 0)  					{  						WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  					}  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessQueue,The following statement contains a magic number: while (true)  			{  				KeyValuePair<int' Package> pair;    				if (_queue.TryPeek(out pair))  				{  					if (pair.Key == _lastSequenceNumber + 1)  					{  						if (_queue.TryDequeue(out pair))  						{  							_lastSequenceNumber = pair.Key;    							HandlePackage(pair.Value);    							if (_queue.Count == 0)  							{  								WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  							}  						}  					}  					else if (pair.Key <= _lastSequenceNumber)  					{  						if (Log.IsDebugEnabled) Log.Warn($"{Username} - Resent. Expected {_lastSequenceNumber + 1}' but was {pair.Key}.");  						if (_queue.TryDequeue(out pair))  						{  							pair.Value.PutPool();  						}  					}  					else  					{  						if (Log.IsDebugEnabled) Log.Warn($"{Username} - Wrong sequence. Expected {_lastSequenceNumber + 1}' but was {pair.Key}.");  						WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  					}  				}  				else  				{  					if (_queue.Count == 0)  					{  						WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  					}  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessQueue,The following statement contains a magic number: while (true)  			{  				KeyValuePair<int' Package> pair;    				if (_queue.TryPeek(out pair))  				{  					if (pair.Key == _lastSequenceNumber + 1)  					{  						if (_queue.TryDequeue(out pair))  						{  							_lastSequenceNumber = pair.Key;    							HandlePackage(pair.Value);    							if (_queue.Count == 0)  							{  								WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  							}  						}  					}  					else if (pair.Key <= _lastSequenceNumber)  					{  						if (Log.IsDebugEnabled) Log.Warn($"{Username} - Resent. Expected {_lastSequenceNumber + 1}' but was {pair.Key}.");  						if (_queue.TryDequeue(out pair))  						{  							pair.Value.PutPool();  						}  					}  					else  					{  						if (Log.IsDebugEnabled) Log.Warn($"{Username} - Wrong sequence. Expected {_lastSequenceNumber + 1}' but was {pair.Key}.");  						WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  					}  				}  				else  				{  					if (_queue.Count == 0)  					{  						WaitHandle.SignalAndWait(_mainWaitEvent' _waitEvent' TimeSpan.FromMilliseconds(50)' true);  					}  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnOpenConnectionReply2,The following statement contains a magic number: Thread.Sleep(100);
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeChangeDimension,The following statement contains a magic number: Thread.Sleep(3000);
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeResourcePacksInfo,The following statement contains a magic number: if (message.resourcepackinfos.Count != 0)  			{  				ResourcePackIds resourcePackIds = new ResourcePackIds();    				foreach (var packInfo in message.resourcepackinfos)  				{  					resourcePackIds.Add(packInfo.PackIdVersion.Id);  				}    				McpeResourcePackClientResponse response = new McpeResourcePackClientResponse();  				response.responseStatus = 2;  				response.resourcepackids = resourcePackIds;  				SendPackage(response);  			}  			else  			{  				McpeResourcePackClientResponse response = new McpeResourcePackClientResponse();  				response.responseStatus = 3;  				SendPackage(response);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeResourcePacksInfo,The following statement contains a magic number: if (message.resourcepackinfos.Count != 0)  			{  				ResourcePackIds resourcePackIds = new ResourcePackIds();    				foreach (var packInfo in message.resourcepackinfos)  				{  					resourcePackIds.Add(packInfo.PackIdVersion.Id);  				}    				McpeResourcePackClientResponse response = new McpeResourcePackClientResponse();  				response.responseStatus = 2;  				response.resourcepackids = resourcePackIds;  				SendPackage(response);  			}  			else  			{  				McpeResourcePackClientResponse response = new McpeResourcePackClientResponse();  				response.responseStatus = 3;  				SendPackage(response);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeResourcePackStack,The following statement contains a magic number: {  				McpeResourcePackClientResponse response = new McpeResourcePackClientResponse();  				response.responseStatus = 4;  				SendPackage(response);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeResourcePackChunkData,The following statement contains a magic number: if (resourcePackDataInfos.Count == 0)  			{  				McpeResourcePackClientResponse response = new McpeResourcePackClientResponse();  				response.responseStatus = 3;  				SendPackage(response);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendLogin,The following statement contains a magic number: McpeLogin loginPacket = new McpeLogin  			{  				protocolVersion = Config.GetProperty("EnableEdu"' false) ? 111 : 150'  				payload = data  			};
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendLogin,The following statement contains a magic number: McpeLogin loginPacket = new McpeLogin  			{  				protocolVersion = Config.GetProperty("EnableEdu"' false) ? 111 : 150'  				payload = data  			};
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,InitiateEncryption,The following statement contains a magic number: try  			{  				ECDiffieHellmanPublicKey publicKey = CryptoUtils.FromDerEncoded(serverKey);  				Log.Debug("ServerKey (b64):\n" + serverKey);  				Log.Debug($"Cert:\n{publicKey.ToXmlString()}");    				Log.Debug($"RANDOM TOKEN (raw):\n\n{Encoding.UTF8.GetString(randomKeyToken)}");    				if (randomKeyToken.Length != 0)  				{  					Log.Error("Lenght of random bytes: " + randomKeyToken.Length);  				}    				// Create shared shared secret  				ECDiffieHellmanCng ecKey = new ECDiffieHellmanCng(Session.CryptoContext.ClientKey);  				ecKey.HashAlgorithm = CngAlgorithm.Sha256;  				ecKey.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;  				ecKey.SecretPrepend = randomKeyToken; // Server token    				byte[] secret = ecKey.DeriveKeyMaterial(publicKey);    				//Log.Debug($"SECRET KEY (b64):\n{Convert.ToBase64String(secret)}");  				Log.Debug($"SECRET KEY (raw):\n{Encoding.UTF8.GetString(secret)}");    				{  					RijndaelManaged rijAlg = new RijndaelManaged  					{  						BlockSize = 128'  						Padding = PaddingMode.None'  						Mode = CipherMode.CFB'  						FeedbackSize = 8'  						Key = secret'  						IV = secret.Take(16).ToArray()'  					};    					// Create a decrytor to perform the stream transform.  					ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream inputStream = new MemoryStream();  					CryptoStream cryptoStreamIn = new CryptoStream(inputStream' decryptor' CryptoStreamMode.Read);    					ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream outputStream = new MemoryStream();  					CryptoStream cryptoStreamOut = new CryptoStream(outputStream' encryptor' CryptoStreamMode.Write);    					Session.CryptoContext = new CryptoContext  					{  						Algorithm = rijAlg'  						Decryptor = decryptor'  						Encryptor = encryptor'  						InputStream = inputStream'  						OutputStream = outputStream'  						CryptoStreamIn = cryptoStreamIn'  						CryptoStreamOut = cryptoStreamOut'  						UseEncryption = true'  					};  				}    				Thread.Sleep(1250);  				McpeClientToServerHandshake magic = new McpeClientToServerHandshake();  				//byte[] encodedMagic = magic.Encode();  				//McpeBatch batch = BatchUtils.CreateBatchPacket(encodedMagic' 0' encodedMagic.Length' CompressionLevel.Fastest' true);  				//batch.Encode();  				SendPackage(magic);  			}  			catch (Exception e)  			{  				Log.Error("Initiate encryption"' e);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,InitiateEncryption,The following statement contains a magic number: try  			{  				ECDiffieHellmanPublicKey publicKey = CryptoUtils.FromDerEncoded(serverKey);  				Log.Debug("ServerKey (b64):\n" + serverKey);  				Log.Debug($"Cert:\n{publicKey.ToXmlString()}");    				Log.Debug($"RANDOM TOKEN (raw):\n\n{Encoding.UTF8.GetString(randomKeyToken)}");    				if (randomKeyToken.Length != 0)  				{  					Log.Error("Lenght of random bytes: " + randomKeyToken.Length);  				}    				// Create shared shared secret  				ECDiffieHellmanCng ecKey = new ECDiffieHellmanCng(Session.CryptoContext.ClientKey);  				ecKey.HashAlgorithm = CngAlgorithm.Sha256;  				ecKey.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;  				ecKey.SecretPrepend = randomKeyToken; // Server token    				byte[] secret = ecKey.DeriveKeyMaterial(publicKey);    				//Log.Debug($"SECRET KEY (b64):\n{Convert.ToBase64String(secret)}");  				Log.Debug($"SECRET KEY (raw):\n{Encoding.UTF8.GetString(secret)}");    				{  					RijndaelManaged rijAlg = new RijndaelManaged  					{  						BlockSize = 128'  						Padding = PaddingMode.None'  						Mode = CipherMode.CFB'  						FeedbackSize = 8'  						Key = secret'  						IV = secret.Take(16).ToArray()'  					};    					// Create a decrytor to perform the stream transform.  					ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream inputStream = new MemoryStream();  					CryptoStream cryptoStreamIn = new CryptoStream(inputStream' decryptor' CryptoStreamMode.Read);    					ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream outputStream = new MemoryStream();  					CryptoStream cryptoStreamOut = new CryptoStream(outputStream' encryptor' CryptoStreamMode.Write);    					Session.CryptoContext = new CryptoContext  					{  						Algorithm = rijAlg'  						Decryptor = decryptor'  						Encryptor = encryptor'  						InputStream = inputStream'  						OutputStream = outputStream'  						CryptoStreamIn = cryptoStreamIn'  						CryptoStreamOut = cryptoStreamOut'  						UseEncryption = true'  					};  				}    				Thread.Sleep(1250);  				McpeClientToServerHandshake magic = new McpeClientToServerHandshake();  				//byte[] encodedMagic = magic.Encode();  				//McpeBatch batch = BatchUtils.CreateBatchPacket(encodedMagic' 0' encodedMagic.Length' CompressionLevel.Fastest' true);  				//batch.Encode();  				SendPackage(magic);  			}  			catch (Exception e)  			{  				Log.Error("Initiate encryption"' e);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,InitiateEncryption,The following statement contains a magic number: try  			{  				ECDiffieHellmanPublicKey publicKey = CryptoUtils.FromDerEncoded(serverKey);  				Log.Debug("ServerKey (b64):\n" + serverKey);  				Log.Debug($"Cert:\n{publicKey.ToXmlString()}");    				Log.Debug($"RANDOM TOKEN (raw):\n\n{Encoding.UTF8.GetString(randomKeyToken)}");    				if (randomKeyToken.Length != 0)  				{  					Log.Error("Lenght of random bytes: " + randomKeyToken.Length);  				}    				// Create shared shared secret  				ECDiffieHellmanCng ecKey = new ECDiffieHellmanCng(Session.CryptoContext.ClientKey);  				ecKey.HashAlgorithm = CngAlgorithm.Sha256;  				ecKey.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;  				ecKey.SecretPrepend = randomKeyToken; // Server token    				byte[] secret = ecKey.DeriveKeyMaterial(publicKey);    				//Log.Debug($"SECRET KEY (b64):\n{Convert.ToBase64String(secret)}");  				Log.Debug($"SECRET KEY (raw):\n{Encoding.UTF8.GetString(secret)}");    				{  					RijndaelManaged rijAlg = new RijndaelManaged  					{  						BlockSize = 128'  						Padding = PaddingMode.None'  						Mode = CipherMode.CFB'  						FeedbackSize = 8'  						Key = secret'  						IV = secret.Take(16).ToArray()'  					};    					// Create a decrytor to perform the stream transform.  					ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream inputStream = new MemoryStream();  					CryptoStream cryptoStreamIn = new CryptoStream(inputStream' decryptor' CryptoStreamMode.Read);    					ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream outputStream = new MemoryStream();  					CryptoStream cryptoStreamOut = new CryptoStream(outputStream' encryptor' CryptoStreamMode.Write);    					Session.CryptoContext = new CryptoContext  					{  						Algorithm = rijAlg'  						Decryptor = decryptor'  						Encryptor = encryptor'  						InputStream = inputStream'  						OutputStream = outputStream'  						CryptoStreamIn = cryptoStreamIn'  						CryptoStreamOut = cryptoStreamOut'  						UseEncryption = true'  					};  				}    				Thread.Sleep(1250);  				McpeClientToServerHandshake magic = new McpeClientToServerHandshake();  				//byte[] encodedMagic = magic.Encode();  				//McpeBatch batch = BatchUtils.CreateBatchPacket(encodedMagic' 0' encodedMagic.Length' CompressionLevel.Fastest' true);  				//batch.Encode();  				SendPackage(magic);  			}  			catch (Exception e)  			{  				Log.Error("Initiate encryption"' e);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,InitiateEncryption,The following statement contains a magic number: try  			{  				ECDiffieHellmanPublicKey publicKey = CryptoUtils.FromDerEncoded(serverKey);  				Log.Debug("ServerKey (b64):\n" + serverKey);  				Log.Debug($"Cert:\n{publicKey.ToXmlString()}");    				Log.Debug($"RANDOM TOKEN (raw):\n\n{Encoding.UTF8.GetString(randomKeyToken)}");    				if (randomKeyToken.Length != 0)  				{  					Log.Error("Lenght of random bytes: " + randomKeyToken.Length);  				}    				// Create shared shared secret  				ECDiffieHellmanCng ecKey = new ECDiffieHellmanCng(Session.CryptoContext.ClientKey);  				ecKey.HashAlgorithm = CngAlgorithm.Sha256;  				ecKey.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;  				ecKey.SecretPrepend = randomKeyToken; // Server token    				byte[] secret = ecKey.DeriveKeyMaterial(publicKey);    				//Log.Debug($"SECRET KEY (b64):\n{Convert.ToBase64String(secret)}");  				Log.Debug($"SECRET KEY (raw):\n{Encoding.UTF8.GetString(secret)}");    				{  					RijndaelManaged rijAlg = new RijndaelManaged  					{  						BlockSize = 128'  						Padding = PaddingMode.None'  						Mode = CipherMode.CFB'  						FeedbackSize = 8'  						Key = secret'  						IV = secret.Take(16).ToArray()'  					};    					// Create a decrytor to perform the stream transform.  					ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream inputStream = new MemoryStream();  					CryptoStream cryptoStreamIn = new CryptoStream(inputStream' decryptor' CryptoStreamMode.Read);    					ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key' rijAlg.IV);  					MemoryStream outputStream = new MemoryStream();  					CryptoStream cryptoStreamOut = new CryptoStream(outputStream' encryptor' CryptoStreamMode.Write);    					Session.CryptoContext = new CryptoContext  					{  						Algorithm = rijAlg'  						Decryptor = decryptor'  						Encryptor = encryptor'  						InputStream = inputStream'  						OutputStream = outputStream'  						CryptoStreamIn = cryptoStreamIn'  						CryptoStreamOut = cryptoStreamOut'  						UseEncryption = true'  					};  				}    				Thread.Sleep(1250);  				McpeClientToServerHandshake magic = new McpeClientToServerHandshake();  				//byte[] encodedMagic = magic.Encode();  				//McpeBatch batch = BatchUtils.CreateBatchPacket(encodedMagic' 0' encodedMagic.Length' CompressionLevel.Fastest' true);  				//batch.Encode();  				SendPackage(magic);  			}  			catch (Exception e)  			{  				Log.Error("Initiate encryption"' e);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpePlayStatus,The following statement contains a magic number: if (PlayerStatus == 3)  			{  				HasSpawned = true;  				if (IsEmulator)  				{  					PlayerStatusChangedWaitHandle.Set();    					SendMcpeMovePlayer();  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendCraftingEvent2,The following statement contains a magic number: if (recipe != null)  			{  				Log.Error("Sending crafting event: " + recipe.Id);    				McpeCraftingEvent crafting = McpeCraftingEvent.CreateObject();  				crafting.windowId = 0;  				crafting.recipeType = 1;  				crafting.recipeId = recipe.Id;    				{  					ItemStacks slotData = new ItemStacks();  					for (uint i = 0; i < recipe.Input.Length; i++)  					{  						slotData.Add(recipe.Input[i]);    						McpeInventorySlot sendSlot = McpeInventorySlot.CreateObject();  						sendSlot.inventoryId = 0;  						sendSlot.slot = i;  						sendSlot.item = recipe.Input[i];  						SendPackage(sendSlot);    						//McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  						//setSlot.item = recipe.Input[i];  						//setSlot.windowId = 0;  						//setSlot.slot = (short) (i);  						//SendPackage(setSlot);  						//Log.Error("Set set slot");  					}  					crafting.input = slotData;    					{  						McpeMobEquipment eq = McpeMobEquipment.CreateObject();  						eq.runtimeEntityId = EntityId;  						eq.slot = 9;  						eq.selectedSlot = 0;  						eq.item = recipe.Input[0];  						SendPackage(eq);  						Log.Error("Set eq slot");  					}  				}  				{  					ItemStacks slotData = new ItemStacks {recipe.Result};  					crafting.result = slotData;  				}    				SendPackage(crafting);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendCraftingEvent,The following statement contains a magic number: if (recipe != null)  			{  				{  					//McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  					//setSlot.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					//setSlot.windowId = 0;  					//setSlot.slot = 0;  					//SendPackage(setSlot);  				}  				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 9;  					eq.selectedSlot = 0;  					eq.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					SendPackage(eq);  				}    				Log.Error("Sending crafting event: " + recipe.Id);    				McpeCraftingEvent crafting = McpeCraftingEvent.CreateObject();  				crafting.windowId = 0;  				crafting.recipeType = 1;  				crafting.recipeId = recipe.Id;    				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(17)' 0) {Count = 1}};  					crafting.input = slotData;  				}  				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(5)' 0) {Count = 1}};  					crafting.result = slotData;  				}    				SendPackage(crafting);    				//{  				//	McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  				//	setSlot.item = new MetadataSlot(new ItemStack(new ItemBlock(new Block(5)' 0)' 4));  				//	setSlot.windowId = 0;  				//	setSlot.slot = 0;  				//	SendPackage(setSlot);  				//}    				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 10;  					eq.selectedSlot = 1;  					eq.item = new ItemBlock(new Block(5)' 0) {Count = 1};  					SendPackage(eq);  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendCraftingEvent,The following statement contains a magic number: if (recipe != null)  			{  				{  					//McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  					//setSlot.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					//setSlot.windowId = 0;  					//setSlot.slot = 0;  					//SendPackage(setSlot);  				}  				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 9;  					eq.selectedSlot = 0;  					eq.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					SendPackage(eq);  				}    				Log.Error("Sending crafting event: " + recipe.Id);    				McpeCraftingEvent crafting = McpeCraftingEvent.CreateObject();  				crafting.windowId = 0;  				crafting.recipeType = 1;  				crafting.recipeId = recipe.Id;    				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(17)' 0) {Count = 1}};  					crafting.input = slotData;  				}  				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(5)' 0) {Count = 1}};  					crafting.result = slotData;  				}    				SendPackage(crafting);    				//{  				//	McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  				//	setSlot.item = new MetadataSlot(new ItemStack(new ItemBlock(new Block(5)' 0)' 4));  				//	setSlot.windowId = 0;  				//	setSlot.slot = 0;  				//	SendPackage(setSlot);  				//}    				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 10;  					eq.selectedSlot = 1;  					eq.item = new ItemBlock(new Block(5)' 0) {Count = 1};  					SendPackage(eq);  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendCraftingEvent,The following statement contains a magic number: if (recipe != null)  			{  				{  					//McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  					//setSlot.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					//setSlot.windowId = 0;  					//setSlot.slot = 0;  					//SendPackage(setSlot);  				}  				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 9;  					eq.selectedSlot = 0;  					eq.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					SendPackage(eq);  				}    				Log.Error("Sending crafting event: " + recipe.Id);    				McpeCraftingEvent crafting = McpeCraftingEvent.CreateObject();  				crafting.windowId = 0;  				crafting.recipeType = 1;  				crafting.recipeId = recipe.Id;    				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(17)' 0) {Count = 1}};  					crafting.input = slotData;  				}  				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(5)' 0) {Count = 1}};  					crafting.result = slotData;  				}    				SendPackage(crafting);    				//{  				//	McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  				//	setSlot.item = new MetadataSlot(new ItemStack(new ItemBlock(new Block(5)' 0)' 4));  				//	setSlot.windowId = 0;  				//	setSlot.slot = 0;  				//	SendPackage(setSlot);  				//}    				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 10;  					eq.selectedSlot = 1;  					eq.item = new ItemBlock(new Block(5)' 0) {Count = 1};  					SendPackage(eq);  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendCraftingEvent,The following statement contains a magic number: if (recipe != null)  			{  				{  					//McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  					//setSlot.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					//setSlot.windowId = 0;  					//setSlot.slot = 0;  					//SendPackage(setSlot);  				}  				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 9;  					eq.selectedSlot = 0;  					eq.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					SendPackage(eq);  				}    				Log.Error("Sending crafting event: " + recipe.Id);    				McpeCraftingEvent crafting = McpeCraftingEvent.CreateObject();  				crafting.windowId = 0;  				crafting.recipeType = 1;  				crafting.recipeId = recipe.Id;    				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(17)' 0) {Count = 1}};  					crafting.input = slotData;  				}  				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(5)' 0) {Count = 1}};  					crafting.result = slotData;  				}    				SendPackage(crafting);    				//{  				//	McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  				//	setSlot.item = new MetadataSlot(new ItemStack(new ItemBlock(new Block(5)' 0)' 4));  				//	setSlot.windowId = 0;  				//	setSlot.slot = 0;  				//	SendPackage(setSlot);  				//}    				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 10;  					eq.selectedSlot = 1;  					eq.item = new ItemBlock(new Block(5)' 0) {Count = 1};  					SendPackage(eq);  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendCraftingEvent,The following statement contains a magic number: if (recipe != null)  			{  				{  					//McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  					//setSlot.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					//setSlot.windowId = 0;  					//setSlot.slot = 0;  					//SendPackage(setSlot);  				}  				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 9;  					eq.selectedSlot = 0;  					eq.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					SendPackage(eq);  				}    				Log.Error("Sending crafting event: " + recipe.Id);    				McpeCraftingEvent crafting = McpeCraftingEvent.CreateObject();  				crafting.windowId = 0;  				crafting.recipeType = 1;  				crafting.recipeId = recipe.Id;    				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(17)' 0) {Count = 1}};  					crafting.input = slotData;  				}  				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(5)' 0) {Count = 1}};  					crafting.result = slotData;  				}    				SendPackage(crafting);    				//{  				//	McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  				//	setSlot.item = new MetadataSlot(new ItemStack(new ItemBlock(new Block(5)' 0)' 4));  				//	setSlot.windowId = 0;  				//	setSlot.slot = 0;  				//	SendPackage(setSlot);  				//}    				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 10;  					eq.selectedSlot = 1;  					eq.item = new ItemBlock(new Block(5)' 0) {Count = 1};  					SendPackage(eq);  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendCraftingEvent,The following statement contains a magic number: if (recipe != null)  			{  				{  					//McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  					//setSlot.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					//setSlot.windowId = 0;  					//setSlot.slot = 0;  					//SendPackage(setSlot);  				}  				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 9;  					eq.selectedSlot = 0;  					eq.item = new ItemBlock(new Block(17)' 0) {Count = 1};  					SendPackage(eq);  				}    				Log.Error("Sending crafting event: " + recipe.Id);    				McpeCraftingEvent crafting = McpeCraftingEvent.CreateObject();  				crafting.windowId = 0;  				crafting.recipeType = 1;  				crafting.recipeId = recipe.Id;    				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(17)' 0) {Count = 1}};  					crafting.input = slotData;  				}  				{  					ItemStacks slotData = new ItemStacks {new ItemBlock(new Block(5)' 0) {Count = 1}};  					crafting.result = slotData;  				}    				SendPackage(crafting);    				//{  				//	McpeContainerSetSlot setSlot = McpeContainerSetSlot.CreateObject();  				//	setSlot.item = new MetadataSlot(new ItemStack(new ItemBlock(new Block(5)' 0)' 4));  				//	setSlot.windowId = 0;  				//	setSlot.slot = 0;  				//	SendPackage(setSlot);  				//}    				{  					McpeMobEquipment eq = McpeMobEquipment.CreateObject();  					eq.runtimeEntityId = EntityId;  					eq.slot = 10;  					eq.selectedSlot = 1;  					eq.item = new ItemBlock(new Block(5)' 0) {Count = 1};  					SendPackage(eq);  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeCraftingData,The following statement contains a magic number: foreach (Recipe recipe in msg.recipes)  			{  				ShapelessRecipe shapelessRecipe = recipe as ShapelessRecipe;  				if (shapelessRecipe != null)  				{  					writer.WriteLine($"new ShapelessRecipe(new Item({shapelessRecipe.Result.Id}' {shapelessRecipe.Result.Metadata}' {shapelessRecipe.Result.Count})'");  					writer.Indent++;  					writer.WriteLine("new List<Item>");  					writer.WriteLine("{");  					writer.Indent++;  					foreach (var itemStack in shapelessRecipe.Input)  					{  						writer.WriteLine($"new Item({itemStack.Id}' {itemStack.Metadata}' {itemStack.Count})'");  					}  					writer.Indent--;  					writer.WriteLine("})'");  					writer.Indent--;    					continue;  				}    				ShapedRecipe shapedRecipe = recipe as ShapedRecipe;  				if (shapedRecipe != null && _recipeToSend == null)  				{  					if (shapedRecipe.Result.Id == 5 && shapedRecipe.Result.Count == 4 && shapedRecipe.Result.Metadata == 0)  					{  						Log.Error("Setting recipe! " + shapedRecipe.Id);  						_recipeToSend = shapedRecipe;  					}  				}  				if (shapedRecipe != null)  				{  					writer.WriteLine($"new ShapedRecipe({shapedRecipe.Width}' {shapedRecipe.Height}' new Item({shapedRecipe.Result.Id}' {shapedRecipe.Result.Metadata}' {shapedRecipe.Result.Count})'");  					writer.Indent++;  					writer.WriteLine("new Item[]");  					writer.WriteLine("{");  					writer.Indent++;  					foreach (Item item in shapedRecipe.Input)  					{  						writer.WriteLine($"new Item({item.Id}' {item.Metadata})'");  					}  					writer.Indent--;  					writer.WriteLine("})'");  					writer.Indent--;    					continue;  				}    				SmeltingRecipe smeltingRecipe = recipe as SmeltingRecipe;  				if (smeltingRecipe != null)  				{  					writer.WriteLine($"new SmeltingRecipe(new Item({smeltingRecipe.Result.Id}' {smeltingRecipe.Result.Metadata}' {smeltingRecipe.Result.Count})' new Item({smeltingRecipe.Input.Id}' {smeltingRecipe.Input.Metadata}))'");  					continue;  				}    				MultiRecipe multiRecipe = recipe as MultiRecipe;  				if (multiRecipe != null)  				{  					writer.WriteLine($"new MultiRecipe() {{ Id = new UUID(\"{recipe.Id}\") }}' // {recipe.Id}");  					continue;  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeCraftingData,The following statement contains a magic number: foreach (Recipe recipe in msg.recipes)  			{  				ShapelessRecipe shapelessRecipe = recipe as ShapelessRecipe;  				if (shapelessRecipe != null)  				{  					writer.WriteLine($"new ShapelessRecipe(new Item({shapelessRecipe.Result.Id}' {shapelessRecipe.Result.Metadata}' {shapelessRecipe.Result.Count})'");  					writer.Indent++;  					writer.WriteLine("new List<Item>");  					writer.WriteLine("{");  					writer.Indent++;  					foreach (var itemStack in shapelessRecipe.Input)  					{  						writer.WriteLine($"new Item({itemStack.Id}' {itemStack.Metadata}' {itemStack.Count})'");  					}  					writer.Indent--;  					writer.WriteLine("})'");  					writer.Indent--;    					continue;  				}    				ShapedRecipe shapedRecipe = recipe as ShapedRecipe;  				if (shapedRecipe != null && _recipeToSend == null)  				{  					if (shapedRecipe.Result.Id == 5 && shapedRecipe.Result.Count == 4 && shapedRecipe.Result.Metadata == 0)  					{  						Log.Error("Setting recipe! " + shapedRecipe.Id);  						_recipeToSend = shapedRecipe;  					}  				}  				if (shapedRecipe != null)  				{  					writer.WriteLine($"new ShapedRecipe({shapedRecipe.Width}' {shapedRecipe.Height}' new Item({shapedRecipe.Result.Id}' {shapedRecipe.Result.Metadata}' {shapedRecipe.Result.Count})'");  					writer.Indent++;  					writer.WriteLine("new Item[]");  					writer.WriteLine("{");  					writer.Indent++;  					foreach (Item item in shapedRecipe.Input)  					{  						writer.WriteLine($"new Item({item.Id}' {item.Metadata})'");  					}  					writer.Indent--;  					writer.WriteLine("})'");  					writer.Indent--;    					continue;  				}    				SmeltingRecipe smeltingRecipe = recipe as SmeltingRecipe;  				if (smeltingRecipe != null)  				{  					writer.WriteLine($"new SmeltingRecipe(new Item({smeltingRecipe.Result.Id}' {smeltingRecipe.Result.Metadata}' {smeltingRecipe.Result.Count})' new Item({smeltingRecipe.Input.Id}' {smeltingRecipe.Input.Metadata}))'");  					continue;  				}    				MultiRecipe multiRecipe = recipe as MultiRecipe;  				if (multiRecipe != null)  				{  					writer.WriteLine($"new MultiRecipe() {{ Id = new UUID(\"{recipe.Id}\") }}' // {recipe.Id}");  					continue;  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeLevelEvent,The following statement contains a magic number: if (msg.eventId == 2001)  			{  				int blockId = data & 0xff;  				int metadata = data >> 12;  				Log.Debug($"BlockID={blockId}' Metadata={metadata}");  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeLevelEvent,The following statement contains a magic number: if (msg.eventId == 2001)  			{  				int blockId = data & 0xff;  				int metadata = data >> 12;  				Log.Debug($"BlockID={blockId}' Metadata={metadata}");  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following statement contains a magic number: foreach (var kvp in metadata._entries)  			{  				int idx = kvp.Key;  				MetadataEntry entry = kvp.Value;    				sb.Append($"metadata[{idx}] = new ");  				switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}  				sb.AppendLine();  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,FlagsToString,The following statement contains a magic number: byte[] bytes = new byte[8];
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeAddEntity,The following statement contains a magic number: if (message.metadata.Contains(0))  			{  				long? value = ((MetadataLong) message.metadata[0])?.Value;  				if (value != null)  				{  					long dataValue = (long) value;  					Log.Debug($"Bit-array datavalue: dec={dataValue} hex=0x{dataValue:x2}' bin={Convert.ToString(dataValue' 2)}b ");  				}  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeStartGame,The following statement contains a magic number: Level.Version = 19133;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnMcpeStartGame,The following statement contains a magic number: {  				var packet = McpeRequestChunkRadius.CreateObject();  				ChunkRadius = 5;  				packet.chunkRadius = ChunkRadius;    				SendPackage(packet);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnConnectionRequestAccepted,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,OnConnectionRequestAccepted,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendData,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,TraceReceive,The following statement contains a magic number: if (verbosity == 0)  			{  				Log.Debug($"> Receive: {message.Id} (0x{message.Id:x2}): {message.GetType().Name}");  			}  			else if (verbosity == 1)  			{  				var jsonSerializerSettings = new JsonSerializerSettings  				{  					PreserveReferencesHandling = PreserveReferencesHandling.Arrays'    					Formatting = Formatting.Indented'  				};  				jsonSerializerSettings.Converters.Add(new NbtIntConverter());  				jsonSerializerSettings.Converters.Add(new NbtStringConverter());    				string result = JsonConvert.SerializeObject(message' jsonSerializerSettings);  				Log.Debug($"> Receive: {message.Id} (0x{message.Id:x2}): {message.GetType().Name}\n{result}");  			}  			else if (verbosity == 2)  			{  				Log.Debug($"> Receive: {message.Id} (0x{message.Id:x2}): {message.GetType().Name}\n{Package.HexDump(message.Bytes)}");  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendUnconnectedPing,The following statement contains a magic number: if (_serverEndpoint != null)  			{  				SendData(data' _serverEndpoint);  			}  			else  			{  				SendData(data' new IPEndPoint(IPAddress.Broadcast' 19132));  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendConnectedPong,The following statement contains a magic number: var packet = new ConnectedPong  			{  				sendpingtime = sendpingtime'  				sendpongtime = sendpingtime + 200  			};
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendOpenConnectionRequest1,The following statement contains a magic number: var packet = new OpenConnectionRequest1()  			{  				raknetProtocolVersion = 8'  				mtuSize = _mtuSize  			};
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendOpenConnectionRequest1,The following statement contains a magic number: byte[] data2 = new byte[_mtuSize - data.Length - 10];
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendNewIncomingConnection,The following statement contains a magic number: packet.systemAddresses = new IPEndPoint[20];
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendNewIncomingConnection,The following statement contains a magic number: for (int i = 0; i < 20; i++)  			{  				packet.systemAddresses[i] = new IPEndPoint(IPAddress.Any' 0);  			}
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendMcpeMovePlayer,The following statement contains a magic number: movePlayerPacket.yaw = 91;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendMcpeMovePlayer,The following statement contains a magic number: movePlayerPacket.pitch = 28;
Magic Number,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,SendMcpeMovePlayer,The following statement contains a magic number: movePlayerPacket.headYaw = 91;
Magic Number,MiNET.Client,ObjectDumper,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\ObjectDumper.cs,WriteTab,The following statement contains a magic number: while (pos%8 != 0) Write(" ");
Missing Default,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,ProcessMessage,The following switch statement is missing a default case: switch (msgIdType)  				{  					case DefaultMessageIdTypes.ID_UNCONNECTED_PONG:  					{  						UnconnectedPong incoming = (UnconnectedPong) message;  						Log.Warn($"MOTD: {incoming.serverName}");  						if (!HaveServer)  						{  							_serverEndpoint = senderEndpoint;  							HaveServer = true;  							SendOpenConnectionRequest1();  						}    						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_1:  					{  						OpenConnectionReply1 incoming = (OpenConnectionReply1) message;  						if (incoming.mtuSize != _mtuSize) Log.Warn("Error' mtu differ from what we sent:" + incoming.mtuSize);  						Log.Warn($"Server with ID {incoming.serverGuid} security={incoming.serverHasSecurity}");  						_mtuSize = incoming.mtuSize;  						SendOpenConnectionRequest2();  						break;  					}  					case DefaultMessageIdTypes.ID_OPEN_CONNECTION_REPLY_2:  					{  						OnOpenConnectionReply2((OpenConnectionReply2) message);  						break;  					}  					case DefaultMessageIdTypes.ID_NO_FREE_INCOMING_CONNECTIONS:  					{  						OnNoFreeIncomingConnections((NoFreeIncomingConnections) message);  						break;  					}  				}
Missing Default,MiNET.Client,MiNetClient,C:\repos\NiclasOlofsson_MiNET\src\MiNET\MiNET.Client\MiNetClient.cs,MetadataToCode,The following switch statement is missing a default case: switch (entry.Identifier)  				{  					case 0:  					{  						var e = (MetadataByte) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 1:  					{  						var e = (MetadataShort) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 2:  					{  						var e = (MetadataInt) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 3:  					{  						var e = (MetadataFloat) entry;  						sb.Append($"{e.GetType().Name}({e.Value.ToString(NumberFormatInfo.InvariantInfo)}f);");  						break;  					}  					case 4:  					{  						var e = (MetadataString) entry;  						sb.Append($"{e.GetType().Name}(\"{e.Value}\");");  						break;  					}  					case 5:  					{  						var e = (MetadataSlot) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 6:  					{  						var e = (MetadataIntCoordinates) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  					case 7:  					{  						var e = (MetadataLong) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						if (idx == 0)  						{  							sb.Append($" // {Convert.ToString((long) e.Value' 2)}; {FlagsToString(e.Value)}");  						}  						break;  					}  					case 8:  					{  						var e = (MetadataVector3) entry;  						sb.Append($"{e.GetType().Name}({e.Value});");  						break;  					}  				}
