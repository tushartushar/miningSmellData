Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpNative.Compiler,Core,C:\repos\afrogeek_SharpNative\Compiler\Core.cs,Factory,The method has 137 lines of code.
Long Method,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,The method has 103 lines of code.
Long Method,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,The method has 102 lines of code.
Long Method,SharpNative.Compiler,OutputWriter,C:\repos\afrogeek_SharpNative\Compiler\OutputWriter.cs,Finalize,The method has 130 lines of code.
Long Method,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The method has 143 lines of code.
Long Method,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,RunTests,The method has 129 lines of code.
Long Method,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteNamespaces,The method has 104 lines of code.
Long Method,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteReflectionInfo,The method has 204 lines of code.
Long Method,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The method has 187 lines of code.
Long Method,SharpNative.Compiler,TypeProcessor,C:\repos\afrogeek_SharpNative\Compiler\TypeProcessor.cs,ConvertTypeUncached,The method has 105 lines of code.
Long Method,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,CreateArray,The method has 103 lines of code.
Long Method,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The method has 109 lines of code.
Long Method,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The method has 153 lines of code.
Long Method,SharpNative.Compiler,WriteBinaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteBinaryExpression.cs,ProcessExpression,The method has 290 lines of code.
Long Method,SharpNative.Compiler,WriteCastExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteCastExpression.cs,Go,The method has 152 lines of code.
Long Method,SharpNative.Compiler,WriteEnum,C:\repos\afrogeek_SharpNative\Compiler\WriteEnum.cs,Go,The method has 245 lines of code.
Long Method,SharpNative.Compiler,WriteEvent,C:\repos\afrogeek_SharpNative\Compiler\WriteEvent.cs,Go,The method has 165 lines of code.
Long Method,SharpNative.Compiler,WriteField,C:\repos\afrogeek_SharpNative\Compiler\WriteField.cs,Go,The method has 127 lines of code.
Long Method,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The method has 237 lines of code.
Long Method,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The method has 160 lines of code.
Long Method,SharpNative.Compiler,WriteMemberAccessExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteMemberAccessExpression.cs,Go,The method has 123 lines of code.
Long Method,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,WriteIt,The method has 196 lines of code.
Long Method,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The method has 145 lines of code.
Long Method,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The method has 300 lines of code.
Long Method,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The method has 190 lines of code.
Long Method,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutBoxed,The method has 107 lines of code.
Long Method,SharpNative.Compiler,WriteUnaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteUnaryExpression.cs,WritePrefix,The method has 149 lines of code.
Long Method,SharpNative.Compiler,WriteUnaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteUnaryExpression.cs,WritePostfix,The method has 127 lines of code.
Long Method,SharpNative.Compiler,WriteVariableDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteVariableDeclaration.cs,ProcessInitializer,The method has 100 lines of code.
Long Method,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The method has 172 lines of code.
Complex Method,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,GetOriginalUnreducedDefinition,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,Cyclomatic complexity of the method is 13
Complex Method,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,Cyclomatic complexity of the method is 13
Complex Method,SharpNative.Compiler,OutputWriter,C:\repos\afrogeek_SharpNative\Compiler\OutputWriter.cs,Finalize,Cyclomatic complexity of the method is 28
Complex Method,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetCSharpName,Cyclomatic complexity of the method is 11
Complex Method,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,Cyclomatic complexity of the method is 21
Complex Method,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,CompileFiles,Cyclomatic complexity of the method is 12
Complex Method,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,RunTests,Cyclomatic complexity of the method is 11
Complex Method,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,Main,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,OverloadResolver,C:\repos\afrogeek_SharpNative\Compiler\OverloadResolver.cs,MethodName,Cyclomatic complexity of the method is 10
Complex Method,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteReflectionInfo,Cyclomatic complexity of the method is 12
Complex Method,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,Cyclomatic complexity of the method is 16
Complex Method,SharpNative.Compiler,TypeProcessor,C:\repos\afrogeek_SharpNative\Compiler\TypeProcessor.cs,LocalizeName,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,TypeProcessor,C:\repos\afrogeek_SharpNative\Compiler\TypeProcessor.cs,ConvertTypeUncached,Cyclomatic complexity of the method is 12
Complex Method,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,CreateArray,Cyclomatic complexity of the method is 14
Complex Method,SharpNative.Compiler,WriteBinaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteBinaryExpression.cs,ProcessExpression,Cyclomatic complexity of the method is 22
Complex Method,SharpNative.Compiler,WriteConstructorBody,C:\repos\afrogeek_SharpNative\Compiler\WriteConstructor.cs,WriteInstanceConstructor,Cyclomatic complexity of the method is 11
Complex Method,SharpNative.Compiler,WriteElementAccessExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteElementAccessExpression.cs,Go,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,WriteEnum,C:\repos\afrogeek_SharpNative\Compiler\WriteEnum.cs,Go,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,WriteEvent,C:\repos\afrogeek_SharpNative\Compiler\WriteEvent.cs,Go,Cyclomatic complexity of the method is 10
Complex Method,SharpNative.Compiler,WriteField,C:\repos\afrogeek_SharpNative\Compiler\WriteField.cs,Go,Cyclomatic complexity of the method is 11
Complex Method,SharpNative.Compiler,WriteForStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteForStatement.cs,Go,Cyclomatic complexity of the method is 17
Complex Method,SharpNative.Compiler,WriteIdentifierName,C:\repos\afrogeek_SharpNative\Compiler\WriteIdentifierName.cs,TransformIdentifier,Cyclomatic complexity of the method is 9
Complex Method,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,Cyclomatic complexity of the method is 16
Complex Method,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,WriteArguments,Cyclomatic complexity of the method is 10
Complex Method,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,Cyclomatic complexity of the method is 18
Complex Method,SharpNative.Compiler,WriteLambdaExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteLambdaExpression.cs,Go,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,WriteLiteralExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteLiteralExpression.cs,Go,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,WriteLocalDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteLocalDeclaration.cs,ProcessInitializer,Cyclomatic complexity of the method is 12
Complex Method,SharpNative.Compiler,WriteMemberAccessExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteMemberAccessExpression.cs,Go,Cyclomatic complexity of the method is 13
Complex Method,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetParameterListAsString,Cyclomatic complexity of the method is 12
Complex Method,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetParameterListAsString,Cyclomatic complexity of the method is 12
Complex Method,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,WriteIt,Cyclomatic complexity of the method is 15
Complex Method,SharpNative.Compiler,WriteOperatorDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteOperatorDeclaration.cs,Go,Cyclomatic complexity of the method is 15
Complex Method,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,Cyclomatic complexity of the method is 14
Complex Method,SharpNative.Compiler,WriteReturnStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteReturnStatement.cs,Go,Cyclomatic complexity of the method is 12
Complex Method,SharpNative.Compiler,WriteSwitchStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteSwitchStatement.cs,Go,Cyclomatic complexity of the method is 14
Complex Method,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,GetTypeConstraints,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,Cyclomatic complexity of the method is 9
Complex Method,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutBoxed,Cyclomatic complexity of the method is 8
Complex Method,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,SortFields,Cyclomatic complexity of the method is 10
Complex Method,SharpNative.Compiler,WriteVariableDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteVariableDeclaration.cs,ProcessInitializer,Cyclomatic complexity of the method is 14
Complex Method,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,FixPropertyUnaryExpressions,Cyclomatic complexity of the method is 9
Complex Method,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,Cyclomatic complexity of the method is 13
Long Parameter List,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,CompileProject,The method has 5 parameters. Parameters: outDir' pathToSolution' projects' extraDefines' extraTranslations
Long Parameter List,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,CompileSolution,The method has 5 parameters. Parameters: outDir' pathToSolution' projects' extraDefines' extraTranslations
Long Parameter List,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,Go,The method has 5 parameters. Parameters: outDir' extraTranslation' exePath' cSharp' testName
Long Parameter List,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The method has 6 parameters. Parameters: target' lastTemporaryIndex' newRoot' originalObjectExpressionSyntax' replacedNodes' depth
Long Parameter List,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,WriteArrayElements,The method has 6 parameters. Parameters: initializer' writer' inferred' level' omitbraces' elementType
Long Parameter List,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,CreateArray,The method has 7 parameters. Parameters: initializer' writer' type' arrayType' _aType' first' inferredDimensions
Long Parameter List,SharpNative.Compiler,WriteField,C:\repos\afrogeek_SharpNative\Compiler\WriteField.cs,Go,The method has 7 parameters. Parameters: writer' field' modifiers' name' type' initializerOpt' isThreadStatic
Long Parameter List,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,WriteArguments,The method has 11 parameters. Parameters: writer' invocationExpression' arguments' firstParameter' inParams' methodSymbol' foundParamsArray' typeSymbol' isOverloaded' symbol' instanceName
Long Parameter List,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetParameterListAsString,The method has 5 parameters. Parameters: parameters' includeTypes' iface' writebraces' genericClass
Long Parameter List,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteRegion,The method has 10 parameters. Parameters: get' body' iface' writer' typeString' name' modifiers' parameters' isindexer' hasGetter
Long Parameter List,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteSetter,The method has 16 parameters. Parameters: writer' isProxy' hasSetter' acccessmodifiers' name' typeString' iface' isOverride' setterHasBody' modifiers' isInterface' fieldName' setterbody' parameters' isindexer' hasGetter
Long Parameter List,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteGetter,The method has 14 parameters. Parameters: writer' isProxy' hasGetter' acccessmodifiers' typeString' name' iface' getterHasBody' modifiers' isInterface' fieldName' getterbody' parameters' isindexer
Long Parameter List,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteAutoFieldName,The method has 11 parameters. Parameters: writer' name' modifiers' isInterface' hasGetter' getterHasBody' hasSetter' setterHasBody' typeString' isOverride' isIndexer
Long Parameter List,SharpNative.Compiler.DlangAst,InvocationRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\InvocationRewriter.cs,ProcessArguments,The method has 5 parameters. Parameters: context' method' isArgumentArray' getArgumentName' args
Long Parameter List,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,Property,The method has 6 parameters. Parameters: type' name' hasGetter' hasSetter' gblock' sblock
Long Identifier,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializers,The length of the parameter objectCreationExpressionSyntaxs is 31.
Long Identifier,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The length of the parameter originalObjectExpressionSyntax is 30.
Long Identifier,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The length of the parameter objectCreationExpressionSyntaxs is 31.
Long Identifier,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The length of the parameter noriginalObjectExpressionSyntax is 31.
Long Identifier,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutBoxed,The length of the parameter findImplementationForInterfaceMember is 36.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The length of the statement  "                    if (@event != null && (@event.ContainingType.BaseType != null && @event.ContainingType.BaseType.GetAllMembers().OfType<IEventSymbol>().Any(k => k.Name==@event.Name) && @event.IsOverride==false)) " is 194.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The length of the statement  "                        if (@method != null && (@method.ContainingType.BaseType != null && @method.ContainingType.BaseType.GetAllMembers().OfType<IMethodSymbol>().Any(k => MemberUtilities.CompareMethods(k'@method)) && @method.IsOverride == false)) " is 223.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The length of the statement  "                        if (@property != null && (@property.ContainingType.BaseType != null && @property.ContainingType.BaseType.GetAllMembers().OfType<IPropertySymbol>().Any(k => k.Name == @property.Name) && @property.IsOverride == false)) " is 216.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The length of the statement  "                        if (@field != null && (@field.ContainingType.BaseType != null && @field.ContainingType.BaseType.GetAllMembers().OfType<IFieldSymbol>().Any(k => k.Name == @field.Name) && @field.IsOverride == false)) " is 198.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsModuleMember,The length of the statement  "            return symbol != null && symbol.ContainingSymbol is INamedTypeSymbol && symbol.ContainingType.TypeKind == TypeKind.Module; " is 122.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,VerifyGetAwaiter,The length of the statement  "            if (!returnType.GetMembers().OfType<IPropertySymbol>().Any(p => p.Name == WellKnownMemberNames.IsCompleted && p.Type.SpecialType == SpecialType.System_Boolean && p.GetMethod != null)) " is 183.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,VerifyGetAwaiter,The length of the statement  "            if (!methods.Any(x => x.Name == WellKnownMemberNames.OnCompleted && x.ReturnsVoid && x.Parameters.Length == 1 && x.Parameters.First().Type.TypeKind == TypeKind.Delegate)) " is 170.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,InferAwaitableReturnType,The length of the statement  "            var potentialGetAwaiters = semanticModel.LookupSymbols(position' container: returnType' name: WellKnownMemberNames.GetAwaiter' includeReducedExtensionMethods: true); " is 165.
Long Statement,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,InferAwaitableReturnType,The length of the statement  "            var getResults = getAwaiters.SelectMany(g => semanticModel.LookupSymbols(position' container: g.ReturnType' name: WellKnownMemberNames.GetResult)); " is 147.
Long Statement,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,ShouldUseOverrideKeyword,The length of the statement  "                //partial methods seem exempt from C#'s normal override keyword requirement' so we have to check manually to see if it exists in a base class " is 141.
Long Statement,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,The length of the statement  "                //                if (!member.GetModifiers().Any(SyntaxKind.NewKeyword) && methodSymbol is IMethodSymbol) // This is not neccessary for properties " is 146.
Long Statement,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,The length of the statement  "                //                        enumerable.FirstOrDefault(k => CompareMethods(k as IMethodSymbol' (IMethodSymbol) methodSymbol)); " is 123.
Long Statement,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,The length of the statement  "                //                if (!member.GetModifiers().Any(SyntaxKind.NewKeyword) && methodSymbol is IMethodSymbol) // This is not neccessary for properties " is 146.
Long Statement,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,The length of the statement  "                //                        enumerable.FirstOrDefault(k => CompareMethods(k as IMethodSymbol' (IMethodSymbol) methodSymbol)); " is 123.
Long Statement,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetMethodName,The length of the statement  "            //            if (member.GetModifiers().Any(SyntaxKind.NewKeyword) && methodSymbol.OriginalDefinition.ContainingType.TypeKind != TypeKind.Interface) //Take care of new " is 167.
Long Statement,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,WriteMethodPointer,The length of the statement  "                    //   var methodName = TypeProcessor.ConvertType(methodSymbol.ContainingType) +"."+ WriteIdentifierName.TransformIdentifier(methodSymbol.Name); " is 142.
Long Statement,SharpNative.Compiler,OutputWriter,C:\repos\afrogeek_SharpNative\Compiler\OutputWriter.cs,Finalize,The length of the statement  "                //                var myHeader = TypeProcessor.GetHeaderName(TypeState.Instance.Namespace + "." + TypeState.Instance.TypeName); " is 127.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetFullName,The length of the statement  "                result = Context.Instance.SymbolNames[namespaceSymbol.ContainingNamespace' namespaceSymbol.ContainingNamespace.GetFullName()] + "." + result; " is 141.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetCSharpName,The length of the statement  "                return field.Declaration.Variables.Select(j=> WriteIdentifierName.TransformIdentifier(j.Identifier.Text)).Aggregate((a'b)=>a+"'"+b); " is 132.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetCSharpName,The length of the statement  "                return _eventField.Declaration.Variables.Select(j => WriteIdentifierName.TransformIdentifier(j.Identifier.Text)).Aggregate((a' b) => a + "'" + b); " is 146.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetContainingType,The length of the statement  "            return (ITypeSymbol)ModelExtensions.GetDeclaredSymbol(Context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree)' classDeclaration); " is 139.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetContainingMethod,The length of the statement  "                    (IMethodSymbol)ModelExtensions.GetDeclaredSymbol(Context.Compilation.GetSemanticModel(method.SyntaxTree)' (ConstructorDeclarationSyntax)method); " is 144.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetContainingMethod,The length of the statement  "                (IMethodSymbol)ModelExtensions.GetDeclaredSymbol(Context.Compilation.GetSemanticModel(method.SyntaxTree)' (MethodDeclarationSyntax)method); " is 139.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsUnconstructedType,The length of the statement  "//            namedTypeSymbol.ConstructedFrom.ToString() != namedTypeSymbol.ToString() && namedTypeSymbol.ConstructedFrom.ConstructedFrom.ToString() == namedTypeSymbol.ConstructedFrom.ToString() && namedTypeSymbol.HasOrIsEnclosedInGenericParameters() " is 250.
Long Statement,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,GetDetails,The length of the statement  "            return String.Format("{0} (Line {1}:{2}' Line {3}:{4}) node: {5}' Type: {6}"' fileName' startLine.Line + 1' startLine.Character + 1' " is 132.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteNamespaces,The length of the statement  "            //For now ignore system namespace to prevent conflicts' later we should just check if the module is defined in our sources " is 122.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteNamespaces,The length of the statement  "                        var alltypes = @namespace.Key.GetTypeMembers().Union(@namespace.Value).DistinctBy(k=>k); // For purposes of reflection ... later this should become opt-out ... just use "version(SharpNativeReflection) " is 200.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteNamespaces,The length of the statement  "                        //                        foreach (var @name in namespaces.DistinctBy(o=>o.Key).Except(@namespace)) //Cant work leads to cycles " is 127.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteNamespaces,The length of the statement  "                            var allClasses = alltypes.Where(type => genericMethod.ContainingType.IsAssignableFrom(type)).ToList(); // Or use a HashSet' for better Contains perf. " is 149.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteNamespaces,The length of the statement  "                       // writer.WriteLine("public final static " + TypeProcessor.ConvertType(genericMethod.ReturnType) + WriteIdentifierName.TransformIdentifier(genericMethod.Name) +  ); " is 164.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteNamespaces,The length of the statement  "                                   WriteMethod.WriteIt(writer'(MethodDeclarationSyntax) genericMethod.DeclaringSyntaxReferences[0].GetSyntax()'true' allClasses); " is 126.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteReflectionInfo,The length of the statement  "            writer.WriteLine(".__Setup(" + (specialization.BaseType!=null?("__TypeOf!(" + TypeProcessor.ConvertType(specialization.BaseType' false' false' false)+")") :"null") + "'" + (specialization.Interfaces.Length>0? ("[" + specialization.Interfaces.Select( " is 249.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteReflectionInfo,The length of the statement  "                                ? ".__Field(\"{0}\"' new FieldInfo__G!({1}'{2})(function {2} ({1}* _param_{4}){{ return _param_{4}.{3};}}'function void ({1}* _param_{4}' {2} _param_{0}){{ _param_{4}.{3} = _param_{0};}})' {5})" " is 194.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteReflectionInfo,The length of the statement  "                        // //.__Property("Counter"'new PropertyInfo__G!(Simple'int)(function int (Simple a){ return a.Counter();}'function void (Simple a'int _age){ a.Counter(_age);})) // Need to explicitly set the interfaces etc ... " is 209.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteReflectionInfo,The length of the statement  "                                ".__Constructor(\"{0}\"' new ConstructorInfo__G!({1}'{2} function({4}))( ({4})=> "+ (specialization.TypeKind==TypeKind.Struct?"" :"new ") +"{1}({5})))" " is 151.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,WriteReflectionInfo,The length of the statement  "                writer.WriteLine(".__Method(\"GetType\"' new MethodInfo__G!({0}'System.Namespace.Type function())(&{0}.GetType))"' TypeProcessor.ConvertType(specialization' true' true' false)); " is 177.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,GetGenericMetadataName,The length of the statement  "            return specialization.ContainingNamespace.FullNameWithDotCSharp() + (specialization.ContainingType!=null? specialization.ContainingType.MetadataName +"+" : "") + specialization.MetadataName + " is 191.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,GetGenericMetadataName,The length of the statement  "                    return u.ContainingNamespace.FullNameWithDotCSharp() + (u.ContainingType != null ? (u.ContainingType.Name + "+") : "") + (namedTypeSymbol != null && namedTypeSymbol.IsGenericType ? (namedTypeSymbol.GetGenericMetadataName()) : (String.IsNullOrEmpty(u.MetadataName) ? u.Name : u.MetadataName)); " is 292.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,Generate,The length of the statement  "//    public abstract class __YieldIterator<T> : System.Collections.Generic.IEnumerable<T>' System.Collections.Generic.IEnumerator<T> " is 133.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessTypes,The length of the statement  "                }).Where(k => k.Symbol.ContainingType == null && (k.Symbol.ContainingNamespace.FullNameWithDot() + k.TypeName)!= "System.Namespace.__YieldIterator__G") // Ignore all nested classes " is 180.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessTypes,The length of the statement  "                                Console.WriteLine("An exception occurred: " + ex.Message + "\r\n" + ex.StackTrace + "\r\nwhile processing node " + Context.LastNode.ToFullString() + " in " + Context.Instance.TypeName + " from " + Context.LastNode.GetDetails()); " is 228.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,IsSpecialized,The length of the statement  "                    return k.TypeKind != TypeKind.TypeParameter && (asNamed != null && asNamed.TypeArguments.All(l => IsSpecialized(l as INamedTypeSymbol))); " is 137.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,GetGenericSpecializations,The length of the statement  "                .SelectMany(o => o.GetRoot().DescendantNodes().OfType<GenericNameSyntax>().Union(o.GetRoot().DescendantNodes().OfType<TypeSyntax>())) " is 133.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializers,The length of the statement  "                    //                      Console.WriteLine ("Found a root..." + initcounter++ + ": " + target.GetLocation().GetLineSpan()); " is 122.
Long Statement,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializers,The length of the statement  "                        //                                      newList.Add ((ObjectCreationExpressionSyntax)newRoot.GetCurrentNode (statementSyntax)); " is 127.
Long Statement,SharpNative.Compiler,TriviaProcessor,C:\repos\afrogeek_SharpNative\Compiler\TriviaProcessor.cs,ProcessTrivias,The length of the statement  "            //if we encounter a #if SharpNative' we set this to true' which indicates that the next DisabledTextTrivia should be written as pure code.    " is 138.
Long Statement,SharpNative.Compiler,TriviaProcessor,C:\repos\afrogeek_SharpNative\Compiler\TriviaProcessor.cs,DoNotWrite,The length of the statement  "            //set to 1 if we encounter a #if !SharpNative directive (while it's 0).  Incremented for each #if that's started inside of that' and decremented for each #endif " is 160.
Long Statement,SharpNative.Compiler,TriviaProcessor,C:\repos\afrogeek_SharpNative\Compiler\TriviaProcessor.cs,DoNotWrite,The length of the statement  "            //set to 1 if we encounter an #if SharpNative directive (while it's 0).  Incremented for each #if that's started inside of that' and decremented for each #endif " is 160.
Long Statement,SharpNative.Compiler,TypeProcessor,C:\repos\afrogeek_SharpNative\Compiler\TypeProcessor.cs,ConvertTypeUncached,The length of the statement  "//                            k => typeString.StartsWith(k.Name.ToFullString() + ".Namespace."' StringComparison.Ordinal)); " is 123.
Long Statement,SharpNative.Compiler,TypeProcessor,C:\repos\afrogeek_SharpNative\Compiler\TypeProcessor.cs,ConvertTypeUncached,The length of the statement  "                    return typeSymbol.ContainingNamespace.FullNameWithDot(true'false) + WriteIdentifierName.TransformIdentifier(typeSymbol.Name); " is 125.
Long Statement,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The length of the statement  "                //                    writer.Write(""); // Ideally Escape analysis should take care of this' but for now all value types are on heap and ref types on stack " is 155.
Long Statement,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The length of the statement  "                //    throw new Exception("Initalizers along with array sizes are not supported - please use a size or an initializer " + Utility.Descriptor(array)); " is 149.
Long Statement,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The length of the statement  "            //                        // Ideally Escape analysis should take care of this' but for now all value types are on heap and ref types on stack " is 141.
Long Statement,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The length of the statement  "            //                        // Ideally Escape analysis should take care of this' but for now all value types are on heap and ref types on stack " is 141.
Long Statement,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The length of the statement  "            //                //                    writer.Write(""); // Ideally Escape analysis should take care of this' but for now all value types are on heap and ref types on stack " is 173.
Long Statement,SharpNative.Compiler,WriteArrayCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteArrayCreationExpression.cs,Go,The length of the statement  "            //                //    throw new Exception("Initalizers along with array sizes are not supported - please use a size or an initializer " + Utility.Descriptor(array)); " is 167.
Long Statement,SharpNative.Compiler,WriteBinaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteBinaryExpression.cs,ProcessExpression,The length of the statement  "                //We should start with exact converters and then move to more generic convertors i.e. base class or integers which are implicitly convertible " is 141.
Long Statement,SharpNative.Compiler,WriteCastExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteCastExpression.cs,Go,The length of the statement  "                //We should start with exact converters and then move to more generic convertors i.e. base class or integers which are implicitly convertible " is 141.
Long Statement,SharpNative.Compiler,WriteCastExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteCastExpression.cs,Go,The length of the statement  "                //                            initializerType.Type.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 216.
Long Statement,SharpNative.Compiler,WriteCastExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteCastExpression.cs,Go,The length of the statement  "                    //.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 168.
Long Statement,SharpNative.Compiler,WriteCastExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteCastExpression.cs,Go,The length of the statement  "                //We should start with exact converters and then move to more generic convertors i.e. base class or integers which are implicitly convertible " is 141.
Long Statement,SharpNative.Compiler,WriteCastExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteCastExpression.cs,Go,The length of the statement  "                //                            initializerType.Type.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 216.
Long Statement,SharpNative.Compiler,WriteCastExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteCastExpression.cs,Go,The length of the statement  "                    //.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 168.
Long Statement,SharpNative.Compiler,WriteConstructorBody,C:\repos\afrogeek_SharpNative\Compiler\WriteConstructor.cs,Go,The length of the statement  "            //Only write out static constructors here.  If we encounter an instance constructor' we can ignore it since it's already written out by WriteType " is 145.
Long Statement,SharpNative.Compiler,WriteConstructorBody,C:\repos\afrogeek_SharpNative\Compiler\WriteConstructor.cs,WriteInstanceConstructor,The length of the statement  "				writer.WriteLine(accessmodifiers + constructorName + WriteMethod.GetParameterListAsString(method.ParameterList.Parameters)); " is 124.
Long Statement,SharpNative.Compiler,WriteConstructorBody,C:\repos\afrogeek_SharpNative\Compiler\WriteConstructor.cs,ShouldUseOverrideKeyword,The length of the statement  "                //partial methods seem exempt from C#'s normal override keyword requirement' so we have to check manually to see if it exists in a base class " is 141.
Long Statement,SharpNative.Compiler,WriteElementAccessExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteElementAccessExpression.cs,Go,The length of the statement  "            //Todo if we are using unsafe / fast mode' just use array->Data()[i] should bypass bounds check and indirection also should be as fast as pure c++ arrays " is 153.
Long Statement,SharpNative.Compiler,WriteEnum,C:\repos\afrogeek_SharpNative\Compiler\WriteEnum.cs,Go,The length of the statement  "            if (Context.Instance.Type.GetAttributes().Any(k => k.AttributeClass != null && k.AttributeClass.Name == "FlagsAttribute")) " is 122.
Long Statement,SharpNative.Compiler,WriteEnum,C:\repos\afrogeek_SharpNative\Compiler\WriteEnum.cs,Go,The length of the statement  "            writer.WriteLine(string.Format("public this({0} value)"' TypeProcessor.ConvertType(Context.Instance.Type.EnumUnderlyingType))); " is 127.
Long Statement,SharpNative.Compiler,WriteEnum,C:\repos\afrogeek_SharpNative\Compiler\WriteEnum.cs,Go,The length of the statement  "            writer.WriteLine("public enum __names =[" + values.Select(j => "\"" + WriteIdentifierName.TransformIdentifier(j.Syntax.Identifier.Text) + "\"").Aggregate((a' b) => a + "'" + b) + "];"); " is 185.
Long Statement,SharpNative.Compiler,WriteEnum,C:\repos\afrogeek_SharpNative\Compiler\WriteEnum.cs,Go,The length of the statement  "            //                                 //(genericArgs.Any() ? ("( " + (string.Join(" ' "' genericArgs.Select(o => o)) + " )")) : "") +//Internal boxed should not be generic " is 168.
Long Statement,SharpNative.Compiler,WriteEvent,C:\repos\afrogeek_SharpNative\Compiler\WriteEvent.cs,Go,The length of the statement  "            var methodName = WriteIdentifierName.TransformIdentifier(MemberUtilities.GetMethodName(eventSymbol' ref isInterface' out interfaceImplemented' out proxies)); " is 157.
Long Statement,SharpNative.Compiler,WriteEvent,C:\repos\afrogeek_SharpNative\Compiler\WriteEvent.cs,Go,The length of the statement  "                //                if (property.Modifiers.Any(SyntaxKind.PublicKeyword) || property.Modifiers.Any(SyntaxKind.InternalKeyword)) " is 125.
Long Statement,SharpNative.Compiler,WriteEvent,C:\repos\afrogeek_SharpNative\Compiler\WriteEvent.cs,Go,The length of the statement  "                        writer.WriteLine("__Event!(" + typeString + ") " + name + "(" + (interfaceImplemented!=null ? (  TypeProcessor.ConvertType(interfaceImplemented) + " __ij = null") :"")+") @property"); " is 183.
Long Statement,SharpNative.Compiler,WriteField,C:\repos\afrogeek_SharpNative\Compiler\WriteField.cs,Go,The length of the statement  "//            var isPtr = typeinfo.Type != null && (typeinfo.Type.IsValueType || typeinfo.Type.TypeKind==TypeKind.TypeParameter) ? "" : ""; " is 139.
Long Statement,SharpNative.Compiler,WriteField,C:\repos\afrogeek_SharpNative\Compiler\WriteField.cs,Go,The length of the statement  "//                    writer.Write((!string.IsNullOrEmpty(fieldInfo.ContainingNamespace.FullName())?(fieldInfo.ContainingNamespace.FullName()+".") :"") + fieldInfo.Name+"."+name); " is 179.
Long Statement,SharpNative.Compiler,WriteForEachStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteForEachStatement.cs,Go,The length of the statement  "                writer.WriteLine("auto {0} = {1}[{2}];"' WriteIdentifierName.TransformIdentifier(foreachStatement.Identifier.Text)' forArray' forIter); " is 135.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "            //                            interfaceMethod = interfaceMethods.FirstOrDefault(k => CompareMethods(k as IMethodSymbol' methodSymbol)); " is 135.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "                                    && !containingType.IsAssignableFrom(Context.Instance.Type);// !(invocationExpression.Expression is BaseExpressionSyntax); " is 121.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "            //When the code specifically names generic arguments' include them in the method name ... dmd needs help with inference' so we give it the types anyway " is 151.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "                //return TryConvertType(named) + (named.TypeKind == TypeKind.Struct && o.ConstraintTypes.Any(k => k.TypeKind == //TypeKind.Interface) ? ".__Boxed_" : ""); " is 154.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "                named.TypeArguments.Select(o => TypeProcessor.GetGenericParameterType(named.TypeParameters[named.TypeArguments.IndexOf(o)]' o)).Aggregate((a' b) => a + "' " + b) " is 161.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "//                                     ((IMethodSymbol) symbol).TypeArguments.Select(r => TypeProcessor.ConvertType(r)  )) + " is 124.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "            //Determine if it's an extension method called in a non-extension way.  In this case' just pretend it's not an extension method " is 127.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "            //              extensionNamespace = null; //override Translations.xml for nullable enums. We want them to convert to the enum's ToString method " is 144.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "            //&& methodSymbol.ContainingType!=Context.Instance.Type; //If we are currently working on a basic type e.g. in corlib' don't alter the code " is 139.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "                    var methodDeclarationSyntaxs = declaringSyntaxReferences as MethodDeclarationSyntax[] ?? declaringSyntaxReferences.ToArray(); " is 125.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "                        writer.Write(WriteIdentifierName.TransformIdentifier(methodSymbol.ContainingType.Name'methodSymbol.ContainingType) + "."); " is 122.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "            bool isOverloaded = methodSymbol.ContainingType.GetMembers(methodSymbol.Name).OfType<IMethodSymbol>().Any(j => j.TypeParameters == methodSymbol.TypeParameters && ParameterMatchesWithRefOutIn(methodSymbol' j)); " is 209.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,Go,The length of the statement  "            WriteArguments(writer' invocationExpression' arguments' firstParameter' inParams' methodSymbol' foundParamsArray' typeSymbol' isOverloaded' symbol'instanceName); " is 161.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                var shouldBox = initializerType.Type != null && (initializerType.Type!=initializerType.ConvertedType) && ((initializerType.Type.IsValueType || initializerType.Type.TypeKind == TypeKind.TypeParameter) && " is 202.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                var shouldCast=  initializerType.Type != null && (initializerType.Type.TypeKind==TypeKind.Interface && initializerType.ConvertedType.SpecialType==SpecialType.System_Object); " is 173.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                var shouldUnBox = initializerType.Type != null && (initializerType.Type != initializerType.ConvertedType) && !initializerType.Type.IsValueType && " is 145.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                    //We should start with exact converters and then move to more generic convertors i.e. base class or integers which are implicitly convertible " is 141.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                    //                            initializerType.Type.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 216.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                        //.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 168.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                    //We should start with exact converters and then move to more generic convertors i.e. base class or integers which are implicitly convertible " is 141.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                    //                            initializerType.Type.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 216.
Long Statement,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The length of the statement  "                        //.GetMembers("op_Implicit").OfType<IMethodSymbol>().FirstOrDefault(h => h.ReturnType == initializerType.Type && h.Parameters[0].Type == initializerType.ConvertedType); " is 168.
Long Statement,SharpNative.Compiler,WriteLiteralExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteLiteralExpression.cs,Go,The length of the statement  "                    if (typeInfo.ConvertedType != typeInfo.Type && typeInfo.ConvertedType.IsPrimitiveInteger() && typeInfo.Type.IsPrimitiveInteger()) " is 129.
Long Statement,SharpNative.Compiler,WriteLocalDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteLocalDeclaration.cs,Go,The length of the statement  "                        //   writer.Write("auto ");//Kills BoxingTest unfortunately as boxed types are also used to make unbound generics work :( " is 121.
Long Statement,SharpNative.Compiler,WriteLocalDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteLocalDeclaration.cs,ProcessInitializer,The length of the statement  "                if (type == null && convertedType == null) //TODO: Rare Case (Compiling csnative corlib... need to find a solution' for now just write it out " is 141.
Long Statement,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetParameterListAsString,The length of the statement  "                bool isRef = parameter.RefKind == RefKind.Ref || parameter.RefKind == RefKind.Out;// parameter.Modifiers.Any(SyntaxKind.OutKeyword) || " is 134.
Long Statement,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetParameterListAsString,The length of the statement  "                     var type = (TypeProcessor.GetTypeInfo(parameter.Type).Type ?? TypeProcessor.GetTypeInfo(parameter.Type).ConvertedType) as IArrayTypeSymbol; " is 139.
Long Statement,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetParameterListAsString,The length of the statement  "                    var type = (TypeProcessor.GetTypeInfo(parameter.Type).Type ?? TypeProcessor.GetTypeInfo(parameter.Type).ConvertedType) as IArrayTypeSymbol; " is 139.
Long Statement,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,WriteIt,The length of the statement  "                   ( ((INamedTypeSymbol)methodSymbol.ReturnType).TypeArguments.Any() && ((INamedTypeSymbol)methodSymbol.ReturnType).TypeArguments[0].TypeKind==TypeKind.TypeParameter) ? "__G" : ""); " is 178.
Long Statement,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetMethodConstraints,The length of the statement  "                                constraints += ((isFirst ? "" : "&&") + " is(" + constraintName + " : " + TypeProcessor.ConvertType(type'true'true'true) + " is 122.
Long Statement,SharpNative.Compiler,WriteMethod,C:\repos\afrogeek_SharpNative\Compiler\WriteMethod.cs,GetMethodConstraints,The length of the statement  "							constraints += ((isFirst ? "" : "&&") + " is(" + constraintName + " : " + dlangCondition.Replace("<"'"!(").Replace(">"'")") + " is 125.
Long Statement,SharpNative.Compiler,WriteObjectCreationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteObjectCreationExpression.cs,Go,The length of the statement  "                //new'ing up a Nullable<T> has special sematics in C#.  If we're calling this with no parameters' just use null. Otherwise just use the parameter. " is 146.
Long Statement,SharpNative.Compiler,WriteOperatorDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteOperatorDeclaration.cs,Go,The length of the statement  "                //TypeProcessor.ConvertType (paramType.Type)' actualMethodName' token' methodBody.Replace(method.ParameterList.Parameters[0].Identifier.ValueText'"this"))); " is 156.
Long Statement,SharpNative.Compiler,WriteOperatorDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteOperatorDeclaration.cs,Go,The length of the statement  "            writer.WriteLine("public static " + returnType + " " + actualMethodName + WriteMethod.GetParameterListAsString(method.ParameterList.Parameters)); " is 145.
Long Statement,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,ConvertPInvokeType,The length of the statement  "////					return "(" + string.Join ("' "' dlg.Parameters.ToList ().Select (o => TryConvertType (o.Type))) + ") => " + TryConvertType (dlg.ReturnType); " is 149.
Long Statement,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,Go,The length of the statement  "//			var methodParams = methodSymbol.Parameters.Any () ? methodSymbol.Parameters.Select (h => ConvertPInvokeType (h.Type)).Aggregate ((k' y) => (k) + " '" + y) : ""; " is 165.
Long Statement,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,Go,The length of the statement  "//                                    pinvokeAttributes.ArgumentList.Arguments.FirstOrDefault(g => g.Expression != null) " is 120.
Long Statement,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,Go,The length of the statement  "                var methodInternalName = TypeProcessor.ConvertType(methodSymbol.ContainingType'false).Replace(".Namespace."'"_").Replace("."'"_")+ "_" + methodName; " is 148.
Long Statement,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,GetParameterList,The length of the statement  "//				bool isRef = parameter.Modifiers.Any (SyntaxKind.OutKeyword) || parameter.Modifiers.Any (SyntaxKind.RefKeyword);// || parameter.Modifiers.Any (SyntaxKind.InKeyword); " is 171.
Long Statement,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,GetParameterList,The length of the statement  "                //				var ptr = (localSymbol.Type != null && !(localSymbol.Type.IsValueType || localSymbol.Type.TypeKind == TypeKind.TypeParameter)); " is 133.
Long Statement,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,GetParameterList,The length of the statement  "                //					Program.RefOutSymbols.TryAdd (TypeProcessor.GetDeclaredSymbol (parameter)' null); //TODO: clean this completely out' not at all needed for Dlang " is 151.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "                        //                        getterbody=String.Format("return new __IteratorBlock!({0})(delegate(__IteratorBlock!({0}) __iter){{ {1} }});"' " is 136.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "                   (((INamedTypeSymbol)propertySymbol.Type).TypeArguments.Any() && ((INamedTypeSymbol)propertySymbol.Type).TypeArguments[0].TypeKind == TypeKind.TypeParameter) ? "__G" : ""); " is 171.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "                parameters = WriteMethod.GetParameterListAsString(@params.Parameters' iface: proxies == null ? iface : null' writebraces: false); " is 129.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "            WriteGetter(writer' isProxy' hasGetter' acccessmodifiers' typeString' name'  proxies == null ? iface : null' getterHasBody' modifiers' isInterface' fieldName' getterbody' parameters' indexerDeclarationSyntax != null); " is 217.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "            WriteSetter(writer' isProxy' hasSetter' acccessmodifiers' name' typeString' proxies == null ? iface : null' isOverride' setterHasBody' modifiers' isInterface' fieldName' setterbody' parameters' isindexer'hasGetter); " is 215.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "//				var fieldacccessmodifiers = acccessmodifiers.Replace ("abstract"' "").Replace ("virtual"'"").Replace("override"'""); " is 122.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "//					staticWriter.WriteLine (name + String.Format (" = __Property!(" + typeString + ")(__ToDelegate(&set{0})' __ToDelegate(&get{0}));"' name)); " is 145.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "//					instanceWriter.WriteLine (name + String.Format (" = __Property!(" + typeString + ")((&set{0})' (&get{0}));"' name)); " is 123.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "                            parameters2 = WriteMethod.GetParameterListAsString(@params.Parameters' iface: null' includeTypes: false'writebraces:false); " is 123.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "                           // parameters2 = WriteMethod.GetParameterListAsString(@params.Parameters' iface: proxies == null ? iface : null' writebraces: false); " is 133.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "                        setterbody = writer.WriteIndentToString() + "return opIndexAssign(value'" + parameters2 + ");";// + "=" + "value" + ";"; " is 120.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "                    WriteGetter(writer' isProxy' hasGetter' acccessmodifiers' typeString' name' proxy.ContainingType' getterHasBody' modifiers' isInterface' fieldName' getterbody' parameters' isindexer); " is 183.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The length of the statement  "					WriteSetter (writer' isProxy' hasSetter' acccessmodifiers' name' typeString' proxy.ContainingType' isOverride' setterHasBody' modifiers' isInterface' fieldName' setterbody' parameters' isindexer'hasGetter); " is 206.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteSetter,The length of the statement  "					writer.WriteLine (string.Format ("{0} {2} {5}{1}({2} value{3}{4}){4} {{  __Value.{1} = value; return value;}}"' acccessmodifiers' name' hasGetter ? typeString : "void"' (iface != null ? ("'" + TypeProcessor.ConvertType (iface) + " __ig=null") : "")' isOverride' args)); " is 269.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteSetter,The length of the statement  "					writer.WriteLine (string.Format ("{0} {2} {1}({2} value'{3}{4}) {4} {{  __Value.{1} = value;return value;}}"' acccessmodifiers' name' typeString' parameters' isOverride)); " is 171.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteSetter,The length of the statement  "						writer.WriteLine (string.Format ("{0} {2} {5}{1}({2} value{3}{4});"' acccessmodifiers' name' hasGetter ? typeString : "void"' (iface != null ? ("'" + TypeProcessor.ConvertType (iface) + " __ig=null") : "")' isOverride' args)); " is 226.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteSetter,The length of the statement  "						writer.WriteLine (string.Format ("{0} {2} {1}({2} value'{3}{4});"' acccessmodifiers' name' typeString' parameters' isOverride)); " is 128.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteSetter,The length of the statement  "                        writer.WriteLine (string.Format("{0} {2} {6}{1}({2} value{3}){4} {{{5} = value;{7}}}"' acccessmodifiers' name' hasGetter?typeString :"void"' (iface != null ? ("'" + TypeProcessor.ConvertType (iface) + " __ig=null") : "")' isOverride' fieldName' args'returnValue)); " is 264.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteSetter,The length of the statement  "                        writer.WriteLine (string.Format("{0} {2} {1}({2} value'{3}){4} {{{5} = value;{6}}}" ' acccessmodifiers' name' typeString' parameters' isOverride' fieldName' returnValue)); " is 171.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteGetter,The length of the statement  "					writer.WriteLine (string.Format ("{0}{1} {4}{2}({3}) {{ return __Value.{2};}}"' acccessmodifiers' typeString' name' (iface != null ? (TypeProcessor.ConvertType (iface) + " __ig=null") : "")' args)); " is 198.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteGetter,The length of the statement  "					writer.WriteLine (string.Format ("{0}{1} {2}({3})  {{ return __Value.{2};}}"' acccessmodifiers' typeString' name' parameters)); " is 127.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteGetter,The length of the statement  "						writer.WriteLine (string.Format ("{0}{1} {4}{2}({3});"' acccessmodifiers' typeString' name' (iface != null ? (TypeProcessor.ConvertType (iface) + " __ig=null") : "")' args)); " is 174.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteGetter,The length of the statement  "						writer.WriteLine (string.Format ("{0}{1} {5}{2}({3}) {{ return {4};}}"' acccessmodifiers' typeString' name' (iface != null ? (TypeProcessor.ConvertType (iface) + " __ig=null") : "")' fieldName' args)); " is 201.
Long Statement,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteGetter,The length of the statement  "						writer.WriteLine (string.Format ("{0}{1} {2}({3})  {{ return {4};}}"' acccessmodifiers' typeString' name' parameters' fieldName)); " is 130.
Long Statement,SharpNative.Compiler,WriteSwitchStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteSwitchStatement.cs,Go,The length of the statement  "				writer.WriteLine ("switch(" + Core.WriteString (switchStatement.Expression) + (isStringSwitch ? ".Hash" : "") + (isEnumSwitch ? ".__Value" : "") + ")"); " is 152.
Long Statement,SharpNative.Compiler,WriteSwitchStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteSwitchStatement.cs,Go,The length of the statement  "					writer.WriteLine ("switch(" + Core.WriteString (switchStatement.Expression) + (isStringSwitch ? ".Hash" : "") + (isEnumSwitch ? ".__Value" : "") + ")"); " is 152.
Long Statement,SharpNative.Compiler,WriteThrowStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteThrowStatement.cs,Go,The length of the statement  "                //On just "throw" with no exception name' navigate up the stack to find the nearest catch block and insert the exception's name " is 127.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The length of the statement  "            TypeProcessor.AddAlias(Context.Instance.Type.ContainingNamespace as INamespaceSymbol' Context.Instance.Type.ContainingNamespace.GetModuleName()); " is 145.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The length of the statement  "                var baselist = typeSymbols.Select(k => k.Syntax.As<BaseTypeDeclarationSyntax>()).Select(o => o.BaseList).Where(k => k != null).ToArray(); " is 137.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The length of the statement  "                                          !(typeSymbols.First().Symbol.TypeKind == TypeKind.Interface || typeSymbols.First().Symbol.TypeKind == TypeKind.Struct))) " is 120.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The length of the statement  "                    //                            "Overloaded constructors are not supported.  Consider changing all but one to static Create methods " + " is 133.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The length of the statement  "                    //                    if (membersToWrite.Count == 0 && (partials.Any(o => o.Syntax.Modifiers.Any(SyntaxKind.StaticKeyword)))) " is 125.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The length of the statement  "                            //						writer.Write (" class "); // Allows inheritance ... but too many issues' will look at this when it gets relevant " is 120.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,GetTypeConstraints,The length of the statement  "                            constraints += (isFirst ? "" : "&&") + "is(" + WriteIdentifierName.TransformIdentifier(constraint.Name.ToFullString()) + ":" + TypeProcessor.ConvertType(type) +")"; " is 164.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,GetTypeConstraints,The length of the statement  "                            constraints += (isFirst ? "" : "&&") + "__isNewwable!(" + WriteIdentifierName.TransformIdentifier(constraint.Name.ToFullString()) + ")"; " is 136.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,GetTypeConstraints,The length of the statement  "                                constraints += (isFirst ? "" : "&&") + "__isCSStruct!(" + WriteIdentifierName.TransformIdentifier(constraint.Name.ToFullString()) + ")"; " is 136.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,GetTypeConstraints,The length of the statement  "                                constraints += (isFirst ? "" : "&&") + "__isClass!(" + WriteIdentifierName.TransformIdentifier(constraint.Name.ToFullString()) + ")"; " is 133.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,GetTypeConstraints,The length of the statement  "                            constraints += ((isFirst ? "" : "&&") + " is(" + constraint.Name + " : " + dlangCondition.Replace("<"' "!(").Replace(">"' ")") + " is 128.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The length of the statement  "                            //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value"); " is 193.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The length of the statement  "                        //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value"); " is 193.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The length of the statement  "                        //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value"); " is 193.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The length of the statement  "                        //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value"); " is 193.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The length of the statement  "                //					var charset = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "CharSet"); " is 124.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutBoxed,The length of the statement  "                                 //(genericArgs.Any() ? ("( " + (string.Join(" ' "' genericArgs.Select(o => o)) + " )")) : "") +//Internal boxed should not be generic " is 133.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutBoxed,The length of the statement  "                //                    writer.WriteLine("return __Value.ToString();"' Program.GetGenericMetadataName(Context.Instance.Type)); " is 124.
Long Statement,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutBoxed,The length of the statement  "                writer.WriteLine("super({0}.init);"' typeName); //TODO fix this for another TypeNew that calls the valuetype constructor only " is 125.
Long Statement,SharpNative.Compiler,WriteUnaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteUnaryExpression.cs,WritePrefix,The length of the statement  "                //					//TODO: cannot take addresses of structs in 32/64-bit mode and subtract them ... really weird d-bug ... leads to wrong math ... should we do a shift ? " is 157.
Long Statement,SharpNative.Compiler,WriteUnaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteUnaryExpression.cs,WritePostfix,The length of the statement  "                //                                    SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression'SyntaxFactory.Literal(-1))) " is 133.
Long Statement,SharpNative.Compiler,WriteUnaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteUnaryExpression.cs,WritePostfix,The length of the statement  "                //                                     SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression' SyntaxFactory.Literal(+1))) " is 135.
Long Statement,SharpNative.Compiler,WriteUsingStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteUsingStatement.cs,Go,The length of the statement  "            //Ensure the using statement is a local variable - we can't deal with things we can't reliably repeat in the finally block " is 122.
Long Statement,SharpNative.Compiler,WriteUsingStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteUsingStatement.cs,Go,The length of the statement  "//                throw new Exception("Using statements must reference a local variable. " + Utility.Descriptor(usingStatement)); " is 129.
Long Statement,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The length of the statement  "                   //   (node.Parent is ExpressionSyntax || node.Parent is MethodDeclarationSyntax || node.Parent is PropertyDeclarationSyntax " is 123.
Long Statement,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The length of the statement  "                      !(node.Parent is QualifiedNameSyntax) && !(node.Parent is MemberAccessExpressionSyntax) && !(node.Parent is ThisExpressionSyntax)) " is 130.
Long Statement,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The length of the statement  "                              if (symbolInfo.Symbol.ContainingType != null && !symbolInfo.Symbol.IsStatic && symbolInfo.Symbol.ContainingType == firstParent) " is 127.
Long Statement,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The length of the statement  "                //   (node.Parent is ExpressionSyntax || node.Parent is MethodDeclarationSyntax || node.Parent is PropertyDeclarationSyntax " is 123.
Long Statement,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The length of the statement  "              !(node.Parent is QualifiedNameSyntax) && !(node.Parent is MemberAccessExpressionSyntax) && !(node.Parent is ThisExpressionSyntax)) " is 130.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,WithBaseList,The length of the statement  "            return declaration.WithBaseList(SyntaxFactory.BaseList(SyntaxFactory.SeparatedList(baseTypes' baseTypes.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))))); " is 171.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,WithParameterList,The length of the statement  "            return constructor.WithParameterList(SyntaxFactory.ParameterList(SyntaxFactory.SeparatedList(parameters' parameters.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))))); " is 183.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,WithParameterList,The length of the statement  "            return method.WithParameterList(SyntaxFactory.ParameterList(SyntaxFactory.SeparatedList(parameters' parameters.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))))); " is 178.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,Property,The length of the statement  "            var propertyDeclarationSyntax = SyntaxFactory.PropertyDeclaration(type' name).WithModifiers(SyntaxFactory.TokenList(new SyntaxToken[] " is 133.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,Field,The length of the statement  "            return SyntaxFactory.FieldDeclaration(SyntaxFactory.VariableDeclaration(type' SyntaxFactory.SeparatedList(new[] { SyntaxFactory.VariableDeclarator(name) }))); " is 158.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,Field,The length of the statement  "            return SyntaxFactory.FieldDeclaration(SyntaxFactory.VariableDeclaration(type' SyntaxFactory.SeparatedList(new[] { SyntaxFactory.VariableDeclarator(name) }))); " is 158.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,WithTypeParameters,The length of the statement  "                .WithTypeParameterList(SyntaxFactory.TypeParameterList(SyntaxFactory.SeparatedList(typeParameters' typeParameters.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))))); " is 181.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,Local,The length of the statement  "            var declaration = SyntaxFactory.LocalDeclarationStatement(SyntaxFactory.VariableDeclaration(SyntaxFactory.ParseTypeName("var")' " is 127.
Long Statement,SharpNative.Compiler.YieldAsync,Cs,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\Cs.cs,New,The length of the statement  "                .WithArgumentList(SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(arguments.Select(x => SyntaxFactory.Argument(x))' arguments.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))))); " is 200.
Long Statement,SharpNative.Compiler.YieldAsync,StatMachineGeneratorFixer,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StatMachineGeneratorFixer.cs,VisitGenericName,The length of the statement  "                if (symbol == null || (new[] { SymbolKind.Field' SymbolKind.Event' SymbolKind.Method' SymbolKind.Property }.Contains(symbol.Kind) && !symbol.ContainingType.Name.StartsWith(enclosingTypeName) && !symbol.IsStatic)) " is 212.
Long Statement,SharpNative.Compiler.YieldAsync,StatMachineGeneratorFixer,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StatMachineGeneratorFixer.cs,VisitGenericName,The length of the statement  "                    return SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' SyntaxFactory.IdentifierName("_this")' node); " is 130.
Long Statement,SharpNative.Compiler.YieldAsync,StatMachineGeneratorFixer,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StatMachineGeneratorFixer.cs,VisitIdentifierName,The length of the statement  "                    if (symbol == null || (new[] { SymbolKind.Field' SymbolKind.Event' SymbolKind.Method' SymbolKind.Property }.Contains(symbol.Kind) && !symbol.ContainingType.Name.StartsWith(enclosingTypeName) && !symbol.IsStatic)) " is 212.
Long Statement,SharpNative.Compiler.YieldAsync,StatMachineGeneratorFixer,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StatMachineGeneratorFixer.cs,VisitIdentifierName,The length of the statement  "                        return SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' SyntaxFactory.IdentifierName("_this")' node); " is 130.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "                constructorParameters.Add(SyntaxFactory.Parameter(SyntaxFactory.Identifier("_this")).WithType(thisField.Declaration.Type)); " is 123.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "                constructorParameters.AddRange((node as MethodDeclarationSyntax).ParameterList.Parameters.Select(x => SyntaxFactory.Parameter(x.Identifier).WithType(x.Type))); " is 159.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "                        constructorParameters.Select(x => Cs.Express(Cs.Assign(Cs.This().Member(x.Identifier)' SyntaxFactory.IdentifierName(x.Identifier)))) " is 132.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "            var ienumerable_g = SyntaxFactory.ParseTypeName("System.Collections.Generic.IEnumerable<" + elementType.ToDisplayString() + ">"); " is 129.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "            var ienumerator_g = SyntaxFactory.ParseTypeName("System.Collections.Generic.IEnumerator<" + elementType.ToDisplayString() + ">"); " is 129.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "           .WithExplicitInterfaceSpecifier(SyntaxFactory.ExplicitInterfaceSpecifier(SyntaxFactory.ParseName("System.Collections.IEnumerable"))) " is 132.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "                    )).WithExplicitInterfaceSpecifier(SyntaxFactory.ExplicitInterfaceSpecifier(SyntaxFactory.ParseName("System.Collections.IEnumerator"))); " is 135.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "                        (method as IMethodSymbol).TypeParameters.Select(x => x).Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))) " is 120.
Long Statement,SharpNative.Compiler.YieldAsync,YieldClassGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldClassGenerator.cs,CreateEnumerator,The length of the statement  "            ClassDeclarationSyntax result = SyntaxFactory.ClassDeclaration(className).WithBaseList(baseTypes).WithMembers(members.ToArray()); " is 129.
Long Statement,SharpNative.Compiler.YieldAsync,YieldGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldGenerator.cs,VisitClassDeclaration,The length of the statement  "            foreach (var method in node.Members.OfType<MemberDeclarationSyntax>().Where(j=>j is MethodDeclarationSyntax || j is PropertyDeclarationSyntax).Where(x => YieldChecker.HasYield(x))) " is 180.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitLocalDeclarationStatement,The length of the statement  "                    var assignment = SyntaxFactory.IdentifierName(variable.Identifier.ToString()).Assign(StateMachineThisFixer.Fix(variable.Initializer.Value)); " is 140.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitTryStatement,The length of the statement  "                finallyState.Add(Cs.If(Cs.This().Member(exceptionName).NotEqualTo(Cs.Null())' Cs.Throw(Cs.This().Member(exceptionName)))); " is 122.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitTryStatement,The length of the statement  "                        SyntaxFactory.CatchClause(SyntaxFactory.CatchDeclaration(SyntaxFactory.ParseTypeName("System.Exception")' exceptionName)' null' gotoFinally) }))); " is 146.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitDoStatement,The length of the statement  "                conditionState.Add(Cs.If(StateMachineThisFixer.Fix(node.Condition)' ChangeState(iterationState)' ChangeState(nextState))); " is 122.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitForStatement,The length of the statement  "                        var assignment = SyntaxFactory.IdentifierName(variable.Identifier.ToString()).Assign(StateMachineThisFixer.Fix(variable.Initializer.Value)); " is 140.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitForStatement,The length of the statement  "                        node = (ForStatementSyntax)HoistVariable(node' variable.Identifier' SyntaxFactory.ParseTypeName(symbol.Type.GetFullName())); " is 124.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitForStatement,The length of the statement  "                var forStatement = SyntaxFactory.WhileStatement(StateMachineThisFixer.Fix(node.Condition) ?? Cs.True()' SyntaxFactory.Block(CaptureState(node.Statement' postState' nextState))); " is 177.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitForEachStatement,The length of the statement  "                currentState.Add(Cs.Express(SyntaxFactory.IdentifierName(enumerator).Assign(SyntaxFactory.InvocationExpression(SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' StateMachineThisFixer.Fix(node.Expression)' SyntaxFactory.IdentifierName("GetEnumerator")))))); " is 284.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitForEachStatement,The length of the statement  "                bodyBatch.Add(Cs.Express(SyntaxFactory.IdentifierName(node.Identifier).Assign(SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression'  " is 155.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitForEachStatement,The length of the statement  "                var moveNext = SyntaxFactory.InvocationExpression(SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' SyntaxFactory.IdentifierName(enumerator)' SyntaxFactory.IdentifierName("MoveNext"))); " is 213.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitSwitchStatement,The length of the statement  "                foreach (var section in node.Sections.Select(x => x.WithStatements(SyntaxFactory.List(x.Statements.Select(BreakStatementStripper.StripStatements))))) " is 149.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitSwitchStatement,The length of the statement  "                    switchStatement = switchStatement.AddSections(Cs.Section(section.Labels' CaptureState(section' switchState.NextState' nextState))); " is 131.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitIfStatement,The length of the statement  "                ifStatement = ifStatement.WithStatement(SyntaxFactory.Block(CaptureState(node.Statement' ifState.NextState' nextState))); " is 121.
Long Statement,SharpNative.Compiler.YieldAsync,YieldStateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\YieldStateGenerator.cs,VisitIfStatement,The length of the statement  "                    ifStatement = ifStatement.WithElse(SyntaxFactory.ElseClause(SyntaxFactory.Block(CaptureState(node.Else' ifState.NextState' nextState)))); " is 137.
Complex Conditional,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The conditional expression  "@event != null && (@event.ContainingType.BaseType != null && @event.ContainingType.BaseType.GetAllMembers().OfType<IEventSymbol>().Any(k => k.Name==@event.Name) && @event.IsOverride==false)"  is complex.
Complex Conditional,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The conditional expression  "@method != null && (@method.ContainingType.BaseType != null && @method.ContainingType.BaseType.GetAllMembers().OfType<IMethodSymbol>().Any(k => MemberUtilities.CompareMethods(k'@method)) && @method.IsOverride == false)"  is complex.
Complex Conditional,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The conditional expression  "@property != null && (@property.ContainingType.BaseType != null && @property.ContainingType.BaseType.GetAllMembers().OfType<IPropertySymbol>().Any(k => k.Name == @property.Name) && @property.IsOverride == false)"  is complex.
Complex Conditional,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,VerifyGetAwaiter,The conditional expression  "!methods.Any(x => x.Name == WellKnownMemberNames.OnCompleted && x.ReturnsVoid && x.Parameters.Length == 1 && x.Parameters.First().Type.TypeKind == TypeKind.Delegate)"  is complex.
Complex Conditional,SharpNative.Compiler,MemberUtilities,C:\repos\afrogeek_SharpNative\Compiler\MemberUtilities.cs,GetAccessModifiers,The conditional expression  "modifiers.Any(SyntaxKind.PublicKeyword) || modifiers.Any(SyntaxKind.InternalKeyword) ||                  modifiers.Any(SyntaxKind.ProtectedKeyword) || modifiers.Any(SyntaxKind.AbstractKeyword) ||                  isInterface"  is complex.
Complex Conditional,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,Main,The conditional expression  "args.Length == 0 || args.Any(o => o == "-?" || o == "--help" || o == "/?")"  is complex.
Complex Conditional,SharpNative.Compiler,TransformedArgument,C:\repos\afrogeek_SharpNative\Compiler\TransformedArgument.cs,Write,The conditional expression  "symbol.Symbol != null && type.ConvertedType != null && symbol.Symbol.Kind == SymbolKind.Method &&                      type.ConvertedType.TypeKind == TypeKind.Delegate"  is complex.
Complex Conditional,SharpNative.Compiler,TriviaProcessor,C:\repos\afrogeek_SharpNative\Compiler\TriviaProcessor.cs,WriteTrailingTrivia,The conditional expression  "trivia.CSharpKind() == SyntaxKind.SingleLineCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.MultiLineCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.SingleLineDocumentationCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.MultiLineDocumentationCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.WhitespaceTrivia"  is complex.
Complex Conditional,SharpNative.Compiler,TriviaProcessor,C:\repos\afrogeek_SharpNative\Compiler\TriviaProcessor.cs,WriteLeadingTrivia,The conditional expression  "trivia.CSharpKind() == SyntaxKind.SingleLineCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.MultiLineCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.SingleLineDocumentationCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.MultiLineDocumentationCommentTrivia ||                      trivia.CSharpKind() == SyntaxKind.WhitespaceTrivia"  is complex.
Complex Conditional,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,IsBasicType,The conditional expression  "specialType == SpecialType.System_Boolean || specialType == SpecialType.System_Byte ||                  specialType == SpecialType.System_Char                  || specialType == SpecialType.System_Double || specialType == SpecialType.System_Enum ||                  specialType == SpecialType.System_Int16                  || specialType == SpecialType.System_Int32 || specialType == SpecialType.System_Int64 ||                  specialType == SpecialType.System_IntPtr                  || specialType == SpecialType.System_Decimal || specialType == SpecialType.System_Double ||                  specialType == SpecialType.System_Single || specialType == SpecialType.System_SByte                  || specialType == SpecialType.System_UInt16 || specialType == SpecialType.System_UInt32 ||                  specialType == SpecialType.System_UInt64 || specialType == SpecialType.System_UIntPtr ||                  specialType == SpecialType.System_Void"  is complex.
Complex Conditional,SharpNative.Compiler,WriteBinaryExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteBinaryExpression.cs,ProcessExpression,The conditional expression  "(rightExpressionType.Type != null && rightExpressionType.Type.IsValueType) ||                      (leftExpressionType.Type != null && leftExpressionType.Type.IsValueType)"  is complex.
Complex Conditional,SharpNative.Compiler,WriteConstructorBody,C:\repos\afrogeek_SharpNative\Compiler\WriteConstructor.cs,WriteInstanceConstructor,The conditional expression  "method.Modifiers.Any(SyntaxKind.PublicKeyword) || method.Modifiers.Any(SyntaxKind.InternalKeyword) ||                  method.Modifiers.Any(SyntaxKind.ProtectedKeyword) || method.Modifiers.Any(SyntaxKind.AbstractKeyword) ||                  isInterface"  is complex.
Complex Conditional,SharpNative.Compiler,WriteEvent,C:\repos\afrogeek_SharpNative\Compiler\WriteEvent.cs,Go,The conditional expression  "modifiers.Any(SyntaxKind.PublicKeyword) || modifiers.Any(SyntaxKind.InternalKeyword) ||                      modifiers.Any(SyntaxKind.ProtectedKeyword) || modifiers.Any(SyntaxKind.AbstractKeyword) ||                      isInterface"  is complex.
Complex Conditional,SharpNative.Compiler,WriteField,C:\repos\afrogeek_SharpNative\Compiler\WriteField.cs,Go,The conditional expression  "modifiers.Any(SyntaxKind.PublicKeyword) || modifiers.Any(SyntaxKind.InternalKeyword) ||                  modifiers.Any(SyntaxKind.ProtectedKeyword) || modifiers.Any(SyntaxKind.AbstractKeyword)"  is complex.
Complex Conditional,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,WriteAutoFieldName,The conditional expression  "(hasGetter && !getterHasBody) &&                      (hasSetter && !setterHasBody) && (!modifiers.Any(SyntaxKind.AbstractKeyword))"  is complex.
Complex Conditional,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The conditional expression  "bases != null && (!bases.Any((j => j.TypeKind != TypeKind.Interface)) &&                                            !(typeSymbols.First().Symbol.TypeKind == TypeKind.Interface || typeSymbols.First().Symbol.TypeKind == TypeKind.Struct))"  is complex.
Complex Conditional,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The conditional expression  "node is IdentifierNameSyntax &&                     //   (node.Parent is ExpressionSyntax || node.Parent is MethodDeclarationSyntax || node.Parent is PropertyDeclarationSyntax                       // || node.Parent is BlockSyntax) &&                        !(node.Parent.Parent is InitializerExpressionSyntax) &&                        !(node.Parent is QualifiedNameSyntax) && !(node.Parent is MemberAccessExpressionSyntax) && !(node.Parent is ThisExpressionSyntax)"  is complex.
Complex Conditional,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The conditional expression  "node is MemberAccessExpressionSyntax &&                  //   (node.Parent is ExpressionSyntax || node.Parent is MethodDeclarationSyntax || node.Parent is PropertyDeclarationSyntax                  // || node.Parent is BlockSyntax) &&                  !(node.Parent.Parent is InitializerExpressionSyntax) &&                !(node.Parent is QualifiedNameSyntax) && !(node.Parent is MemberAccessExpressionSyntax) && !(node.Parent is ThisExpressionSyntax)"  is complex.
Complex Conditional,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,Visit,The conditional expression  "symbol != null && (!(symbol                                      is                                      ILocalSymbol) && !(symbol is IParameterSymbol) && symbol.Name != ".ctor")"  is complex.
Complex Conditional,SharpNative.Compiler.YieldAsync,StateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StateGenerator.cs,CaptureState,The conditional expression  "currentState != breakState && currentState != catchBatch && currentState != nextState && currentState != oldState"  is complex.
Complex Conditional,SharpNative.Compiler.YieldAsync,StatMachineGeneratorFixer,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StatMachineGeneratorFixer.cs,VisitGenericName,The conditional expression  "symbol == null || (new[] { SymbolKind.Field' SymbolKind.Event' SymbolKind.Method' SymbolKind.Property }.Contains(symbol.Kind) && !symbol.ContainingType.Name.StartsWith(enclosingTypeName) && !symbol.IsStatic)"  is complex.
Complex Conditional,SharpNative.Compiler.YieldAsync,StatMachineGeneratorFixer,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StatMachineGeneratorFixer.cs,VisitIdentifierName,The conditional expression  "symbol == null || (new[] { SymbolKind.Field' SymbolKind.Event' SymbolKind.Method' SymbolKind.Property }.Contains(symbol.Kind) && !symbol.ContainingType.Name.StartsWith(enclosingTypeName) && !symbol.IsStatic)"  is complex.
Empty Catch Block,SharpNative.Compiler,Context,C:\repos\afrogeek_SharpNative\Compiler\Context.cs,UpdateContext,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,FileExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,ExecuteCommand,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,FileExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,ExecuteCommand,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,FileExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,DeleteFile,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializers,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessObjectInitializer,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The method has an empty catch block.
Empty Catch Block,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The method has an empty catch block.
Magic Number,SharpNative.Compiler,ConversionExtensions,C:\repos\afrogeek_SharpNative\Compiler\ConversionExtensions.cs,GetImplicitCoversionOp,The following statement contains a magic number: int lastSizeDiff = 1000;
Magic Number,SharpNative.Compiler,ConversionExtensions,C:\repos\afrogeek_SharpNative\Compiler\ConversionExtensions.cs,SizeOf,The following statement contains a magic number: switch (typeSymbol.SpecialType)              {                  case SpecialType.System_Boolean:                      return sizeof(bool);                  case SpecialType.System_Byte:                      return sizeof(byte);                  case SpecialType.System_Char:                      return sizeof(char);                  case SpecialType.System_Decimal:                      return sizeof(decimal);                  case SpecialType.System_Double:                      return sizeof(double);                  case SpecialType.System_Enum: //TODO: Fix this                      return sizeof(int);                  case SpecialType.System_Int16:                      return sizeof(short);                  case SpecialType.System_Int32:                      return sizeof(int);                  case SpecialType.System_Int64:                      return sizeof(long);                  case SpecialType.System_SByte:                      return sizeof(sbyte);                  case SpecialType.System_Single:                      return sizeof(float);                  case SpecialType.System_UInt16:                      return sizeof(ushort);                  case SpecialType.System_UInt32:                      return sizeof(uint);                  case SpecialType.System_UInt64:                      return sizeof(ulong);                  default:                      return 100000;              }
Magic Number,SharpNative.Compiler,ConversionExtensions,C:\repos\afrogeek_SharpNative\Compiler\ConversionExtensions.cs,GetExplictCoversionOp,The following statement contains a magic number: int lastSizeDiff = 1000;
Magic Number,SharpNative.Compiler,FileExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,ExecuteCommand,The following statement contains a magic number: using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))              using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))              {                  process.OutputDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          try                          {                              outputWaitHandle.Set();                          }                          catch (Exception)                          {                                                                                      }                                               }                      else                      {                          output.AppendLine(e.Data);                      }                  };                  process.ErrorDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          try                          {                              errorWaitHandle.Set();                          }                          catch (Exception)                          {                          }                      }                      else                      {                          error.AppendLine(e.Data);                      }                  };                    var start = DateTime.Now;                                   process.Start();                  process.BeginOutputReadLine();                  process.BeginErrorReadLine();                    //240 seconds ... for some tests .. i.e. benchmarks                  if (process.WaitForExit(240000) &&                      outputWaitHandle.WaitOne(240000) &&                      errorWaitHandle.WaitOne(240000))                  {                      // Process completed. Check process.ExitCode here.                      var standardOutput = output.ToString();                      var standardError = error.ToString();                        var end = DateTime.Now - start;                      if (Driver.Verbose)                          Console.WriteLine("Process took " + end.TotalMilliseconds + " ms");                      return String.IsNullOrWhiteSpace(standardOutput)                          ? standardError                          : String.IsNullOrWhiteSpace(standardError)                              ? standardOutput                              : standardOutput + Environment.NewLine + standardError;                  }                  else                  {                      // Timed out.                      return "Process terminated immaturely";                  }              }
Magic Number,SharpNative.Compiler,FileExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,ExecuteCommand,The following statement contains a magic number: using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))              using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))              {                  process.OutputDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          try                          {                              outputWaitHandle.Set();                          }                          catch (Exception)                          {                                                                                      }                                               }                      else                      {                          output.AppendLine(e.Data);                      }                  };                  process.ErrorDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          try                          {                              errorWaitHandle.Set();                          }                          catch (Exception)                          {                          }                      }                      else                      {                          error.AppendLine(e.Data);                      }                  };                    var start = DateTime.Now;                                   process.Start();                  process.BeginOutputReadLine();                  process.BeginErrorReadLine();                    //240 seconds ... for some tests .. i.e. benchmarks                  if (process.WaitForExit(240000) &&                      outputWaitHandle.WaitOne(240000) &&                      errorWaitHandle.WaitOne(240000))                  {                      // Process completed. Check process.ExitCode here.                      var standardOutput = output.ToString();                      var standardError = error.ToString();                        var end = DateTime.Now - start;                      if (Driver.Verbose)                          Console.WriteLine("Process took " + end.TotalMilliseconds + " ms");                      return String.IsNullOrWhiteSpace(standardOutput)                          ? standardError                          : String.IsNullOrWhiteSpace(standardError)                              ? standardOutput                              : standardOutput + Environment.NewLine + standardError;                  }                  else                  {                      // Timed out.                      return "Process terminated immaturely";                  }              }
Magic Number,SharpNative.Compiler,FileExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,ExecuteCommand,The following statement contains a magic number: using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))              using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))              {                  process.OutputDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          try                          {                              outputWaitHandle.Set();                          }                          catch (Exception)                          {                                                                                      }                                               }                      else                      {                          output.AppendLine(e.Data);                      }                  };                  process.ErrorDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          try                          {                              errorWaitHandle.Set();                          }                          catch (Exception)                          {                          }                      }                      else                      {                          error.AppendLine(e.Data);                      }                  };                    var start = DateTime.Now;                                   process.Start();                  process.BeginOutputReadLine();                  process.BeginErrorReadLine();                    //240 seconds ... for some tests .. i.e. benchmarks                  if (process.WaitForExit(240000) &&                      outputWaitHandle.WaitOne(240000) &&                      errorWaitHandle.WaitOne(240000))                  {                      // Process completed. Check process.ExitCode here.                      var standardOutput = output.ToString();                      var standardError = error.ToString();                        var end = DateTime.Now - start;                      if (Driver.Verbose)                          Console.WriteLine("Process took " + end.TotalMilliseconds + " ms");                      return String.IsNullOrWhiteSpace(standardOutput)                          ? standardError                          : String.IsNullOrWhiteSpace(standardError)                              ? standardOutput                              : standardOutput + Environment.NewLine + standardError;                  }                  else                  {                      // Timed out.                      return "Process terminated immaturely";                  }              }
Magic Number,SharpNative.Compiler,OutputWriter,C:\repos\afrogeek_SharpNative\Compiler\OutputWriter.cs,WriteIndent,The following statement contains a magic number: var c = Indent * 2;
Magic Number,SharpNative.Compiler,OutputWriter,C:\repos\afrogeek_SharpNative\Compiler\OutputWriter.cs,WriteIndentToString,The following statement contains a magic number: var c = Indent * 2;
Magic Number,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,RunTests,The following statement contains a magic number: try              {                        if (pathToFiles == null)                      throw new Exception("/source parameter not passed");                      var filenames = Directory.GetFiles(Path.GetFullPath(pathToFiles)' "*.cs");                    Console.WriteLine("\r\r" + ("Running all tests in : " + pathToFiles) + "\r\r");                  Func<string' string> strip = i => Regex.Replace(i ?? ""' "[\r\n \t]+"' " ").Trim();                  int count = 0;                  int passCount = 0;                    NativeCompilationUtils.SetCompilerOptions(options);                  var bclDir = pathToDcorlib;                    if (String.IsNullOrEmpty(bclDir))                  {                      bclDir = Directory.GetParent(                          Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location + "..\\..\\..\\..\\..\\")) +                      "\\SharpNative\\DCorlib";                  }                    var bclFiles = Directory.GetFiles(bclDir' "*.d"' SearchOption.AllDirectories)                          .OrderBy(o => o)                          .ToList();                  var failedTestNames = new List<string>();                  foreach (var filename in filenames)                  {                          var _source = FileExtensions.ReadFile(Path.GetFullPath(filename));                      if (_source == null)                      {                          Environment.ExitCode = 1;                            //throw new ArgumentNullException("\nSource Files Cannot be read");                          return;                      }                        if (_source == "-1")                      {                          Environment.ExitCode = 1;                            Console.WriteLine("\nSource File Cannot be read");                          return;                      }                        var shortName = Path.GetFileName(filename);                      Console.WriteLine("-------------------------Running Test: " + shortName +                          "-------------------------");                        string applicationExe;                          string dlangNativeExe;                        if (String.IsNullOrEmpty(outDir))                      {                          outDir = TempDir;                      }                        dlangNativeExe = outputFilename + "_d.exe";                      applicationExe = outputFilename + ".exe";                          if (outputFilename == null)                      {                          outputFilename = Path.GetFileNameWithoutExtension(filename);                          dlangNativeExe = outDir + "/" + outputFilename + "_d.exe";                          applicationExe = outDir + "/" + outputFilename + ".exe";                      }                          applicationExe.DeleteFile();                      Program.Go(outDir' extraTranslations' applicationExe'                          new string[] { FileExtensions.ReadFile(filename) }'                          outputFilename + ".exe");                          if (Verbose)                          Console.WriteLine("Generating native exe: " + dlangNativeExe);                        dlangNativeExe.DeleteFile();                                                 var start = DateTime.Now;                            var outputFiles = Directory.GetFiles(outDir' "*.d"' SearchOption.AllDirectories);                        NativeCompilationUtils.CompileAppToNativeExe(                          (outputFiles).Where(j => j.EndsWith(".d")).Union(bclFiles).ToArray()' dlangNativeExe);                          Console.WriteLine("\nCompiling to binary took " + (DateTime.Now - start).TotalMilliseconds +                          " ms\n");                          var CSharpOutput = applicationExe.ExecuteCommand(RunWithArgs);                      var CppOutput = dlangNativeExe.ExecuteCommand(RunWithArgs);                      Console.WriteLine(CSharpOutput);                      Console.WriteLine(CppOutput);                        count++;                        if (count % 20 == 0)                      {                          GC.Collect();                      }                        if (strip(CSharpOutput) == strip(CppOutput))                      {                          passCount++;                          Console.WriteLine("-------------------------Test {0} Passed:-------------------------\n"'                              shortName);                      }                      else                      {                          Console.WriteLine(String.Format("Test {0} Failed:\n"' shortName));                          failedTestNames.Add(Path.GetFileNameWithoutExtension(shortName));                      }                            }                    Console.WriteLine(                      String.Format("Summary \nTotal:{0} \nPass Rate:{1} \nPassed: {2} \nFailed: {3} {4}\n"'                          filenames.Count()' (passCount * 100) / ((float)filenames.Count())' passCount'                          filenames.Count() - passCount'                          (filenames.Count() - passCount == 0)                                ? ""                                : failedTestNames.Aggregate((k' j) => k + " ' " + j)));                    PrepareTempDir();                    Environment.ExitCode = 0;                }              catch (AggregateException agex)              {                  Environment.ExitCode = 1;                    Exception ex = agex;                  while (ex is AggregateException)                      ex = ex.InnerException;                    Console.WriteLine("\nException:");                  Console.WriteLine(ex.Message);              }              catch (Exception ex)              {                  Environment.ExitCode = 1;                    Console.WriteLine("\nException:");                  Console.WriteLine(ex.Message);              }
Magic Number,SharpNative.Compiler,Driver,C:\repos\afrogeek_SharpNative\Compiler\Driver.cs,RunTests,The following statement contains a magic number: try              {                        if (pathToFiles == null)                      throw new Exception("/source parameter not passed");                      var filenames = Directory.GetFiles(Path.GetFullPath(pathToFiles)' "*.cs");                    Console.WriteLine("\r\r" + ("Running all tests in : " + pathToFiles) + "\r\r");                  Func<string' string> strip = i => Regex.Replace(i ?? ""' "[\r\n \t]+"' " ").Trim();                  int count = 0;                  int passCount = 0;                    NativeCompilationUtils.SetCompilerOptions(options);                  var bclDir = pathToDcorlib;                    if (String.IsNullOrEmpty(bclDir))                  {                      bclDir = Directory.GetParent(                          Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location + "..\\..\\..\\..\\..\\")) +                      "\\SharpNative\\DCorlib";                  }                    var bclFiles = Directory.GetFiles(bclDir' "*.d"' SearchOption.AllDirectories)                          .OrderBy(o => o)                          .ToList();                  var failedTestNames = new List<string>();                  foreach (var filename in filenames)                  {                          var _source = FileExtensions.ReadFile(Path.GetFullPath(filename));                      if (_source == null)                      {                          Environment.ExitCode = 1;                            //throw new ArgumentNullException("\nSource Files Cannot be read");                          return;                      }                        if (_source == "-1")                      {                          Environment.ExitCode = 1;                            Console.WriteLine("\nSource File Cannot be read");                          return;                      }                        var shortName = Path.GetFileName(filename);                      Console.WriteLine("-------------------------Running Test: " + shortName +                          "-------------------------");                        string applicationExe;                          string dlangNativeExe;                        if (String.IsNullOrEmpty(outDir))                      {                          outDir = TempDir;                      }                        dlangNativeExe = outputFilename + "_d.exe";                      applicationExe = outputFilename + ".exe";                          if (outputFilename == null)                      {                          outputFilename = Path.GetFileNameWithoutExtension(filename);                          dlangNativeExe = outDir + "/" + outputFilename + "_d.exe";                          applicationExe = outDir + "/" + outputFilename + ".exe";                      }                          applicationExe.DeleteFile();                      Program.Go(outDir' extraTranslations' applicationExe'                          new string[] { FileExtensions.ReadFile(filename) }'                          outputFilename + ".exe");                          if (Verbose)                          Console.WriteLine("Generating native exe: " + dlangNativeExe);                        dlangNativeExe.DeleteFile();                                                 var start = DateTime.Now;                            var outputFiles = Directory.GetFiles(outDir' "*.d"' SearchOption.AllDirectories);                        NativeCompilationUtils.CompileAppToNativeExe(                          (outputFiles).Where(j => j.EndsWith(".d")).Union(bclFiles).ToArray()' dlangNativeExe);                          Console.WriteLine("\nCompiling to binary took " + (DateTime.Now - start).TotalMilliseconds +                          " ms\n");                          var CSharpOutput = applicationExe.ExecuteCommand(RunWithArgs);                      var CppOutput = dlangNativeExe.ExecuteCommand(RunWithArgs);                      Console.WriteLine(CSharpOutput);                      Console.WriteLine(CppOutput);                        count++;                        if (count % 20 == 0)                      {                          GC.Collect();                      }                        if (strip(CSharpOutput) == strip(CppOutput))                      {                          passCount++;                          Console.WriteLine("-------------------------Test {0} Passed:-------------------------\n"'                              shortName);                      }                      else                      {                          Console.WriteLine(String.Format("Test {0} Failed:\n"' shortName));                          failedTestNames.Add(Path.GetFileNameWithoutExtension(shortName));                      }                            }                    Console.WriteLine(                      String.Format("Summary \nTotal:{0} \nPass Rate:{1} \nPassed: {2} \nFailed: {3} {4}\n"'                          filenames.Count()' (passCount * 100) / ((float)filenames.Count())' passCount'                          filenames.Count() - passCount'                          (filenames.Count() - passCount == 0)                                ? ""                                : failedTestNames.Aggregate((k' j) => k + " ' " + j)));                    PrepareTempDir();                    Environment.ExitCode = 0;                }              catch (AggregateException agex)              {                  Environment.ExitCode = 1;                    Exception ex = agex;                  while (ex is AggregateException)                      ex = ex.InnerException;                    Console.WriteLine("\nException:");                  Console.WriteLine(ex.Message);              }              catch (Exception ex)              {                  Environment.ExitCode = 1;                    Console.WriteLine("\nException:");                  Console.WriteLine(ex.Message);              }
Magic Number,SharpNative.Compiler,OverloadResolver,C:\repos\afrogeek_SharpNative\Compiler\OverloadResolver.cs,ExpandedMethodName,The following statement contains a magic number: var ret = new StringBuilder(20);
Magic Number,SharpNative.Compiler,OverloadResolver,C:\repos\afrogeek_SharpNative\Compiler\OverloadResolver.cs,ExpandedMethodName,The following statement contains a magic number: var ret = new StringBuilder(20);
Magic Number,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,Descriptor,The following statement contains a magic number: if (sb.Length > 2)                  sb.Remove(sb.Length - 2' 2);
Magic Number,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,Descriptor,The following statement contains a magic number: if (sb.Length > 2)                  sb.Remove(sb.Length - 2' 2);
Magic Number,SharpNative.Compiler,Utility,C:\repos\afrogeek_SharpNative\Compiler\Utility.cs,Descriptor,The following statement contains a magic number: if (sb.Length > 2)                  sb.Remove(sb.Length - 2' 2);
Magic Number,SharpNative.Compiler,WriteDelegate,C:\repos\afrogeek_SharpNative\Compiler\WriteDelegate.cs,WriteOneDelegate,The following statement contains a magic number: using (                  writer =                      outputWriter == null                          ? new OutputWriter(Context.Instance.Namespace' Context.Instance.TypeName)                          : new TempWriter())              {                    if (outputWriter != null)                  {                      writer.WriteLine();                      writer.Indent = outputWriter.Indent + 2;                      writer.WriteIndent();                  }                    writer.FileExists = fileExists;                    WriteBcl.Go(writer);                    WriteStandardIncludes.Go(writer);                    //Look for generic arguments                                   {                      List<TypeParameterSyntax> genericArgs = new List<TypeParameterSyntax>();                      if (first.Syntax.TypeParameterList != null)                          genericArgs = first.Syntax.TypeParameterList.Parameters.ToList();                        var name = WriteType.TypeName(Context.Instance.Type' false); //Context.Instance.TypeName;                        if (genericArgs.Count > 0)                      {                          name = "template " + name;                          name += ("(");                          name += (string.Join(" ' "' genericArgs.Select(o => o)));                          name += (")");                            writer.WriteLine(name);                            writer.OpenBrace();                            writer.WriteLine("alias __Delegate!(" + TypeProcessor.ConvertType(first.Syntax.ReturnType) + " delegate" +                                           WriteMethod.GetParameterListAsString(first.Syntax.ParameterList.Parameters) + ") " +                                           WriteType.TypeName(Context.Instance.Type' false) + ";");                            writer.CloseBrace();                      }                      else                      {                          //Non-generic                          writer.WriteLine("alias __Delegate!(" + TypeProcessor.ConvertType(first.Syntax.ReturnType) + " delegate" +                                           WriteMethod.GetParameterListAsString(first.Syntax.ParameterList.Parameters) + ") " +                                           WriteType.TypeName(Context.Instance.Type' false) + ";");                      }                  }                    if (outputWriter != null)                      outputWriter.WriteLine(writer.ToString());              }
Magic Number,SharpNative.Compiler,WriteLiteralExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteLiteralExpression.cs,EncodeNonAsciiCharacters,The following statement contains a magic number: foreach (char c in value)              {                  if (c > 127)                  {                      // This character is too big for ASCII                      string encodedValue = "\\u" + ((int)c).ToString("x4");                      sb.Append(encodedValue);                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,SharpNative.Compiler,WriteLocalDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteLocalDeclaration.cs,EvaluateValue,The following statement contains a magic number: try              {  //Should be able to extend this to do some basic CTFE and speed up pure method calls                  // var assembly = Compile(code);                  var type2 = Program.CurrentAssembly.GetType("Primes");                  var method = type2.GetMethod("AddPrimes"' BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);                  var result = method.Invoke(null' new object[] {10000});                      // var constantval = Program.GetModel(value).GetConstantValue(result);              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message + ex.StackTrace);                  //throw;              }
Magic Number,SharpNative.Compiler,WriteOperatorDeclaration,C:\repos\afrogeek_SharpNative\Compiler\WriteOperatorDeclaration.cs,Go,The following statement contains a magic number: if (method.ParameterList.Parameters.Count == 2)              {                  if (methodName.EndsWith("Right"))                      paramType = method.ParameterList.Parameters[0];                  else                      paramType = method.ParameterList.Parameters[1];              }
Magic Number,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The following statement contains a magic number: if (getterHasBody)              {                                      getterbody = Core.WriteBlock(getter.Body' false' writer.Indent + 2);                    if (!isProxy && isYield)                  {                      var namedTypeSymbol = propertySymbol.Type as INamedTypeSymbol;                      if (namedTypeSymbol != null)                      {                          //                        var iteratortype = namedTypeSymbol.TypeArguments[0];                          //                        getterbody=String.Format("return new __IteratorBlock!({0})(delegate(__IteratorBlock!({0}) __iter){{ {1} }});"'                          //                            TypeProcessor.ConvertType(iteratortype)'getterbody);                            var className = propertySymbol.GetYieldClassName()+(                     (((INamedTypeSymbol)propertySymbol.Type).TypeArguments.Any() && ((INamedTypeSymbol)propertySymbol.Type).TypeArguments[0].TypeKind == TypeKind.TypeParameter) ? "__G" : "");                                  // writer.WriteLine(accessString + returnTypeString + methodSignatureString + @params2 + constraints);                            //writer.OpenBrace();                            if (!propertySymbol.IsStatic)                          {                                getterbody = writer.WriteIndentToString() + ("return new " + className + "(this);");                          }                          else                          {                              getterbody = writer.WriteIndentToString() + ("return new " + className + "();");                            }                      }                  }              }
Magic Number,SharpNative.Compiler,WriteProperty,C:\repos\afrogeek_SharpNative\Compiler\WriteProperty.cs,Go,The following statement contains a magic number: if (setterHasBody)  			{  				setterbody = Core.WriteString (setter.Body' false' writer.Indent + 2);  				if (isindexer)  				{  					setterbody +=  writer.WriteIndentToString()+ "return value;";  				}  				else  				{  				    if (hasGetter)  				    {  				        setterbody += writer.WriteIndentToString() + "return " + name + ";";  				    }    				}  			}
Magic Number,SharpNative.Compiler,WriteSizeOfExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteSizeOfExpression.cs,SizeOf,The following statement contains a magic number: switch (type.SpecialType)              {                  case SpecialType.System_Byte:                  case SpecialType.System_SByte:                      return 1;                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                      return 2;                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                      return 4;                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return 8;                  case SpecialType.System_Single:                      return 4;                  case SpecialType.System_Double:                      return 8;                  case SpecialType.System_Char:                      return 2;                  case SpecialType.System_Boolean:                      return 1;                  default:                      throw new Exception("Need handler for sizeof " + type);              }
Magic Number,SharpNative.Compiler,WriteSizeOfExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteSizeOfExpression.cs,SizeOf,The following statement contains a magic number: switch (type.SpecialType)              {                  case SpecialType.System_Byte:                  case SpecialType.System_SByte:                      return 1;                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                      return 2;                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                      return 4;                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return 8;                  case SpecialType.System_Single:                      return 4;                  case SpecialType.System_Double:                      return 8;                  case SpecialType.System_Char:                      return 2;                  case SpecialType.System_Boolean:                      return 1;                  default:                      throw new Exception("Need handler for sizeof " + type);              }
Magic Number,SharpNative.Compiler,WriteSizeOfExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteSizeOfExpression.cs,SizeOf,The following statement contains a magic number: switch (type.SpecialType)              {                  case SpecialType.System_Byte:                  case SpecialType.System_SByte:                      return 1;                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                      return 2;                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                      return 4;                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return 8;                  case SpecialType.System_Single:                      return 4;                  case SpecialType.System_Double:                      return 8;                  case SpecialType.System_Char:                      return 2;                  case SpecialType.System_Boolean:                      return 1;                  default:                      throw new Exception("Need handler for sizeof " + type);              }
Magic Number,SharpNative.Compiler,WriteSizeOfExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteSizeOfExpression.cs,SizeOf,The following statement contains a magic number: switch (type.SpecialType)              {                  case SpecialType.System_Byte:                  case SpecialType.System_SByte:                      return 1;                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                      return 2;                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                      return 4;                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return 8;                  case SpecialType.System_Single:                      return 4;                  case SpecialType.System_Double:                      return 8;                  case SpecialType.System_Char:                      return 2;                  case SpecialType.System_Boolean:                      return 1;                  default:                      throw new Exception("Need handler for sizeof " + type);              }
Magic Number,SharpNative.Compiler,WriteSizeOfExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteSizeOfExpression.cs,SizeOf,The following statement contains a magic number: switch (type.SpecialType)              {                  case SpecialType.System_Byte:                  case SpecialType.System_SByte:                      return 1;                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                      return 2;                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                      return 4;                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return 8;                  case SpecialType.System_Single:                      return 4;                  case SpecialType.System_Double:                      return 8;                  case SpecialType.System_Char:                      return 2;                  case SpecialType.System_Boolean:                      return 1;                  default:                      throw new Exception("Need handler for sizeof " + type);              }
Magic Number,SharpNative.Compiler,WriteSizeOfExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteSizeOfExpression.cs,SizeOf,The following statement contains a magic number: switch (type.SpecialType)              {                  case SpecialType.System_Byte:                  case SpecialType.System_SByte:                      return 1;                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                      return 2;                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                      return 4;                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return 8;                  case SpecialType.System_Single:                      return 4;                  case SpecialType.System_Double:                      return 8;                  case SpecialType.System_Char:                      return 2;                  case SpecialType.System_Boolean:                      return 1;                  default:                      throw new Exception("Need handler for sizeof " + type);              }
Magic Number,SharpNative.Compiler,WriteSwitchStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteSwitchStatement.cs,Go,The following statement contains a magic number: foreach (                  var section in                      switchStatement.Sections.Where(                          o => o.Labels.None(z => z.Keyword.RawKind == (decimal) SyntaxKind.DefaultKeyword)))              {                    foreach (var label in section.Labels)                  {                      writer.WriteIndent();                      WriteLabel.Go(writer' (CaseSwitchLabelSyntax) label' isStringSwitch);                  }                              writer.OpenBrace(false);                    foreach (var statement in section.Statements)                  {                      if (!(statement is BreakStatementSyntax))                          writer.Write(Core.WriteString(statement' false' writer.Indent+2));                  }                    writer.WriteLine("break;\r\n");                  writer.CloseBrace(false);              }
Magic Number,SharpNative.Compiler,WriteSwitchStatement,C:\repos\afrogeek_SharpNative\Compiler\WriteSwitchStatement.cs,Go,The following statement contains a magic number: if (defaultSection != null)              {       				foreach (var label in defaultSection.Labels) // Could be more than one label :P  				{  					writer.WriteIndent();  					if (label is CaseSwitchLabelSyntax)  						WriteLabel.Go (writer' (CaseSwitchLabelSyntax)label' isStringSwitch);  					else  						writer.WriteLine (label.ToFullString().Trim());  				}                   // writer.WriteLine("default:");                  writer.OpenBrace(false);                  foreach (var statement in defaultSection.Statements)                  {                      if (!(statement is BreakStatementSyntax))                          writer.Write(Core.WriteString(statement'false' writer.Indent+2));                  }                  writer.WriteLine("break;");                  writer.CloseBrace(false);              }              else              {                  writer.WriteLine("default:");                      writer.WriteLine("break;");              }
Magic Number,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteOutOneType,The following statement contains a magic number: using (                  writer =                      parentModuleWriter == null                          ? new OutputWriter(Context.Instance.Namespace' Context.Instance.TypeName)                          : new TempWriter())              {                      writer.FileExists = fileExists;                    if (parentModuleWriter != null)                  {                      writer.WriteLine();                      writer.Indent = parentModuleWriter.Indent + 2;                      writer.WriteIndent();                  }                    var bases = new List<ITypeSymbol>();                  var baselist = typeSymbols.Select(k => k.Syntax.As<BaseTypeDeclarationSyntax>()).Select(o => o.BaseList).Where(k => k != null).ToArray();                    if (baselist.Any())                  {                      bases = baselist.SelectMany(k => k.Types)                          .Select(o => TypeProcessor.GetTypeInfo(o.Type).ConvertedType ?? TypeProcessor.GetTypeInfo(o.Type).Type)                          .Where(k=>k!=null)                          .Distinct()                          .ToList();                  }                    //                var interfaces = bases.Where(o => o.TypeKind == TypeKind.Interface).ToList();                    if (Context.Instance.Type != Context.Object)                  {                      if (bases != null && (!bases.Any((j => j.TypeKind != TypeKind.Interface)) &&                                            !(typeSymbols.First().Symbol.TypeKind == TypeKind.Interface || typeSymbols.First().Symbol.TypeKind == TypeKind.Struct)))                          //TODO: fix structs using mixins / alias this                          bases.Add(Context.Object);                  }                  if(bases==null)                      bases =  new List<ITypeSymbol>();                    foreach (var type in bases)                  {                      TypeProcessor.AddUsedType(type);                  }                    //TODO: Fix enum support                  if (typeSymbols.First().Syntax is EnumDeclarationSyntax)                  {                      WriteEnum.Go(writer'                          Context.Instance.Partials.Select(o => o.Syntax)                              .Cast<EnumDeclarationSyntax>()                              .SelectMany(o => o.Members)                              .Where(o => !Program.DoNotWrite.ContainsKey(o)));                        if (parentModuleWriter != null)                          parentModuleWriter.Write(writer.ToString());                        return;                  }                    Context.Instance.AllMembers =                      typeSymbols.Select(k => k.Syntax.As<TypeDeclarationSyntax>()).SelectMany(o => o.Members)                          .Where(o => !Program.DoNotWrite.ContainsKey(o))                          .ToList();                    var allMembersToWrite = Context.Instance.AllMembers                      .Where(member => !(member is TypeDeclarationSyntax)                                       && !(member is EnumDeclarationSyntax)                                       && !(member is DelegateDeclarationSyntax) &&                                       !(member is ConstructorDeclarationSyntax))                      .ToList();                    Context.Instance.MemberNames = allMembersToWrite.Select(k => k.GetCSharpName()).ToList();                  if (Context.Instance.Type.ContainingType != null)                  {                      Context.Instance.MemberNames.AddRange(Context.Instance.Type.ContainingType.MemberNames);                  }                                     {                          //                    WriteStandardIncludes.Go(writer);                        //                    writer.WriteLine(String.Format("#include \"{0}\""' TypeState.Instance.TypeName + ".h"));                            WriteBcl.Go(writer);                        //TypeState.Instance.DerivesFromObject = bases.Count == interfaces.Count;                        var @namespace = typeSymbols.First().Symbol.ContainingNamespace.FullName();                      var genericArgs = Context.Instance.Type.TypeParameters.Select(l => l as ITypeSymbol).ToList();                        //Module name = namespace + "." + typename;                        WriteStandardIncludes.Go(writer);                        //                    var namespaces = @namespace.Split(new string[] { "." }' StringSplitOptions.None);                      //                      //                    if (@namespace.Length > 0)                      //                    {                      //                        foreach (var ns in namespaces)                      //                        {                      //                            writer.WriteLine("namespace " + ns + "\r\n{");                      //                            writer.WriteLine("namespace " + ns + "\r\n{");                      //                        }                      //                      //                    }                        var instanceCtors = Context.Instance.AllMembers.OfType<ConstructorDeclarationSyntax>()                          .Where(o => !o.Modifiers.Any(SyntaxKind.StaticKeyword))                          .ToList();                        var staticCtors = Context.Instance.AllMembers.OfType<ConstructorDeclarationSyntax>()                          .Where(o => (o.Modifiers.Any(SyntaxKind.StaticKeyword)))                          .ToList();                        //TODO: Add support for overloading constructing                      //                    if (instanceCtors.Count > 1)                      //                        throw new Exception(                      //                            "Overloaded constructors are not supported.  Consider changing all but one to static Create methods " +                      //                            Utility.Descriptor(first.Syntax));                        //                    var ctorOpt = instanceCtors.SingleOrDefault();                      //TODO: Handle interfaces by                      /*                  class Interface                  {                      public:                          virtual ~Interface() { }                          virtual void test() = 0; // Functions' must all be virtual                  }                  */                        var membersToWrite = allMembersToWrite.ToList();                      //.Where(o => IsStatic(o) == staticMembers).ToList();                        //                    if (membersToWrite.Count == 0 && (partials.Any(o => o.Syntax.Modifiers.Any(SyntaxKind.StaticKeyword))))                      //                        continue;                        //                    if (staticMembers)                      //                        writer.Write("object ");                      //                    else if (first.Syntax.Kind == SyntaxKind.InterfaceDeclaration)                      //                        writer.Write("trait ");                      //                    else                      //                    {                      //                        if (partials.Any(o => o.Syntax.Modifiers.Any(SyntaxKind.AbstractKeyword)))                      //                            writer.Write("abstract ");                        //                    }                        // writer.Write(TypeState.Instance.TypeName);                        if (typeSymbols.First().Syntax is TypeDeclarationSyntax)                      {                          //Internal classes/structs are declared static in D to behave correctly                          if (parentModuleWriter != null)                              writer.Write("static ");                          if (Context.Instance.Type.TypeKind == TypeKind.Class)                              writer.Write("class ");                          else if (Context.Instance.Type.TypeKind == TypeKind.Interface)                              writer.Write("interface ");                          else if (Context.Instance.Type.TypeKind == TypeKind.Struct)                          {                              writer.Write("struct ");                              //						writer.Write (" class "); // Allows inheritance ... but too many issues' will look at this when it gets relevant                          }                          else                              throw new Exception("don't know how to write type: " + Context.Instance.Type.TypeKind);                          List<ITypeSymbol> parentTypeParameters;                          if (Context.Instance.Type.ContainingType != null)                              parentTypeParameters = GetParentTypeParameters(Context.Instance.Type);                          else                              parentTypeParameters = new List<ITypeSymbol>();                            writer.Write(TypeName(Context.Instance.Type' false));                          //TypeProcessor.ConvertType(Context.Instance.Type' true' false'true));                            if (Context.Instance.Type.IsGenericType)                          {                                {                                  foreach (var @base in bases)                                  {                                      var namedTypeSymbol = @base as INamedTypeSymbol;                                      if (namedTypeSymbol != null)                                      {                                          foreach (var arg in namedTypeSymbol.TypeArguments)                                          {                                              if (arg.TypeKind == TypeKind.TypeParameter && !parentTypeParameters.Contains(arg))                                              {                                                  if (!genericArgs.Any(k => k.Name == arg.Name))                                                      genericArgs.Add(arg);                                              }                                          }                                      }                                  }                                  if (genericArgs.Any())                                  {                                      writer.Write("(" +                                                   string.Join(" ' "'                                                       genericArgs.Select(o => TypeProcessor.ConvertType(o' true' true' false))) + ")");                                  }                              }                          }                            bool firstBase = true;                            if (Context.Instance.Type.TypeKind != TypeKind.Struct)                          {                              foreach (var baseType in bases.OrderBy(o => o.TypeKind == TypeKind.Interface ? 1 : 0))                              {                                  var convertType = TypeProcessor.ConvertType(baseType);                                    writer.Write(firstBase ? " : " : " '");                                    writer.Write(convertType);                                    firstBase = false;                              }                          }                            string constraints = GetTypeConstraints((TypeDeclarationSyntax) typeSymbols.First().Syntax);                          writer.Write(constraints);                      }                        writer.WriteLine();                        writer.OpenBrace();                        var nonFields = WriteFields(membersToWrite' typeSymbols.First()' writer);                        foreach (var member in nonFields)                      {                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                        WriteConstructors(instanceCtors' writer);                        WriteStaticConstructors(staticCtors' writer);                        //PInvoke is now centralized' so we can call it on all libraries etc without issue                        writer.Indent--;                      WriteOutNestedTypes(typeSymbols.First()' writer);                        var methodSymbols = membersToWrite.OfType<MethodDeclarationSyntax>().Select(TypeProcessor.GetDeclaredSymbol);                      //TypeProcessor.GetDeclaredSymbol(method);                        if (!methodSymbols.OfType<IMethodSymbol>()                         .Any(k => k.Name == "ToString" && k.Parameters.Length == 0 && k.ReturnType == Context.String))                      {                          if (Context.Instance.Type.TypeKind == TypeKind.Struct ||                              (Context.Instance.Type.TypeKind == TypeKind.Class))                          {                              var overrideS = Context.Instance.Type.TypeKind == TypeKind.Struct ? "" : "override ";                              writer.WriteLine();                              writer.WriteLine("public " + overrideS + "String ToString()");                              writer.OpenBrace();                              writer.WriteLine("return GetType().FullName;");//Better names based on specialization                              writer.CloseBrace();                          }                        }                        WriteOutBoxed(writer' genericArgs' bases);                  }                    if (Context.Instance.Type.TypeKind == TypeKind.Struct)                  {                      writer.WriteLine();                      writer.WriteLine("public __Boxed_ __Get_Boxed()");                      writer.OpenBrace();                      writer.WriteLine("return new __Boxed_(this);");                      writer.CloseBrace();                      writer.WriteLine("alias __Get_Boxed this;");                  }                    if (Context.Instance.Type.TypeKind != TypeKind.Interface)                  {                      writer.WriteLine();                      if (Context.Instance.Type.TypeKind == TypeKind.Class)                          writer.WriteLine("public override Type GetType()");                      //					else if (Context.Instance.Type.TypeKind == TypeKind.Interface) // Messes with GetType overrides of objects                      //					{                      //						writer.WriteLine ("public final Type GetType()");                      //					}                      else if (Context.Instance.Type.TypeKind == TypeKind.Struct)                          writer.WriteLine("public Type GetType()");                      writer.OpenBrace();                      //if (Context.Instance.Type.TypeKind == TypeKind.Class)                      writer.WriteLine("return __TypeOf!(typeof(this));");                      // else                      //     writer.WriteLine("return __TypeOf!(__Boxed_);");                        writer.CloseBrace();                  }                    writer.CloseBrace();                    WriteEntryMethod(writer);                    if (parentModuleWriter != null)                  {                      writer.Finalize();                      parentModuleWriter.Write(writer.ToString());                  }              }
Magic Number,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The following statement contains a magic number: if (structLayout != null)              {                  LayoutKind value = LayoutKind.Auto;                  if (                      structLayout.ArgumentList.Arguments.Any(                          k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value"))                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments.FirstOrDefault(                                      k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value")                                      .Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                    else if (structLayout.ArgumentList.Arguments.Count > 0 &&                           structLayout.ArgumentList.Arguments[0].NameEquals == null)                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments[0].Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                  int pack = -1;                  int size = -1;                  CharSet charset = CharSet.Auto;                  //					if (structLayout.ArgumentList.Arguments.Count > 1)                  {                      try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "CharSet"))                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments.FirstOrDefault(                                              k =>                                                  k.NameEquals != null &&                                                  k.NameEquals.Name.ToFullString().Trim() == "CharSet")                                              .Expression.ToFullString()                                              .SubstringAfterLast('.'));                              //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 1 &&                                   structLayout.ArgumentList.Arguments[1].NameEquals == null)                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments[1].Expression.ToFullString()                                              .SubstringAfterLast('.'));                          }                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Pack"))                          {                              pack =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k =>                                              k.NameEquals != null &&                                              k.NameEquals.Name.ToFullString().Trim() == "Pack")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 2 &&                                   structLayout.ArgumentList.Arguments[2].NameEquals == null)                              pack = int.Parse(structLayout.ArgumentList.Arguments[2].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Size"))                          {                              size =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k => k.NameColon != null && k.NameColon.ToFullString().Trim() == "Size")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 3 &&                                   structLayout.ArgumentList.Arguments[3].NameEquals == null)                              size = int.Parse(structLayout.ArgumentList.Arguments[3].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        //						size = int.Parse (structLayout.ArgumentList.Arguments [3].Expression.ToFullString ());                  }                  //					var pack = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Pack");                  //					var charset = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "CharSet");                  //					var size = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Size");                    if (value == LayoutKind.Explicit)                  {                      var fieldGroups =                          fields.GroupBy(f => f.GetAttribute(Context.FieldOffset).ArgumentList.Arguments[0].ToString())                              .OrderBy(k => k.Key);                      writer.Indent++;                        foreach (var group in fieldGroups)                      {                          writer.WriteLine("//FieldOffset(" + @group.Key + ")");                          writer.WriteLine("union {");                          foreach (var member in @group)                              Core.Write(writer' member);                          writer.WriteLine("}");                      }                        //						foreach (var member in fields)                      //						{                      //							//                    writer.WriteLine();                      //							Core.Write (writer' member);                      //						}                  }                  else if (value == LayoutKind.Sequential)                  {                      fields = SortFields(fields);                        writer.Indent++;                        foreach (var member in fields)                      {                          if (pack != -1)                              writer.WriteLine("align (" + pack + "): //Pack = " + pack);                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }                    else                  {                      //Looks like C# aligns to 1 by default ... don't know about D...                      fields = SortFields(fields);                        writer.Indent++;                      foreach (var member in fields)                      {                          pack = 1;                          //TODO: on mac osx and mono this is required' on windows' it causes and issue                          //                            writer.WriteLine("align (" + pack + "): //Pack = " + pack + " C# default");                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }              }              else              {                  //Looks like C# aligns to 1 by default ... don't know about D...                  fields = SortFields(fields);                    writer.Indent++;                  foreach (var member in fields)                  {                      var pack = 1;                      //TODO: on mac osx and mono this is required' on windows' it causes an issue (sizes are different)                      //                        writer.WriteLine("align (" + pack + "): //Pack = " + pack + "C# default");                      //                    writer.WriteLine();                      Core.Write(writer' member);                  }              }
Magic Number,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The following statement contains a magic number: if (structLayout != null)              {                  LayoutKind value = LayoutKind.Auto;                  if (                      structLayout.ArgumentList.Arguments.Any(                          k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value"))                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments.FirstOrDefault(                                      k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value")                                      .Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                    else if (structLayout.ArgumentList.Arguments.Count > 0 &&                           structLayout.ArgumentList.Arguments[0].NameEquals == null)                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments[0].Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                  int pack = -1;                  int size = -1;                  CharSet charset = CharSet.Auto;                  //					if (structLayout.ArgumentList.Arguments.Count > 1)                  {                      try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "CharSet"))                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments.FirstOrDefault(                                              k =>                                                  k.NameEquals != null &&                                                  k.NameEquals.Name.ToFullString().Trim() == "CharSet")                                              .Expression.ToFullString()                                              .SubstringAfterLast('.'));                              //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 1 &&                                   structLayout.ArgumentList.Arguments[1].NameEquals == null)                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments[1].Expression.ToFullString()                                              .SubstringAfterLast('.'));                          }                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Pack"))                          {                              pack =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k =>                                              k.NameEquals != null &&                                              k.NameEquals.Name.ToFullString().Trim() == "Pack")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 2 &&                                   structLayout.ArgumentList.Arguments[2].NameEquals == null)                              pack = int.Parse(structLayout.ArgumentList.Arguments[2].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Size"))                          {                              size =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k => k.NameColon != null && k.NameColon.ToFullString().Trim() == "Size")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 3 &&                                   structLayout.ArgumentList.Arguments[3].NameEquals == null)                              size = int.Parse(structLayout.ArgumentList.Arguments[3].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        //						size = int.Parse (structLayout.ArgumentList.Arguments [3].Expression.ToFullString ());                  }                  //					var pack = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Pack");                  //					var charset = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "CharSet");                  //					var size = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Size");                    if (value == LayoutKind.Explicit)                  {                      var fieldGroups =                          fields.GroupBy(f => f.GetAttribute(Context.FieldOffset).ArgumentList.Arguments[0].ToString())                              .OrderBy(k => k.Key);                      writer.Indent++;                        foreach (var group in fieldGroups)                      {                          writer.WriteLine("//FieldOffset(" + @group.Key + ")");                          writer.WriteLine("union {");                          foreach (var member in @group)                              Core.Write(writer' member);                          writer.WriteLine("}");                      }                        //						foreach (var member in fields)                      //						{                      //							//                    writer.WriteLine();                      //							Core.Write (writer' member);                      //						}                  }                  else if (value == LayoutKind.Sequential)                  {                      fields = SortFields(fields);                        writer.Indent++;                        foreach (var member in fields)                      {                          if (pack != -1)                              writer.WriteLine("align (" + pack + "): //Pack = " + pack);                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }                    else                  {                      //Looks like C# aligns to 1 by default ... don't know about D...                      fields = SortFields(fields);                        writer.Indent++;                      foreach (var member in fields)                      {                          pack = 1;                          //TODO: on mac osx and mono this is required' on windows' it causes and issue                          //                            writer.WriteLine("align (" + pack + "): //Pack = " + pack + " C# default");                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }              }              else              {                  //Looks like C# aligns to 1 by default ... don't know about D...                  fields = SortFields(fields);                    writer.Indent++;                  foreach (var member in fields)                  {                      var pack = 1;                      //TODO: on mac osx and mono this is required' on windows' it causes an issue (sizes are different)                      //                        writer.WriteLine("align (" + pack + "): //Pack = " + pack + "C# default");                      //                    writer.WriteLine();                      Core.Write(writer' member);                  }              }
Magic Number,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The following statement contains a magic number: if (structLayout != null)              {                  LayoutKind value = LayoutKind.Auto;                  if (                      structLayout.ArgumentList.Arguments.Any(                          k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value"))                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments.FirstOrDefault(                                      k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value")                                      .Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                    else if (structLayout.ArgumentList.Arguments.Count > 0 &&                           structLayout.ArgumentList.Arguments[0].NameEquals == null)                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments[0].Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                  int pack = -1;                  int size = -1;                  CharSet charset = CharSet.Auto;                  //					if (structLayout.ArgumentList.Arguments.Count > 1)                  {                      try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "CharSet"))                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments.FirstOrDefault(                                              k =>                                                  k.NameEquals != null &&                                                  k.NameEquals.Name.ToFullString().Trim() == "CharSet")                                              .Expression.ToFullString()                                              .SubstringAfterLast('.'));                              //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 1 &&                                   structLayout.ArgumentList.Arguments[1].NameEquals == null)                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments[1].Expression.ToFullString()                                              .SubstringAfterLast('.'));                          }                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Pack"))                          {                              pack =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k =>                                              k.NameEquals != null &&                                              k.NameEquals.Name.ToFullString().Trim() == "Pack")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 2 &&                                   structLayout.ArgumentList.Arguments[2].NameEquals == null)                              pack = int.Parse(structLayout.ArgumentList.Arguments[2].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Size"))                          {                              size =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k => k.NameColon != null && k.NameColon.ToFullString().Trim() == "Size")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 3 &&                                   structLayout.ArgumentList.Arguments[3].NameEquals == null)                              size = int.Parse(structLayout.ArgumentList.Arguments[3].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        //						size = int.Parse (structLayout.ArgumentList.Arguments [3].Expression.ToFullString ());                  }                  //					var pack = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Pack");                  //					var charset = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "CharSet");                  //					var size = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Size");                    if (value == LayoutKind.Explicit)                  {                      var fieldGroups =                          fields.GroupBy(f => f.GetAttribute(Context.FieldOffset).ArgumentList.Arguments[0].ToString())                              .OrderBy(k => k.Key);                      writer.Indent++;                        foreach (var group in fieldGroups)                      {                          writer.WriteLine("//FieldOffset(" + @group.Key + ")");                          writer.WriteLine("union {");                          foreach (var member in @group)                              Core.Write(writer' member);                          writer.WriteLine("}");                      }                        //						foreach (var member in fields)                      //						{                      //							//                    writer.WriteLine();                      //							Core.Write (writer' member);                      //						}                  }                  else if (value == LayoutKind.Sequential)                  {                      fields = SortFields(fields);                        writer.Indent++;                        foreach (var member in fields)                      {                          if (pack != -1)                              writer.WriteLine("align (" + pack + "): //Pack = " + pack);                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }                    else                  {                      //Looks like C# aligns to 1 by default ... don't know about D...                      fields = SortFields(fields);                        writer.Indent++;                      foreach (var member in fields)                      {                          pack = 1;                          //TODO: on mac osx and mono this is required' on windows' it causes and issue                          //                            writer.WriteLine("align (" + pack + "): //Pack = " + pack + " C# default");                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }              }              else              {                  //Looks like C# aligns to 1 by default ... don't know about D...                  fields = SortFields(fields);                    writer.Indent++;                  foreach (var member in fields)                  {                      var pack = 1;                      //TODO: on mac osx and mono this is required' on windows' it causes an issue (sizes are different)                      //                        writer.WriteLine("align (" + pack + "): //Pack = " + pack + "C# default");                      //                    writer.WriteLine();                      Core.Write(writer' member);                  }              }
Magic Number,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The following statement contains a magic number: if (structLayout != null)              {                  LayoutKind value = LayoutKind.Auto;                  if (                      structLayout.ArgumentList.Arguments.Any(                          k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value"))                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments.FirstOrDefault(                                      k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value")                                      .Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                    else if (structLayout.ArgumentList.Arguments.Count > 0 &&                           structLayout.ArgumentList.Arguments[0].NameEquals == null)                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments[0].Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                  int pack = -1;                  int size = -1;                  CharSet charset = CharSet.Auto;                  //					if (structLayout.ArgumentList.Arguments.Count > 1)                  {                      try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "CharSet"))                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments.FirstOrDefault(                                              k =>                                                  k.NameEquals != null &&                                                  k.NameEquals.Name.ToFullString().Trim() == "CharSet")                                              .Expression.ToFullString()                                              .SubstringAfterLast('.'));                              //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 1 &&                                   structLayout.ArgumentList.Arguments[1].NameEquals == null)                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments[1].Expression.ToFullString()                                              .SubstringAfterLast('.'));                          }                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Pack"))                          {                              pack =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k =>                                              k.NameEquals != null &&                                              k.NameEquals.Name.ToFullString().Trim() == "Pack")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 2 &&                                   structLayout.ArgumentList.Arguments[2].NameEquals == null)                              pack = int.Parse(structLayout.ArgumentList.Arguments[2].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Size"))                          {                              size =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k => k.NameColon != null && k.NameColon.ToFullString().Trim() == "Size")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 3 &&                                   structLayout.ArgumentList.Arguments[3].NameEquals == null)                              size = int.Parse(structLayout.ArgumentList.Arguments[3].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        //						size = int.Parse (structLayout.ArgumentList.Arguments [3].Expression.ToFullString ());                  }                  //					var pack = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Pack");                  //					var charset = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "CharSet");                  //					var size = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Size");                    if (value == LayoutKind.Explicit)                  {                      var fieldGroups =                          fields.GroupBy(f => f.GetAttribute(Context.FieldOffset).ArgumentList.Arguments[0].ToString())                              .OrderBy(k => k.Key);                      writer.Indent++;                        foreach (var group in fieldGroups)                      {                          writer.WriteLine("//FieldOffset(" + @group.Key + ")");                          writer.WriteLine("union {");                          foreach (var member in @group)                              Core.Write(writer' member);                          writer.WriteLine("}");                      }                        //						foreach (var member in fields)                      //						{                      //							//                    writer.WriteLine();                      //							Core.Write (writer' member);                      //						}                  }                  else if (value == LayoutKind.Sequential)                  {                      fields = SortFields(fields);                        writer.Indent++;                        foreach (var member in fields)                      {                          if (pack != -1)                              writer.WriteLine("align (" + pack + "): //Pack = " + pack);                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }                    else                  {                      //Looks like C# aligns to 1 by default ... don't know about D...                      fields = SortFields(fields);                        writer.Indent++;                      foreach (var member in fields)                      {                          pack = 1;                          //TODO: on mac osx and mono this is required' on windows' it causes and issue                          //                            writer.WriteLine("align (" + pack + "): //Pack = " + pack + " C# default");                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }              }              else              {                  //Looks like C# aligns to 1 by default ... don't know about D...                  fields = SortFields(fields);                    writer.Indent++;                  foreach (var member in fields)                  {                      var pack = 1;                      //TODO: on mac osx and mono this is required' on windows' it causes an issue (sizes are different)                      //                        writer.WriteLine("align (" + pack + "): //Pack = " + pack + "C# default");                      //                    writer.WriteLine();                      Core.Write(writer' member);                  }              }
Magic Number,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The following statement contains a magic number: if (structLayout != null)              {                  LayoutKind value = LayoutKind.Auto;                  if (                      structLayout.ArgumentList.Arguments.Any(                          k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value"))                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments.FirstOrDefault(                                      k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value")                                      .Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                    else if (structLayout.ArgumentList.Arguments.Count > 0 &&                           structLayout.ArgumentList.Arguments[0].NameEquals == null)                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments[0].Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                  int pack = -1;                  int size = -1;                  CharSet charset = CharSet.Auto;                  //					if (structLayout.ArgumentList.Arguments.Count > 1)                  {                      try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "CharSet"))                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments.FirstOrDefault(                                              k =>                                                  k.NameEquals != null &&                                                  k.NameEquals.Name.ToFullString().Trim() == "CharSet")                                              .Expression.ToFullString()                                              .SubstringAfterLast('.'));                              //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 1 &&                                   structLayout.ArgumentList.Arguments[1].NameEquals == null)                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments[1].Expression.ToFullString()                                              .SubstringAfterLast('.'));                          }                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Pack"))                          {                              pack =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k =>                                              k.NameEquals != null &&                                              k.NameEquals.Name.ToFullString().Trim() == "Pack")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 2 &&                                   structLayout.ArgumentList.Arguments[2].NameEquals == null)                              pack = int.Parse(structLayout.ArgumentList.Arguments[2].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Size"))                          {                              size =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k => k.NameColon != null && k.NameColon.ToFullString().Trim() == "Size")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 3 &&                                   structLayout.ArgumentList.Arguments[3].NameEquals == null)                              size = int.Parse(structLayout.ArgumentList.Arguments[3].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        //						size = int.Parse (structLayout.ArgumentList.Arguments [3].Expression.ToFullString ());                  }                  //					var pack = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Pack");                  //					var charset = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "CharSet");                  //					var size = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Size");                    if (value == LayoutKind.Explicit)                  {                      var fieldGroups =                          fields.GroupBy(f => f.GetAttribute(Context.FieldOffset).ArgumentList.Arguments[0].ToString())                              .OrderBy(k => k.Key);                      writer.Indent++;                        foreach (var group in fieldGroups)                      {                          writer.WriteLine("//FieldOffset(" + @group.Key + ")");                          writer.WriteLine("union {");                          foreach (var member in @group)                              Core.Write(writer' member);                          writer.WriteLine("}");                      }                        //						foreach (var member in fields)                      //						{                      //							//                    writer.WriteLine();                      //							Core.Write (writer' member);                      //						}                  }                  else if (value == LayoutKind.Sequential)                  {                      fields = SortFields(fields);                        writer.Indent++;                        foreach (var member in fields)                      {                          if (pack != -1)                              writer.WriteLine("align (" + pack + "): //Pack = " + pack);                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }                    else                  {                      //Looks like C# aligns to 1 by default ... don't know about D...                      fields = SortFields(fields);                        writer.Indent++;                      foreach (var member in fields)                      {                          pack = 1;                          //TODO: on mac osx and mono this is required' on windows' it causes and issue                          //                            writer.WriteLine("align (" + pack + "): //Pack = " + pack + " C# default");                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }              }              else              {                  //Looks like C# aligns to 1 by default ... don't know about D...                  fields = SortFields(fields);                    writer.Indent++;                  foreach (var member in fields)                  {                      var pack = 1;                      //TODO: on mac osx and mono this is required' on windows' it causes an issue (sizes are different)                      //                        writer.WriteLine("align (" + pack + "): //Pack = " + pack + "C# default");                      //                    writer.WriteLine();                      Core.Write(writer' member);                  }              }
Magic Number,SharpNative.Compiler,WriteType,C:\repos\afrogeek_SharpNative\Compiler\WriteType.cs,WriteFields,The following statement contains a magic number: if (structLayout != null)              {                  LayoutKind value = LayoutKind.Auto;                  if (                      structLayout.ArgumentList.Arguments.Any(                          k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value"))                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments.FirstOrDefault(                                      k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Value")                                      .Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                    else if (structLayout.ArgumentList.Arguments.Count > 0 &&                           structLayout.ArgumentList.Arguments[0].NameEquals == null)                  {                      value =                          (LayoutKind)                              Enum.Parse(typeof(LayoutKind)'                                  structLayout.ArgumentList.Arguments[0].Expression.ToFullString()                                      .SubstringAfterLast('.'));                  }                  int pack = -1;                  int size = -1;                  CharSet charset = CharSet.Auto;                  //					if (structLayout.ArgumentList.Arguments.Count > 1)                  {                      try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "CharSet"))                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments.FirstOrDefault(                                              k =>                                                  k.NameEquals != null &&                                                  k.NameEquals.Name.ToFullString().Trim() == "CharSet")                                              .Expression.ToFullString()                                              .SubstringAfterLast('.'));                              //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 1 &&                                   structLayout.ArgumentList.Arguments[1].NameEquals == null)                          {                              charset =                                  (CharSet)                                      Enum.Parse(typeof(CharSet)'                                          structLayout.ArgumentList.Arguments[1].Expression.ToFullString()                                              .SubstringAfterLast('.'));                          }                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Pack"))                          {                              pack =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k =>                                              k.NameEquals != null &&                                              k.NameEquals.Name.ToFullString().Trim() == "Pack")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 2 &&                                   structLayout.ArgumentList.Arguments[2].NameEquals == null)                              pack = int.Parse(structLayout.ArgumentList.Arguments[2].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        try                      {                          if (                              structLayout.ArgumentList.Arguments.Any(                                  k => k.NameEquals != null && k.NameEquals.Name.ToFullString().Trim() == "Size"))                          {                              size =                                  int.Parse(                                      structLayout.ArgumentList.Arguments.FirstOrDefault(                                          k => k.NameColon != null && k.NameColon.ToFullString().Trim() == "Size")                                          .Expression.ToFullString());                          }                          //structLayout.ArgumentList.Arguments.Where (k => k.Expression is MemberAccessExpressionSyntax).FirstOrDefault(k=>(k.Expression as MemberAccessExpressionSyntax).Name.ToFullString() == "Value");                          else if (structLayout.ArgumentList.Arguments.Count > 3 &&                                   structLayout.ArgumentList.Arguments[3].NameEquals == null)                              size = int.Parse(structLayout.ArgumentList.Arguments[3].Expression.ToFullString());                      }                      catch (Exception ex)                      {                      }                        //						size = int.Parse (structLayout.ArgumentList.Arguments [3].Expression.ToFullString ());                  }                  //					var pack = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Pack");                  //					var charset = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "CharSet");                  //					var size = structLayout.ArgumentList.Arguments.FirstOrDefault (k => k.NameColon.Name.ToFullString() == "Size");                    if (value == LayoutKind.Explicit)                  {                      var fieldGroups =                          fields.GroupBy(f => f.GetAttribute(Context.FieldOffset).ArgumentList.Arguments[0].ToString())                              .OrderBy(k => k.Key);                      writer.Indent++;                        foreach (var group in fieldGroups)                      {                          writer.WriteLine("//FieldOffset(" + @group.Key + ")");                          writer.WriteLine("union {");                          foreach (var member in @group)                              Core.Write(writer' member);                          writer.WriteLine("}");                      }                        //						foreach (var member in fields)                      //						{                      //							//                    writer.WriteLine();                      //							Core.Write (writer' member);                      //						}                  }                  else if (value == LayoutKind.Sequential)                  {                      fields = SortFields(fields);                        writer.Indent++;                        foreach (var member in fields)                      {                          if (pack != -1)                              writer.WriteLine("align (" + pack + "): //Pack = " + pack);                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }                    else                  {                      //Looks like C# aligns to 1 by default ... don't know about D...                      fields = SortFields(fields);                        writer.Indent++;                      foreach (var member in fields)                      {                          pack = 1;                          //TODO: on mac osx and mono this is required' on windows' it causes and issue                          //                            writer.WriteLine("align (" + pack + "): //Pack = " + pack + " C# default");                          //                    writer.WriteLine();                          Core.Write(writer' member);                      }                  }              }              else              {                  //Looks like C# aligns to 1 by default ... don't know about D...                  fields = SortFields(fields);                    writer.Indent++;                  foreach (var member in fields)                  {                      var pack = 1;                      //TODO: on mac osx and mono this is required' on windows' it causes an issue (sizes are different)                      //                        writer.WriteLine("align (" + pack + "): //Pack = " + pack + "C# default");                      //                    writer.WriteLine();                      Core.Write(writer' member);                  }              }
Magic Number,SharpNative.Compiler.YieldAsync,StateGenerator,C:\repos\afrogeek_SharpNative\Compiler\YieldAsync\StateGenerator.cs,GenerateNewName,The following statement contains a magic number: var counter = 2;
Duplicate Code,SharpNative.Compiler,Program,C:\repos\afrogeek_SharpNative\Compiler\Program.cs,ProcessTypes,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 42)' (50' 77))
Duplicate Code,SharpNative.Compiler,WriteInvocationExpression,C:\repos\afrogeek_SharpNative\Compiler\WriteInvocationExpression.cs,ProcessArgument,The method contains a code clone-set at the following line numbers (starting from the method definition): ((68' 88)' (104' 124))
Duplicate Code,SharpNative.Compiler.DlangAst,CSharpToDlangRewriter,C:\repos\afrogeek_SharpNative\Compiler\DlangAst\CSharpToDlangRewriter.cs,FixPropertyUnaryExpressions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 42)' (46' 83))
Missing Default,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,GetResultantVisibility,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Alias:                      // Aliases are uber private.  They're only visible in the same file that they                      // were declared in.                      return Accessibility.Private;                    case SymbolKind.Parameter:                      // Parameters are only as visible as their containing symbol                      return GetResultantVisibility(symbol.ContainingSymbol);                    case SymbolKind.TypeParameter:                      // Type Parameters are private.                      return Accessibility.Private;              }
Missing Default,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,GetResultantVisibility,The following switch statement is missing a default case: switch (symbol.DeclaredAccessibility)                  {                      // If we see anything private' then the symbol is private.                      case Accessibility.NotApplicable:                      case Accessibility.Private:                          return Accessibility.Private;                        // If we see anything internal' then knock it down from public to                      // internal.                      case Accessibility.Internal:                      case Accessibility.ProtectedAndInternal:                          visibility = Accessibility.Internal;                          break;                            // For anything else (Public' Protected' ProtectedOrInternal)' the                          // symbol stays at the level we've gotten so far.                  }
Missing Default,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,OverriddenMember,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Event:                      return ((IEventSymbol)symbol).OverriddenEvent;                    case SymbolKind.Method:                      return ((IMethodSymbol)symbol).OverriddenMethod;                    case SymbolKind.Property:                      return ((IPropertySymbol)symbol).OverriddenProperty;              }
Missing Default,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,IsNew,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Event:                  {                      var @event = symbol as IEventSymbol;                        if (@event != null && (@event.ContainingType.BaseType != null && @event.ContainingType.BaseType.GetAllMembers().OfType<IEventSymbol>().Any(k => k.Name==@event.Name) && @event.IsOverride==false))                      {                          return true;                      }                          }                      break;                    case SymbolKind.Method:                  {                          var @method = symbol as IMethodSymbol;                          if (@method != null && (@method.ContainingType.BaseType != null && @method.ContainingType.BaseType.GetAllMembers().OfType<IMethodSymbol>().Any(k => MemberUtilities.CompareMethods(k'@method)) && @method.IsOverride == false))                          {                              return true;                          }                                                                         }                      break;                                          case SymbolKind.Property:                  {                          var @property = symbol as IPropertySymbol;                            if (@property != null && (@property.ContainingType.BaseType != null && @property.ContainingType.BaseType.GetAllMembers().OfType<IPropertySymbol>().Any(k => k.Name == @property.Name) && @property.IsOverride == false))                          {                              return true;                          }                        }                                            break;                                          case SymbolKind.Field: // New Field is nothing special' base field                  {                        /*  var @field = symbol as IFieldSymbol;                          if (@field != null && (@field.ContainingType.BaseType != null && @field.ContainingType.BaseType.GetAllMembers().OfType<IFieldSymbol>().Any(k => k.Name == @field.Name) && @field.IsOverride == false))                          {                              return true;                          }*/                          return false;                      }                      break;              }
Missing Default,SharpNative.Compiler,ISymbolExtensions,C:\repos\afrogeek_SharpNative\Compiler\FileExtensions.cs,GetMemberType,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Field:                      return ((IFieldSymbol)symbol).Type;                  case SymbolKind.Property:                      return ((IPropertySymbol)symbol).Type;                  case SymbolKind.Method:                      return ((IMethodSymbol)symbol).ReturnType;                  case SymbolKind.Event:                      return ((IEventSymbol)symbol).Type;              }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_SByte: // Safety precaution?                      case SpecialType.System_Int16:                      case SpecialType.System_Int32:                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_Char:                      case SpecialType.System_UInt16:                      case SpecialType.System_Int32:                      case SpecialType.System_UInt32:                      case SpecialType.System_Int64:                      case SpecialType.System_UInt64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_Byte:                      case SpecialType.System_Int16:                      case SpecialType.System_UInt16:                      case SpecialType.System_Int32:                      case SpecialType.System_UInt32:                      case SpecialType.System_Int64:                      case SpecialType.System_UInt64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_Int16:                      case SpecialType.System_Int32:                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_UInt16:                      case SpecialType.System_Int32:                      case SpecialType.System_UInt32:                      case SpecialType.System_Int64:                      case SpecialType.System_UInt64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_Int32:                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_UInt32:                      case SpecialType.System_Int64:                      case SpecialType.System_UInt64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_Single:                      case SpecialType.System_Double:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,RoslynExtensions,C:\repos\afrogeek_SharpNative\Compiler\RoslynExtensions.cs,IsImplicitNumericCast,The following switch statement is missing a default case: switch (baseType.SpecialType)                  {                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          // TODO: Need to work on decimal' its treated as a normal int ... should we use D's 80-bit type ?                             return true;                  }
Missing Default,SharpNative.Compiler,NativeCompilationUtils,C:\repos\afrogeek_SharpNative\Compiler\NativeCompilationUtils.cs,SetCompilerOptions,The following switch statement is missing a default case: switch (compilerKind)              {                  case "ldcwin":                      CompilerOptions = new LdcWindowsOptions();                      break;                  case "dmdwin":                      CompilerOptions = new DMDWindowsOptions();                      break;                               }
Missing Default,SharpNative.Compiler,WritePInvokeMethodBody,C:\repos\afrogeek_SharpNative\Compiler\WritePInvokeMethodBody.cs,ConvertPInvokeType,The following switch statement is missing a default case: switch (dType)              {                  case "String":                      return "char *"; //TODO: Should be dependent on the charset                  case "Array_T!(String)":                      return "char**";              }
