Implementation smell,Namespace,Class,File,Method,Description
Complex Method,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,ReleaseDesignerOutlets,Cyclomatic complexity of the method is 14
Long Statement,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,RunAllTests_Click,The length of the statement  "								ViewModel.CompilerErrors += String.Format("-------------------------Test {0} Passed:-------------------------\n"' shortName); " is 125.
Long Statement,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,RunAllTests_Click,The length of the statement  "					ViewModel.CompilerErrors += String.Format("Summary \nTotal:{0} \nPass Rate:{1} \nPassed: {2} \nFailed: {3} {4}\n"' noRunTests' (passCount*100)/((float)noRunTests)' passCount' noRunTests-passCount' (noRunTests-passCount ==0)?"":failedTestNames.Aggregate((k'j)=>k+" ' "+j)); " is 272.
Long Statement,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,CompileCSharp,The length of the statement  "				var output = ("/bin/bash").ExecuteCommand(" -c \"/usr/bin/mono --attach=disable --gc=sgen " + LastCompiledExecutablePath +"\""'""); " is 131.
Long Statement,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,CompileD,The length of the statement  "						ViewModel.CompilerErrors += String.Format("Please set correct BCL directory' current value \"{0}\" doesn't exist"' BCLDir); " is 123.
Long Statement,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,CompileD,The length of the statement  "			// @"C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\vcvars32.bat".ExecuteCommand(""'@"C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\"); " is 160.
Long Statement,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,CompileD,The length of the statement  "			var outputexe = MainWindowViewModel.TempDir + "/"+ LastCompiledExecutable.Replace(".exe"' ".d").Replace(".d"' "_d.exe"); " is 120.
Long Statement,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,CompileD,The length of the statement  "				// @"C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\vcvars32.bat".ExecuteCommand(""'@"C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\"); " is 160.
Long Statement,VisualCompiler,MainWindowViewModel,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MainWindowViewModel.cs,CompileCode,The length of the statement  "				var files = Directory.GetFiles(Path.GetDirectoryName(slnPath)' "*.cs"' SearchOption.AllDirectories)//.Union(Directory.GetFiles(TempDir' "*.h"' SearchOption.AllDirectories)) " is 172.
Long Statement,VisualCompiler,MainWindowViewModel,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MainWindowViewModel.cs,CompileCode,The length of the statement  "//				var compilation = CSharpCompilation.Create (testName' files.Select (o => CSharpSyntaxTree.ParseText (o))' new MetadataReference[]  " is 135.
Long Statement,VisualCompiler,MainWindowViewModel,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MainWindowViewModel.cs,CompileCode,The length of the statement  "//					new MetadataImageReference (AssemblyMetadata.CreateFromImageStream (new FileStream (typeof(object).Assembly.Location' FileMode.Open' FileAccess.Read)))' " is 159.
Long Statement,VisualCompiler,MainWindowViewModel,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MainWindowViewModel.cs,CompileCode,The length of the statement  "//					new MetadataImageReference (AssemblyMetadata.CreateFromImageStream (new FileStream (typeof(Enumerable).Assembly.Location' FileMode.Open' FileAccess.Read)))' // Linq " is 171.
Long Statement,VisualCompiler,MainWindowViewModel,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MainWindowViewModel.cs,CompileCode,The length of the statement  "//					new MetadataImageReference (AssemblyMetadata.CreateFromImageStream (new FileStream (typeof(RuntimeBinderException).Assembly.Location' FileMode.Open' FileAccess.Read)))' " is 175.
Long Statement,VisualCompiler,MainWindowViewModel,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MainWindowViewModel.cs,CompileCode,The length of the statement  "//					new MetadataImageReference (AssemblyMetadata.CreateFromImageStream (new FileStream (typeof(Microsoft.CSharp.CSharpCodeProvider).Assembly.Location' FileMode.Open' FileAccess.Read)))' " is 188.
Long Statement,VisualCompiler,MainWindowViewModel,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MainWindowViewModel.cs,CompileCode,The length of the statement  "			var filesFromDisk = Directory.GetFiles(TempDir' "*.d"' SearchOption.AllDirectories)//.Union(Directory.GetFiles(TempDir' "*.h"' SearchOption.AllDirectories)) " is 156.
Empty Catch Block,VisualCompiler,Extensions,C:\repos\afrogeek_SharpNative\VisualCompilerMac\Extensions.cs,DeleteFile,The method has an empty catch block.
Magic Number,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,RunAllTests_Click,The following statement contains a magic number: if (result == 1) {  				var filename = openPanel.Filename; // will switch to .Url later  //				var newText = File.ReadAllText (filename);  //				CSharpFilename.StringValue = Path.GetFileName (filename);  //				CSharpTextEditor.Replace (new NSRange (0' CSharpTextEditor.Value.Length)' newText);  //				ViewModel.SourceCode = newText;  //				ViewModel.RecompileSource ();    				Func<string' string> strip = i => Regex.Replace(i??""' "[\r\n \t]+"' " ").Trim();    				ViewModel.CompilerErrors = "\r\r" + ("Running all tests in : " + filename) + "\r\r";  				int passCount = 0;  				//			if (ResetStatus != null)  				//				ResetStatus.Stop();  					List<string> failedTestNames = new List<string> ();  				ThreadPool.QueueUserWorkItem((h) =>  					{    					var allTests = Directory.EnumerateFiles(filename).Where(u=> Path.GetExtension(u)==".cs").ToList().CustomSort();  					int noRunTests = 0;  						foreach(var file in allTests)  						{    							var shortName = Path.GetFileName(file);  						Console.WriteLine("-------------------------Running Test: " + shortName+ "-------------------------");  						ViewModel.CompilerErrors += "-------------------------Running Test: " + shortName+ "-------------------------";  						var text = Extensions.ReadFile (file);    						if(text=="-1")  							break;    							InvokeOnMainThread(()=>{  								CSharpFilename.StringValue = Path.GetFileName (file);      								CSharpTextEditor.Value = text;  						  							});    						CSharpOutput ="Z..)";  						CppOutput ="A..)";  						noRunTests++;  //							ViewModel.CompileAndRunCode(shortName'File.ReadAllText(file));  						CompileCSharp(false);  						CompileD();      						if (strip(CSharpOutput) == strip(CppOutput))  						{  								passCount++;  							InvokeOnMainThread(() =>  								{  									//	TestStatus.Content = "PASSED";  									//TestStatus.Background =  									//	new SolidColorBrush(System.Windows.Media.Color.FromRgb(Color.GreenYellow.R'  									//		Color.GreenYellow.G' Color.GreenYellow.B));    								ViewModel.CompilerErrors += String.Format("-------------------------Test {0} Passed:-------------------------\n"' shortName);  								});  							Console.WriteLine( String.Format("-------------------------Test {0} Passed:-------------------------\n"' shortName));    						}  						else  						{  							InvokeOnMainThread(() =>  								{  									//								TestStatus.Content = "FAILED";  									//								TestStatus.Background =  									//									new SolidColorBrush(System.Windows.Media.Color.FromRgb(Color.Red.R' Color.Red.G' Color.Red.B));  //										ViewModel.CompilerErrors += String.Format("Test {2} Failed:\n\nCSharp Output:\n{0}\nD Output:\n{1}"'  //											CSharpOutput' CppOutput' shortName);  										ViewModel.CompilerErrors += String.Format("Test {0} Failed:\n"' shortName);  								Console.WriteLine( String.Format("-------------------------Test {0} Failed:-------------------------\n"' shortName));    										failedTestNames.Add(Path.GetFileNameWithoutExtension(shortName));    								});  						}  						//					if (ResetStatus == null)  						//					{  						//						ResetStatus = new Timer(2000);  						//						ResetStatus.AutoReset = false;  						//						ResetStatus.Elapsed += (o' args) => Dispatcher.Invoke(() =>  						//							{  						//								TestStatus.Content = "TEST STATUS";  						//								TestStatus.Background =  						//									new SolidColorBrush(System.Windows.Media.Color.FromRgb(Color.White.R' Color.White.G'  						//										Color.White.B));  						//							});  						//					}  						//					ResetStatus.Start();  						}    					ViewModel.CompilerErrors += String.Format("Summary \nTotal:{0} \nPass Rate:{1} \nPassed: {2} \nFailed: {3} {4}\n"' noRunTests' (passCount*100)/((float)noRunTests)' passCount' noRunTests-passCount' (noRunTests-passCount ==0)?"":failedTestNames.Aggregate((k'j)=>k+" ' "+j));    					});  					      			}
Magic Number,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,GetAsData,The following statement contains a magic number: outError = NSError.FromDomain (NSError.OsStatusErrorDomain' -4);
Magic Number,VisualCompiler,MyDocument,C:\repos\afrogeek_SharpNative\VisualCompilerMac\MyDocument.cs,ReadFromData,The following statement contains a magic number: outError = NSError.FromDomain (NSError.OsStatusErrorDomain' -4);
Magic Number,VisualCompiler,Extensions,C:\repos\afrogeek_SharpNative\VisualCompilerMac\Extensions.cs,ExecuteCommand,The following statement contains a magic number: using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))              using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))              {                  process.OutputDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          outputWaitHandle.Set();                      }                      else                      {                          output.AppendLine(e.Data);                      }                  };                  process.ErrorDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          errorWaitHandle.Set();                      }                      else                      {                          error.AppendLine(e.Data);                      }                  };                    var start = DateTime.Now;                                   process.Start();                  process.BeginOutputReadLine();                  process.BeginErrorReadLine();                    //120 seconds ... for some tests .. i.e. benchmarks                  if (process.WaitForExit(240000) &&                      outputWaitHandle.WaitOne(240000) &&                      errorWaitHandle.WaitOne(240000))                  {                      // Process completed. Check process.ExitCode here.                      var standardOutput = output.ToString();                      var standardError = error.ToString();                        var end = DateTime.Now - start;                      Console.WriteLine("Process took " + end.TotalMilliseconds + " ms");                      return String.IsNullOrWhiteSpace(standardOutput)                          ? standardError                          : String.IsNullOrWhiteSpace(standardError)                              ? standardOutput                              : standardOutput + Environment.NewLine + standardError;                  }                  else                  {                      // Timed out.                      return "Process terminated immaturely";                  }              }
Magic Number,VisualCompiler,Extensions,C:\repos\afrogeek_SharpNative\VisualCompilerMac\Extensions.cs,ExecuteCommand,The following statement contains a magic number: using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))              using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))              {                  process.OutputDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          outputWaitHandle.Set();                      }                      else                      {                          output.AppendLine(e.Data);                      }                  };                  process.ErrorDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          errorWaitHandle.Set();                      }                      else                      {                          error.AppendLine(e.Data);                      }                  };                    var start = DateTime.Now;                                   process.Start();                  process.BeginOutputReadLine();                  process.BeginErrorReadLine();                    //120 seconds ... for some tests .. i.e. benchmarks                  if (process.WaitForExit(240000) &&                      outputWaitHandle.WaitOne(240000) &&                      errorWaitHandle.WaitOne(240000))                  {                      // Process completed. Check process.ExitCode here.                      var standardOutput = output.ToString();                      var standardError = error.ToString();                        var end = DateTime.Now - start;                      Console.WriteLine("Process took " + end.TotalMilliseconds + " ms");                      return String.IsNullOrWhiteSpace(standardOutput)                          ? standardError                          : String.IsNullOrWhiteSpace(standardError)                              ? standardOutput                              : standardOutput + Environment.NewLine + standardError;                  }                  else                  {                      // Timed out.                      return "Process terminated immaturely";                  }              }
Magic Number,VisualCompiler,Extensions,C:\repos\afrogeek_SharpNative\VisualCompilerMac\Extensions.cs,ExecuteCommand,The following statement contains a magic number: using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))              using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))              {                  process.OutputDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          outputWaitHandle.Set();                      }                      else                      {                          output.AppendLine(e.Data);                      }                  };                  process.ErrorDataReceived += (sender' e) =>                  {                      if (e.Data == null)                      {                          errorWaitHandle.Set();                      }                      else                      {                          error.AppendLine(e.Data);                      }                  };                    var start = DateTime.Now;                                   process.Start();                  process.BeginOutputReadLine();                  process.BeginErrorReadLine();                    //120 seconds ... for some tests .. i.e. benchmarks                  if (process.WaitForExit(240000) &&                      outputWaitHandle.WaitOne(240000) &&                      errorWaitHandle.WaitOne(240000))                  {                      // Process completed. Check process.ExitCode here.                      var standardOutput = output.ToString();                      var standardError = error.ToString();                        var end = DateTime.Now - start;                      Console.WriteLine("Process took " + end.TotalMilliseconds + " ms");                      return String.IsNullOrWhiteSpace(standardOutput)                          ? standardError                          : String.IsNullOrWhiteSpace(standardError)                              ? standardOutput                              : standardOutput + Environment.NewLine + standardError;                  }                  else                  {                      // Timed out.                      return "Process terminated immaturely";                  }              }
