Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Hangfire.Redis,RedisConnection,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisConnection.cs,RedisConnection,The method has 5 parameters. Parameters: storage' redis' subscription' jobStorageIdentity' fetchTimeout
Long Parameter List,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetJobsWithProperties,The method has 5 parameters. Parameters: redis' jobIds' properties' stateProperties' selector
Long Identifier,Hangfire.Redis,RedisInfoKeys,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisInfoKeys.cs,,The length of the parameter repl_backlog_first_byte_offset is 30.
Long Statement,Hangfire.Redis,FetchedJobsWatcher,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\FetchedJobsWatcher.cs,ProcessQueue,The length of the statement  "            using (new RedisLock(connection.Redis' _storage.GetRedisKey($"queue:{queue}:dequeued:lock")' _storage.Identity + Thread.CurrentThread.ManagedThreadId' _options.FetchedLockTimeout)) " is 180.
Long Statement,Hangfire.Redis,RedisConnection,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisConnection.cs,AcquireDistributedLock,The length of the statement  "            return new RedisLock(Redis' _storage.GetRedisKey(resource)' _jobStorageIdentity + Thread.CurrentThread.ManagedThreadId' timeout); " is 129.
Long Statement,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,Servers,The length of the statement  "                        redis.HashGet(_storage.GetRedisKey($"server:{serverName}")' new RedisValue[] { "WorkerCount"' "StartedAt"' "Heartbeat" }) " is 121.
Long Statement,Hangfire.Redis,RedisStorage,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisStorage.cs,GetConnection,The length of the statement  "            return new RedisConnection(this' _connectionMultiplexer.GetDatabase(Db)' _subscription' _identity' _options.FetchTimeout); " is 122.
Long Statement,Hangfire.Redis,RedisWriteOnlyTransaction,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisWriteOnlyTransaction.cs,Commit,The length of the statement  "						throw new HangFireRedisException("Transaction commit was failed due to WATCH condition failure. Retry attempts exceeded."); " is 123.
Magic Number,Hangfire.Redis,ExpiredJobsWatcher,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\ExpiredJobsWatcher.cs,Execute,The following statement contains a magic number: using (var connection = (RedisConnection)_storage.GetConnection())              {                  var redis = connection.Redis;                                    foreach (var key in ProcessedKeys)                  {                      var redisKey = _storage.GetRedisKey(key);                        var count = redis.ListLength(redisKey);                      if (count == 0) continue;                        Logger.InfoFormat("Removing expired records from the '{0}' list..."' key);                                            const int batchSize = 100;                      var keysToRemove = new List<string>();                                            for (var last = count - 1; last >= 0; last -= batchSize)                      {                          var first = Math.Max(0' last - batchSize + 1);                                                    var jobIds = redis.ListRange(redisKey' first' last).ToStringArray();                          if (jobIds.Length == 0) continue;                                                    var pipeline = redis.CreateBatch();                          var tasks = new Task[jobIds.Length];                            for (var i = 0; i < jobIds.Length; i++)                          {                              tasks[i] = pipeline.KeyExistsAsync(_storage.GetRedisKey($"job:{jobIds[i]}"));                          }                                                    pipeline.Execute();                          Task.WaitAll(tasks);                            keysToRemove.AddRange(jobIds.Where((t' i) => !((Task<bool>)tasks[i]).Result));                      }                                            if (keysToRemove.Count == 0) continue;                        Logger.InfoFormat("Removing {0} expired jobs from '{1}' list..."' keysToRemove.Count' key);                        using (var transaction = connection.CreateWriteTransaction())                      {                          foreach (var jobId in keysToRemove)                          {                              transaction.RemoveFromList(key' jobId);                          }                                                    transaction.Commit();                      }                  }              }
Magic Number,Hangfire.Redis,RedisLock,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisLock.cs,SleepBackOffMultiplier,The following statement contains a magic number: var nextTry = rand.Next(                  (int)Math.Pow(i' 2)' (int)Math.Pow(i + 1' 2) + 1);
Magic Number,Hangfire.Redis,RedisLock,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisLock.cs,SleepBackOffMultiplier,The following statement contains a magic number: var nextTry = rand.Next(                  (int)Math.Pow(i' 2)' (int)Math.Pow(i + 1' 2) + 1);
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,ProcessingJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var jobIds = redis                      .SortedSetRangeByRank(_storage.GetRedisKey("processing")' from' from + count - 1)                      .ToStringArray();                    return new JobList<ProcessingJobDto>(GetJobsWithProperties(redis'                      jobIds'                      null'                      new[] { "StartedAt"' "ServerName"' "ServerId"' "State" }'                      (job' jobData' state) => new ProcessingJobDto                      {                          ServerId = state[2] ?? state[1]'                          Job = job'                          StartedAt = JobHelper.DeserializeNullableDateTime(state[0])'                          InProcessingState = ProcessingState.StateName.Equals(                              state[3]' StringComparison.OrdinalIgnoreCase)'                      })  					.Where(x=> x.Value.ServerId != null)  					.OrderBy(x => x.Value.StartedAt).ToList());              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,ProcessingJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var jobIds = redis                      .SortedSetRangeByRank(_storage.GetRedisKey("processing")' from' from + count - 1)                      .ToStringArray();                    return new JobList<ProcessingJobDto>(GetJobsWithProperties(redis'                      jobIds'                      null'                      new[] { "StartedAt"' "ServerName"' "ServerId"' "State" }'                      (job' jobData' state) => new ProcessingJobDto                      {                          ServerId = state[2] ?? state[1]'                          Job = job'                          StartedAt = JobHelper.DeserializeNullableDateTime(state[0])'                          InProcessingState = ProcessingState.StateName.Equals(                              state[3]' StringComparison.OrdinalIgnoreCase)'                      })  					.Where(x=> x.Value.ServerId != null)  					.OrderBy(x => x.Value.StartedAt).ToList());              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,ScheduledJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var scheduledJobs = redis                      .SortedSetRangeByRankWithScores(_storage.GetRedisKey("schedule")' from' from + count - 1)                      .ToList();                    if (scheduledJobs.Count == 0)                  {                      return new JobList<ScheduledJobDto>(new List<KeyValuePair<string' ScheduledJobDto>>());                  }                    var jobs = new ConcurrentDictionary<string' List<string>>();                  var states = new ConcurrentDictionary<string' List<string>>();;    				var pipeline = redis.CreateBatch();  				var tasks = new Task[scheduledJobs.Count * 2];  				int i = 0;                  foreach (var scheduledJob in scheduledJobs)                  {                      var jobId = scheduledJob.Element;  					tasks[i] = pipeline.HashGetAsync(  								_storage.GetRedisKey($"job:{jobId}")'  								new RedisValue[] { "Type"' "Method"' "ParameterTypes"' "Arguments" })  						.ContinueWith(x => jobs.TryAdd(jobId' x.Result.ToStringArray().ToList()));  					i++;  					tasks[i] = pipeline.HashGetAsync(  								_storage.GetRedisKey($"job:{jobId}:state")'  								new RedisValue[] { "State"' "ScheduledAt" })  						.ContinueWith(x => states.TryAdd(jobId' x.Result.ToStringArray().ToList()));  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return new JobList<ScheduledJobDto>(scheduledJobs                      .Select(job => new KeyValuePair<string' ScheduledJobDto>(                          job.Element'                          new ScheduledJobDto                          {                              EnqueueAt = JobHelper.FromTimestamp((long) job.Score)'                              Job = TryToGetJob(jobs[job.Element][0]' jobs[job.Element][1]' jobs[job.Element][2]' jobs[job.Element][3])'                              ScheduledAt =                                  states[job.Element].Count > 1                                      ? JobHelper.DeserializeNullableDateTime(states[job.Element][1])                                      : null'                              InScheduledState =                                  ScheduledState.StateName.Equals(states[job.Element][0]' StringComparison.OrdinalIgnoreCase)                          }))                      .ToList());              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,ScheduledJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var scheduledJobs = redis                      .SortedSetRangeByRankWithScores(_storage.GetRedisKey("schedule")' from' from + count - 1)                      .ToList();                    if (scheduledJobs.Count == 0)                  {                      return new JobList<ScheduledJobDto>(new List<KeyValuePair<string' ScheduledJobDto>>());                  }                    var jobs = new ConcurrentDictionary<string' List<string>>();                  var states = new ConcurrentDictionary<string' List<string>>();;    				var pipeline = redis.CreateBatch();  				var tasks = new Task[scheduledJobs.Count * 2];  				int i = 0;                  foreach (var scheduledJob in scheduledJobs)                  {                      var jobId = scheduledJob.Element;  					tasks[i] = pipeline.HashGetAsync(  								_storage.GetRedisKey($"job:{jobId}")'  								new RedisValue[] { "Type"' "Method"' "ParameterTypes"' "Arguments" })  						.ContinueWith(x => jobs.TryAdd(jobId' x.Result.ToStringArray().ToList()));  					i++;  					tasks[i] = pipeline.HashGetAsync(  								_storage.GetRedisKey($"job:{jobId}:state")'  								new RedisValue[] { "State"' "ScheduledAt" })  						.ContinueWith(x => states.TryAdd(jobId' x.Result.ToStringArray().ToList()));  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return new JobList<ScheduledJobDto>(scheduledJobs                      .Select(job => new KeyValuePair<string' ScheduledJobDto>(                          job.Element'                          new ScheduledJobDto                          {                              EnqueueAt = JobHelper.FromTimestamp((long) job.Score)'                              Job = TryToGetJob(jobs[job.Element][0]' jobs[job.Element][1]' jobs[job.Element][2]' jobs[job.Element][3])'                              ScheduledAt =                                  states[job.Element].Count > 1                                      ? JobHelper.DeserializeNullableDateTime(states[job.Element][1])                                      : null'                              InScheduledState =                                  ScheduledState.StateName.Equals(states[job.Element][0]' StringComparison.OrdinalIgnoreCase)                          }))                      .ToList());              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,ScheduledJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var scheduledJobs = redis                      .SortedSetRangeByRankWithScores(_storage.GetRedisKey("schedule")' from' from + count - 1)                      .ToList();                    if (scheduledJobs.Count == 0)                  {                      return new JobList<ScheduledJobDto>(new List<KeyValuePair<string' ScheduledJobDto>>());                  }                    var jobs = new ConcurrentDictionary<string' List<string>>();                  var states = new ConcurrentDictionary<string' List<string>>();;    				var pipeline = redis.CreateBatch();  				var tasks = new Task[scheduledJobs.Count * 2];  				int i = 0;                  foreach (var scheduledJob in scheduledJobs)                  {                      var jobId = scheduledJob.Element;  					tasks[i] = pipeline.HashGetAsync(  								_storage.GetRedisKey($"job:{jobId}")'  								new RedisValue[] { "Type"' "Method"' "ParameterTypes"' "Arguments" })  						.ContinueWith(x => jobs.TryAdd(jobId' x.Result.ToStringArray().ToList()));  					i++;  					tasks[i] = pipeline.HashGetAsync(  								_storage.GetRedisKey($"job:{jobId}:state")'  								new RedisValue[] { "State"' "ScheduledAt" })  						.ContinueWith(x => states.TryAdd(jobId' x.Result.ToStringArray().ToList()));  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return new JobList<ScheduledJobDto>(scheduledJobs                      .Select(job => new KeyValuePair<string' ScheduledJobDto>(                          job.Element'                          new ScheduledJobDto                          {                              EnqueueAt = JobHelper.FromTimestamp((long) job.Score)'                              Job = TryToGetJob(jobs[job.Element][0]' jobs[job.Element][1]' jobs[job.Element][2]' jobs[job.Element][3])'                              ScheduledAt =                                  states[job.Element].Count > 1                                      ? JobHelper.DeserializeNullableDateTime(states[job.Element][1])                                      : null'                              InScheduledState =                                  ScheduledState.StateName.Equals(states[job.Element][0]' StringComparison.OrdinalIgnoreCase)                          }))                      .ToList());              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,Servers,The following statement contains a magic number: return UseConnection(redis =>              {                  var serverNames = redis                      .SetMembers(_storage.GetRedisKey("servers"))                      .Select(x => (string)x)                      .ToList();                    if (serverNames.Count == 0)                  {                      return new List<ServerDto>();                  }                    var servers = new Dictionary<string' List<string>>();                  var queues = new Dictionary<string' List<string>>();                    foreach (var serverName in serverNames)                  {                      servers.Add(serverName'                          redis.HashGet(_storage.GetRedisKey($"server:{serverName}")' new RedisValue[] { "WorkerCount"' "StartedAt"' "Heartbeat" })                              .ToStringArray().ToList()                          );                      queues.Add(serverName'                          redis.ListRange(_storage.GetRedisKey($"server:{serverName}:queues"))                              .ToStringArray().ToList()                          );                  }                      return serverNames.Select(x => new ServerDto                  {                      Name = x'                      WorkersCount = int.Parse(servers[x][0])'                      Queues = queues[x]'                      StartedAt = JobHelper.DeserializeDateTime(servers[x][1])'                      Heartbeat = JobHelper.DeserializeNullableDateTime(servers[x][2])                  }).ToList();              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,FailedJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var failedJobIds = redis                      .SortedSetRangeByRank(_storage.GetRedisKey("failed")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      failedJobIds'                      null'                      new[] { "FailedAt"' "ExceptionType"' "ExceptionMessage"' "ExceptionDetails"' "State"' "Reason" }'                      (job' jobData' state) => new FailedJobDto                      {                          Job = job'                          Reason = state[5]'                          FailedAt = JobHelper.DeserializeNullableDateTime(state[0])'                          ExceptionType = state[1]'                          ExceptionMessage = state[2]'                          ExceptionDetails = state[3]'                          InFailedState = FailedState.StateName.Equals(state[4]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,FailedJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var failedJobIds = redis                      .SortedSetRangeByRank(_storage.GetRedisKey("failed")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      failedJobIds'                      null'                      new[] { "FailedAt"' "ExceptionType"' "ExceptionMessage"' "ExceptionDetails"' "State"' "Reason" }'                      (job' jobData' state) => new FailedJobDto                      {                          Job = job'                          Reason = state[5]'                          FailedAt = JobHelper.DeserializeNullableDateTime(state[0])'                          ExceptionType = state[1]'                          ExceptionMessage = state[2]'                          ExceptionDetails = state[3]'                          InFailedState = FailedState.StateName.Equals(state[4]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,FailedJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var failedJobIds = redis                      .SortedSetRangeByRank(_storage.GetRedisKey("failed")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      failedJobIds'                      null'                      new[] { "FailedAt"' "ExceptionType"' "ExceptionMessage"' "ExceptionDetails"' "State"' "Reason" }'                      (job' jobData' state) => new FailedJobDto                      {                          Job = job'                          Reason = state[5]'                          FailedAt = JobHelper.DeserializeNullableDateTime(state[0])'                          ExceptionType = state[1]'                          ExceptionMessage = state[2]'                          ExceptionDetails = state[3]'                          InFailedState = FailedState.StateName.Equals(state[4]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,FailedJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var failedJobIds = redis                      .SortedSetRangeByRank(_storage.GetRedisKey("failed")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      failedJobIds'                      null'                      new[] { "FailedAt"' "ExceptionType"' "ExceptionMessage"' "ExceptionDetails"' "State"' "Reason" }'                      (job' jobData' state) => new FailedJobDto                      {                          Job = job'                          Reason = state[5]'                          FailedAt = JobHelper.DeserializeNullableDateTime(state[0])'                          ExceptionType = state[1]'                          ExceptionMessage = state[2]'                          ExceptionDetails = state[3]'                          InFailedState = FailedState.StateName.Equals(state[4]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,SucceededJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var succeededJobIds = redis                      .ListRange(_storage.GetRedisKey("succeeded")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      succeededJobIds'                      null'                      new[] { "SucceededAt"' "PerformanceDuration"' "Latency"' "State"' "Result" }'                      (job' jobData' state) => new SucceededJobDto                      {                          Job = job'                          Result = state[4]'                          SucceededAt = JobHelper.DeserializeNullableDateTime(state[0])'                          TotalDuration = state[1] != null && state[2] != null                              ? (long?) long.Parse(state[1]) + (long?) long.Parse(state[2])                              : null'                          InSucceededState = SucceededState.StateName.Equals(state[3]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,SucceededJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var succeededJobIds = redis                      .ListRange(_storage.GetRedisKey("succeeded")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      succeededJobIds'                      null'                      new[] { "SucceededAt"' "PerformanceDuration"' "Latency"' "State"' "Result" }'                      (job' jobData' state) => new SucceededJobDto                      {                          Job = job'                          Result = state[4]'                          SucceededAt = JobHelper.DeserializeNullableDateTime(state[0])'                          TotalDuration = state[1] != null && state[2] != null                              ? (long?) long.Parse(state[1]) + (long?) long.Parse(state[2])                              : null'                          InSucceededState = SucceededState.StateName.Equals(state[3]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,SucceededJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var succeededJobIds = redis                      .ListRange(_storage.GetRedisKey("succeeded")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      succeededJobIds'                      null'                      new[] { "SucceededAt"' "PerformanceDuration"' "Latency"' "State"' "Result" }'                      (job' jobData' state) => new SucceededJobDto                      {                          Job = job'                          Result = state[4]'                          SucceededAt = JobHelper.DeserializeNullableDateTime(state[0])'                          TotalDuration = state[1] != null && state[2] != null                              ? (long?) long.Parse(state[1]) + (long?) long.Parse(state[2])                              : null'                          InSucceededState = SucceededState.StateName.Equals(state[3]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,SucceededJobs,The following statement contains a magic number: return UseConnection(redis =>              {                  var succeededJobIds = redis                      .ListRange(_storage.GetRedisKey("succeeded")' from' from + count - 1)  					.ToStringArray();                    return GetJobsWithProperties(                      redis'                      succeededJobIds'                      null'                      new[] { "SucceededAt"' "PerformanceDuration"' "Latency"' "State"' "Result" }'                      (job' jobData' state) => new SucceededJobDto                      {                          Job = job'                          Result = state[4]'                          SucceededAt = JobHelper.DeserializeNullableDateTime(state[0])'                          TotalDuration = state[1] != null && state[2] != null                              ? (long?) long.Parse(state[1]) + (long?) long.Parse(state[2])                              : null'                          InSucceededState = SucceededState.StateName.Equals(state[3]' StringComparison.OrdinalIgnoreCase)                      });              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,Queues,The following statement contains a magic number: return UseConnection(redis =>              {                  var queues = redis                      .SetMembers(_storage.GetRedisKey("queues"))  					.Select(x=> (string)x)                      .ToList();                    var result = new List<QueueWithTopEnqueuedJobsDto>(queues.Count);                    foreach (var queue in queues)                  {                      string[] firstJobIds = null;                      long length = 0;                      long fetched = 0;      					var pipeline = redis.CreateBatch();  					Task[] tasks = new Task[3];  					tasks[0] = pipeline.ListRangeAsync(                              _storage.GetRedisKey($"queue:{queue}")' -5' -1)  							.ContinueWith(x => firstJobIds = x.Result.ToStringArray());                        tasks[1] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}"))  						.ContinueWith(x => length = x.Result);                        tasks[2] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}:dequeued"))  						.ContinueWith(x => fetched = x.Result);    					pipeline.Execute();  					Task.WaitAll(tasks);                        var jobs = GetJobsWithProperties(                          redis'                          firstJobIds'                          new[] { "State" }'                          new[] { "EnqueuedAt"' "State" }'                          (job' jobData' state) => new EnqueuedJobDto                          {                              Job = job'                              State = jobData[0]'                              EnqueuedAt = JobHelper.DeserializeNullableDateTime(state[0])'                              InEnqueuedState = jobData[0].Equals(state[1]' StringComparison.OrdinalIgnoreCase)                          });                        result.Add(new QueueWithTopEnqueuedJobsDto                      {                          Name = queue'                          FirstJobs = jobs'                          Length = length'                          Fetched = fetched                      });                  }                    return result;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,Queues,The following statement contains a magic number: return UseConnection(redis =>              {                  var queues = redis                      .SetMembers(_storage.GetRedisKey("queues"))  					.Select(x=> (string)x)                      .ToList();                    var result = new List<QueueWithTopEnqueuedJobsDto>(queues.Count);                    foreach (var queue in queues)                  {                      string[] firstJobIds = null;                      long length = 0;                      long fetched = 0;      					var pipeline = redis.CreateBatch();  					Task[] tasks = new Task[3];  					tasks[0] = pipeline.ListRangeAsync(                              _storage.GetRedisKey($"queue:{queue}")' -5' -1)  							.ContinueWith(x => firstJobIds = x.Result.ToStringArray());                        tasks[1] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}"))  						.ContinueWith(x => length = x.Result);                        tasks[2] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}:dequeued"))  						.ContinueWith(x => fetched = x.Result);    					pipeline.Execute();  					Task.WaitAll(tasks);                        var jobs = GetJobsWithProperties(                          redis'                          firstJobIds'                          new[] { "State" }'                          new[] { "EnqueuedAt"' "State" }'                          (job' jobData' state) => new EnqueuedJobDto                          {                              Job = job'                              State = jobData[0]'                              EnqueuedAt = JobHelper.DeserializeNullableDateTime(state[0])'                              InEnqueuedState = jobData[0].Equals(state[1]' StringComparison.OrdinalIgnoreCase)                          });                        result.Add(new QueueWithTopEnqueuedJobsDto                      {                          Name = queue'                          FirstJobs = jobs'                          Length = length'                          Fetched = fetched                      });                  }                    return result;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,Queues,The following statement contains a magic number: return UseConnection(redis =>              {                  var queues = redis                      .SetMembers(_storage.GetRedisKey("queues"))  					.Select(x=> (string)x)                      .ToList();                    var result = new List<QueueWithTopEnqueuedJobsDto>(queues.Count);                    foreach (var queue in queues)                  {                      string[] firstJobIds = null;                      long length = 0;                      long fetched = 0;      					var pipeline = redis.CreateBatch();  					Task[] tasks = new Task[3];  					tasks[0] = pipeline.ListRangeAsync(                              _storage.GetRedisKey($"queue:{queue}")' -5' -1)  							.ContinueWith(x => firstJobIds = x.Result.ToStringArray());                        tasks[1] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}"))  						.ContinueWith(x => length = x.Result);                        tasks[2] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}:dequeued"))  						.ContinueWith(x => fetched = x.Result);    					pipeline.Execute();  					Task.WaitAll(tasks);                        var jobs = GetJobsWithProperties(                          redis'                          firstJobIds'                          new[] { "State" }'                          new[] { "EnqueuedAt"' "State" }'                          (job' jobData' state) => new EnqueuedJobDto                          {                              Job = job'                              State = jobData[0]'                              EnqueuedAt = JobHelper.DeserializeNullableDateTime(state[0])'                              InEnqueuedState = jobData[0].Equals(state[1]' StringComparison.OrdinalIgnoreCase)                          });                        result.Add(new QueueWithTopEnqueuedJobsDto                      {                          Name = queue'                          FirstJobs = jobs'                          Length = length'                          Fetched = fetched                      });                  }                    return result;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetHourlyTimelineStats,The following statement contains a magic number: for (var i = 0; i < 24; i++)              {                  dates.Add(endDate);                  endDate = endDate.AddHours(-1);              }
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetTimelineStats,The following statement contains a magic number: var startDate = endDate.AddDays(-7);
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetJobsWithProperties,The following statement contains a magic number: var tasks = new List<Task>(jobIds.Length * 2);
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetJobsWithProperties,The following statement contains a magic number: var jobList = new JobList<T>(jobIds                  .Select(jobId => new                  {                      JobId = jobId'                      Job = jobs[jobId].Result.ToStringArray()'                      Method = TryToGetJob(                          jobs[jobId].Result[properties.Length]'                          jobs[jobId].Result[properties.Length + 1]'                          jobs[jobId].Result[properties.Length + 2]'                          jobs[jobId].Result[properties.Length + 3])'                      State = stateProperties != null ? states[jobId].Result.ToStringArray() : null                  })                  .Select(x => new KeyValuePair<string' T>(                      x.JobId'                      x.Job.Any(y => y != null)                           ? selector(x.Method' x.Job' x.State)                           : default(T))));
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetJobsWithProperties,The following statement contains a magic number: var jobList = new JobList<T>(jobIds                  .Select(jobId => new                  {                      JobId = jobId'                      Job = jobs[jobId].Result.ToStringArray()'                      Method = TryToGetJob(                          jobs[jobId].Result[properties.Length]'                          jobs[jobId].Result[properties.Length + 1]'                          jobs[jobId].Result[properties.Length + 2]'                          jobs[jobId].Result[properties.Length + 3])'                      State = stateProperties != null ? states[jobId].Result.ToStringArray() : null                  })                  .Select(x => new KeyValuePair<string' T>(                      x.JobId'                      x.Job.Any(y => y != null)                           ? selector(x.Method' x.Job' x.State)                           : default(T))));
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisMonitoringApi,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisMonitoringApi.cs,GetStatistics,The following statement contains a magic number: return UseConnection(redis =>              {                  var stats = new StatisticsDto();                    var queues = redis.SetMembers(_storage.GetRedisKey("queues")' CommandFlags.HighPriority);    				var pipeline = redis.CreateBatch();  				var tasks = new Task[queues.Length + 8];                    tasks[0] = pipeline.SetLengthAsync(_storage.GetRedisKey("servers")' CommandFlags.HighPriority)  					.ContinueWith(x=> stats.Servers = x.Result);                    tasks[1] = pipeline.SetLengthAsync(_storage.GetRedisKey("queues")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Queues = x.Result);                    tasks[2] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("schedule")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Scheduled = x.Result);                    tasks[3] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("processing")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Processing = x.Result);                    tasks[4] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:succeeded")' CommandFlags.HighPriority)                      .ContinueWith(x => stats.Succeeded = long.Parse(x.Result.HasValue ?  (string)x.Result: "0"));                    tasks[5] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("failed")' flags: CommandFlags.HighPriority)  					.ContinueWith(x => stats.Failed = x.Result);                    tasks[6] = pipeline.StringGetAsync(_storage.GetRedisKey("stats:deleted")' CommandFlags.HighPriority)  					.ContinueWith(x => stats.Deleted = long.Parse(x.Result.HasValue ?  (string)x.Result : "0"));                    tasks[7] = pipeline.SortedSetLengthAsync(_storage.GetRedisKey("recurring-jobs")' flags: CommandFlags.HighPriority)                      .ContinueWith(x => stats.Recurring = x.Result);    				var i = 8;                  foreach (var queue in queues)                  {                      tasks[i] = pipeline.ListLengthAsync(_storage.GetRedisKey($"queue:{queue}")' CommandFlags.HighPriority)  						.ContinueWith(x => { lock (stats) { stats.Enqueued += x.Result; } });  					i++;                  }    				pipeline.Execute();  				Task.WaitAll(tasks);                    return stats;              });
Magic Number,Hangfire.Redis,RedisStorageOptions,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisStorageOptions.cs,RedisStorageOptions,The following statement contains a magic number: InvisibilityTimeout = TimeSpan.FromMinutes(30);
Magic Number,Hangfire.Redis,RedisStorageOptions,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisStorageOptions.cs,RedisStorageOptions,The following statement contains a magic number: FetchTimeout = TimeSpan.FromMinutes(3);
Magic Number,Hangfire.Redis,RedisStorageOptions,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisStorageOptions.cs,RedisStorageOptions,The following statement contains a magic number: SucceededListSize = 499;
Magic Number,Hangfire.Redis,RedisStorageOptions,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisStorageOptions.cs,RedisStorageOptions,The following statement contains a magic number: DeletedListSize = 499;
Magic Number,Hangfire.Redis,RedisWriteOnlyTransaction,C:\repos\marcoCasamento_Hangfire.Redis.StackExchange\Hangfire.Redis.StackExchange\RedisWriteOnlyTransaction.cs,Commit,The following statement contains a magic number: if (!_transaction.Execute())               {                  // RedisTransaction.Commit returns false only when                  // WATCH condition has been failed. So' we should                   // re-play the transaction.                    int replayCount = 1;                  const int maxReplayCount = 3;                  while (!_transaction.Execute())                  {                      if (replayCount++ >= maxReplayCount)                      {  						throw new HangFireRedisException("Transaction commit was failed due to WATCH condition failure. Retry attempts exceeded.");                      }                  }              }
