Implementation smell,Namespace,Class,File,Method,Description
Long Method,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_bitap,The method has 111 lines of code.
Long Method,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getFilePositions,The method has 115 lines of code.
Complex Method,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_length,Cyclomatic complexity of the method is 9
Complex Method,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_bitap,Cyclomatic complexity of the method is 13
Complex Method,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetSearchEngine,Cyclomatic complexity of the method is 8
Complex Method,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetReplaceEngine,Cyclomatic complexity of the method is 8
Complex Method,dnGREP.Engines,GrepPlugin,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepPlugin.cs,LoadPluginSettings,Cyclomatic complexity of the method is 10
Complex Method,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doRegexSearch,Cyclomatic complexity of the method is 13
Complex Method,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doRegexReplace,Cyclomatic complexity of the method is 10
Complex Method,dnGREP.Engines,NeedlemanWunch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\SimMetrics.cs,GetUnnormalisedSimilarity,Cyclomatic complexity of the method is 9
Complex Method,dnGREP.Common,GrepCore,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepCore.cs,Replace,Cyclomatic complexity of the method is 8
Long Parameter List,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_length,The method has 5 parameters. Parameters: text' pattern' loc' isWholeWord' threashold
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Search,The method has 5 parameters. Parameters: file' searchPattern' searchType' searchOptions' encoding
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Search,The method has 6 parameters. Parameters: input' fileName' searchPattern' searchType' searchOptions' encoding
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Replace,The method has 7 parameters. Parameters: sourceFile' destinationFile' searchPattern' replacePattern' searchType' searchOptions' encoding
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Replace,The method has 7 parameters. Parameters: readStream' writeStream' searchPattern' replacePattern' searchType' searchOptions' encoding
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,search,The method has 6 parameters. Parameters: input' fileName' searchPattern' searchOptions' searchMethod' encoding
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,searchMultiline,The method has 6 parameters. Parameters: input' fileName' searchPattern' searchOptions' searchMethod' encoding
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,replace,The method has 7 parameters. Parameters: inputStream' outputStream' searchPattern' replacePattern' searchOptions' replaceMethod' encoding
Long Parameter List,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,replaceMultiline,The method has 7 parameters. Parameters: inputStream' outputStream' searchPattern' replacePattern' searchOptions' replaceMethod' encoding
Long Parameter List,dnGREP.Engines,IGrepEngine,C:\repos\dnGrep_dnGrep\dnGREP.Engines\IGrepEngine.cs,Search,The method has 5 parameters. Parameters: file' searchPattern' searchType' searchOptions' encoding
Long Parameter List,dnGREP.Engines,IGrepEngine,C:\repos\dnGrep_dnGrep\dnGREP.Engines\IGrepEngine.cs,Search,The method has 6 parameters. Parameters: input' fileName' searchPattern' searchType' searchOptions' encoding
Long Parameter List,dnGREP.Engines,IGrepEngine,C:\repos\dnGrep_dnGrep\dnGREP.Engines\IGrepEngine.cs,Replace,The method has 7 parameters. Parameters: sourceFile' destinationFile' searchPattern' replacePattern' searchType' searchOptions' encoding
Long Parameter List,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doFuzzySearchMultiline,The method has 5 parameters. Parameters: lineNumber' text' searchPattern' searchOptions' includeContext
Long Parameter List,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doXPathSearch,The method has 5 parameters. Parameters: lineNumber' text' searchXPath' searchOptions' includeContext
Long Parameter List,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getAbsoluteCharPosition,The method has 5 parameters. Parameters: line' position' text' lineLengths' leftTrimmed
Long Parameter List,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doRegexSearch,The method has 5 parameters. Parameters: lineNumber' text' searchPattern' searchOptions' includeContext
Long Parameter List,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doTextSearchCaseInsensitive,The method has 5 parameters. Parameters: lineNumber' text' searchText' searchOptions' includeContext
Long Parameter List,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doTextSearchCaseSensitive,The method has 5 parameters. Parameters: lineNumber' text' searchText' searchOptions' includeContext
Long Parameter List,dnGREP.Engines,GrepEngineInitParams,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,GrepEngineInitParams,The method has 5 parameters. Parameters: showLinesInContext' linesBefore' linesAfter' fuzzyMatchThreshold' verboseMatchCount
Long Parameter List,dnGREP.Common,GrepCore,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepCore.cs,Search,The method has 5 parameters. Parameters: files' searchType' searchPattern' searchOptions' codePage
Long Parameter List,dnGREP.Common,GrepCore,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepCore.cs,Replace,The method has 6 parameters. Parameters: files' searchType' searchPattern' replacePattern' searchOptions' codePage
Long Statement,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_length,The length of the statement  "                if (!(isWholeWord && loc + pattern.Length < text.Length && !Utils.IsValidEndText(text.Substring(loc' pattern.Length + 1)))) " is 123.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,LoadPlugins,The length of the statement  "                            logger.Log<Exception>(LogLevel.Error' "Failed to initialize " + Path.GetFileNameWithoutExtension(pluginFile) + " engine."' ex); " is 127.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetArchiveExtenstions,The length of the statement  "                    (r.Extensions.Contains("zip") || r.Extensions.Contains("gzip") || r.Extensions.Contains("gz") || r.Extensions.Contains("7z"))) " is 126.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetSearchEngine,The length of the statement  "                if (FrameworkVersionsAreCompatible(fileTypeEngines[fileExtension].Engine.FrameworkVersion' plainTextEngine.FrameworkVersion)) " is 125.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetSearchEngine,The length of the statement  "                        failedEngines[fileTypeEngines[fileExtension].Engine.GetType().Name] = "Failed to initialize the plugin. See error log for details."; " is 132.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetSearchEngine,The length of the statement  "                    failedEngines[fileTypeEngines[fileExtension].Engine.GetType().Name] = "Plugin developed under outdated framework. Please update the plugin."; " is 141.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetReplaceEngine,The length of the statement  "            if (fileTypeEngines.ContainsKey(fileExtension) && fileTypeEngines[fileExtension].Enabled && !fileTypeEngines[fileExtension].Engine.IsSearchOnly) " is 144.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetReplaceEngine,The length of the statement  "                if (FrameworkVersionsAreCompatible(fileTypeEngines[fileExtension].Engine.FrameworkVersion' plainTextEngine.FrameworkVersion)) " is 125.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetReplaceEngine,The length of the statement  "                        failedEngines[fileTypeEngines[fileExtension].Engine.GetType().Name] = "Failed to initialize the plugin. See error log for details."; " is 132.
Long Statement,dnGREP.Engines,GrepEngineFactory,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineFactory.cs,GetReplaceEngine,The length of the statement  "                    failedEngines[fileTypeEngines[fileExtension].Engine.GetType().Name] = "Plugin developed under outdated framework. Please update the plugin."; " is 141.
Long Statement,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Search,The length of the statement  "            using (FileStream fileStream = new FileStream(file' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.SequentialScan)) " is 134.
Long Statement,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Replace,The length of the statement  "                return replaceMultiline(readStream' writeStream' searchPattern' replacePattern' searchOptions' replaceMethod' encoding); " is 120.
Long Statement,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doFuzzySearchMultiline,The length of the statement  "                int matchLength = fuzzyMatchEngine.match_length(text.Substring(counter)' searchPattern' matchLocation' isWholeWord' initParams.FuzzyMatchThreshold); " is 148.
Long Statement,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doXPathSearch,The length of the statement  "                    // Code from http://stackoverflow.com/questions/10606534/how-to-search-xml-files-with-xpath-returning-line-and-column-numbers-of-found " is 134.
Long Statement,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getFilePositions,The length of the statement  "                                            results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1; " is 130.
Long Statement,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getFilePositions,The length of the statement  "                                            results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1; " is 130.
Long Statement,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getFilePositions,The length of the statement  "                                        results[i] = new GrepSearchResult.GrepMatch(lineInfo.LineNumber - 1' getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 2' text' lineLengths' false)' 0); " is 175.
Long Statement,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doFuzzyReplace,The length of the statement  "                int matchLength = fuzzyMatchEngine.match_length(text.Substring(counter)' searchPattern' matchLocation' isWholeWord' initParams.FuzzyMatchThreshold); " is 148.
Long Statement,dnGREP.Common,GrepCore,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepCore.cs,Search,The length of the statement  "                        if ((searchOptions & GrepSearchOption.StopAfterFirstMatch) == GrepSearchOption.StopAfterFirstMatch && searchResults.Count > 0) " is 126.
Complex Conditional,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_length,The conditional expression  "text == null || pattern == null || text.Length == 0 || pattern.Length == 0"  is complex.
Complex Conditional,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getAbsoluteCharPosition,The conditional expression  "text[i] != '\n' && text[i] != '\r' && text[i] != '\t' && text[i] != ' ' && text[i] != '<' && text[i] != '/'"  is complex.
Empty Catch Block,dnGREP.Common,GrepCore,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepCore.cs,Replace,The method has an empty catch block.
Empty Catch Block,dnGREP.Common,GrepCore,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepCore.cs,Replace,The method has an empty catch block.
Magic Number,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_length,The following statement contains a magic number: while (counter < pattern.Length * 2)              {                  if (counter + loc < text.Length)                  {                      counter++;                      string tempMatchWord = text.Substring(loc' counter);                      if (isWholeWord && counter + loc < text.Length && !Utils.IsValidEndText(text.Substring(loc + counter)))                      {                          continue;                      }                        double tempMatchIndex = nw.GetSimilarity(pattern' tempMatchWord);                      if (tempMatchIndex > matchIndex)                      {                          matchIndex = tempMatchIndex;                          matchWord = tempMatchWord;                      }                  }                  else                  {                      break;                  }              }
Magic Number,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++)              {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid)                  {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern)                          <= score_threshold)                      {                          bin_min = bin_mid;                      }                      else                      {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--)                  {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1]))                      {                          // Out of range.                          charMatch = 0;                      }                      else                      {                          charMatch = s[text[j - 1]];                      }                      if (d == 0)                      {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      }                      else                      {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                              | (((last_rd[j + 1] | last_rd[j]) << 1) | 1)                              | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0)                      {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold)                          {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc)                              {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              }                              else                              {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold)                  {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++)              {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid)                  {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern)                          <= score_threshold)                      {                          bin_min = bin_mid;                      }                      else                      {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--)                  {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1]))                      {                          // Out of range.                          charMatch = 0;                      }                      else                      {                          charMatch = s[text[j - 1]];                      }                      if (d == 0)                      {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      }                      else                      {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                              | (((last_rd[j + 1] | last_rd[j]) << 1) | 1)                              | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0)                      {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold)                          {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc)                              {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              }                              else                              {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold)                  {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,dnGREP.Engines,GoogleMatch,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GoogleMatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++)              {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid)                  {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern)                          <= score_threshold)                      {                          bin_min = bin_mid;                      }                      else                      {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--)                  {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1]))                      {                          // Out of range.                          charMatch = 0;                      }                      else                      {                          charMatch = s[text[j - 1]];                      }                      if (d == 0)                      {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      }                      else                      {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                              | (((last_rd[j + 1] | last_rd[j]) << 1) | 1)                              | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0)                      {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold)                          {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc)                              {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              }                              else                              {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold)                  {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Search,The following statement contains a magic number: using (FileStream fileStream = new FileStream(file' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.SequentialScan))              {                  return Search(fileStream' file' searchPattern' searchType' searchOptions' encoding);              }
Magic Number,dnGREP.Engines,GrepPlugin,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepPlugin.cs,LoadPluginSettings,The following statement contains a magic number: if (pluginFilePath != null && File.Exists(pluginFilePath))              {                  try                  {                      foreach (string line in File.ReadAllLines(pluginFilePath))                      {                          string[] tokens = line.Split('=');                          if (tokens.Length != 2)                              continue;                            switch (tokens[0].Trim().ToUpper())                          {                              case "FILE":                                  DllFilePath = tokens[1].Trim();                                  break;                              case "ENABLED":                                  Enabled = Utils.ParseBoolean(tokens[1].Trim()' true);                                  break;                              case "EXTENSIONS":                                  Extensions.Clear();                                  foreach (string extension in tokens[1].Trim().Split('''))                                  {                                      Extensions.Add(extension.Trim().ToLower());                                  }                                  break;                          }                      }                        string tempDllFilePath = DllFilePath;                      if (!File.Exists(tempDllFilePath))                          tempDllFilePath = Path.GetDirectoryName(pluginFilePath) + "\\" + tempDllFilePath;                        if (File.Exists(tempDllFilePath))                      {                          Assembly assembly = Assembly.LoadFile(tempDllFilePath);                          Type[] types = assembly.GetTypes();                          foreach (Type type in types)                          {                              if (type.GetInterface("IGrepEngine") != null)                              {                                  IGrepEngine engine = (IGrepEngine)Activator.CreateInstance(type);                                  Engine = engine;                                  break;                              }                          }                      }                  }                  catch (Exception ex)                  {                      throw ex;                  }              }
Magic Number,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doXPathSearch,The following statement contains a magic number: if (text.Length > 5 && text.Substring(0' 5).ToLower() == "<?xml")              {                  List<XPathPosition> positions = new List<XPathPosition>();                  using (StringReader reader = new StringReader(text))                  {                      // Code from http://stackoverflow.com/questions/10606534/how-to-search-xml-files-with-xpath-returning-line-and-column-numbers-of-found                      XPathDocument xmlDoc = new XPathDocument(reader);                      var xpn = xmlDoc.CreateNavigator();                      xpn.MoveToFollowing(XPathNodeType.Element);                      var xns = xpn.GetNamespacesInScope(XmlNamespaceScope.All);                      var xmngr = new XmlNamespaceManager(xpn.NameTable);                      foreach (var key in xns.Keys)                          xmngr.AddNamespace(key' xns[key]);                      var xpni = xpn.Select(searchXPath' xmngr);                        int foundCounter = 0;                      while (xpni.MoveNext())                      {                          foundCounter++;                          var xn = xpni.Current;                            var xpathPositions = new XPathPosition();                          if (xn.NodeType == System.Xml.XPath.XPathNodeType.Attribute)                          {                              xpathPositions.EndsOnAttribute = true;                              xpathPositions.AttributeName = xn.Name;                          }                          List<int> currentPositions = new List<int>();                          getXpathPositions(xn' ref currentPositions);                          if (xpathPositions.EndsOnAttribute)                              currentPositions.RemoveAt(currentPositions.Count - 1);                          xpathPositions.Path = currentPositions;                          positions.Add(xpathPositions);                      }                  }                    results.AddRange(getFilePositions(text' positions));              }
Magic Number,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doXPathSearch,The following statement contains a magic number: if (text.Length > 5 && text.Substring(0' 5).ToLower() == "<?xml")              {                  List<XPathPosition> positions = new List<XPathPosition>();                  using (StringReader reader = new StringReader(text))                  {                      // Code from http://stackoverflow.com/questions/10606534/how-to-search-xml-files-with-xpath-returning-line-and-column-numbers-of-found                      XPathDocument xmlDoc = new XPathDocument(reader);                      var xpn = xmlDoc.CreateNavigator();                      xpn.MoveToFollowing(XPathNodeType.Element);                      var xns = xpn.GetNamespacesInScope(XmlNamespaceScope.All);                      var xmngr = new XmlNamespaceManager(xpn.NameTable);                      foreach (var key in xns.Keys)                          xmngr.AddNamespace(key' xns[key]);                      var xpni = xpn.Select(searchXPath' xmngr);                        int foundCounter = 0;                      while (xpni.MoveNext())                      {                          foundCounter++;                          var xn = xpni.Current;                            var xpathPositions = new XPathPosition();                          if (xn.NodeType == System.Xml.XPath.XPathNodeType.Attribute)                          {                              xpathPositions.EndsOnAttribute = true;                              xpathPositions.AttributeName = xn.Name;                          }                          List<int> currentPositions = new List<int>();                          getXpathPositions(xn' ref currentPositions);                          if (xpathPositions.EndsOnAttribute)                              currentPositions.RemoveAt(currentPositions.Count - 1);                          xpathPositions.Path = currentPositions;                          positions.Add(xpathPositions);                      }                  }                    results.AddRange(getFilePositions(text' positions));              }
Magic Number,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getFilePositions,The following statement contains a magic number: using (StringReader textReader = new StringReader(text))              using (XmlReader reader = XmlReader.Create(textReader))              {                  List<int> currPos = new List<int>();                    try                  {                      IXmlLineInfo lineInfo = ((IXmlLineInfo)reader);                      if (lineInfo.HasLineInfo())                      {                          bool readyToBreak = false;                          // Parse the XML and display each node.                          while (reader.Read() && !readyToBreak)                          {                              switch (reader.NodeType)                              {                                  case XmlNodeType.Element:                                        if (currPos.Count <= reader.Depth)                                      {                                          currPos.Add(1);                                      }                                      else                                      {                                          currPos[reader.Depth]++;                                      }                                        break;                                    case XmlNodeType.EndElement:                                      while (reader.Depth < currPos.Count - 1)                                      {                                          currPos.RemoveAt(reader.Depth + 1); // currPos.Count - 1 would work too.                                      }                                        for (int i = 0; i < positions.Count; i++)                                      {                                          if (xPathPositionsMatch(currPos' positions[i].Path))                                          {                                              endFound[i] = true;                                          }                                      }                                      break;                                  default:                                      break;                              }                                if (reader.NodeType == XmlNodeType.EndElement)                              {                                  for (int i = 0; i < positions.Count; i++)                                  {                                      if (endFound[i] && !xPathPositionsMatch(currPos' positions[i].Path))                                      {                                          if (results[i] != null)                                          {                                              results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1;                                          }                                          endFound[i] = false;                                      }                                  }                              }                                if (reader.NodeType == XmlNodeType.Element)                              {                                  for (int i = 0; i < positions.Count; i++)                                  {                                      if (endFound[i])                                      {                                          if (results[i] != null)                                          {                                              results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1;                                          }                                          endFound[i] = false;                                      }                                        if (xPathPositionsMatch(currPos' positions[i].Path))                                      {                                          results[i] = new GrepSearchResult.GrepMatch(lineInfo.LineNumber - 1' getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 2' text' lineLengths' false)' 0);                                      }                                        // If empty element (e.g.<element/>)                                      if (reader.IsEmptyElement)                                      {                                          if (xPathPositionsMatch(currPos' positions[i].Path))                                          {                                              endFound[i] = true;                                          }                                      }                                  }                              }                          }                      }                  }                  finally                  {                      for (int i = 0; i < positions.Count; i++)                      {                          if (results[i] != null && results[i].Length == 0)                              results[i].EndPosition = text.Length - 1;                      }                        reader.Close();                  }                  // Close the reader.              }
Magic Number,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getFilePositions,The following statement contains a magic number: using (StringReader textReader = new StringReader(text))              using (XmlReader reader = XmlReader.Create(textReader))              {                  List<int> currPos = new List<int>();                    try                  {                      IXmlLineInfo lineInfo = ((IXmlLineInfo)reader);                      if (lineInfo.HasLineInfo())                      {                          bool readyToBreak = false;                          // Parse the XML and display each node.                          while (reader.Read() && !readyToBreak)                          {                              switch (reader.NodeType)                              {                                  case XmlNodeType.Element:                                        if (currPos.Count <= reader.Depth)                                      {                                          currPos.Add(1);                                      }                                      else                                      {                                          currPos[reader.Depth]++;                                      }                                        break;                                    case XmlNodeType.EndElement:                                      while (reader.Depth < currPos.Count - 1)                                      {                                          currPos.RemoveAt(reader.Depth + 1); // currPos.Count - 1 would work too.                                      }                                        for (int i = 0; i < positions.Count; i++)                                      {                                          if (xPathPositionsMatch(currPos' positions[i].Path))                                          {                                              endFound[i] = true;                                          }                                      }                                      break;                                  default:                                      break;                              }                                if (reader.NodeType == XmlNodeType.EndElement)                              {                                  for (int i = 0; i < positions.Count; i++)                                  {                                      if (endFound[i] && !xPathPositionsMatch(currPos' positions[i].Path))                                      {                                          if (results[i] != null)                                          {                                              results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1;                                          }                                          endFound[i] = false;                                      }                                  }                              }                                if (reader.NodeType == XmlNodeType.Element)                              {                                  for (int i = 0; i < positions.Count; i++)                                  {                                      if (endFound[i])                                      {                                          if (results[i] != null)                                          {                                              results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1;                                          }                                          endFound[i] = false;                                      }                                        if (xPathPositionsMatch(currPos' positions[i].Path))                                      {                                          results[i] = new GrepSearchResult.GrepMatch(lineInfo.LineNumber - 1' getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 2' text' lineLengths' false)' 0);                                      }                                        // If empty element (e.g.<element/>)                                      if (reader.IsEmptyElement)                                      {                                          if (xPathPositionsMatch(currPos' positions[i].Path))                                          {                                              endFound[i] = true;                                          }                                      }                                  }                              }                          }                      }                  }                  finally                  {                      for (int i = 0; i < positions.Count; i++)                      {                          if (results[i] != null && results[i].Length == 0)                              results[i].EndPosition = text.Length - 1;                      }                        reader.Close();                  }                  // Close the reader.              }
Magic Number,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,getFilePositions,The following statement contains a magic number: using (StringReader textReader = new StringReader(text))              using (XmlReader reader = XmlReader.Create(textReader))              {                  List<int> currPos = new List<int>();                    try                  {                      IXmlLineInfo lineInfo = ((IXmlLineInfo)reader);                      if (lineInfo.HasLineInfo())                      {                          bool readyToBreak = false;                          // Parse the XML and display each node.                          while (reader.Read() && !readyToBreak)                          {                              switch (reader.NodeType)                              {                                  case XmlNodeType.Element:                                        if (currPos.Count <= reader.Depth)                                      {                                          currPos.Add(1);                                      }                                      else                                      {                                          currPos[reader.Depth]++;                                      }                                        break;                                    case XmlNodeType.EndElement:                                      while (reader.Depth < currPos.Count - 1)                                      {                                          currPos.RemoveAt(reader.Depth + 1); // currPos.Count - 1 would work too.                                      }                                        for (int i = 0; i < positions.Count; i++)                                      {                                          if (xPathPositionsMatch(currPos' positions[i].Path))                                          {                                              endFound[i] = true;                                          }                                      }                                      break;                                  default:                                      break;                              }                                if (reader.NodeType == XmlNodeType.EndElement)                              {                                  for (int i = 0; i < positions.Count; i++)                                  {                                      if (endFound[i] && !xPathPositionsMatch(currPos' positions[i].Path))                                      {                                          if (results[i] != null)                                          {                                              results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1;                                          }                                          endFound[i] = false;                                      }                                  }                              }                                if (reader.NodeType == XmlNodeType.Element)                              {                                  for (int i = 0; i < positions.Count; i++)                                  {                                      if (endFound[i])                                      {                                          if (results[i] != null)                                          {                                              results[i].EndPosition = getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 3' text' lineLengths' true) + 1;                                          }                                          endFound[i] = false;                                      }                                        if (xPathPositionsMatch(currPos' positions[i].Path))                                      {                                          results[i] = new GrepSearchResult.GrepMatch(lineInfo.LineNumber - 1' getAbsoluteCharPosition(lineInfo.LineNumber - 1' lineInfo.LinePosition - 2' text' lineLengths' false)' 0);                                      }                                        // If empty element (e.g.<element/>)                                      if (reader.IsEmptyElement)                                      {                                          if (xPathPositionsMatch(currPos' positions[i].Path))                                          {                                              endFound[i] = true;                                          }                                      }                                  }                              }                          }                      }                  }                  finally                  {                      for (int i = 0; i < positions.Count; i++)                      {                          if (results[i] != null && results[i].Length == 0)                              results[i].EndPosition = text.Length - 1;                      }                        reader.Close();                  }                  // Close the reader.              }
Magic Number,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doXPathReplace,The following statement contains a magic number: if (text.Length > 5 && text.Substring(0' 5).ToLower() == "<?xml")              {                  XmlDocument xmlDoc = new XmlDocument();                  xmlDoc.LoadXml(text);                  XmlNodeList xmlNodes = xmlDoc.SelectNodes(searchXPath);                    foreach (XmlNode xmlNode in xmlNodes)                  {                      xmlNode.InnerXml = doPatternReplacement(replaceText);                  }                  StringBuilder sb = new StringBuilder();                  StringWriter stringWriter = new StringWriter(sb);                  using (XmlTextWriter xmlWriter = new XmlTextWriter(stringWriter))                  {                      xmlWriter.Formatting = Formatting.Indented;                      xmlDoc.WriteContentTo(xmlWriter);                      xmlWriter.Flush();                  }                    return sb.ToString();              }
Magic Number,dnGREP.Engines,GrepEngineBase,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEngineBase.cs,doXPathReplace,The following statement contains a magic number: if (text.Length > 5 && text.Substring(0' 5).ToLower() == "<?xml")              {                  XmlDocument xmlDoc = new XmlDocument();                  xmlDoc.LoadXml(text);                  XmlNodeList xmlNodes = xmlDoc.SelectNodes(searchXPath);                    foreach (XmlNode xmlNode in xmlNodes)                  {                      xmlNode.InnerXml = doPatternReplacement(replaceText);                  }                  StringBuilder sb = new StringBuilder();                  StringWriter stringWriter = new StringWriter(sb);                  using (XmlTextWriter xmlWriter = new XmlTextWriter(stringWriter))                  {                      xmlWriter.Formatting = Formatting.Indented;                      xmlDoc.WriteContentTo(xmlWriter);                      xmlWriter.Flush();                  }                    return sb.ToString();              }
Magic Number,dnGREP.Engines,AbstractStringMetric,C:\repos\dnGrep_dnGrep\dnGREP.Engines\SimMetrics.cs,GetSimilarityTimingActual,The following statement contains a magic number: long timeBefore = (DateTime.Now.Ticks - 621355968000000000) / 10000;
Magic Number,dnGREP.Engines,AbstractStringMetric,C:\repos\dnGrep_dnGrep\dnGREP.Engines\SimMetrics.cs,GetSimilarityTimingActual,The following statement contains a magic number: long timeBefore = (DateTime.Now.Ticks - 621355968000000000) / 10000;
Magic Number,dnGREP.Engines,AbstractStringMetric,C:\repos\dnGrep_dnGrep\dnGREP.Engines\SimMetrics.cs,GetSimilarityTimingActual,The following statement contains a magic number: long timeAfter = (DateTime.Now.Ticks - 621355968000000000) / 10000;
Magic Number,dnGREP.Engines,AbstractStringMetric,C:\repos\dnGrep_dnGrep\dnGREP.Engines\SimMetrics.cs,GetSimilarityTimingActual,The following statement contains a magic number: long timeAfter = (DateTime.Now.Ticks - 621355968000000000) / 10000;
Missing Default,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Search,The following switch statement is missing a default case: switch (searchType)              {                  case SearchType.PlainText:                      if ((searchOptions & GrepSearchOption.CaseSensitive) == GrepSearchOption.CaseSensitive)                      {                          searchMethod = doTextSearchCaseSensitive;                      }                      else                      {                          searchMethod = doTextSearchCaseInsensitive;                      }                      break;                  case SearchType.Regex:                      searchMethod = doRegexSearch;                      break;                  case SearchType.XPath:                      searchMethod = doXPathSearch;                      break;                  case SearchType.Soundex:                      searchMethod = doFuzzySearchMultiline;                      break;              }
Missing Default,dnGREP.Engines,GrepEnginePlainText,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepEnginePlainText.cs,Replace,The following switch statement is missing a default case: switch (searchType)              {                  case SearchType.PlainText:                      if ((searchOptions & GrepSearchOption.CaseSensitive) == GrepSearchOption.CaseSensitive)                      {                          replaceMethod = doTextReplaceCaseSensitive;                      }                      else                      {                          replaceMethod = doTextReplaceCaseInsensitive;                      }                      break;                  case SearchType.Regex:                      replaceMethod = doRegexReplace;                      break;                  case SearchType.XPath:                      replaceMethod = doXPathReplace;                      break;                  case SearchType.Soundex:                      replaceMethod = doFuzzyReplace;                      break;              }
Missing Default,dnGREP.Engines,GrepPlugin,C:\repos\dnGrep_dnGrep\dnGREP.Engines\GrepPlugin.cs,LoadPluginSettings,The following switch statement is missing a default case: switch (tokens[0].Trim().ToUpper())                          {                              case "FILE":                                  DllFilePath = tokens[1].Trim();                                  break;                              case "ENABLED":                                  Enabled = Utils.ParseBoolean(tokens[1].Trim()' true);                                  break;                              case "EXTENSIONS":                                  Extensions.Clear();                                  foreach (string extension in tokens[1].Trim().Split('''))                                  {                                      Extensions.Add(extension.Trim().ToLower());                                  }                                  break;                          }
