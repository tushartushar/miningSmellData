Implementation smell,Namespace,Class,File,Method,Description
Long Method,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The method has 114 lines of code.
Long Method,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The method has 114 lines of code.
Complex Method,Dwarrowdelf.AI,AssignmentAI,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AssignmentAI.cs,DecideAction,Cyclomatic complexity of the method is 10
Complex Method,Dwarrowdelf,Bresenhams,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\Bresenhams.cs,PlotLine3,Cyclomatic complexity of the method is 9
Complex Method,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,Cyclomatic complexity of the method is 11
Complex Method,Dwarrowdelf,SaveGameDeserializer,C:\repos\tomba_dwarrowdelf\Common\Game\Json\JsonDeserializer.cs,DeserializeGameObject,Cyclomatic complexity of the method is 10
Complex Method,Dwarrowdelf,SaveGameSerializer,C:\repos\tomba_dwarrowdelf\Common\Game\Json\JsonSerializer.cs,WriteGameObjectData,Cyclomatic complexity of the method is 9
Complex Method,Dwarrowdelf,EnvironmentExtensions,C:\repos\tomba_dwarrowdelf\Common\Game\EnvironmentExtensions.cs,CanMoveFrom,Cyclomatic complexity of the method is 10
Complex Method,Dwarrowdelf,EnvironmentExtensions,C:\repos\tomba_dwarrowdelf\Common\Game\EnvironmentExtensions.cs,CanMoveTo,Cyclomatic complexity of the method is 10
Complex Method,Dwarrowdelf,MarkovNameGenerator,C:\repos\tomba_dwarrowdelf\Common\Lib\MarkovNameGenerator.cs,MarkovNameGenerator,Cyclomatic complexity of the method is 9
Complex Method,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,Cyclomatic complexity of the method is 11
Complex Method,Dwarrowdelf.Jobs.JobGroups,JobGroup,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\JobGroups\JobGroup.cs,SetStatus,Cyclomatic complexity of the method is 8
Long Parameter List,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,Find,The method has 7 parameters. Parameters: env' src' srcPositioning' dst' dstPositioning' maxNodeCount' cancellationToken
Long Parameter List,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,FindArea,The method has 6 parameters. Parameters: env' src' srcPositioning' dstArea' maxNodeCount' cancellationToken
Long Parameter List,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,Find,The method has 5 parameters. Parameters: env' src' dest' positioning' finalLocation
Long Parameter List,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,ParallelFind,The method has 6 parameters. Parameters: env' src' dest' positioning' resBackward' resForward
Long Parameter List,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,FindMany,The method has 6 parameters. Parameters: env' src' srcPositioning' func' maxNodeCount' cancellationToken
Long Parameter List,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,FindMany,The method has 6 parameters. Parameters: env' src' srcPositioning' target' maxNodeCount' cancellationToken
Long Parameter List,Dwarrowdelf,RayCastLerp,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\RayCastLerp.cs,Calculate,The method has 5 parameters. Parameters: viewerLocation' visionRange' visibilityMap' mapSize' blockerDelegate
Long Parameter List,Dwarrowdelf,RayCastLerp,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\RayCastLerp.cs,Calculate3,The method has 5 parameters. Parameters: viewerLocation' visionRange' visibilityMap' mapSize' blockerDelegate
Long Parameter List,Dwarrowdelf,RayCastBresenhams,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\RayCastBresenhams.cs,Calculate,The method has 5 parameters. Parameters: viewerLocation' visionRange' visibilityMap' mapSize' blockerDelegate
Long Parameter List,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The method has 5 parameters. Parameters: viewerLocation' visionRange' visibilityMap' mapSize' blockerDelegate
Long Parameter List,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The method has 6 parameters. Parameters: data' startColumn' octant' startSlope' endSlope' id
Long Parameter List,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,IntGrid2Z,The method has 5 parameters. Parameters: x' y' columns' rows' z
Long Parameter List,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The method has 5 parameters. Parameters: viewerLocation' visionRange' visibilityMap' mapSize' blockerDelegate
Long Parameter List,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The method has 6 parameters. Parameters: data' startColumn' octant' startSlope' endSlope' id
Long Parameter List,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,LinearInterpolation,The method has 5 parameters. Parameters: x0' x1' y0' y1' x
Long Parameter List,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,BiLerp,The method has 10 parameters. Parameters: x' y' x0y0' x0y1' x1y0' x1y1' x1' x2' y1' y2
Long Parameter List,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,TriLerp,The method has 17 parameters. Parameters: x' y' z' x0y0z0' x0y0z1' x0y1z0' x0y1z1' x1y0z0' x1y0z1' x1y1z0' x1y1z1' x1' x2' y1' y2' z1' z2
Long Parameter List,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,IntGrid3,The method has 6 parameters. Parameters: x' y' z' columns' rows' depth
Long Parameter List,Dwarrowdelf,MMLogTraceListener,C:\repos\tomba_dwarrowdelf\Common\Lib\MMLogTraceListener.cs,TraceEvent,The method has 5 parameters. Parameters: eventCache' source' eventType' id' message
Long Parameter List,Dwarrowdelf,MMLogTraceListener,C:\repos\tomba_dwarrowdelf\Common\Lib\MMLogTraceListener.cs,TraceEvent,The method has 6 parameters. Parameters: eventCache' source' eventType' id' format' args
Long Parameter List,Dwarrowdelf.TerrainGen,DiamondSquare,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DiamondSquare.cs,Render,The method has 7 parameters. Parameters: grid' corners' range' h' random' min' max
Long Parameter List,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreSphere,The method has 7 parameters. Parameters: terrain' random' center' r' oreMaterialID' probIn' probOut
Long Parameter List,Dwarrowdelf.Jobs.AssignmentGroups,MoveConstructAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\AssignmentGroups\MoveConstructAssignment.cs,MoveConstructAssignment,The method has 5 parameters. Parameters: parent' mode' items' environment' location
Long Parameter List,Dwarrowdelf.Jobs.AssignmentGroups,FetchItemAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\AssignmentGroups\FetchItemAssignment.cs,FetchItemAssignment,The method has 5 parameters. Parameters: parent' env' location' item' positioning
Long Parameter List,Dwarrowdelf.Jobs.Assignments,ConstructAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\ConstructAssignment.cs,ConstructAssignment,The method has 5 parameters. Parameters: parent' mode' environment' location' items
Long Parameter List,Dwarrowdelf.Jobs.Assignments,HaulToAreaAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\HaulToAreaAssignment.cs,HaulToAreaAssignment,The method has 5 parameters. Parameters: parent' environment' destination' positioning' hauledItem
Long Parameter List,Dwarrowdelf.Jobs.Assignments,HaulAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\HaulAssignment.cs,HaulAssignment,The method has 5 parameters. Parameters: parent' environment' destination' positioning' hauledItem
Long Parameter List,Dwarrowdelf.Jobs.JobGroups,ConstructJob,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\JobGroups\ConstructJob.cs,ConstructJob,The method has 5 parameters. Parameters: parent' mode' items' environment' location
Long Parameter List,Dwarrowdelf.Jobs.JobGroups,FetchItems,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\JobGroups\FetchItems.cs,FetchItems,The method has 5 parameters. Parameters: parent' env' location' items' positioning
Long Identifier,Dwarrowdelf,WorkHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\WorkHelpers.cs,,The length of the parameter ConstructPavementTerrainFilter is 30.
Long Statement,Dwarrowdelf.AI,HerbivoreAI,C:\repos\tomba_dwarrowdelf\Common\Game\AI\HerbivoreAI.cs,GetNewOrCurrentAssignment,The length of the statement  "						var enemies = AIHelpers.FindEnemies(worker' LivingCategory.Carnivore | LivingCategory.Civilized | LivingCategory.Monster); " is 122.
Long Statement,Dwarrowdelf.AI,HerbivoreAI,C:\repos\tomba_dwarrowdelf\Common\Game\AI\HerbivoreAI.cs,GetNewOrCurrentAssignment,The length of the statement  "						var enemies = AIHelpers.FindEnemies(worker' LivingCategory.Carnivore | LivingCategory.Civilized | LivingCategory.Monster); " is 122.
Long Statement,Dwarrowdelf.AI,AssignmentAI,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AssignmentAI.cs,DecideAction,The length of the statement  "				this.HasAssignment && this.CurrentAssignment.CurrentAction != null ? this.CurrentAssignment.CurrentAction.ToString() : "<none>"); " is 129.
Long Statement,Dwarrowdelf.AI,AssignmentAI,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AssignmentAI.cs,ActionStarted,The length of the statement  "				this.HasAssignment && this.CurrentAssignment.CurrentAction != null ? this.CurrentAssignment.CurrentAction.ToString() : "<none>"); " is 129.
Long Statement,Dwarrowdelf.AI,AssignmentAI,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AssignmentAI.cs,ActionDone,The length of the statement  "			trace.TraceVerbose("ActionDone({0}' State {1}): Worker.Action = {2}' CurrentAssignment {3}' CurrentAssignment.Action = {4}"' " is 124.
Long Statement,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The length of the statement  "			//Debug.Print("{4}{0}: Calc' start col {3}' slope {1} -> {2}"' id' startSlope' endSlope' startColumn' new string(' '' (id - 1) * 4)); " is 133.
Long Statement,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The length of the statement  "			x = (x | x << 32) & 0x1f00000000ffff;  // shift left 32 bits' OR with self' and 00011111000000000000000000000000000000001111111111111111 " is 136.
Long Statement,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The length of the statement  "			x = (x | x << 16) & 0x1f0000ff0000ff;  // shift left 32 bits' OR with self' and 00011111000000000000000011111111000000000000000011111111 " is 136.
Long Statement,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The length of the statement  "			x = (x | x << 8) & 0x100f00f00f00f00f; // shift left 32 bits' OR with self' and 0001000000001111000000001111000000001111000000001111000000000000 " is 144.
Long Statement,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The length of the statement  "			x = (x | x << 4) & 0x10c30c30c30c30c3; // shift left 32 bits' OR with self' and 0001000011000011000011000011000011000011000011000011000100000000 " is 144.
Long Statement,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The length of the statement  "			answer = morton256_z[(z >> 16) & 0xFF] | // we start by shifting the third byte' since we only look at the first 21 bits " is 120.
Long Statement,Dwarrowdelf,SaveGameDeserializer,C:\repos\tomba_dwarrowdelf\Common\Game\Json\JsonDeserializer.cs,DeserializeSerializable,The length of the statement  "			var defConstructor = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' new Type[0]' null); " is 136.
Long Statement,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,Parse,The length of the statement  "			return new IntGrid2Z(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)' Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info)); " is 176.
Long Statement,Dwarrowdelf,TypeInfo,C:\repos\tomba_dwarrowdelf\Common\Game\Json\JsonServices.cs,GetMembers,The length of the statement  "			var members = type.GetMembers(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 128.
Long Statement,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The length of the statement  "			//Debug.Print("{4}{0}: Calc' start col {3}' slope {1} -> {2}"' id' startSlope' endSlope' startColumn' new string(' '' (id - 1) * 4)); " is 133.
Long Statement,Dwarrowdelf,Workbenches,C:\repos\tomba_dwarrowdelf\Common\Game\Workbenches.cs,FindBuildableItem,The length of the statement  "			return s_workbenchInfos.SelectMany(kvp => kvp.Value.BuildableItems).SingleOrDefault(bi => bi.FullKey == buildableItemFullKey); " is 126.
Long Statement,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,Contains,The length of the statement  "			return (p.X >= this.X) && (p.X < this.X + this.Columns) && (p.Y >= this.Y) && (p.Y < this.Y + this.Rows) && (p.Z >= this.Z) && (p.Z < this.Z + this.Depth); " is 155.
Long Statement,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,IsIntercardinal,The length of the statement  "			return dir == Direction.NorthEast || dir == Direction.SouthEast || dir == Direction.SouthWest || dir == Direction.NorthWest; " is 124.
Long Statement,Dwarrowdelf,IntGrid2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2.cs,Equals,The length of the statement  "			return this.m_x == other.m_x && this.m_y == other.m_y && this.m_columns == other.m_columns && this.m_rows == other.m_rows; " is 122.
Long Statement,Dwarrowdelf,IntGrid2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2.cs,Parse,The length of the statement  "			return new IntGrid2(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)' Convert.ToInt32(arr[3]' info)); " is 144.
Long Statement,Dwarrowdelf.Jobs.JobGroups,FellTreeParallelJob,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\JobGroups\FellTreeParallelJob.cs,AddNewJobs,The length of the statement  "			m_locs = m_area.Range().Where(p => !m_jobs.Any(i => i.Item1 == p) && m_environment.GetTileData(p).HasFellableTree).Take(3 - c); " is 127.
Complex Conditional,Dwarrowdelf,TypeInfo,C:\repos\tomba_dwarrowdelf\Common\Game\Json\JsonServices.cs,CompareEntries,The conditional expression  "(simpleA && simpleB) || (!simpleA && !simpleB)"  is complex.
Complex Conditional,Dwarrowdelf,TypeInfo,C:\repos\tomba_dwarrowdelf\Common\Game\Json\JsonServices.cs,GetConverter,The conditional expression  "typeConverter != null &&  				typeConverter.GetType() != typeof(TypeConverter) &&  				typeConverter.GetType() != typeof(CollectionConverter) &&  				typeConverter.CanConvertTo(typeof(string))"  is complex.
Complex Conditional,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,ContainsInclusive,The conditional expression  "this.X1 <= other.X1 && other.X2 <= this.X2 &&  				this.Y1 <= other.Y1 && other.Y2 <= this.Y2 &&  				this.Z1 <= other.Z1 && other.Z2 <= this.Z2"  is complex.
Complex Conditional,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,ContainsExclusive,The conditional expression  "this.X1 < other.X1 && other.X2 < this.X2 &&  				this.Y1 < other.Y1 && other.Y2 < this.Y2 &&  				this.Z1 < other.Z1 && other.Z2 < this.Z2"  is complex.
Complex Conditional,Dwarrowdelf.TerrainGen,ArtificialGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\ArtificialGen.cs,CreateCubeMap,The conditional expression  "x < margin || y < margin || z < margin ||  							x >= size.Width - margin || y >= size.Height - margin || z >= size.Depth - margin"  is complex.
Complex Conditional,Dwarrowdelf.TerrainGen,MyTarget,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,GetIsTarget,The conditional expression  "p.X != 0 && p.Y != 0 && p.X != m_terrain.Width - 1 && p.Y != m_terrain.Height - 1"  is complex.
Magic Number,Dwarrowdelf.AI,AIHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AIHelpers.cs,FindNearestEnemy,The following statement contains a magic number: int maxSide = 2 * range + 1;
Magic Number,Dwarrowdelf.AI,AIHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AIHelpers.cs,FindNearestEnemy,The following statement contains a magic number: var rect = new IntGrid2Z(location.X - maxSide / 2' location.Y - maxSide / 2' maxSide' maxSide' location.Z);
Magic Number,Dwarrowdelf.AI,AIHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AIHelpers.cs,FindNearestEnemy,The following statement contains a magic number: var rect = new IntGrid2Z(location.X - maxSide / 2' location.Y - maxSide / 2' maxSide' maxSide' location.Z);
Magic Number,Dwarrowdelf.AI,AIHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AIHelpers.cs,FindEnemies,The following statement contains a magic number: int maxSide = 2 * range + 1;
Magic Number,Dwarrowdelf.AI,AIHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AIHelpers.cs,FindEnemies,The following statement contains a magic number: var rect = new IntGrid2Z(location.X - maxSide / 2' location.Y - maxSide / 2' maxSide' maxSide' location.Z);
Magic Number,Dwarrowdelf.AI,AIHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\AI\AIHelpers.cs,FindEnemies,The following statement contains a magic number: var rect = new IntGrid2Z(location.X - maxSide / 2' location.Y - maxSide / 2' maxSide' maxSide' location.Z);
Magic Number,Dwarrowdelf.AI,HerbivoreAI,C:\repos\tomba_dwarrowdelf\Common\Game\AI\HerbivoreAI.cs,GetFleeVector,The following statement contains a magic number: var fleeVector = enemies.Aggregate(new DoubleVector3()'  				(accu' enemy) =>  				{  					var v = new DoubleVector3(this.Worker.Location - enemy.Location);    					// XXX if null vector' flee up. (which probably leads to fleeing in some parallel direction).  					if (v.IsNull)  						return accu + new DoubleVector3(0' 0' 1);    					v = v * 100 / v.SquaredLength;  					return accu + v;  				});
Magic Number,Dwarrowdelf,AStarDefaultTarget,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarTarget.cs,GetHeuristic,The following statement contains a magic number: int h = COST_DIAGONAL * hDiagonal + COST_STRAIGHT * (hStraight - 2 * hDiagonal);
Magic Number,Dwarrowdelf,AStarAreaTarget,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarTarget.cs,GetHeuristic,The following statement contains a magic number: return (ushort)((dst - location).ManhattanLength * 10);
Magic Number,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,CanReach,The following statement contains a magic number: var taskForward = new Task(delegate  			{  				resForward = Find(env' src' DirectionSet.Exact' dst' dstPositioning' 200000' cts.Token);  			});
Magic Number,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,CanReach,The following statement contains a magic number: var taskBackward = new Task(delegate  			{  				resBackward = Find(env' dst' dstPositioning.Reverse()' src' DirectionSet.Exact' 200000' cts.Token);  			});
Magic Number,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,ParallelFind,The following statement contains a magic number: var taskForward = new Task(delegate  			{  				rf = Find(env' src' DirectionSet.Exact' dest' positioning' 200000' cts.Token);  			});
Magic Number,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,ParallelFind,The following statement contains a magic number: var taskBackward = new Task(delegate  			{  				rb = Find(env' dest' positioning.Reverse()' src' DirectionSet.Exact' 200000' cts.Token);  			});
Magic Number,Dwarrowdelf,AStar,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\AStarHelpers.cs,AStar,The following statement contains a magic number: this.MaxNodeCount = 200000;
Magic Number,Dwarrowdelf,BFS,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\BFS.cs,BFS,The following statement contains a magic number: this.MaxNodeCount = 200000;
Magic Number,Dwarrowdelf,EnumBitMask<TEnum>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\EnumBitMask.cs,ToString,The following statement contains a magic number: var sb = new StringBuilder("0b"' s_numBits + 2);
Magic Number,Dwarrowdelf,EnumBitMask64<TEnum>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\EnumBitMask64.cs,EnumBitMask64,The following statement contains a magic number: if (max > 64)  				throw new Exception();
Magic Number,Dwarrowdelf,EnumBitMask64<TEnum>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\EnumBitMask64.cs,ToString,The following statement contains a magic number: var sb = new StringBuilder("0b"' s_numBits + 2);
Magic Number,Dwarrowdelf,EnumBitMask32<TEnum>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\EnumBitMask32.cs,EnumBitMask32,The following statement contains a magic number: if (max > 32)  				throw new Exception();
Magic Number,Dwarrowdelf,EnumBitMask32<TEnum>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\EnumBitMask32.cs,ToString,The following statement contains a magic number: var sb = new StringBuilder("0b"' s_numBits + 2);
Magic Number,Dwarrowdelf,DataGrid2D<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\DataGrid2D.cs,Scale,The following statement contains a magic number: if (newSize.Width <= oldSize.Width && newSize.Height <= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= 2;  				ydiff /= 2;    				var grid = this.Grid;    				for (int y = 0; y < newSize.Height; ++y)  				{  					Array.Copy(grid' (y + ydiff) * oldSize.Width + xdiff'  						grid' y * newSize.Width + 0' newSize.Width);  				}  			}  			else if (newSize.Width >= oldSize.Width && newSize.Height >= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= -2;  				ydiff /= -2;    				var grid = this.Grid;    				for (int y = oldSize.Height - 1; y >= 0; --y)  				{  					Array.Copy(grid' y * oldSize.Width + 0'  						grid' (y + ydiff) * newSize.Width + xdiff' oldSize.Width);  				}    				// clear top rows  				Array.Clear(grid' 0' ydiff * newSize.Width);    				// clear bottom rows  				Array.Clear(grid' (newSize.Height - ydiff) * newSize.Width' ydiff * newSize.Width);    				// clear the edges  				for (int y = ydiff; y < newSize.Height - ydiff; ++y)  				{  					Array.Clear(grid' y * newSize.Width' xdiff);  					Array.Clear(grid' y * newSize.Width + newSize.Width - xdiff' xdiff);  				}  			}  			else  			{  				this.Invalid = true;  			}
Magic Number,Dwarrowdelf,DataGrid2D<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\DataGrid2D.cs,Scale,The following statement contains a magic number: if (newSize.Width <= oldSize.Width && newSize.Height <= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= 2;  				ydiff /= 2;    				var grid = this.Grid;    				for (int y = 0; y < newSize.Height; ++y)  				{  					Array.Copy(grid' (y + ydiff) * oldSize.Width + xdiff'  						grid' y * newSize.Width + 0' newSize.Width);  				}  			}  			else if (newSize.Width >= oldSize.Width && newSize.Height >= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= -2;  				ydiff /= -2;    				var grid = this.Grid;    				for (int y = oldSize.Height - 1; y >= 0; --y)  				{  					Array.Copy(grid' y * oldSize.Width + 0'  						grid' (y + ydiff) * newSize.Width + xdiff' oldSize.Width);  				}    				// clear top rows  				Array.Clear(grid' 0' ydiff * newSize.Width);    				// clear bottom rows  				Array.Clear(grid' (newSize.Height - ydiff) * newSize.Width' ydiff * newSize.Width);    				// clear the edges  				for (int y = ydiff; y < newSize.Height - ydiff; ++y)  				{  					Array.Clear(grid' y * newSize.Width' xdiff);  					Array.Clear(grid' y * newSize.Width + newSize.Width - xdiff' xdiff);  				}  			}  			else  			{  				this.Invalid = true;  			}
Magic Number,Dwarrowdelf,DataGrid2D<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\DataGrid2D.cs,Scale,The following statement contains a magic number: if (newSize.Width <= oldSize.Width && newSize.Height <= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= 2;  				ydiff /= 2;    				var grid = this.Grid;    				for (int y = 0; y < newSize.Height; ++y)  				{  					Array.Copy(grid' (y + ydiff) * oldSize.Width + xdiff'  						grid' y * newSize.Width + 0' newSize.Width);  				}  			}  			else if (newSize.Width >= oldSize.Width && newSize.Height >= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= -2;  				ydiff /= -2;    				var grid = this.Grid;    				for (int y = oldSize.Height - 1; y >= 0; --y)  				{  					Array.Copy(grid' y * oldSize.Width + 0'  						grid' (y + ydiff) * newSize.Width + xdiff' oldSize.Width);  				}    				// clear top rows  				Array.Clear(grid' 0' ydiff * newSize.Width);    				// clear bottom rows  				Array.Clear(grid' (newSize.Height - ydiff) * newSize.Width' ydiff * newSize.Width);    				// clear the edges  				for (int y = ydiff; y < newSize.Height - ydiff; ++y)  				{  					Array.Clear(grid' y * newSize.Width' xdiff);  					Array.Clear(grid' y * newSize.Width + newSize.Width - xdiff' xdiff);  				}  			}  			else  			{  				this.Invalid = true;  			}
Magic Number,Dwarrowdelf,DataGrid2D<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\DataGrid2D.cs,Scale,The following statement contains a magic number: if (newSize.Width <= oldSize.Width && newSize.Height <= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= 2;  				ydiff /= 2;    				var grid = this.Grid;    				for (int y = 0; y < newSize.Height; ++y)  				{  					Array.Copy(grid' (y + ydiff) * oldSize.Width + xdiff'  						grid' y * newSize.Width + 0' newSize.Width);  				}  			}  			else if (newSize.Width >= oldSize.Width && newSize.Height >= oldSize.Height)  			{  				var xdiff = oldSize.Width - newSize.Width;  				var ydiff = oldSize.Height - newSize.Height;    				xdiff /= -2;  				ydiff /= -2;    				var grid = this.Grid;    				for (int y = oldSize.Height - 1; y >= 0; --y)  				{  					Array.Copy(grid' y * oldSize.Width + 0'  						grid' (y + ydiff) * newSize.Width + xdiff' oldSize.Width);  				}    				// clear top rows  				Array.Clear(grid' 0' ydiff * newSize.Width);    				// clear bottom rows  				Array.Clear(grid' (newSize.Height - ydiff) * newSize.Width' ydiff * newSize.Width);    				// clear the edges  				for (int y = ydiff; y < newSize.Height - ydiff; ++y)  				{  					Array.Clear(grid' y * newSize.Width' xdiff);  					Array.Clear(grid' y * newSize.Width + newSize.Width - xdiff' xdiff);  				}  			}  			else  			{  				this.Invalid = true;  			}
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,Hash2D,The following statement contains a magic number: return ((y & 0xffff) << 16) | ((x & 0xffff) << 0);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,Hash3D,The following statement contains a magic number: return ((z & 0xff) << 24) | ((y & 0xfff) << 12) | ((x & 0xfff) << 0);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,Hash3D,The following statement contains a magic number: return ((z & 0xff) << 24) | ((y & 0xfff) << 12) | ((x & 0xfff) << 0);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashUInt32,The following statement contains a magic number: a = (a ^ 61) ^ (a >> 16);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashUInt32,The following statement contains a magic number: a = (a ^ 61) ^ (a >> 16);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashUInt32,The following statement contains a magic number: a = a + (a << 3);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashUInt32,The following statement contains a magic number: a = a ^ (a >> 4);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashUInt32,The following statement contains a magic number: a = a ^ (a >> 15);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashInt32,The following statement contains a magic number: v = ~v + (v << 15);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashInt32,The following statement contains a magic number: v = v ^ (v >> 12);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashInt32,The following statement contains a magic number: v = v + (v << 2);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashInt32,The following statement contains a magic number: v = v ^ (v >> 4);
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashInt32,The following statement contains a magic number: v = v * 2057;
Magic Number,Dwarrowdelf,Hash,C:\repos\tomba_dwarrowdelf\Common\Lib\Hash.cs,HashInt32,The following statement contains a magic number: v = v ^ (v >> 16);
Magic Number,Dwarrowdelf,Bresenhams,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\Bresenhams.cs,PlotLine,The following statement contains a magic number: int err = dX / 2;
Magic Number,Dwarrowdelf,Bresenhams,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\Bresenhams.cs,PlotLine3,The following statement contains a magic number: int errorXY = deltaX / 2;
Magic Number,Dwarrowdelf,Bresenhams,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\Bresenhams.cs,PlotLine3,The following statement contains a magic number: int errorXZ = deltaX / 2;
Magic Number,Dwarrowdelf,LerpLine,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\LerpLine.cs,PlotLine,The following statement contains a magic number: const int MUL = 1 << 16;
Magic Number,Dwarrowdelf,LerpLine,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\LerpLine.cs,PlotLine3,The following statement contains a magic number: const int MUL = 1 << 16;
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int octant = 0; octant < 8; ++octant)  				Calculate(ref data' 1' octant' 0.0' 1.0' 1);
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursiveStrict,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursiveStrict.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,VisionMap,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\VisionMap.cs,VisionMap,The following statement contains a magic number: m_side = visionRange * 2 + 1;
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_For,The following statement contains a magic number: for (int i = 0; i < (sizeof(ulong) * 8) / 3; ++i)  				answer |= ((x & (1UL << i)) << 2 * i) | ((y & (1UL << i)) << (2 * i + 1)) | ((z & (1UL << i)) << (2 * i + 2));
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_For,The following statement contains a magic number: for (int i = 0; i < (sizeof(ulong) * 8) / 3; ++i)  				answer |= ((x & (1UL << i)) << 2 * i) | ((y & (1UL << i)) << (2 * i + 1)) | ((z & (1UL << i)) << (2 * i + 2));
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_For,The following statement contains a magic number: for (int i = 0; i < (sizeof(ulong) * 8) / 3; ++i)  				answer |= ((x & (1UL << i)) << 2 * i) | ((y & (1UL << i)) << (2 * i + 1)) | ((z & (1UL << i)) << (2 * i + 2));
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_For,The following statement contains a magic number: for (int i = 0; i < (sizeof(ulong) * 8) / 3; ++i)  				answer |= ((x & (1UL << i)) << 2 * i) | ((y & (1UL << i)) << (2 * i + 1)) | ((z & (1UL << i)) << (2 * i + 2));
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_For,The following statement contains a magic number: for (int i = 0; i < (sizeof(ulong) * 8) / 3; ++i)  				answer |= ((x & (1UL << i)) << 2 * i) | ((y & (1UL << i)) << (2 * i + 1)) | ((z & (1UL << i)) << (2 * i + 2));
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_For,The following statement contains a magic number: for (int i = 0; i < (sizeof(ulong) * 8) / 3; ++i)  				answer |= ((x & (1UL << i)) << 2 * i) | ((y & (1UL << i)) << (2 * i + 1)) | ((z & (1UL << i)) << (2 * i + 2));
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The following statement contains a magic number: x = (x | x << 32) & 0x1f00000000ffff;
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The following statement contains a magic number: x = (x | x << 16) & 0x1f0000ff0000ff;
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The following statement contains a magic number: x = (x | x << 8) & 0x100f00f00f00f00f;
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The following statement contains a magic number: x = (x | x << 4) & 0x10c30c30c30c30c3;
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,SplitBy3,The following statement contains a magic number: x = (x | x << 2) & 0x1249249249249249;
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_MagicBits,The following statement contains a magic number: return SplitBy3(x) | SplitBy3(y) << 1 | SplitBy3(z) << 2;
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = morton256_z[(z >> 16) & 0xFF] | // we start by shifting the third byte' since we only look at the first 21 bits  						morton256_y[(y >> 16) & 0xFF] |  						morton256_x[(x >> 16) & 0xFF];
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = morton256_z[(z >> 16) & 0xFF] | // we start by shifting the third byte' since we only look at the first 21 bits  						morton256_y[(y >> 16) & 0xFF] |  						morton256_x[(x >> 16) & 0xFF];
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = morton256_z[(z >> 16) & 0xFF] | // we start by shifting the third byte' since we only look at the first 21 bits  						morton256_y[(y >> 16) & 0xFF] |  						morton256_x[(x >> 16) & 0xFF];
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = answer << 48 | morton256_z[(z >> 8) & 0xFF] | // shifting second byte  						morton256_y[(y >> 8) & 0xFF] |  						morton256_x[(x >> 8) & 0xFF];
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = answer << 48 | morton256_z[(z >> 8) & 0xFF] | // shifting second byte  						morton256_y[(y >> 8) & 0xFF] |  						morton256_x[(x >> 8) & 0xFF];
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = answer << 48 | morton256_z[(z >> 8) & 0xFF] | // shifting second byte  						morton256_y[(y >> 8) & 0xFF] |  						morton256_x[(x >> 8) & 0xFF];
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = answer << 48 | morton256_z[(z >> 8) & 0xFF] | // shifting second byte  						morton256_y[(y >> 8) & 0xFF] |  						morton256_x[(x >> 8) & 0xFF];
Magic Number,Dwarrowdelf,MortonOrder,C:\repos\tomba_dwarrowdelf\Common\Lib\MortonOrder.cs,MortonEncode_LUT,The following statement contains a magic number: answer = answer << 24 |  						morton256_z[(z) & 0xFF] | // first byte  						morton256_y[(y) & 0xFF] |  						morton256_x[(x) & 0xFF];
Magic Number,Dwarrowdelf,MWCRandom,C:\repos\tomba_dwarrowdelf\Common\Lib\MWCRandom.cs,NextUint,The following statement contains a magic number: m_z = 36969 * (m_z & 65535) + (m_z >> 16);
Magic Number,Dwarrowdelf,MWCRandom,C:\repos\tomba_dwarrowdelf\Common\Lib\MWCRandom.cs,NextUint,The following statement contains a magic number: m_z = 36969 * (m_z & 65535) + (m_z >> 16);
Magic Number,Dwarrowdelf,MWCRandom,C:\repos\tomba_dwarrowdelf\Common\Lib\MWCRandom.cs,NextUint,The following statement contains a magic number: m_z = 36969 * (m_z & 65535) + (m_z >> 16);
Magic Number,Dwarrowdelf,MWCRandom,C:\repos\tomba_dwarrowdelf\Common\Lib\MWCRandom.cs,NextUint,The following statement contains a magic number: m_w = 18000 * (m_w & 65535) + (m_w >> 16);
Magic Number,Dwarrowdelf,MWCRandom,C:\repos\tomba_dwarrowdelf\Common\Lib\MWCRandom.cs,NextUint,The following statement contains a magic number: m_w = 18000 * (m_w & 65535) + (m_w >> 16);
Magic Number,Dwarrowdelf,MWCRandom,C:\repos\tomba_dwarrowdelf\Common\Lib\MWCRandom.cs,NextUint,The following statement contains a magic number: m_w = 18000 * (m_w & 65535) + (m_w >> 16);
Magic Number,Dwarrowdelf,MWCRandom,C:\repos\tomba_dwarrowdelf\Common\Lib\MWCRandom.cs,NextUint,The following statement contains a magic number: return (m_z << 16) + m_w;
Magic Number,Dwarrowdelf,PipeConnectionListener,C:\repos\tomba_dwarrowdelf\Common\Game\Net\PipeConnectionListener.cs,NewAccept,The following statement contains a magic number: var stream = new NamedPipeServerStream("Dwarrowdelf.Pipe"' PipeDirection.InOut' 4' PipeTransmissionMode.Byte'  				PipeOptions.Asynchronous);
Magic Number,Dwarrowdelf,TcpConnectionListener,C:\repos\tomba_dwarrowdelf\Common\Game\Net\TcpConnectionListener.cs,StartListening,The following statement contains a magic number: s_listenSocket.Listen(100);
Magic Number,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,GetHashCode,The following statement contains a magic number: return this.X | (this.Y << 8) | (this.Columns << 16) | (this.Rows << 24);
Magic Number,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,GetHashCode,The following statement contains a magic number: return this.X | (this.Y << 8) | (this.Columns << 16) | (this.Rows << 24);
Magic Number,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,GetHashCode,The following statement contains a magic number: return this.X | (this.Y << 8) | (this.Columns << 16) | (this.Rows << 24);
Magic Number,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,Parse,The following statement contains a magic number: return new IntGrid2Z(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)' Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info));
Magic Number,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,Parse,The following statement contains a magic number: return new IntGrid2Z(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)' Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info));
Magic Number,Dwarrowdelf,IntGrid2Z,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2Z.cs,Parse,The following statement contains a magic number: return new IntGrid2Z(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)' Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info));
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int octant = 0; octant < 8; ++octant)  				Calculate(ref data' 1' octant' 0.0' 1.0' 1);
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: switch (octant)  			{  				case 0:  				case 7:  					maxX = Math.Min(data.VisionRange' data.MapSize.Width - data.ViewerLocation.X - 1);  					break;    				case 1:  				case 2:  					maxX = Math.Min(data.VisionRange' data.MapSize.Height - data.ViewerLocation.Y - 1);  					break;    				case 3:  				case 4:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.X);  					break;    				case 5:  				case 6:  					maxX = Math.Min(data.VisionRange' data.ViewerLocation.Y);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,ShadowCastRecursive,C:\repos\tomba_dwarrowdelf\Common\Lib\LOS\ShadowCastRecursive.cs,Calculate,The following statement contains a magic number: for (int x = startColumn; x <= maxX; ++x)  			{  				bool currentlyBlocked = false;  				double newStart = 0;    				int lowY = MyMath.RoundTowards(startSlope * x);  				int highY = MyMath.RoundAway(endSlope * x);    				switch (octant)  				{  					case 0:  					case 3:  						highY = Math.Min(highY' data.MapSize.Height - data.ViewerLocation.Y - 1);  						break;    					case 1:  					case 6:  						highY = Math.Min(highY' data.MapSize.Width - data.ViewerLocation.X - 1);  						break;    					case 7:  					case 4:  						highY = Math.Min(highY' data.ViewerLocation.Y);  						break;    					case 2:  					case 5:  						highY = Math.Min(highY' data.ViewerLocation.X);  						break;    					default:  						throw new Exception();  				}    				//Debug.Print("{0}{1}: col {2} lowY {3}' highY {4}"' new string(' '' (id - 1) * 4)' id' x' lowY' highY);    				for (int y = lowY; y <= highY; ++y)  				{  					IntVector2 translatedLocation = OctantTranslate(new IntVector2(x' y)' octant);  					IntVector2 mapLocation = translatedLocation.Offset(data.ViewerLocation.X' data.ViewerLocation.Y);    					Debug.Assert(data.MapSize.Contains(mapLocation));    					if (x * x + y * y > data.VisionRangeSquared)  					{  						data.VisibilityMap[translatedLocation] = false;  						continue;  					}    					double lowerSlope = (y - 0.5) / (x + 0.5);  					double upperSlope = (y + 0.5) / (x - 0.5);    #if PERMISSIVE  					if (upperSlope < startSlope || lowerSlope > endSlope)  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}    					bool tileBlocked = data.BlockerDelegate(mapLocation);  #elif MEDIUM_STRICT  					double centerSlope = (double)y / x;    					bool tileBlocked = data.BlockerDelegate(mapLocation);    					if (!tileBlocked && (centerSlope < startSlope || centerSlope > endSlope))  					{  						//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} ouside arc"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);  						continue;  					}  #else  #error no mode defined  #endif  					//Debug.Print("{0}{1}: {2}'{3}   center {4:F2} visible"' new string(' '' (id - 1) * 4)' id' x' y' centerSlope);    					data.VisibilityMap[translatedLocation] = true;    					if (currentlyBlocked)  					{  						if (tileBlocked)  						{  							newStart = upperSlope;  							continue;  						}  						else  						{  							currentlyBlocked = false;  							startSlope = newStart;  							//Debug.Print("{0}{1}: {2}'{3}  new startSlope {4:F2}"' new string(' '' (id - 1) * 4)' id' x' y' startSlope);  						}  					}  					else  					{  						if (tileBlocked)  						{  							currentlyBlocked = true;  							newStart = upperSlope;    							Calculate(ref data' x + 1' octant' startSlope' lowerSlope' id + 1);  						}  					}  				}    				if (currentlyBlocked)  					break;  			}
Magic Number,Dwarrowdelf,BinaryHeap<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\OpenList.cs,Parent,The following statement contains a magic number: return idx / 2;
Magic Number,Dwarrowdelf,BinaryHeap<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\OpenList.cs,Left,The following statement contains a magic number: return idx * 2;
Magic Number,Dwarrowdelf,BinaryHeap<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\OpenList.cs,Right,The following statement contains a magic number: return idx * 2 + 1;
Magic Number,Dwarrowdelf,BinaryHeap<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\OpenList.cs,Add,The following statement contains a magic number: if (m_count + 1 == m_openList.Length)  			{  				T[] newArray = new T[m_openList.Length * 2];  				m_openList.CopyTo(newArray' 0);  				m_openList = newArray;  			}
Magic Number,Dwarrowdelf,BinaryHeap<T>,C:\repos\tomba_dwarrowdelf\Common\Lib\AStar\OpenList.cs,HeapifyDown,The following statement contains a magic number: while (i * 2 <= m_count)  			{  				int lowest;  				int li = Left(i);  				int ri = Right(i);    				if (ri <= m_count && m_openList[ri].F < m_openList[li].F)  					lowest = ri;  				else  					lowest = li;    				if (m_openList[lowest].F < n.F)  					m_openList[i] = m_openList[lowest];  				else  					break;    				i = lowest;  			}
Magic Number,Dwarrowdelf,IntSize3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntSize3.cs,Parse,The following statement contains a magic number: return new IntSize3(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info));
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,IntVector3,The following statement contains a magic number: m_value =  				((long)(x & 0xffff) << 0) |  				((long)(y & 0xffff) << 16) |  				((long)(z & 0xffff) << 48);
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,IntVector3,The following statement contains a magic number: m_value =  				((long)(x & 0xffff) << 0) |  				((long)(y & 0xffff) << 16) |  				((long)(z & 0xffff) << 48);
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,Parse,The following statement contains a magic number: return new IntVector3(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info));
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastCos,The following statement contains a magic number: rot %= 8;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastCos,The following statement contains a magic number: if (rot < 0)  				rot += 8;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastCos,The following statement contains a magic number: if (rot == 0 || rot == 1 || rot == 7)  				return 1;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastCos,The following statement contains a magic number: if (rot == 2 || rot == 6)  				return 0;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastCos,The following statement contains a magic number: if (rot == 2 || rot == 6)  				return 0;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastSin,The following statement contains a magic number: rot %= 8;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastSin,The following statement contains a magic number: if (rot < 0)  				rot += 8;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastSin,The following statement contains a magic number: if (rot == 1 || rot == 2 || rot == 3)  				return 1;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastSin,The following statement contains a magic number: if (rot == 1 || rot == 2 || rot == 3)  				return 1;
Magic Number,Dwarrowdelf,IntVector3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector3.cs,FastSin,The following statement contains a magic number: if (rot == 0 || rot == 4)  				return 0;
Magic Number,Dwarrowdelf,GameColorRGB,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\GameColor.cs,GetHashCode,The following statement contains a magic number: return (m_r << 16) | (m_g << 8) | m_b;
Magic Number,Dwarrowdelf,GameColorRGB,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\GameColor.cs,GetHashCode,The following statement contains a magic number: return (m_r << 16) | (m_g << 8) | m_b;
Magic Number,Dwarrowdelf,GameColorRGB,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\GameColor.cs,ToRGBA,The following statement contains a magic number: return (255 << 24) | (m_b << 16) | (m_g << 8) | m_r;
Magic Number,Dwarrowdelf,GameColorRGB,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\GameColor.cs,ToRGBA,The following statement contains a magic number: return (255 << 24) | (m_b << 16) | (m_g << 8) | m_r;
Magic Number,Dwarrowdelf,GameColorRGB,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\GameColor.cs,ToRGBA,The following statement contains a magic number: return (255 << 24) | (m_b << 16) | (m_g << 8) | m_r;
Magic Number,Dwarrowdelf,GameColorRGB,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\GameColor.cs,ToRGBA,The following statement contains a magic number: return (255 << 24) | (m_b << 16) | (m_g << 8) | m_r;
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,DivRoundNearest,The following statement contains a magic number: return m > 0 ?  				(m + n / 2) / n :  				(m - n / 2) / n;
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,DivRoundNearest,The following statement contains a magic number: return m > 0 ?  				(m + n / 2) / n :  				(m - n / 2) / n;
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,Round,The following statement contains a magic number: return val >= 0 ? (int)(val + 0.5) : (int)(val - 0.5);
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,Round,The following statement contains a magic number: return val >= 0 ? (int)(val + 0.5) : (int)(val - 0.5);
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,QuadraticBezier,The following statement contains a magic number: var b = 2 * (1 - t) * t * x1;
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,CubicBezier,The following statement contains a magic number: var b = 3 * (1 - t) * (1 - t) * t * x1;
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,CubicBezier,The following statement contains a magic number: var c = 3 * (1 - t) * t * t * x2;
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,SmoothStep,The following statement contains a magic number: return x * x * (3 - 2 * x);
Magic Number,Dwarrowdelf,MyMath,C:\repos\tomba_dwarrowdelf\Common\Lib\MyMath.cs,SmoothStep,The following statement contains a magic number: return x * x * (3 - 2 * x);
Magic Number,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,GetHashCode,The following statement contains a magic number: return ((this.Columns ^ this.Rows ^ this.Depth) << 16) | (this.X ^ this.Y ^ this.Z);
Magic Number,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,Parse,The following statement contains a magic number: return new IntGrid3(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)'  				Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info)' Convert.ToInt32(arr[5]' info));
Magic Number,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,Parse,The following statement contains a magic number: return new IntGrid3(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)'  				Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info)' Convert.ToInt32(arr[5]' info));
Magic Number,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,Parse,The following statement contains a magic number: return new IntGrid3(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)'  				Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info)' Convert.ToInt32(arr[5]' info));
Magic Number,Dwarrowdelf,IntGrid3,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid3.cs,Parse,The following statement contains a magic number: return new IntGrid3(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)'  				Convert.ToInt32(arr[3]' info)' Convert.ToInt32(arr[4]' info)' Convert.ToInt32(arr[5]' info));
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToDirectionSet,The following statement contains a magic number: int bit = z * 9 + y * 3 + x;
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToDirectionSet,The following statement contains a magic number: int bit = z * 9 + y * 3 + x;
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToDirections,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9 - 1;  				int y = (i % 9) / 3 - 1;  				int x = (i % 3) - 1;    				yield return ComponentsToDirection(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToDirections,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9 - 1;  				int y = (i % 9) / 3 - 1;  				int x = (i % 3) - 1;    				yield return ComponentsToDirection(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToDirections,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9 - 1;  				int y = (i % 9) / 3 - 1;  				int x = (i % 3) - 1;    				yield return ComponentsToDirection(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToDirections,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9 - 1;  				int y = (i % 9) / 3 - 1;  				int x = (i % 3) - 1;    				yield return ComponentsToDirection(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToDirections,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9 - 1;  				int y = (i % 9) / 3 - 1;  				int x = (i % 3) - 1;    				yield return ComponentsToDirection(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToVectors,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9;  				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;  				z = z - 1;    				yield return new IntVector3(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToVectors,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9;  				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;  				z = z - 1;    				yield return new IntVector3(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToVectors,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9;  				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;  				z = z - 1;    				yield return new IntVector3(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToVectors,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9;  				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;  				z = z - 1;    				yield return new IntVector3(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToVectors,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int z = i / 9;  				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;  				z = z - 1;    				yield return new IntVector3(x' y' z);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToSurroundingPoints,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;    				yield return new IntVector2(p.X + x' p.Y + y);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToSurroundingPoints,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;    				yield return new IntVector2(p.X + x' p.Y + y);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToSurroundingPoints,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;    				yield return new IntVector2(p.X + x' p.Y + y);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,ToSurroundingPoints,The following statement contains a magic number: for (int i = 0; i < 27; ++i)  			{  				if ((ds & (1 << i)) == 0)  					continue;    				int y = (i % 9) / 3;  				int x = (i % 3);    				x = x - 1;  				y = y - 1;    				yield return new IntVector2(p.X + x' p.Y + y);  			}
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,IsValid,The following statement contains a magic number: return x != 3 && y != 3 && z != 3;
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,IsValid,The following statement contains a magic number: return x != 3 && y != 3 && z != 3;
Magic Number,Dwarrowdelf,DirectionExtensions,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\Direction.cs,IsValid,The following statement contains a magic number: return x != 3 && y != 3 && z != 3;
Magic Number,Dwarrowdelf,IntGrid2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2.cs,GetHashCode,The following statement contains a magic number: return this.X | (this.Y << 8) | (this.Columns << 16) | (this.Rows << 24);
Magic Number,Dwarrowdelf,IntGrid2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2.cs,GetHashCode,The following statement contains a magic number: return this.X | (this.Y << 8) | (this.Columns << 16) | (this.Rows << 24);
Magic Number,Dwarrowdelf,IntGrid2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2.cs,GetHashCode,The following statement contains a magic number: return this.X | (this.Y << 8) | (this.Columns << 16) | (this.Rows << 24);
Magic Number,Dwarrowdelf,IntGrid2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2.cs,Parse,The following statement contains a magic number: return new IntGrid2(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)' Convert.ToInt32(arr[3]' info));
Magic Number,Dwarrowdelf,IntGrid2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntGrid2.cs,Parse,The following statement contains a magic number: return new IntGrid2(Convert.ToInt32(arr[0]' info)' Convert.ToInt32(arr[1]' info)' Convert.ToInt32(arr[2]' info)' Convert.ToInt32(arr[3]' info));
Magic Number,Dwarrowdelf,ObjectID,C:\repos\tomba_dwarrowdelf\Common\Game\ObjectID.cs,ObjectID,The following statement contains a magic number: if ((value & ~((1 << 24) - 1)) != 0)  				throw new Exception();
Magic Number,Dwarrowdelf,ObjectID,C:\repos\tomba_dwarrowdelf\Common\Game\ObjectID.cs,ObjectID,The following statement contains a magic number: m_value = ((uint)objectType << 24) | value;
Magic Number,Dwarrowdelf,ObjectID,C:\repos\tomba_dwarrowdelf\Common\Game\ObjectID.cs,TryParse,The following statement contains a magic number: if (str.Length < 2)  				return false;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,IntVector2,The following statement contains a magic number: m_value =  				((x & 0xffff) << 0) |  				((y & 0xffff) << 16);
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,SquareSpiral,The following statement contains a magic number: for (int loop = 0; loop < size * 2 - 1; ++loop)  			{  				for (int i = 0; i < loop / 2 + 1; ++i)  				{  					yield return p;  					p += v;  				}    				v = v.FastRotate(2);  			}
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,SquareSpiral,The following statement contains a magic number: for (int loop = 0; loop < size * 2 - 1; ++loop)  			{  				for (int i = 0; i < loop / 2 + 1; ++i)  				{  					yield return p;  					p += v;  				}    				v = v.FastRotate(2);  			}
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,SquareSpiral,The following statement contains a magic number: for (int loop = 0; loop < size * 2 - 1; ++loop)  			{  				for (int i = 0; i < loop / 2 + 1; ++i)  				{  					yield return p;  					p += v;  				}    				v = v.FastRotate(2);  			}
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,DiagonalSquareSpiral,The following statement contains a magic number: for (int loop = 1; loop < size; ++loop)  			{  				p += new IntVector2(1' 0);    				for (int t = 0; t < 4; ++t)  				{  					for (int i = 0; i < loop; ++i)  					{  						p += v;  						yield return p;  					}    					v = v.FastRotate(2);  				}  			}
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,DiagonalSquareSpiral,The following statement contains a magic number: for (int loop = 1; loop < size; ++loop)  			{  				p += new IntVector2(1' 0);    				for (int t = 0; t < 4; ++t)  				{  					for (int i = 0; i < loop; ++i)  					{  						p += v;  						yield return p;  					}    					v = v.FastRotate(2);  				}  			}
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,Rotate,The following statement contains a magic number: double rad = Math.PI * angle / 180.0;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,GetAllXYDirections,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  			{  				v = v.FastRotate(1);  				yield return v;  			}
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastCos,The following statement contains a magic number: rot %= 8;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastCos,The following statement contains a magic number: if (rot < 0)  				rot += 8;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastCos,The following statement contains a magic number: if (rot == 0 || rot == 1 || rot == 7)  				return 1;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastCos,The following statement contains a magic number: if (rot == 2 || rot == 6)  				return 0;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastCos,The following statement contains a magic number: if (rot == 2 || rot == 6)  				return 0;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastSin,The following statement contains a magic number: rot %= 8;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastSin,The following statement contains a magic number: if (rot < 0)  				rot += 8;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastSin,The following statement contains a magic number: if (rot == 1 || rot == 2 || rot == 3)  				return 1;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastSin,The following statement contains a magic number: if (rot == 1 || rot == 2 || rot == 3)  				return 1;
Magic Number,Dwarrowdelf,IntVector2,C:\repos\tomba_dwarrowdelf\Common\Lib\DataTypes\IntVector2.cs,FastSin,The following statement contains a magic number: if (rot == 0 || rot == 4)  				return 0;
Magic Number,Dwarrowdelf.TerrainGen,ArtificialGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\ArtificialGen.cs,CreateBallMap,The following statement contains a magic number: int r = side / 2 - 1;
Magic Number,Dwarrowdelf.TerrainGen,ArtificialGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\ArtificialGen.cs,CreateBallMap,The following statement contains a magic number: int ir = innerSide / 2 - 1;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: double xk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: double xk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: double yk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: double yk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: int soilLimit = size.Depth * 4 / 5;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: int soilLimit = size.Depth * 4 / 5;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: int grassLimit = terrain.Depth * 4 / 5;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateNoiseTerrain,The following statement contains a magic number: int grassLimit = terrain.Depth * 4 / 5;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,FillFromNoiseMap,The following statement contains a magic number: Parallel.For(0' noiseMap.Data.Length' i =>  			{  				var v = noiseMap.Data[i];   // [-1 .. 1]    				v -= min;  				v /= (max - min);       // [0 .. 1]    				v *= terrainData.Depth * 8 / 10;  				v += terrainData.Depth * 2 / 10;    				noiseMap.Data[i] = v;  			});
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,FillFromNoiseMap,The following statement contains a magic number: Parallel.For(0' noiseMap.Data.Length' i =>  			{  				var v = noiseMap.Data[i];   // [-1 .. 1]    				v -= min;  				v /= (max - min);       // [0 .. 1]    				v *= terrainData.Depth * 8 / 10;  				v += terrainData.Depth * 2 / 10;    				noiseMap.Data[i] = v;  			});
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,FillFromNoiseMap,The following statement contains a magic number: Parallel.For(0' noiseMap.Data.Length' i =>  			{  				var v = noiseMap.Data[i];   // [-1 .. 1]    				v -= min;  				v /= (max - min);       // [0 .. 1]    				v *= terrainData.Depth * 8 / 10;  				v += terrainData.Depth * 2 / 10;    				noiseMap.Data[i] = v;  			});
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,FillFromNoiseMap,The following statement contains a magic number: Parallel.For(0' noiseMap.Data.Length' i =>  			{  				var v = noiseMap.Data[i];   // [-1 .. 1]    				v -= min;  				v /= (max - min);       // [0 .. 1]    				v *= terrainData.Depth * 8 / 10;  				v += terrainData.Depth * 2 / 10;    				noiseMap.Data[i] = v;  			});
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoiseMap,The following statement contains a magic number: double w = size.Width / 256.0;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoiseMap,The following statement contains a magic number: double h = size.Height / 256.0;
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var baseFlatTerrain = new Billow()  			{  				Frequency = 2'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var flatTerrain = new ScaleBias()  			{  				Source0 = baseFlatTerrain'  				Scale = 0.125'  				Bias = -0.75'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var flatTerrain = new ScaleBias()  			{  				Source0 = baseFlatTerrain'  				Scale = 0.125'  				Bias = -0.75'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var terrainType = new Perlin()  			{  				Frequency = 0.5'  				Persistence = 0.25'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var terrainType = new Perlin()  			{  				Frequency = 0.5'  				Persistence = 0.25'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var terrainSelector = new Select()  			{  				Source0 = flatTerrain'  				Source1 = mountainTerrain'  				Control = terrainType'  				LowerBound = 0'  				UpperBound = 1000'  				EdgeFalloff = 0.125'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var terrainSelector = new Select()  			{  				Source0 = flatTerrain'  				Source1 = mountainTerrain'  				Control = terrainType'  				LowerBound = 0'  				UpperBound = 1000'  				EdgeFalloff = 0.125'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var finalTerrain = new Turbulence()  			{  				Source0 = terrainSelector'  				Frequency = 4'  				Power = 0.125'  			};
Magic Number,Dwarrowdelf.TerrainGen,NoiseTerrainGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\NoiseTerrainGen.cs,CreateTerrainNoise,The following statement contains a magic number: var finalTerrain = new Turbulence()  			{  				Source0 = terrainSelector'  				Frequency = 4'  				Power = 0.125'  			};
Magic Number,Dwarrowdelf.TerrainGen,RiverGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,FindStartLoc,The following statement contains a magic number: for (int y = yo - 1; y >= 0; --y)  			{  				int z = m_terrain.GetSurfaceLevel(MapCoord(y' edge));  				if (z < zu)  				{  					zu = z;  					yu = y;  				}    				if (z - 2 > zu)  					break;  			}
Magic Number,Dwarrowdelf.TerrainGen,RiverGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,FindStartLoc,The following statement contains a magic number: for (int y = yo + 1; y < side; ++y)  			{  				int z = m_terrain.GetSurfaceLevel(MapCoord(y' edge));  				if (z < zd)  				{  					zd = z;  					yd = y;  				}    				if (z - 2 > zd)  					break;  			}
Magic Number,Dwarrowdelf.TerrainGen,RiverGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,CreateRiverPath,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  			{  				SideEdge edge = (SideEdge)((i + offset) % 4);    				var startLoc = FindStartLoc(m_random' edge);    				var target = new MyTarget(m_terrain' startLoc' edge);  				int maxNodeCount = 500000; // XXX this should reflect the map size  				var res = AStar.Find(new IntVector3[] { startLoc }' target' maxNodeCount);    				if (res.Status != AStarStatus.Found)  					continue;    				var riverPath = res.GetPathLocationsReverse().Select(p => p.ToIntVector2()).ToArray();    				if (riverPath.Length < 100)  				{  					Trace.TraceInformation("retry' too short");  					continue;  				}    				int tot = riverPath.Aggregate(0' (a' p) =>  					a + MyMath.Min(p.X' p.Y' m_terrain.Width - p.X - 1' m_terrain.Height - p.Y - 1));    				int avg = tot / riverPath.Length;    				if (avg < 20)  				{  					Trace.TraceInformation("too close to edge' avg {0}"' avg);  					continue;  				}    				m_riverPath = riverPath;    				return true;  			}
Magic Number,Dwarrowdelf.TerrainGen,RiverGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,CreateRiverPath,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  			{  				SideEdge edge = (SideEdge)((i + offset) % 4);    				var startLoc = FindStartLoc(m_random' edge);    				var target = new MyTarget(m_terrain' startLoc' edge);  				int maxNodeCount = 500000; // XXX this should reflect the map size  				var res = AStar.Find(new IntVector3[] { startLoc }' target' maxNodeCount);    				if (res.Status != AStarStatus.Found)  					continue;    				var riverPath = res.GetPathLocationsReverse().Select(p => p.ToIntVector2()).ToArray();    				if (riverPath.Length < 100)  				{  					Trace.TraceInformation("retry' too short");  					continue;  				}    				int tot = riverPath.Aggregate(0' (a' p) =>  					a + MyMath.Min(p.X' p.Y' m_terrain.Width - p.X - 1' m_terrain.Height - p.Y - 1));    				int avg = tot / riverPath.Length;    				if (avg < 20)  				{  					Trace.TraceInformation("too close to edge' avg {0}"' avg);  					continue;  				}    				m_riverPath = riverPath;    				return true;  			}
Magic Number,Dwarrowdelf.TerrainGen,RiverGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,CreateRiverPath,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  			{  				SideEdge edge = (SideEdge)((i + offset) % 4);    				var startLoc = FindStartLoc(m_random' edge);    				var target = new MyTarget(m_terrain' startLoc' edge);  				int maxNodeCount = 500000; // XXX this should reflect the map size  				var res = AStar.Find(new IntVector3[] { startLoc }' target' maxNodeCount);    				if (res.Status != AStarStatus.Found)  					continue;    				var riverPath = res.GetPathLocationsReverse().Select(p => p.ToIntVector2()).ToArray();    				if (riverPath.Length < 100)  				{  					Trace.TraceInformation("retry' too short");  					continue;  				}    				int tot = riverPath.Aggregate(0' (a' p) =>  					a + MyMath.Min(p.X' p.Y' m_terrain.Width - p.X - 1' m_terrain.Height - p.Y - 1));    				int avg = tot / riverPath.Length;    				if (avg < 20)  				{  					Trace.TraceInformation("too close to edge' avg {0}"' avg);  					continue;  				}    				m_riverPath = riverPath;    				return true;  			}
Magic Number,Dwarrowdelf.TerrainGen,RiverGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,CreateRiverPath,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  			{  				SideEdge edge = (SideEdge)((i + offset) % 4);    				var startLoc = FindStartLoc(m_random' edge);    				var target = new MyTarget(m_terrain' startLoc' edge);  				int maxNodeCount = 500000; // XXX this should reflect the map size  				var res = AStar.Find(new IntVector3[] { startLoc }' target' maxNodeCount);    				if (res.Status != AStarStatus.Found)  					continue;    				var riverPath = res.GetPathLocationsReverse().Select(p => p.ToIntVector2()).ToArray();    				if (riverPath.Length < 100)  				{  					Trace.TraceInformation("retry' too short");  					continue;  				}    				int tot = riverPath.Aggregate(0' (a' p) =>  					a + MyMath.Min(p.X' p.Y' m_terrain.Width - p.X - 1' m_terrain.Height - p.Y - 1));    				int avg = tot / riverPath.Length;    				if (avg < 20)  				{  					Trace.TraceInformation("too close to edge' avg {0}"' avg);  					continue;  				}    				m_riverPath = riverPath;    				return true;  			}
Magic Number,Dwarrowdelf.TerrainGen,RiverGen,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,CreateRiverPath,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  			{  				SideEdge edge = (SideEdge)((i + offset) % 4);    				var startLoc = FindStartLoc(m_random' edge);    				var target = new MyTarget(m_terrain' startLoc' edge);  				int maxNodeCount = 500000; // XXX this should reflect the map size  				var res = AStar.Find(new IntVector3[] { startLoc }' target' maxNodeCount);    				if (res.Status != AStarStatus.Found)  					continue;    				var riverPath = res.GetPathLocationsReverse().Select(p => p.ToIntVector2()).ToArray();    				if (riverPath.Length < 100)  				{  					Trace.TraceInformation("retry' too short");  					continue;  				}    				int tot = riverPath.Aggregate(0' (a' p) =>  					a + MyMath.Min(p.X' p.Y' m_terrain.Width - p.X - 1' m_terrain.Height - p.Y - 1));    				int avg = tot / riverPath.Length;    				if (avg < 20)  				{  					Trace.TraceInformation("too close to edge' avg {0}"' avg);  					continue;  				}    				m_riverPath = riverPath;    				return true;  			}
Magic Number,Dwarrowdelf.TerrainGen,MyTarget,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,GetIsTarget,The following statement contains a magic number: return  					(m_sourceSide == SideEdge.Left && p.X > m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Top && p.Y > m_terrain.Height / 2) ||  					(m_sourceSide == SideEdge.Right && p.X < m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Bottom && p.Y < m_terrain.Height / 2);
Magic Number,Dwarrowdelf.TerrainGen,MyTarget,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,GetIsTarget,The following statement contains a magic number: return  					(m_sourceSide == SideEdge.Left && p.X > m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Top && p.Y > m_terrain.Height / 2) ||  					(m_sourceSide == SideEdge.Right && p.X < m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Bottom && p.Y < m_terrain.Height / 2);
Magic Number,Dwarrowdelf.TerrainGen,MyTarget,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,GetIsTarget,The following statement contains a magic number: return  					(m_sourceSide == SideEdge.Left && p.X > m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Top && p.Y > m_terrain.Height / 2) ||  					(m_sourceSide == SideEdge.Right && p.X < m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Bottom && p.Y < m_terrain.Height / 2);
Magic Number,Dwarrowdelf.TerrainGen,MyTarget,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,GetIsTarget,The following statement contains a magic number: return  					(m_sourceSide == SideEdge.Left && p.X > m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Top && p.Y > m_terrain.Height / 2) ||  					(m_sourceSide == SideEdge.Right && p.X < m_terrain.Width / 2) ||  					(m_sourceSide == SideEdge.Bottom && p.Y < m_terrain.Height / 2);
Magic Number,Dwarrowdelf.TerrainGen,MyTarget,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,GetHeuristic,The following statement contains a magic number: return (ushort)(p.Z * 10 + r.Next(4));
Magic Number,Dwarrowdelf.TerrainGen,MyTarget,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\RiverGen.cs,GetHeuristic,The following statement contains a magic number: return (ushort)(p.Z * 10 + r.Next(4));
Magic Number,Dwarrowdelf.TerrainGen,Clamper,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\Clamper.cs,Clamp,The following statement contains a magic number: grid.ForEach(v =>  			{  				if (v < average)  				{  					double d = average - v;  					v = average - Math.Pow(d' 1.0 / 20);  				}    				return v;  			});
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateStairs,The following statement contains a magic number: for (int z = m_size.Depth - 1; z > 1; z -= 2)  			{  				var center = new IntVector2(m_random.Next(m_size.Width)' m_random.Next(m_size.Height));    				foreach (var p in IntVector2.SquareSpiral(center' m_size.Width))  				{  					if (m_size.Plane.Contains(p) == false)  						continue;    					var p1 = new IntVector3(p' z);  					var td1 = GetTileData(p1);    					if (td1.IsClear == false)  						continue;    					var p2 = new IntVector3(p' z - 2);  					var td2 = GetTileData(p2);    					if (td2.IsClear == false)  						continue;    					SetTileData(p1' TileData.EmptyTileData);    					td2.ID = TileID.Stairs;  					td2.MaterialID = MaterialID.Granite;    					SetTileData(p1.Down' td2);  					SetTileData(p2' td2);    					break;  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateStairs,The following statement contains a magic number: for (int z = m_size.Depth - 1; z > 1; z -= 2)  			{  				var center = new IntVector2(m_random.Next(m_size.Width)' m_random.Next(m_size.Height));    				foreach (var p in IntVector2.SquareSpiral(center' m_size.Width))  				{  					if (m_size.Plane.Contains(p) == false)  						continue;    					var p1 = new IntVector3(p' z);  					var td1 = GetTileData(p1);    					if (td1.IsClear == false)  						continue;    					var p2 = new IntVector3(p' z - 2);  					var td2 = GetTileData(p2);    					if (td2.IsClear == false)  						continue;    					SetTileData(p1' TileData.EmptyTileData);    					td2.ID = TileID.Stairs;  					td2.MaterialID = MaterialID.Granite;    					SetTileData(p1.Down' td2);  					SetTileData(p2' td2);    					break;  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateDungeon,The following statement contains a magic number: for (int z = m_size.Depth - 3; z > 0; z -= 2)  				CreateDungeonLevel(bsp' z);
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateDungeon,The following statement contains a magic number: for (int z = m_size.Depth - 3; z > 0; z -= 2)  				CreateDungeonLevel(bsp' z);
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateDungeonLevel,The following statement contains a magic number: for (int l = 0; l < leafs; ++l)  			{  				int i = bsp.Length - l - 1;    				var n = bsp[i];  				var grid = n.Grid;    				var xm = GetRandomDouble(0.2' 0.5);  				var ym = GetRandomDouble(0.2' 0.5);    				int columns = (int)((grid.Columns - 1) * xm);  				int rows = (int)((grid.Rows - 1) * ym);  				int x = m_random.Next(grid.Columns - columns) + grid.X;  				int y = m_random.Next(grid.Rows - rows) + grid.Y;    				n.Grid = new IntGrid2(x' y' columns' rows);    				bsp[i] = n;    				rooms.Add(n.Grid);  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateDungeonLevel,The following statement contains a magic number: for (int l = 0; l < leafs; ++l)  			{  				int i = bsp.Length - l - 1;    				var n = bsp[i];  				var grid = n.Grid;    				var xm = GetRandomDouble(0.2' 0.5);  				var ym = GetRandomDouble(0.2' 0.5);    				int columns = (int)((grid.Columns - 1) * xm);  				int rows = (int)((grid.Rows - 1) * ym);  				int x = m_random.Next(grid.Columns - columns) + grid.X;  				int y = m_random.Next(grid.Rows - rows) + grid.Y;    				n.Grid = new IntGrid2(x' y' columns' rows);    				bsp[i] = n;    				rooms.Add(n.Grid);  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateDungeonLevel,The following statement contains a magic number: for (int l = 0; l < leafs; ++l)  			{  				int i = bsp.Length - l - 1;    				var n = bsp[i];  				var grid = n.Grid;    				var xm = GetRandomDouble(0.2' 0.5);  				var ym = GetRandomDouble(0.2' 0.5);    				int columns = (int)((grid.Columns - 1) * xm);  				int rows = (int)((grid.Rows - 1) * ym);  				int x = m_random.Next(grid.Columns - columns) + grid.X;  				int y = m_random.Next(grid.Rows - rows) + grid.Y;    				n.Grid = new IntGrid2(x' y' columns' rows);    				bsp[i] = n;    				rooms.Add(n.Grid);  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateDungeonLevel,The following statement contains a magic number: for (int l = 0; l < leafs; ++l)  			{  				int i = bsp.Length - l - 1;    				var n = bsp[i];  				var grid = n.Grid;    				var xm = GetRandomDouble(0.2' 0.5);  				var ym = GetRandomDouble(0.2' 0.5);    				int columns = (int)((grid.Columns - 1) * xm);  				int rows = (int)((grid.Rows - 1) * ym);  				int x = m_random.Next(grid.Columns - columns) + grid.X;  				int y = m_random.Next(grid.Rows - rows) + grid.Y;    				n.Grid = new IntGrid2(x' y' columns' rows);    				bsp[i] = n;    				rooms.Add(n.Grid);  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateCorridor,The following statement contains a magic number: if (horiz)  			{  				int yinc = from.Y < to.Y ? 1 : -1;    				int middle = from.Y + (to.Y - from.Y) / 2;    				for (int y = from.Y; y != middle; y += yinc)  					SetTileData(new IntVector3(from.X' y' z)' td);    				int x1 = Math.Min(from.X' to.X);  				int x2 = Math.Max(from.X' to.X);    				for (int x = x1; x <= x2; ++x)  					SetTileData(new IntVector3(x' middle' z)' td);    				for (int y = middle; y != to.Y; y += yinc)  					SetTileData(new IntVector3(to.X' y' z)' td);  			}  			else  			{  				int xinc = from.X < to.X ? 1 : -1;    				int middle = from.X + (to.X - from.X) / 2;    				for (int x = from.X; x != middle; x += xinc)  					SetTileData(new IntVector3(x' from.Y' z)' td);    				int y1 = Math.Min(from.Y' to.Y);  				int y2 = Math.Max(from.Y' to.Y);    				for (int y = y1; y <= y2; ++y)  					SetTileData(new IntVector3(middle' y' z)' td);    				for (int x = middle; x != to.X; x += xinc)  					SetTileData(new IntVector3(x' to.Y' z)' td);  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateCorridor,The following statement contains a magic number: if (horiz)  			{  				int yinc = from.Y < to.Y ? 1 : -1;    				int middle = from.Y + (to.Y - from.Y) / 2;    				for (int y = from.Y; y != middle; y += yinc)  					SetTileData(new IntVector3(from.X' y' z)' td);    				int x1 = Math.Min(from.X' to.X);  				int x2 = Math.Max(from.X' to.X);    				for (int x = x1; x <= x2; ++x)  					SetTileData(new IntVector3(x' middle' z)' td);    				for (int y = middle; y != to.Y; y += yinc)  					SetTileData(new IntVector3(to.X' y' z)' td);  			}  			else  			{  				int xinc = from.X < to.X ? 1 : -1;    				int middle = from.X + (to.X - from.X) / 2;    				for (int x = from.X; x != middle; x += xinc)  					SetTileData(new IntVector3(x' from.Y' z)' td);    				int y1 = Math.Min(from.Y' to.Y);  				int y2 = Math.Max(from.Y' to.Y);    				for (int y = y1; y <= y2; ++y)  					SetTileData(new IntVector3(middle' y' z)' td);    				for (int x = middle; x != to.X; x += xinc)  					SetTileData(new IntVector3(x' to.Y' z)' td);  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateNodes,The following statement contains a magic number: if (grid.Columns <= 4 && grid.Rows <= 4)  			{  				Debugger.Break();  				throw new Exception();  			}  			else if (grid.Columns <= 4)  			{  				horiz = true;  			}  			else if (grid.Rows <= 4)  			{  				horiz = false;  			}  			else  			{  				horiz = grid.Columns < grid.Rows;  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateNodes,The following statement contains a magic number: if (grid.Columns <= 4 && grid.Rows <= 4)  			{  				Debugger.Break();  				throw new Exception();  			}  			else if (grid.Columns <= 4)  			{  				horiz = true;  			}  			else if (grid.Rows <= 4)  			{  				horiz = false;  			}  			else  			{  				horiz = grid.Columns < grid.Rows;  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateNodes,The following statement contains a magic number: if (grid.Columns <= 4 && grid.Rows <= 4)  			{  				Debugger.Break();  				throw new Exception();  			}  			else if (grid.Columns <= 4)  			{  				horiz = true;  			}  			else if (grid.Rows <= 4)  			{  				horiz = false;  			}  			else  			{  				horiz = grid.Columns < grid.Rows;  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateNodes,The following statement contains a magic number: if (grid.Columns <= 4 && grid.Rows <= 4)  			{  				Debugger.Break();  				throw new Exception();  			}  			else if (grid.Columns <= 4)  			{  				horiz = true;  			}  			else if (grid.Rows <= 4)  			{  				horiz = false;  			}  			else  			{  				horiz = grid.Columns < grid.Rows;  			}
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateNodes,The following statement contains a magic number: double m = GetRandomDouble(0.4' 0.6);
Magic Number,Dwarrowdelf.TerrainGen,DungeonTerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,CreateNodes,The following statement contains a magic number: double m = GetRandomDouble(0.4' 0.6);
Magic Number,Dwarrowdelf.TerrainGen,BSPTree,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,GetLeft,The following statement contains a magic number: return 2 * i + 1;
Magic Number,Dwarrowdelf.TerrainGen,BSPTree,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,GetRight,The following statement contains a magic number: return 2 * i + 2;
Magic Number,Dwarrowdelf.TerrainGen,BSPTree,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,GetRight,The following statement contains a magic number: return 2 * i + 2;
Magic Number,Dwarrowdelf.TerrainGen,BSPTree,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DungeonTerrainGenerator.cs,GetParent,The following statement contains a magic number: return (i - 1) / 2;
Magic Number,Dwarrowdelf.TerrainGen,DiamondSquare,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DiamondSquare.cs,GetRandom,The following statement contains a magic number: return ctx.Random.NextDouble() * range * 2 - range;
Magic Number,Dwarrowdelf.TerrainGen,DiamondSquare,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DiamondSquare.cs,HeightMap,The following statement contains a magic number: for (int pass = 0; pass < MyMath.Log2(grid.Width); ++pass)  			{  				var parts = MyMath.Pow2(pass);  				var size = (grid.Width - 1) / parts;  				int half = size / 2;    				Debug.Assert(half != 0);    				for (int y = half; y < grid.Height; y += size)  				{  					for (int x = half; x < grid.Width; x += size)  					{  						var p = new IntVector2(x' y);  						Rectangle(ctx' p' half);  					}  				}    				bool odd = true;    				for (int y = 0; y < grid.Height; y += half)  				{  					for (int x = odd ? half : 0; x < grid.Width; x += size)  					{  						var p = new IntVector2(x' y);  						Diamond(ctx' p' half);  					}    					odd = !odd;  				}    				ctx.Range *= Math.Pow(2' -ctx.H);  			}
Magic Number,Dwarrowdelf.TerrainGen,DiamondSquare,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DiamondSquare.cs,HeightMap,The following statement contains a magic number: for (int pass = 0; pass < MyMath.Log2(grid.Width); ++pass)  			{  				var parts = MyMath.Pow2(pass);  				var size = (grid.Width - 1) / parts;  				int half = size / 2;    				Debug.Assert(half != 0);    				for (int y = half; y < grid.Height; y += size)  				{  					for (int x = half; x < grid.Width; x += size)  					{  						var p = new IntVector2(x' y);  						Rectangle(ctx' p' half);  					}  				}    				bool odd = true;    				for (int y = 0; y < grid.Height; y += half)  				{  					for (int x = odd ? half : 0; x < grid.Width; x += size)  					{  						var p = new IntVector2(x' y);  						Diamond(ctx' p' half);  					}    					odd = !odd;  				}    				ctx.Range *= Math.Pow(2' -ctx.H);  			}
Magic Number,Dwarrowdelf.TerrainGen,DiamondSquare,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DiamondSquare.cs,Rectangle,The following statement contains a magic number: var avg = (v1 + v2 + v3 + v4) / 4;
Magic Number,Dwarrowdelf.TerrainGen,DiamondSquare,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\DiamondSquare.cs,Diamond,The following statement contains a magic number: var avg = (v1 + v2 + v3 + v4) / 4;
Magic Number,Dwarrowdelf.TerrainGen,TerrainData,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainData.cs,SetTileData,The following statement contains a magic number: if (data.IsWall && oldLevel <= p.Z)  			{  				// Surface level has risen  				Debug.Assert(p.Z >= 0 && p.Z < 256);  				SetSurfaceLevel(p.X' p.Y' p.Z + 1);  			}  			else if (data.IsWall == false && oldLevel == p.Z + 1)  			{  				// Surface level has possibly lowered  				if (p.Z == 0)  					throw new Exception();    				for (int z = p.Z - 1; z >= 0; --z)  				{  					if (GetTileData(p.X' p.Y' z).IsWall)  					{  						Debug.Assert(z >= 0 && z < 256);  						SetSurfaceLevel(p.X' p.Y' z + 1);  						break;  					}  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainData,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainData.cs,SetTileData,The following statement contains a magic number: if (data.IsWall && oldLevel <= p.Z)  			{  				// Surface level has risen  				Debug.Assert(p.Z >= 0 && p.Z < 256);  				SetSurfaceLevel(p.X' p.Y' p.Z + 1);  			}  			else if (data.IsWall == false && oldLevel == p.Z + 1)  			{  				// Surface level has possibly lowered  				if (p.Z == 0)  					throw new Exception();    				for (int z = p.Z - 1; z >= 0; --z)  				{  					if (GetTileData(p.X' p.Y' z).IsWall)  					{  						Debug.Assert(z >= 0 && z < 256);  						SetSurfaceLevel(p.X' p.Y' z + 1);  						break;  					}  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainData,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainData.cs,CopyTo,The following statement contains a magic number: var arr = new byte[4096 * 8];
Magic Number,Dwarrowdelf.TerrainGen,TerrainData,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainData.cs,CopyTo,The following statement contains a magic number: var arr = new byte[4096 * 8];
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,Generate,The following statement contains a magic number: double xk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,Generate,The following statement contains a magic number: double xk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,Generate,The following statement contains a magic number: double yk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,Generate,The following statement contains a magic number: double yk = (random.NextDouble() * 2 - 1) * 0.01;
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,Generate,The following statement contains a magic number: if (m_data.Width > 128)  			{  				var riverGen = new RiverGen(m_data' m_random);  				if (riverGen.CreateRiverPath())  				{  					riverGen.AdjustRiver();  				}  				else  				{  					Trace.TraceError("Failed to create river");  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,Generate,The following statement contains a magic number: int soilLimit = m_size.Depth * 4 / 5;
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,Generate,The following statement contains a magic number: int soilLimit = m_size.Depth * 4 / 5;
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,GenerateHeightMap,The following statement contains a magic number: Parallel.For(0' m_size.Height' y =>  				{  					double d = max - min;    					for (int x = 0; x < m_size.Width; ++x)  					{  						var v = heightMap[x' y];    						// normalize to 0.0 - 1.0  						v = (v - min) / d;    						// amplify  						v = Math.Pow(v' amplify);    						// adjust  						v *= m_size.Depth / 2;  						v += m_size.Depth / 2 - 1;    						m_data.SetSurfaceLevel(x' y' MyMath.Round(v));  					}  				});
Magic Number,Dwarrowdelf.TerrainGen,TerrainGenerator,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainGenerator.cs,GenerateHeightMap,The following statement contains a magic number: Parallel.For(0' m_size.Height' y =>  				{  					double d = max - min;    					for (int x = 0; x < m_size.Width; ++x)  					{  						var v = heightMap[x' y];    						// normalize to 0.0 - 1.0  						v = (v - min) / d;    						// amplify  						v = Math.Pow(v' amplify);    						// adjust  						v *= m_size.Depth / 2;  						v += m_size.Depth / 2 - 1;    						m_data.SetSurfaceLevel(x' y' MyMath.Round(v));  					}  				});
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateBaseMinerals,The following statement contains a magic number: var layers = new MaterialID[20];
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateBaseMinerals,The following statement contains a magic number: {  				int rep = 0;  				MaterialID mat = MaterialID.Undefined;  				for (int z = 0; z < layers.Length; ++z)  				{  					if (rep == 0)  					{  						rep = random.Next(4) + 1;  						mat = rockMaterials[random.Next(rockMaterials.Length - 1)].ID;  					}    					layers[z] = mat;  					rep--;  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreVeins,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var start = GetRandomSubterraneanLocation(terrain' random);  				var mat = veinMaterials[random.Next(veinMaterials.Length)];  				int len = random.Next(20) + 3;  				int thickness = random.Next(4) + 1;    				var vx = random.NextDouble() * 2 - 1;  				var vy = random.NextDouble() * 2 - 1;  				var vz = vx * xk + vy * yk;    				var v = new DoubleVector3(vx' vy' -vz).Normalize();    				for (double t = 0.0; t < len; t += 1)  				{  					var p = start + (v * t).ToIntVector3();    					CreateOreSphere(terrain' random' p' thickness' mat' random.NextDouble() * 0.75' 0);  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreVeins,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var start = GetRandomSubterraneanLocation(terrain' random);  				var mat = veinMaterials[random.Next(veinMaterials.Length)];  				int len = random.Next(20) + 3;  				int thickness = random.Next(4) + 1;    				var vx = random.NextDouble() * 2 - 1;  				var vy = random.NextDouble() * 2 - 1;  				var vz = vx * xk + vy * yk;    				var v = new DoubleVector3(vx' vy' -vz).Normalize();    				for (double t = 0.0; t < len; t += 1)  				{  					var p = start + (v * t).ToIntVector3();    					CreateOreSphere(terrain' random' p' thickness' mat' random.NextDouble() * 0.75' 0);  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreVeins,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var start = GetRandomSubterraneanLocation(terrain' random);  				var mat = veinMaterials[random.Next(veinMaterials.Length)];  				int len = random.Next(20) + 3;  				int thickness = random.Next(4) + 1;    				var vx = random.NextDouble() * 2 - 1;  				var vy = random.NextDouble() * 2 - 1;  				var vz = vx * xk + vy * yk;    				var v = new DoubleVector3(vx' vy' -vz).Normalize();    				for (double t = 0.0; t < len; t += 1)  				{  					var p = start + (v * t).ToIntVector3();    					CreateOreSphere(terrain' random' p' thickness' mat' random.NextDouble() * 0.75' 0);  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreVeins,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var start = GetRandomSubterraneanLocation(terrain' random);  				var mat = veinMaterials[random.Next(veinMaterials.Length)];  				int len = random.Next(20) + 3;  				int thickness = random.Next(4) + 1;    				var vx = random.NextDouble() * 2 - 1;  				var vy = random.NextDouble() * 2 - 1;  				var vz = vx * xk + vy * yk;    				var v = new DoubleVector3(vx' vy' -vz).Normalize();    				for (double t = 0.0; t < len; t += 1)  				{  					var p = start + (v * t).ToIntVector3();    					CreateOreSphere(terrain' random' p' thickness' mat' random.NextDouble() * 0.75' 0);  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreVeins,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var start = GetRandomSubterraneanLocation(terrain' random);  				var mat = veinMaterials[random.Next(veinMaterials.Length)];  				int len = random.Next(20) + 3;  				int thickness = random.Next(4) + 1;    				var vx = random.NextDouble() * 2 - 1;  				var vy = random.NextDouble() * 2 - 1;  				var vz = vx * xk + vy * yk;    				var v = new DoubleVector3(vx' vy' -vz).Normalize();    				for (double t = 0.0; t < len; t += 1)  				{  					var p = start + (v * t).ToIntVector3();    					CreateOreSphere(terrain' random' p' thickness' mat' random.NextDouble() * 0.75' 0);  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreVeins,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var start = GetRandomSubterraneanLocation(terrain' random);  				var mat = veinMaterials[random.Next(veinMaterials.Length)];  				int len = random.Next(20) + 3;  				int thickness = random.Next(4) + 1;    				var vx = random.NextDouble() * 2 - 1;  				var vy = random.NextDouble() * 2 - 1;  				var vz = vx * xk + vy * yk;    				var v = new DoubleVector3(vx' vy' -vz).Normalize();    				for (double t = 0.0; t < len; t += 1)  				{  					var p = start + (v * t).ToIntVector3();    					CreateOreSphere(terrain' random' p' thickness' mat' random.NextDouble() * 0.75' 0);  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreVeins,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var start = GetRandomSubterraneanLocation(terrain' random);  				var mat = veinMaterials[random.Next(veinMaterials.Length)];  				int len = random.Next(20) + 3;  				int thickness = random.Next(4) + 1;    				var vx = random.NextDouble() * 2 - 1;  				var vy = random.NextDouble() * 2 - 1;  				var vz = vx * xk + vy * yk;    				var v = new DoubleVector3(vx' vy' -vz).Normalize();    				for (double t = 0.0; t < len; t += 1)  				{  					var p = start + (v * t).ToIntVector3();    					CreateOreSphere(terrain' random' p' thickness' mat' random.NextDouble() * 0.75' 0);  				}  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreSphere,The following statement contains a magic number: var bb = new IntGrid3(center.X - r' center.Y - r' center.Z - r' r * 2 + 1' r * 2 + 1' r * 2 + 1);
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreSphere,The following statement contains a magic number: var bb = new IntGrid3(center.X - r' center.Y - r' center.Z - r' r * 2 + 1' r * 2 + 1' r * 2 + 1);
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreSphere,The following statement contains a magic number: var bb = new IntGrid3(center.X - r' center.Y - r' center.Z - r' r * 2 + 1' r * 2 + 1' r * 2 + 1);
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreClusters,The following statement contains a magic number: for (int i = 0; i < 100; ++i)  			{  				var p = GetRandomSubterraneanLocation(terrain' random);  				CreateOreCluster(terrain' random' p' clusterMaterials[random.Next(clusterMaterials.Length)]);  			}
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateOreCluster,The following statement contains a magic number: CreateOreCluster(terrain' p' oreMaterialID' random.Next(6) + 1);
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateVegetation,The following statement contains a magic number: terrain.Size.Plane.Range().AsParallel().ForAll(p2d =>  			{  				int z = terrain.GetSurfaceLevel(p2d);    				var p = new IntVector3(p2d' z);    				if (z >= vegetationLimit)  					return;    				var td = terrain.GetTileData(p);    				if (td.WaterLevel > 0)  					return;    				if (terrain.GetMaterial(p.Down).Category != MaterialCategory.Soil)  					return;    				var r = new MWCRandom(p' baseSeed);    				int v = r.Next(100);    				if (v >= 95)  				{  					td.ID = TileID.Sapling;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 90)  				{  					td.ID = TileID.Tree;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 80)  				{  					td.ID = TileID.Shrub;  					td.MaterialID = berryMaterials[r.Next(berryMaterials.Length)].ID;  				}  				else  				{  					td.ID = TileID.Grass;  					td.MaterialID = grassMaterials[r.Next(grassMaterials.Length)].ID;  				}    				terrain.SetTileDataNoHeight(p' td);  			});
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateVegetation,The following statement contains a magic number: terrain.Size.Plane.Range().AsParallel().ForAll(p2d =>  			{  				int z = terrain.GetSurfaceLevel(p2d);    				var p = new IntVector3(p2d' z);    				if (z >= vegetationLimit)  					return;    				var td = terrain.GetTileData(p);    				if (td.WaterLevel > 0)  					return;    				if (terrain.GetMaterial(p.Down).Category != MaterialCategory.Soil)  					return;    				var r = new MWCRandom(p' baseSeed);    				int v = r.Next(100);    				if (v >= 95)  				{  					td.ID = TileID.Sapling;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 90)  				{  					td.ID = TileID.Tree;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 80)  				{  					td.ID = TileID.Shrub;  					td.MaterialID = berryMaterials[r.Next(berryMaterials.Length)].ID;  				}  				else  				{  					td.ID = TileID.Grass;  					td.MaterialID = grassMaterials[r.Next(grassMaterials.Length)].ID;  				}    				terrain.SetTileDataNoHeight(p' td);  			});
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateVegetation,The following statement contains a magic number: terrain.Size.Plane.Range().AsParallel().ForAll(p2d =>  			{  				int z = terrain.GetSurfaceLevel(p2d);    				var p = new IntVector3(p2d' z);    				if (z >= vegetationLimit)  					return;    				var td = terrain.GetTileData(p);    				if (td.WaterLevel > 0)  					return;    				if (terrain.GetMaterial(p.Down).Category != MaterialCategory.Soil)  					return;    				var r = new MWCRandom(p' baseSeed);    				int v = r.Next(100);    				if (v >= 95)  				{  					td.ID = TileID.Sapling;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 90)  				{  					td.ID = TileID.Tree;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 80)  				{  					td.ID = TileID.Shrub;  					td.MaterialID = berryMaterials[r.Next(berryMaterials.Length)].ID;  				}  				else  				{  					td.ID = TileID.Grass;  					td.MaterialID = grassMaterials[r.Next(grassMaterials.Length)].ID;  				}    				terrain.SetTileDataNoHeight(p' td);  			});
Magic Number,Dwarrowdelf.TerrainGen,TerrainHelpers,C:\repos\tomba_dwarrowdelf\Common\Game\TerrainGen\TerrainHelpers.cs,CreateVegetation,The following statement contains a magic number: terrain.Size.Plane.Range().AsParallel().ForAll(p2d =>  			{  				int z = terrain.GetSurfaceLevel(p2d);    				var p = new IntVector3(p2d' z);    				if (z >= vegetationLimit)  					return;    				var td = terrain.GetTileData(p);    				if (td.WaterLevel > 0)  					return;    				if (terrain.GetMaterial(p.Down).Category != MaterialCategory.Soil)  					return;    				var r = new MWCRandom(p' baseSeed);    				int v = r.Next(100);    				if (v >= 95)  				{  					td.ID = TileID.Sapling;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 90)  				{  					td.ID = TileID.Tree;  					td.MaterialID = woodMaterials[r.Next(woodMaterials.Length)].ID;  				}  				else if (v >= 80)  				{  					td.ID = TileID.Shrub;  					td.MaterialID = berryMaterials[r.Next(berryMaterials.Length)].ID;  				}  				else  				{  					td.ID = TileID.Grass;  					td.MaterialID = grassMaterials[r.Next(grassMaterials.Length)].ID;  				}    				terrain.SetTileDataNoHeight(p' td);  			});
Magic Number,Dwarrowdelf.Jobs.AssignmentGroups,MoveConsumeAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\AssignmentGroups\MoveConsumeAssignment.cs,OnAssignmentDone,The following statement contains a magic number: if (m_state == 2)  				SetStatus(JobStatus.Done);  			else  				m_state = m_state + 1;
Magic Number,Dwarrowdelf.Jobs.AssignmentGroups,MoveConsumeAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\AssignmentGroups\MoveConsumeAssignment.cs,PrepareNextAssignment,The following statement contains a magic number: switch (m_state)  			{  				case 0:  					assignment = new MoveAssignment(this' this.Item.Environment' this.Item.Location' DirectionSet.Exact);  					break;    				case 1:  					assignment = new GetItemAssignment(this' this.Item);  					break;    				case 2:  					assignment = new ConsumeItemAssignment(this' this.Item);  					break;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,FleeMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\FleeMoveAssignment.cs,DoMove,The following statement contains a magic number: for (int i = 0; i < 7; ++i)  			{  				var v = ov.FastRotate(((i + 1) >> 1) * (((i % 2) << 1) - 1));  				var d = env.AdjustMoveDir(this.Worker.Location' v.ToDirection());    				if (d != Direction.None)  					return new MoveAction(d);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,FleeMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\FleeMoveAssignment.cs,DoMove,The following statement contains a magic number: for (int i = 0; i < 7; ++i)  			{  				var v = ov.FastRotate(((i + 1) >> 1) * (((i % 2) << 1) - 1));  				var d = env.AdjustMoveDir(this.Worker.Location' v.ToDirection());    				if (d != Direction.None)  					return new MoveAction(d);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,GrazeMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\GrazeMoveAssignment.cs,PrepareNextActionOverrideHerdless,The following statement contains a magic number: int i = this.Worker.World.Random.Next(8);
Magic Number,Dwarrowdelf.Jobs.Assignments,GrazeMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\GrazeMoveAssignment.cs,PrepareNextActionOverrideHerd,The following statement contains a magic number: if (l < moveStrength && r.Next(4) < 2)  			{  				progress = JobStatus.Ok;  				return new WaitAction(r.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,GrazeMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\GrazeMoveAssignment.cs,PrepareNextActionOverrideHerd,The following statement contains a magic number: if (l < moveStrength && r.Next(4) < 2)  			{  				progress = JobStatus.Ok;  				return new WaitAction(r.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,GrazeMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\GrazeMoveAssignment.cs,PrepareNextActionOverrideHerd,The following statement contains a magic number: if (l < moveStrength && r.Next(4) < 2)  			{  				progress = JobStatus.Ok;  				return new WaitAction(r.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,GrazeMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\GrazeMoveAssignment.cs,PrepareNextActionOverrideHerd,The following statement contains a magic number: if (dir == Direction.None)  			{  				progress = JobStatus.Ok;  				return new WaitAction(r.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,MoveAssignmentBase,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\MoveAssignmentBase.cs,ActionDoneOverride,The following statement contains a magic number: switch (actionStatus)  			{  				case ActionState.Done:  					return CheckProgress(this.Worker);    				case ActionState.Fail:  					m_numFails++;  					if (m_numFails > 10)  						return JobStatus.Abort;    					var res = PreparePath(this.Worker);  					return res;    				case ActionState.Abort:  					return JobStatus.Abort;    				default:  					throw new Exception();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,AssignOverride,The following statement contains a magic number: int i = worker.World.Random.Next(8);
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: int rand = random.Next(100);
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (rand < 25)  			{  				dir = Direction.None;  			}  			else if (rand < 50)  			{  			}  			else if (rand < 75)  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 1 : -1);  				dir = v.ToDirection();  			}  			else  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 2 : -2);  				dir = v.ToDirection();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (rand < 25)  			{  				dir = Direction.None;  			}  			else if (rand < 50)  			{  			}  			else if (rand < 75)  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 1 : -1);  				dir = v.ToDirection();  			}  			else  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 2 : -2);  				dir = v.ToDirection();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (rand < 25)  			{  				dir = Direction.None;  			}  			else if (rand < 50)  			{  			}  			else if (rand < 75)  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 1 : -1);  				dir = v.ToDirection();  			}  			else  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 2 : -2);  				dir = v.ToDirection();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (rand < 25)  			{  				dir = Direction.None;  			}  			else if (rand < 50)  			{  			}  			else if (rand < 75)  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 1 : -1);  				dir = v.ToDirection();  			}  			else  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 2 : -2);  				dir = v.ToDirection();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (rand < 25)  			{  				dir = Direction.None;  			}  			else if (rand < 50)  			{  			}  			else if (rand < 75)  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 1 : -1);  				dir = v.ToDirection();  			}  			else  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 2 : -2);  				dir = v.ToDirection();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (rand < 25)  			{  				dir = Direction.None;  			}  			else if (rand < 50)  			{  			}  			else if (rand < 75)  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 1 : -1);  				dir = v.ToDirection();  			}  			else  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 2 : -2);  				dir = v.ToDirection();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (rand < 25)  			{  				dir = Direction.None;  			}  			else if (rand < 50)  			{  			}  			else if (rand < 75)  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 1 : -1);  				dir = v.ToDirection();  			}  			else  			{  				var v = dir.ToIntVector3();  				v = v.FastRotate(random.Next() % 2 == 0 ? 2 : -2);  				dir = v.ToDirection();  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (dir == Direction.None)  			{  				action = new WaitAction(random.Next(4) + 1);  			}  			else  			{  				var env = this.Worker.Environment;  				m_dir = dir;    				IntVector2 ov = dir.ToIntVector2();    				for (int i = 0; i < 7; ++i)  				{  					var v = ov.FastRotate(((i + 1) >> 1) * (((i % 2) << 1) - 1));  					var d = env.AdjustMoveDir(this.Worker.Location' v.ToDirection());    					if (d != Direction.None)  						action = new MoveAction(d);  				}    				if (action == null && this.Worker.CanMoveTo(Direction.Up))  					action = new MoveAction(Direction.Up);    				if (action == null && this.Worker.CanMoveTo(Direction.Down))  					action = new MoveAction(Direction.Down);    				if (action == null)  					action = new WaitAction(random.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (dir == Direction.None)  			{  				action = new WaitAction(random.Next(4) + 1);  			}  			else  			{  				var env = this.Worker.Environment;  				m_dir = dir;    				IntVector2 ov = dir.ToIntVector2();    				for (int i = 0; i < 7; ++i)  				{  					var v = ov.FastRotate(((i + 1) >> 1) * (((i % 2) << 1) - 1));  					var d = env.AdjustMoveDir(this.Worker.Location' v.ToDirection());    					if (d != Direction.None)  						action = new MoveAction(d);  				}    				if (action == null && this.Worker.CanMoveTo(Direction.Up))  					action = new MoveAction(Direction.Up);    				if (action == null && this.Worker.CanMoveTo(Direction.Down))  					action = new MoveAction(Direction.Down);    				if (action == null)  					action = new WaitAction(random.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (dir == Direction.None)  			{  				action = new WaitAction(random.Next(4) + 1);  			}  			else  			{  				var env = this.Worker.Environment;  				m_dir = dir;    				IntVector2 ov = dir.ToIntVector2();    				for (int i = 0; i < 7; ++i)  				{  					var v = ov.FastRotate(((i + 1) >> 1) * (((i % 2) << 1) - 1));  					var d = env.AdjustMoveDir(this.Worker.Location' v.ToDirection());    					if (d != Direction.None)  						action = new MoveAction(d);  				}    				if (action == null && this.Worker.CanMoveTo(Direction.Up))  					action = new MoveAction(Direction.Up);    				if (action == null && this.Worker.CanMoveTo(Direction.Down))  					action = new MoveAction(Direction.Down);    				if (action == null)  					action = new WaitAction(random.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.Assignments,RandomMoveAssignment,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\Assignments\RandomMoveAssignment.cs,PrepareNextActionOverride,The following statement contains a magic number: if (dir == Direction.None)  			{  				action = new WaitAction(random.Next(4) + 1);  			}  			else  			{  				var env = this.Worker.Environment;  				m_dir = dir;    				IntVector2 ov = dir.ToIntVector2();    				for (int i = 0; i < 7; ++i)  				{  					var v = ov.FastRotate(((i + 1) >> 1) * (((i % 2) << 1) - 1));  					var d = env.AdjustMoveDir(this.Worker.Location' v.ToDirection());    					if (d != Direction.None)  						action = new MoveAction(d);  				}    				if (action == null && this.Worker.CanMoveTo(Direction.Up))  					action = new MoveAction(Direction.Up);    				if (action == null && this.Worker.CanMoveTo(Direction.Down))  					action = new MoveAction(Direction.Down);    				if (action == null)  					action = new WaitAction(random.Next(4) + 1);  			}
Magic Number,Dwarrowdelf.Jobs.JobGroups,FellTreeParallelJob,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\JobGroups\FellTreeParallelJob.cs,AddNewJobs,The following statement contains a magic number: m_locs = m_area.Range().Where(p => !m_jobs.Any(i => i.Item1 == p) && m_environment.GetTileData(p).HasFellableTree).Take(3 - c);
Missing Default,Dwarrowdelf.Jobs.AssignmentGroups,AssignmentGroup,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\AssignmentGroups\AssignmentGroup.cs,PrepareNextAction,The following switch statement is missing a default case: switch (status)  					{  						case JobStatus.Ok:  							Debug.Assert(this.CurrentAction != null);  							return JobStatus.Ok;    						case JobStatus.Done:  							continue;    						case JobStatus.Abort:  						case JobStatus.Fail:  							Debug.Assert(this.CurrentAction == null);  							continue;  					}
Missing Default,Dwarrowdelf.Jobs.AssignmentGroups,AssignmentGroup,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\AssignmentGroups\AssignmentGroup.cs,OnObservableJobStatusChanged,The following switch statement is missing a default case: switch (status)  			{  				case JobStatus.Ok:  					throw new Exception();    				case JobStatus.Abort:  					OnAssignmentAborted();  					break;    				case JobStatus.Fail:  					OnAssignmentFailed();  					break;    				case JobStatus.Done:  					OnAssignmentDone();  					break;  			}
Missing Default,Dwarrowdelf.Jobs.JobGroups,JobGroup,C:\repos\tomba_dwarrowdelf\Common\Game\Jobs\JobGroups\JobGroup.cs,OnObservableJobStatusChanged,The following switch statement is missing a default case: switch (status)  			{  				case JobStatus.Ok:  					throw new Exception();    				case JobStatus.Abort:  					OnSubJobAborted(job);  					break;    				case JobStatus.Fail:  					OnSubJobFailed(job);  					break;    				case JobStatus.Done:  					OnSubJobDone(job);  					break;  			}
