Implementation smell,Namespace,Class,File,Method,Description
Long Method,Dwarrowdelf.Client,VoxelRayCast,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\VoxelRayCast.cs,RunRayCast,The method has 110 lines of code.
Complex Method,Dwarrowdelf.Client,SymbolRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SymbolRenderer.cs,UpdateVertexBuffer,Cyclomatic complexity of the method is 9
Complex Method,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GenerateVertices,Cyclomatic complexity of the method is 13
Complex Method,Dwarrowdelf.Client,VoxelRayCast,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\VoxelRayCast.cs,RunRayCast,Cyclomatic complexity of the method is 8
Long Parameter List,Dwarrowdelf.Client,SharpDXHost,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\GameCore\SharpDXHost.cs,WndProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,Dwarrowdelf.Client,MousePositionService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MousePositionService.cs,PickVoxel,The method has 5 parameters. Parameters: game' screenPos' pickMode' pos' face
Long Parameter List,Dwarrowdelf.Client,MousePositionService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MousePositionService.cs,PickVoxel,The method has 7 parameters. Parameters: env' view' screenPos' cropGrid' pickMode' pos' face
Long Parameter List,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetTextures,The method has 5 parameters. Parameters: p' vox' baseTexture' topTexture' sliceFaces
Long Parameter List,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,HandleVoxel,The method has 5 parameters. Parameters: p' vox' viewGrid' visibleChunkFaces' vertexList
Long Parameter List,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateCube,The method has 6 parameters. Parameters: p' visibleFaces' baseTexture' topTexture' vertexList' sliceFaces
Long Parameter List,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The method has 6 parameters. Parameters: p' face' o0' o1' o2' o3
Long Parameter List,Dwarrowdelf.Client,TerrainVertex,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\TerrainEffect.cs,TerrainVertex,The method has 10 parameters. Parameters: p0' p1' p2' p3' occ0' occ1' occ2' occ3' tex' sliceHack
Long Parameter List,Dwarrowdelf.Client,VoxelRayCast,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\VoxelRayCast.cs,RunRayCast,The method has 5 parameters. Parameters: worldSize' origin' direction' radius' callback
Long Statement,Dwarrowdelf.Client,DebugWindow,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugWindow.xaml.cs,SetGame,The length of the statement  "			cbBigUnknownChunk.Unchecked += (s' e) => { Chunk.UseBigUnknownChunk = false; m_scene.ChunkManager.InvalidateChunks(); }; " is 120.
Long Statement,Dwarrowdelf.Client,FPSCounter,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\FPSCounterSystem.cs,Update,The length of the statement  "				System.Windows.Application.Current.MainWindow.Title = string.Format("{0} frames in {1:F2} ms = {2:F2} fps"' m_frameCount' diff.TotalMilliseconds' fps); " is 151.
Long Statement,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The length of the statement  "			m_vertexBuffer = ToDispose(SharpDX.Toolkit.Graphics.Buffer.Vertex.New<VertexPositionColorTexture>(device' vertices.ToArray())); " is 127.
Long Statement,Dwarrowdelf.Client,MousePositionService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MousePositionService.cs,UpdateMousePos,The length of the statement  "			bool hit = PickVoxel(m_game.Environment' m_surfaceView' mousePos' m_game.ViewGridProvider.ViewGrid' pickMode' out p' out d); " is 124.
Long Statement,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The length of the statement  "			m_vertexBuffer = ToDispose(SharpDX.Toolkit.Graphics.Buffer.Vertex.New<VertexPositionColorTexture>(device' vertices.ToArray())); " is 127.
Long Statement,Dwarrowdelf.Client,SymbolRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SymbolRenderer.cs,UpdateVertexBuffer,The length of the statement  "					m_vertexBuffer = ToDispose(SharpDX.Toolkit.Graphics.Buffer.Vertex.New<SceneryVertex>(this.GraphicsDevice' m_vertexList.Count)); " is 127.
Long Statement,Dwarrowdelf.Client,ViewGridProvider,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\ViewGridProvider.cs,ResetGrid,The length of the statement  "			this.ViewCorner2 = new IntVector3(m_game.Environment.Width - 1' m_game.Environment.Height - 1' m_game.Environment.Depth - 1); " is 125.
Long Statement,Dwarrowdelf.Client,ChunkManager,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\ChunkManager.cs,GetFrustumFarthestCorner,The length of the statement  "			var num = -p1.D * Vector3.Cross(p2.Normal' p3.Normal) - p2.D * Vector3.Cross(p3.Normal' p1.Normal) - p3.D * Vector3.Cross(p1.Normal' p2.Normal); " is 144.
Long Statement,Dwarrowdelf.Client,ChunkManager,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\ChunkManager.cs,UpdateNearList,The length of the statement  "			//var grid = new IntGrid3(viewGrid.Corner1 / Chunk.CHUNK_SIZE' (viewGrid.Corner2 + Chunk.CHUNK_SIZE - 1) / Chunk.CHUNK_SIZE); " is 125.
Long Statement,Dwarrowdelf.Client,TerrainEffect,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\TerrainEffect.cs,CreateGameColorBuffer,The length of the statement  "			var buf = ToDispose(Buffer<int>.New(this.GraphicsDevice' arr' BufferFlags.ShaderResource' SharpDX.DXGI.Format.R8G8B8A8_UNorm' " is 125.
Complex Conditional,Dwarrowdelf.Client,MousePositionService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MousePositionService.cs,UpdateMousePos,The conditional expression  "m_game.Environment == null ||  				m_surfaceView.ViewPort.Width == 0 || m_surfaceView.ViewPort.Height == 0 ||  				m_surfaceView.ViewPort.Bounds.Contains(mousePos.X' mousePos.Y) == false"  is complex.
Complex Conditional,Dwarrowdelf.Client,VoxelRayCast,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\VoxelRayCast.cs,RunRayCast,The conditional expression  "!(x < 0 || y < 0 || z < 0 || x >= wx || y >= wy || z >= wz)"  is complex.
Magic Number,Dwarrowdelf.Client,ChunkOutlineRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\ChunkOutlineRenderer.cs,LoadContent,The following statement contains a magic number: rdesc.DepthBias = -10;
Magic Number,Dwarrowdelf.Client,ChunkOutlineRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\ChunkOutlineRenderer.cs,Draw,The following statement contains a magic number: foreach (var cp in m_chunkManager.Size.Range())  			{  				var chunk = chunks[m_chunkManager.Size.GetIndex(cp)];  				if (chunk == null)  					continue;    				if (chunk.IsAllEmpty)  					m_basicEffect.DiffuseColor = new Vector4(1' 0' 0' 0);  				else if (chunk.IsAllUndefined)  					m_basicEffect.DiffuseColor = new Vector4(0' 1' 0' 0);  				else  					m_basicEffect.DiffuseColor = new Vector4(1' 1' 1' 0);    				m_basicEffect.World = Matrix.Translation((cp * Chunk.CHUNK_SIZE + Chunk.CHUNK_SIZE / 2).ToVector3());  				m_cube.Draw(m_basicEffect);  			}
Magic Number,Dwarrowdelf.Client,CursorService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\CursorService.cs,OnKeyDown,The following statement contains a magic number: if ((e.KeyboardDevice.Modifiers & ModifierKeys.Shift) != 0)  				m = 5;
Magic Number,Dwarrowdelf.Client,CursorService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\CursorService.cs,SetInitialCursorPos,The following statement contains a magic number: if (loc.HasValue == false)  			{  				IntVector3 pos;  				Direction face;    				var view = m_game.Surfaces[0].Views[0];    				var center = new IntVector2((int)view.ViewPort.Width / 2' (int)view.ViewPort.Height / 2);  				var pickMode = ((MapControl3D)m_control).Config.PickMode;    				bool hit = MousePositionService.PickVoxel(m_game' center' pickMode' out pos' out face);    				if (hit)  					loc = pos;  				else  					loc = null;  			}
Magic Number,Dwarrowdelf.Client,CursorService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\CursorService.cs,SetInitialCursorPos,The following statement contains a magic number: if (loc.HasValue == false)  			{  				IntVector3 pos;  				Direction face;    				var view = m_game.Surfaces[0].Views[0];    				var center = new IntVector2((int)view.ViewPort.Width / 2' (int)view.ViewPort.Height / 2);  				var pickMode = ((MapControl3D)m_control).Config.PickMode;    				bool hit = MousePositionService.PickVoxel(m_game' center' pickMode' out pos' out face);    				if (hit)  					loc = pos;  				else  					loc = null;  			}
Magic Number,Dwarrowdelf.Client,DebugAxesRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugAxesRenderer.cs,LoadContent,The following statement contains a magic number: m_plane = ToDispose(GeometricPrimitive.Plane.New(this.GraphicsDevice' 2' 2' 1' true));
Magic Number,Dwarrowdelf.Client,DebugAxesRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugAxesRenderer.cs,LoadContent,The following statement contains a magic number: m_plane = ToDispose(GeometricPrimitive.Plane.New(this.GraphicsDevice' 2' 2' 1' true));
Magic Number,Dwarrowdelf.Client,DebugAxesRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugAxesRenderer.cs,DrawAxes,The following statement contains a magic number: m_basicEffect.Projection = Matrix.OrthoLH(2' 2' 0' 2);
Magic Number,Dwarrowdelf.Client,DebugAxesRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugAxesRenderer.cs,DrawAxes,The following statement contains a magic number: m_basicEffect.Projection = Matrix.OrthoLH(2' 2' 0' 2);
Magic Number,Dwarrowdelf.Client,DebugAxesRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugAxesRenderer.cs,DrawAxes,The following statement contains a magic number: m_basicEffect.Projection = Matrix.OrthoLH(2' 2' 0' 2);
Magic Number,Dwarrowdelf.Client,DebugAxesRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugAxesRenderer.cs,DrawAxes,The following statement contains a magic number: device.Draw(PrimitiveType.LineList' 6);
Magic Number,Dwarrowdelf.Client,DebugWindow,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DebugWindow.xaml.cs,SetGame,The following statement contains a magic number: m_timer.Interval = TimeSpan.FromSeconds(0.25);
Magic Number,Dwarrowdelf.Client,FPSCounter,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\FPSCounterSystem.cs,Update,The following statement contains a magic number: if (diff.TotalMilliseconds >= 1000)  			{  				var fps = m_frameCount / diff.TotalSeconds;    				System.Windows.Application.Current.MainWindow.Title = string.Format("{0} frames in {1:F2} ms = {2:F2} fps"' m_frameCount' diff.TotalMilliseconds' fps);    				m_frameCount = 0;  				m_fpsPrev = time;  			}
Magic Number,Dwarrowdelf.Client,Camera,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\GameCore\Camera.cs,PlanarAdjust,The following statement contains a magic number: if (Math.Abs(m_look.X) > Math.Abs(m_look.Y))  				rot = m_look.X < 0 ? -1 : 1;  			else  				rot = m_look.Y < 0 ? 0 : 2;
Magic Number,Dwarrowdelf.Client,SharpDXHost,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\GameCore\SharpDXHost.cs,SharpDXHost,The following statement contains a magic number: this.MinWidth = 32;
Magic Number,Dwarrowdelf.Client,SharpDXHost,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\GameCore\SharpDXHost.cs,SharpDXHost,The following statement contains a magic number: this.MinHeight = 32;
Magic Number,Dwarrowdelf.Client,SharpDXHost,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\GameCore\SharpDXHost.cs,OnMouseMove,The following statement contains a magic number: if (m_dragState == DragState.Captured)  			{  				if ((pos - m_dragStartPos).Length < 2)  					return;    				m_dragState = DragState.Dragging;    				if (this.DragStarted != null)  					this.DragStarted(m_dragStartPos);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,DesignationRenderer,The following statement contains a magic number: s_rotationQuaternions = new Quaternion[6];
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,SetWorlMatrix,The following statement contains a magic number: worldMatrix *= Matrix.Translation((size.ToIntVector3().ToVector3() - new Vector3(1)) / 2);
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,Draw,The following statement contains a magic number: float t = (float)(Math.Sin(m_game.Time.TotalTime.TotalSeconds * 4) + 1) / 2;
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,Draw,The following statement contains a magic number: float t = (float)(Math.Sin(m_game.Time.TotalTime.TotalSeconds * 4) + 1) / 2;
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,Draw,The following statement contains a magic number: foreach (var kvp in designations)  			{  				SetWorlMatrix(kvp.Key' new IntSize3(1' 1' 1)' Direction.Up);  				m_effect.ConstantBuffers["PerObject"].Update();    				device.Draw(PrimitiveType.TriangleList' 6 * 6);  			}
Magic Number,Dwarrowdelf.Client,DesignationRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\DesignationRenderer.cs,Draw,The following statement contains a magic number: foreach (var kvp in designations)  			{  				SetWorlMatrix(kvp.Key' new IntSize3(1' 1' 1)' Direction.Up);  				m_effect.ConstantBuffers["PerObject"].Update();    				device.Draw(PrimitiveType.TriangleList' 6 * 6);  			}
Magic Number,Dwarrowdelf.Client,ToolTipService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\ToolTipService.cs,ToolTipService,The following statement contains a magic number: popup.HorizontalOffset = 4;
Magic Number,Dwarrowdelf.Client,MyGame,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MyGame.cs,MyGame,The following statement contains a magic number: this.Camera.LookAt(new Vector3(4' 0' 0)' new Vector3(0' 0' 0)' Vector3.UnitZ);
Magic Number,Dwarrowdelf.Client,MyGame,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MyGame.cs,MyGame,The following statement contains a magic number: surface.SizeChanged += (w' h) =>  			{  				var vp = new ViewportF(0' 0' w' h);  				mainView.ViewPort = vp;  				mainView.Camera.SetAspect(vp.AspectRatio);    				axesView.ViewPort = new ViewportF(0' 0' 50' 50);  			};
Magic Number,Dwarrowdelf.Client,MyGame,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MyGame.cs,MyGame,The following statement contains a magic number: surface.SizeChanged += (w' h) =>  			{  				var vp = new ViewportF(0' 0' w' h);  				mainView.ViewPort = vp;  				mainView.Camera.SetAspect(vp.AspectRatio);    				axesView.ViewPort = new ViewportF(0' 0' 50' 50);  			};
Magic Number,Dwarrowdelf.Client,MyGame,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\MyGame.cs,GetEyeFromLookTarget,The following statement contains a magic number: var v = new Vector3(-1' 8' 32.5f) / 32.5f;
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  			{  				var color = i == (int)DirectionOrdinal.South ? new Color(255' 255' 255) : new Color(128' 128' 128);    				var ver = Chunk.s_cubeFaceInfo[i].Vertices.Select(v => v.ToVector3())  					.ToArray();    				var vs = new List<VertexPositionColorTexture>();  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));  				vs.Add(new VertexPositionColorTexture(ver[1]' color' tex[1]));  				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));    				vs.Add(new VertexPositionColorTexture(ver[2]' color' tex[2]));  				vs.Add(new VertexPositionColorTexture(ver[3]' color' tex[3]));  				vs.Add(new VertexPositionColorTexture(ver[0]' color' tex[0]));    				vertices.AddRange(vs);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,SelectionRenderer,The following statement contains a magic number: s_rotationQuaternions = new Quaternion[6];
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,SetWorlMatrix,The following statement contains a magic number: worldMatrix *= Matrix.Translation((size.ToIntVector3().ToVector3() - new Vector3(1)) / 2);
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,Draw,The following statement contains a magic number: if (cursorPos.HasValue)  			{  				m_effect.Parameters["s_cubeColor"].SetValue(Color.Red.ToVector3());  				SetWorlMatrix(cursorPos.Value' new IntSize3(1' 1' 1)' Direction.Up);  				m_effect.ConstantBuffers["PerObject"].Update();    				device.Draw(PrimitiveType.TriangleList' 6 * 6);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,Draw,The following statement contains a magic number: if (cursorPos.HasValue)  			{  				m_effect.Parameters["s_cubeColor"].SetValue(Color.Red.ToVector3());  				SetWorlMatrix(cursorPos.Value' new IntSize3(1' 1' 1)' Direction.Up);  				m_effect.ConstantBuffers["PerObject"].Update();    				device.Draw(PrimitiveType.TriangleList' 6 * 6);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,Draw,The following statement contains a magic number: if (selection.IsSelectionValid)  			{  				var grid = selection.SelectionBox;  				SetWorlMatrix(grid.Corner1' grid.Size' selDir);    				m_effect.Parameters["s_cubeColor"].SetValue(Color.Blue.ToVector3());  				m_effect.ConstantBuffers["PerObject"].Update();    				device.Draw(PrimitiveType.TriangleList' 6 * 6);  			}
Magic Number,Dwarrowdelf.Client,SelectionRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SelectionRenderer.cs,Draw,The following statement contains a magic number: if (selection.IsSelectionValid)  			{  				var grid = selection.SelectionBox;  				SetWorlMatrix(grid.Corner1' grid.Size' selDir);    				m_effect.Parameters["s_cubeColor"].SetValue(Color.Blue.ToVector3());  				m_effect.ConstantBuffers["PerObject"].Update();    				device.Draw(PrimitiveType.TriangleList' 6 * 6);  			}
Magic Number,Dwarrowdelf.Client,SymbolRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SymbolRenderer.cs,UpdateVertexBuffer,The following statement contains a magic number: if (m_vertexList == null)  				m_vertexList = new VertexList<SceneryVertex>(envContents.Count * 2);
Magic Number,Dwarrowdelf.Client,SymbolRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\SymbolRenderer.cs,Draw,The following statement contains a magic number: if (System.Math.Abs(angle) < 45)  				m_effect.CurrentTechnique = m_effect.Techniques["ModeFlat"];  			else  				m_effect.CurrentTechnique = m_effect.Techniques["ModeFollow"];
Magic Number,Dwarrowdelf.Client,TestCubeRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\TestCubeRenderer.cs,Draw,The following statement contains a magic number: m_basicEffect.View = Matrix.Translation(0' 0' 10);
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateUndefinedChunk,The following statement contains a magic number: if (Chunk.UseBigUnknownChunk)  			{  				/* Note: Using chunk sized quads causes t-junction problems */    				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] * size + offset;  					IntVector3 v1 = vertices[1] * size + offset;  					IntVector3 v2 = vertices[2] * size + offset;  					IntVector3 v3 = vertices[3] * size + offset;    					var vd = new TerrainVertex(v0' v1' v2' v3' occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  					vertexList.Add(vd);  				}  			}  			else  			{  				for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  				{  					if ((sides & 1) == 0)  						continue;    					int d0 = side / 2;  					int d1 = (d0 + 1) % 3;  					int d2 = (d0 + 2) % 3;    					bool posFace = (side & 1) == 1;    					var vertices = s_cubeFaceInfo[side].Vertices;    					IntVector3 v0 = vertices[0] + offset;  					IntVector3 v1 = vertices[1] + offset;  					IntVector3 v2 = vertices[2] + offset;  					IntVector3 v3 = vertices[3] + offset;    					var vec1 = new IntVector3();  					vec1[d1] = 1;    					var vec2 = new IntVector3();  					vec2[d2] = 1;    					for (int v = 0; v < size[d1]; ++v)  						for (int u = 0; u < size[d2]; ++u)  						{  							var off = vec1 * v + vec2 * u;  							if (posFace)  								off[d0] = size[d0] - 1;    							var vd = new TerrainVertex(v0 + off' v1 + off' v2 + off' v3 + off'  								occlusion' occlusion' occlusion' occlusion' tex' sliceHack);  							vertexList.Add(vd);  						}  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateCube,The following statement contains a magic number: for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  			{  				if ((sides & 1) == 0)  					continue;    				var vertices = s_cubeFaceInfo[side].Vertices;    				IntVector3 v0' v1' v2' v3;    				v0 = vertices[0] + offset;  				v1 = vertices[1] + offset;  				v2 = vertices[2] + offset;  				v3 = vertices[3] + offset;    				Direction dir = (Direction)(1 << side);    				bool isSliceFace = (sliceFaces & dir) != 0;    				int occ0' occ1' occ2' occ3;    				if (isSliceFace)  				{  					occ0 = occ1 = occ2 = occ3 = 0;  				}  				else  				{  					GetOcclusionsForFace(p' (DirectionOrdinal)side'  						out occ0' out occ1' out occ2' out occ3);  				}    				var tex = side == (int)DirectionOrdinal.PositiveZ ? topTexture : baseTexture;  				byte sliceHack = isSliceFace ? (byte)1 : (byte)0;    				var vd = new TerrainVertex(v0' v1' v2' v3' occ0' occ1' occ2' occ3'  					tex' sliceHack);  				vertexList.Add(vd);  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateCube,The following statement contains a magic number: for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  			{  				if ((sides & 1) == 0)  					continue;    				var vertices = s_cubeFaceInfo[side].Vertices;    				IntVector3 v0' v1' v2' v3;    				v0 = vertices[0] + offset;  				v1 = vertices[1] + offset;  				v2 = vertices[2] + offset;  				v3 = vertices[3] + offset;    				Direction dir = (Direction)(1 << side);    				bool isSliceFace = (sliceFaces & dir) != 0;    				int occ0' occ1' occ2' occ3;    				if (isSliceFace)  				{  					occ0 = occ1 = occ2 = occ3 = 0;  				}  				else  				{  					GetOcclusionsForFace(p' (DirectionOrdinal)side'  						out occ0' out occ1' out occ2' out occ3);  				}    				var tex = side == (int)DirectionOrdinal.PositiveZ ? topTexture : baseTexture;  				byte sliceHack = isSliceFace ? (byte)1 : (byte)0;    				var vd = new TerrainVertex(v0' v1' v2' v3' occ0' occ1' occ2' occ3'  					tex' sliceHack);  				vertexList.Add(vd);  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateCube,The following statement contains a magic number: for (int side = 0; side < 6 && sides != 0; ++side' sides >>= 1)  			{  				if ((sides & 1) == 0)  					continue;    				var vertices = s_cubeFaceInfo[side].Vertices;    				IntVector3 v0' v1' v2' v3;    				v0 = vertices[0] + offset;  				v1 = vertices[1] + offset;  				v2 = vertices[2] + offset;  				v3 = vertices[3] + offset;    				Direction dir = (Direction)(1 << side);    				bool isSliceFace = (sliceFaces & dir) != 0;    				int occ0' occ1' occ2' occ3;    				if (isSliceFace)  				{  					occ0 = occ1 = occ2 = occ3 = 0;  				}  				else  				{  					GetOcclusionsForFace(p' (DirectionOrdinal)side'  						out occ0' out occ1' out occ2' out occ3);  				}    				var tex = side == (int)DirectionOrdinal.PositiveZ ? topTexture : baseTexture;  				byte sliceHack = isSliceFace ? (byte)1 : (byte)0;    				var vd = new TerrainVertex(v0' v1' v2' v3' occ0' occ1' occ2' occ3'  					tex' sliceHack);  				vertexList.Add(vd);  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,GetOcclusionsForFace,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				bool occ_edge1 = occ_edge2;  				bool occ_corner = IsBlocker(p + occ_data[i * 2 + 1]);  				occ_edge2 = IsBlocker(p + occ_data[(i * 2 + 2) % 8]);    				bool exp_edge1 = exp_edge2;  				bool exp_corner = !IsBlocker(p + exp_data[i * 2 + 1]);  				exp_edge2 = !IsBlocker(p + exp_data[(i * 2 + 2) % 8]);    				int occlusion;    				if (occ_edge1 && occ_edge2)  				{  					occlusion = -3;  				}  				else  				{  					occlusion = 0;    					if (occ_edge1)  						occlusion--;  					else if (exp_edge1)  						occlusion++;    					if (occ_edge2)  						occlusion--;  					else if (exp_edge2)  						occlusion++;    					if (occ_corner)  						occlusion--;  					else if (exp_corner)  						occlusion++;  				}    				switch (i)  				{  					case 0:  						o0 = occlusion; break;  					case 1:  						o1 = occlusion; break;  					case 2:  						o2 = occlusion; break;  					case 3:  						o3 = occlusion; break;  					default:  						throw new Exception();  				}  			}
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,CreateFaceInfo,The following statement contains a magic number: var vertices =  				new[] { topRight' bottomRight' bottomLeft' topLeft' }  				.Select(v => v + normal)                                // add normal to lift from origin  				.Select(v => v + new IntVector3(1' 1' 1))               // translate to [0'2]  				.Select(v => v / 2)                                     // scale to [0'1]  				.ToArray();
Magic Number,Dwarrowdelf.Client,Chunk,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\Chunk.cs,Chunk,The following statement contains a magic number: s_cubeFaceInfo = new CubeFaceInfo[6];
Magic Number,Dwarrowdelf.Client,ChunkManager,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\ChunkManager.cs,UpdateNearList,The following statement contains a magic number: float chunkRadius = (float)Math.Sqrt(3) * Chunk.CHUNK_SIZE / 2;
Magic Number,Dwarrowdelf.Client,ChunkManager,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\ChunkManager.cs,UpdateNearList,The following statement contains a magic number: float chunkRadius = (float)Math.Sqrt(3) * Chunk.CHUNK_SIZE / 2;
Magic Number,Dwarrowdelf.Client,ChunkManager,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\ChunkManager.cs,UpdateNearList,The following statement contains a magic number: foreach (var cp in grid.Range())  			{  				var chunk = GetChunk(cp);    				IntVector3 chunkOffset = cp * Chunk.CHUNK_SIZE;    				var chunkGrid = new IntGrid3(chunkOffset' Chunk.ChunkSize);    				var containment = viewGrid.ContainsExclusive(ref chunkGrid);    				if (containment == Containment.Disjoint)  				{  					// the chunk is outside the view area  					if (chunk != null)  						FreeChunk(chunk);  					continue;  				}    				var chunkCenter = chunkOffset.ToVector3() + new Vector3(Chunk.CHUNK_SIZE / 2);    				if (Vector3.Distance(eye' chunkCenter) - chunkRadius > camRadius)  				{  					if (chunk != null)  						FreeChunk(chunk);  					continue;  				}    				if (chunk == null)  					chunk = CreateChunk(cp);    				m_nearList.Add(chunk);  			}
Magic Number,Dwarrowdelf.Client,TerrainEffect,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\TerrainEffect.cs,CreateGameColorBuffer,The following statement contains a magic number: for (int i = 0; i < arr.Length; ++i)  			{  				var gc = (GameColor)i;  				var rgb = GameColorRGB.FromGameColor(gc);  				arr[i] = rgb.R | (rgb.G << 8) | (rgb.B << 16);  			}
Magic Number,Dwarrowdelf.Client,TerrainEffect,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\TerrainEffect.cs,CreateGameColorBuffer,The following statement contains a magic number: for (int i = 0; i < arr.Length; ++i)  			{  				var gc = (GameColor)i;  				var rgb = GameColorRGB.FromGameColor(gc);  				arr[i] = rgb.R | (rgb.G << 8) | (rgb.B << 16);  			}
Magic Number,Dwarrowdelf.Client,TerrainRenderer,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\TerrainRenderer.cs,Draw,The following statement contains a magic number: {  				device.SetRasterizerState(device.RasterizerStates.CullNone);  				device.SetBlendState(device.BlendStates.AlphaBlend);    				m_symbolEffect.EyePos = camera.Position;  				m_symbolEffect.ScreenUp = camera.ScreenUp;  				m_symbolEffect.ViewProjection = camera.View * camera.Projection;    				var angle = (float)System.Math.Acos(Vector3.Dot(-Vector3.UnitZ' camera.Look));  				angle = MathUtil.RadiansToDegrees(angle);  				if (System.Math.Abs(angle) < 45)  					m_symbolEffect.CurrentTechnique = m_symbolEffect.Techniques["ModeFlat"];  				else  					m_symbolEffect.CurrentTechnique = m_symbolEffect.Techniques["ModeCross"];    				var renderPass = m_symbolEffect.CurrentTechnique.Passes[0];  				renderPass.Apply();    				m_chunkManager.DrawTrees();    				device.SetBlendState(device.BlendStates.Default);  				device.SetRasterizerState(device.RasterizerStates.Default);  			}
Magic Number,Dwarrowdelf.Client,VoxelRayCast,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\VoxelTerrain\VoxelRayCast.cs,RunRayCast,The following statement contains a magic number: int z = MyMath.Floor(origin[2]);
Missing Default,Dwarrowdelf.Client,SharpDXHost,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\GameCore\SharpDXHost.cs,OnMouseUp,The following switch statement is missing a default case: switch (state)  			{  				case DragState.Captured:    					var newEvent = new MouseButtonEventArgs(e.MouseDevice' e.Timestamp' MouseButton.Left)  					{  						RoutedEvent = SharpDXHost.MouseClickedEvent  					};  					RaiseEvent(newEvent);    					break;    				case DragState.Dragging:    					if (this.DragEnded != null)  						this.DragEnded(pos);    					break;  			}
Missing Default,Dwarrowdelf.Client,ToolTipService,C:\repos\tomba_dwarrowdelf\Client\MapControl3D\ToolTipService.cs,OnHoverTileView_PropertyChanged,The following switch statement is missing a default case: switch (e.PropertyName)  			{  				case "Location":  				case "AreaElements":  				case "IsEnabled":  					if (m_updateQueued == false)  					{  						m_control.Dispatcher.BeginInvoke(new Action(UpdateToolTip));  						m_updateQueued = true;  					}  					break;  			}
