Implementation smell,Namespace,Class,File,Method,Description
Long Statement,Gemini.Demo.Xna.Modules.SceneViewer,Module,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Modules\SceneViewer\Module.cs,Initialize,The length of the statement  "		_inspectorTool.SelectedObject = new InspectableObjectBuilder ().WithVector3Editor (sceneViewModel' x => x.Position).ToInspectableObject (); " is 139.
Magic Number,Gemini.Demo.Xna.Modules.PrimitiveList.Controls,RotatableCubeControl,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Modules\PrimitiveList\Controls\RotatableCubeControl.cs,RaiseRenderXna,The following statement contains a magic number: if (Primitive != null) {  	// Create the world-view-projection matrices for the cube and camera  	Matrix world = Matrix.CreateFromYawPitchRoll (_yaw' _pitch' 0f);  	Matrix view = Matrix.CreateLookAt (new Vector3 (0' 0' 2.5f)' Vector3.Zero' Vector3.Up);  	Matrix projection = Matrix.CreatePerspectiveFieldOfView (1' args.GraphicsDevice.Viewport.AspectRatio' 1' 10);  	// Draw a cube  	Primitive.Draw (world' view' projection' Color);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals) {  	// Get two vectors perpendicular to the face normal and to each other.  	var side1 = new Vector3 (normal.Y' normal.Z' normal.X);  	var side2 = Vector3.Cross (normal' side1);  	// Six indices (two triangles) per face.  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 1);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 3);  	// Four vertices per face.  	AddVertex ((normal - side1 - side2) * size / 2' normal);  	AddVertex ((normal - side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 - side2) * size / 2' normal);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals) {  	// Get two vectors perpendicular to the face normal and to each other.  	var side1 = new Vector3 (normal.Y' normal.Z' normal.X);  	var side2 = Vector3.Cross (normal' side1);  	// Six indices (two triangles) per face.  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 1);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 3);  	// Four vertices per face.  	AddVertex ((normal - side1 - side2) * size / 2' normal);  	AddVertex ((normal - side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 - side2) * size / 2' normal);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals) {  	// Get two vectors perpendicular to the face normal and to each other.  	var side1 = new Vector3 (normal.Y' normal.Z' normal.X);  	var side2 = Vector3.Cross (normal' side1);  	// Six indices (two triangles) per face.  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 1);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 3);  	// Four vertices per face.  	AddVertex ((normal - side1 - side2) * size / 2' normal);  	AddVertex ((normal - side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 - side2) * size / 2' normal);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals) {  	// Get two vectors perpendicular to the face normal and to each other.  	var side1 = new Vector3 (normal.Y' normal.Z' normal.X);  	var side2 = Vector3.Cross (normal' side1);  	// Six indices (two triangles) per face.  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 1);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 3);  	// Four vertices per face.  	AddVertex ((normal - side1 - side2) * size / 2' normal);  	AddVertex ((normal - side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 - side2) * size / 2' normal);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals) {  	// Get two vectors perpendicular to the face normal and to each other.  	var side1 = new Vector3 (normal.Y' normal.Z' normal.X);  	var side2 = Vector3.Cross (normal' side1);  	// Six indices (two triangles) per face.  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 1);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 3);  	// Four vertices per face.  	AddVertex ((normal - side1 - side2) * size / 2' normal);  	AddVertex ((normal - side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 - side2) * size / 2' normal);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals) {  	// Get two vectors perpendicular to the face normal and to each other.  	var side1 = new Vector3 (normal.Y' normal.Z' normal.X);  	var side2 = Vector3.Cross (normal' side1);  	// Six indices (two triangles) per face.  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 1);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 3);  	// Four vertices per face.  	AddVertex ((normal - side1 - side2) * size / 2' normal);  	AddVertex ((normal - side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 - side2) * size / 2' normal);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals) {  	// Get two vectors perpendicular to the face normal and to each other.  	var side1 = new Vector3 (normal.Y' normal.Z' normal.X);  	var side2 = Vector3.Cross (normal' side1);  	// Six indices (two triangles) per face.  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 1);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 0);  	AddIndex (CurrentVertex + 2);  	AddIndex (CurrentVertex + 3);  	// Four vertices per face.  	AddVertex ((normal - side1 - side2) * size / 2' normal);  	AddVertex ((normal - side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 + side2) * size / 2' normal);  	AddVertex ((normal + side1 - side2) * size / 2' normal);  }  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: AddIndex (CurrentVertex + 2);  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: AddIndex (CurrentVertex + 2);  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: AddIndex (CurrentVertex + 3);  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: AddVertex ((normal - side1 - side2) * size / 2' normal);  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: AddVertex ((normal - side1 + side2) * size / 2' normal);  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: AddVertex ((normal + side1 + side2) * size / 2' normal);  
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: AddVertex ((normal + side1 - side2) * size / 2' normal);  
Magic Number,Gemini.Demo.Xna.Primitives,GeometricPrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\GeometricPrimitive.cs,Draw,The following statement contains a magic number: foreach (var effectPass in effect.CurrentTechnique.Passes) {  	effectPass.Apply ();  	int primitiveCount = _indices.Count / 3;  	graphicsDevice.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0' 0' _vertices.Count' 0' primitiveCount);  }  
Magic Number,Gemini.Demo.Xna.Primitives,GeometricPrimitive,C:\repos\corick_sfml-2d-lucid\gemini-master\src\Gemini.Demo.Xna\Primitives\GeometricPrimitive.cs,Draw,The following statement contains a magic number: if (color.A < 255) {  	// Set renderstates for alpha blended rendering.  	device.BlendState = BlendState.AlphaBlend;  }  else {  	// Set renderstates for opaque rendering.  	device.BlendState = BlendState.Opaque;  }  
