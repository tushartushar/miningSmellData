Implementation smell,Namespace,Class,File,Method,Description
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The method has 379 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 138 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The method has 103 lines of code.
Long Method,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The method has 241 lines of code.
Long Method,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The method has 122 lines of code.
Long Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The method has 113 lines of code.
Long Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The method has 134 lines of code.
Long Method,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The method has 452 lines of code.
Long Method,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The method has 344 lines of code.
Long Method,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The method has 248 lines of code.
Long Method,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The method has 165 lines of code.
Long Method,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The method has 221 lines of code.
Long Method,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The method has 100 lines of code.
Complex Method,SevenZip.CommandLineParser,Parser,C:\repos\pmdcp_framework\Compression\SevenZip\CommandLineParser\CommandLineParser.cs,ParseString,Cyclomatic complexity of the method is 23
Complex Method,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 16
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 80
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 26
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,FillDistancesPrices,Cyclomatic complexity of the method is 11
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,Cyclomatic complexity of the method is 36
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 23
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,Cyclomatic complexity of the method is 13
Complex Method,PMDCP.Compression,SizeCriterion,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_Evaluate,Cyclomatic complexity of the method is 20
Complex Method,PMDCP.Compression,TimeCriterion,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,Evaluate,Cyclomatic complexity of the method is 11
Complex Method,PMDCP.Compression,TimeCriterion,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_Evaluate,Cyclomatic complexity of the method is 20
Complex Method,PMDCP.Compression,CompoundCriterion,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,Evaluate,Cyclomatic complexity of the method is 13
Complex Method,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,Cyclomatic complexity of the method is 89
Complex Method,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,SelectFiles,Cyclomatic complexity of the method is 10
Complex Method,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,Cyclomatic complexity of the method is 15
Complex Method,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,WriteEntryCore,Cyclomatic complexity of the method is 22
Complex Method,PMDCP.Compression.Tar,TarInputStream,C:\repos\pmdcp_framework\Compression\Tar\TarInputStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,PMDCP.Compression.Tar,TarInputStream,C:\repos\pmdcp_framework\Compression\Tar\TarInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 17
Complex Method,PMDCP.Compression.Tar,TarOutputStream,C:\repos\pmdcp_framework\Compression\Tar\TarOutputStream.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,Cyclomatic complexity of the method is 8
Complex Method,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,Cyclomatic complexity of the method is 13
Complex Method,PMDCP.Compression.Zip,ZipFile,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.AddUpdate.cs,AddOrUpdateDirectoryImpl,Cyclomatic complexity of the method is 13
Complex Method,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,Cyclomatic complexity of the method is 10
Complex Method,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,Cyclomatic complexity of the method is 12
Complex Method,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,TruncateBackward,Cyclomatic complexity of the method is 8
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,Cyclomatic complexity of the method is 11
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_fillWindow,Cyclomatic complexity of the method is 8
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 12
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,Cyclomatic complexity of the method is 8
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,SetDeflater,Cyclomatic complexity of the method is 9
Complex Method,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,Cyclomatic complexity of the method is 21
Complex Method,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,Cyclomatic complexity of the method is 125
Complex Method,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Flush,Cyclomatic complexity of the method is 10
Complex Method,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,Cyclomatic complexity of the method is 126
Complex Method,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,Cyclomatic complexity of the method is 22
Complex Method,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,Cyclomatic complexity of the method is 110
Complex Method,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 30
Complex Method,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,Cyclomatic complexity of the method is 9
Complex Method,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 15
Complex Method,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,Cyclomatic complexity of the method is 8
Complex Method,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,Cyclomatic complexity of the method is 16
Complex Method,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,Cyclomatic complexity of the method is 8
Complex Method,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,Read,Cyclomatic complexity of the method is 20
Long Parameter List,SevenZip.CommandLineParser,SwitchForm,C:\repos\pmdcp_framework\Compression\SevenZip\CommandLineParser\CommandLineParser.cs,SwitchForm,The method has 6 parameters.
Long Parameter List,SevenZip,ICoder,C:\repos\pmdcp_framework\Compression\SevenZip\ICoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetAsciiBytes,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Zip,SaveProgressEventArgs,C:\repos\pmdcp_framework\Compression\Zip\Events.cs,SaveProgressEventArgs,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Zip,ExtractProgressEventArgs,C:\repos\pmdcp_framework\Compression\Zip\Events.cs,ExtractProgressEventArgs,The method has 6 parameters.
Long Parameter List,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The method has 6 parameters.
Long Parameter List,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The method has 6 parameters.
Long Parameter List,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Init,The method has 6 parameters.
Long Parameter List,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The method has 8 parameters.
Long Parameter List,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The method has 11 parameters.
Long Parameter List,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters.
Long Parameter List,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Zlib,StaticTree,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,StaticTree,The method has 5 parameters.
Long Parameter List,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,ZlibBaseStream,The method has 5 parameters.
Long Identifier,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,FileSelector,The length of the parameter traverseDirectoryReparsePoints is 30.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,ReadMatchDistances,The length of the statement  "			lenRes += _matchFinder.GetMatchLen ((int)lenRes - 1' _matchDistances [numDistancePairs - 1]' Base.kMatchMaxLen - lenRes); " is 121.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetRepLen1Price,The length of the statement  "	return _isRepG0 [state.Index].GetPrice0 () + _isRep0Long [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 (); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosLenPrice,The length of the statement  "		price = _posSlotPrices [(lenToPosState << Base.kNumPosSlotBits) + GetPosSlot2 (pos)] + _alignPrices [pos & Base.kAlignMask]; " is 124.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "	_optimum [1].Price = _isMatch [(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _previousByte).GetPrice (!_state.IsCharState ()' matchByte' currentByte); " is 214.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "		UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte); " is 244.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "				UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 (); " is 162.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "					UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1)); " is 433.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 (); " is 128.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1)); " is 366.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 (); " is 128.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "			_posSlotPrices [st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 126.
Long Statement,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The length of the statement  "		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1; " is 132.
Long Statement,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The length of the statement  "			UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1; " is 132.
Long Statement,PMDCP.Compression,TimeCriterion,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,ToString,The length of the statement  "	sb.Append (Which.ToString ()).Append (" ").Append (EnumUtil.GetDescription (Operator)).Append (" ").Append (Time.ToString ("yyyy-MM-dd-HH:mm:ss")); " is 147.
Long Statement,PMDCP.Compression,CompoundCriterion,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,ToString,The length of the statement  "	sb.Append ("(").Append ((Left != null) ? Left.ToString () : "null").Append (" ").Append (Conjunction.ToString ()).Append (" ").Append ((Right != null) ? Right.ToString () : "null").Append (")"); " is 194.
Long Statement,PMDCP.Compression.Tar,TarBuffer,C:\repos\pmdcp_framework\Compression\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "		string errorText = string.Format ("TarBuffer.WriteBlock - block to write has length '{0}' which is not the block size of '{1}'"' block.Length' BlockSize); " is 154.
Long Statement,PMDCP.Compression.Tar,TarBuffer,C:\repos\pmdcp_framework\Compression\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "		string errorText = string.Format ("TarBuffer.WriteBlock - record has length '{0}' with offset '{1}' which is less than the record size of '{2}'"' buffer.Length' offset' recordSize); " is 181.
Long Statement,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,Equals,The length of the statement  "		result = (name == localHeader.name) && (mode == localHeader.mode) && (UserId == localHeader.UserId) && (GroupId == localHeader.GroupId) && (Size == localHeader.Size) && (ModTime == localHeader.ModTime) && (Checksum == localHeader.Checksum) && (TypeFlag == localHeader.TypeFlag) && (LinkName == localHeader.LinkName) && (Magic == localHeader.Magic) && (Version == localHeader.Version) && (UserName == localHeader.UserName) && (GroupName == localHeader.GroupName) && (DevMajor == localHeader.DevMajor) && (DevMinor == localHeader.DevMinor); " is 538.
Long Statement,PMDCP.Compression.Tar,TarInputStream,C:\repos\pmdcp_framework\Compression\Tar\TarInputStream.cs,GetNextEntry,The length of the statement  "			else if (header.TypeFlag != TarHeader.LF_NORMAL && header.TypeFlag != TarHeader.LF_OLDNORM && header.TypeFlag != TarHeader.LF_DIR) { " is 132.
Long Statement,PMDCP.Compression.Tar,TarInputStream,C:\repos\pmdcp_framework\Compression\Tar\TarInputStream.cs,GetNextEntry,The length of the statement  "			string errorText = string.Format ("Bad header in record {0} block {1} {2}"' tarBuffer.CurrentRecord' tarBuffer.CurrentBlock' ex.Message); " is 137.
Long Statement,PMDCP.Compression.Tar,TarOutputStream,C:\repos\pmdcp_framework\Compression\Tar\TarOutputStream.cs,CloseEntry,The length of the statement  "		string errorText = string.Format ("Entry closed at '{0}' before the '{1}' bytes specified in the header were written"' currBytes' currSize); " is 140.
Long Statement,PMDCP.Compression.Tar,TarOutputStream,C:\repos\pmdcp_framework\Compression\Tar\TarOutputStream.cs,Write,The length of the statement  "		string errorText = string.Format ("request to write '{0}' bytes exceeds size in header of '{1}' bytes"' count' this.currSize); " is 126.
Long Statement,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,DateTimeToPacked,The length of the statement  "	UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00)); " is 132.
Long Statement,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,DateTimeToPacked,The length of the statement  "	UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800)); " is 132.
Long Statement,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The length of the statement  "					throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1); " is 136.
Long Statement,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,DecryptMessage,The length of the statement  "		throw new System.ArgumentException ("Bad length during Decryption: the length parameter must be smaller than or equal to the size of the destination array."' "length"); " is 168.
Long Statement,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,EncryptMessage,The length of the statement  "		throw new System.ArgumentException ("Bad length during Encryption: The length parameter must be smaller than or equal to the size of the destination array."' "length"); " is 168.
Long Statement,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "		if (signature != ZipConstants.EndOfCentralDirectorySignature && signature != ZipConstants.Zip64EndOfCentralDirectoryRecordSignature && signature != ZipConstants.ZipEntrySignature// workitem 8299 " is 194.
Long Statement,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "			throw new BadReadException (String.Format ("  ZipEntry::ReadDirEntry(): Bad signature (0x{0:X8}) at position 0x{1:X8}"' signature' s.Position)); " is 144.
Long Statement,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "		zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256); " is 120.
Long Statement,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "		zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256); " is 122.
Long Statement,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "	zde._RelativeOffsetOfLocalHeader = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256); " is 133.
Long Statement,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "	// Console.WriteLine("  Comp / Uncomp:        0x{0:X8} ({0})   0x{1:X8} ({1})"' zde._CompressedSize' zde._UncompressedSize); " is 124.
Long Statement,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "		zde._InputUsesZip64 = (zde._CompressedSize == 0xFFFFFFFF || zde._UncompressedSize == 0xFFFFFFFF || zde._RelativeOffsetOfLocalHeader == 0xFFFFFFFF); " is 147.
Long Statement,PMDCP.Compression.Zip,ZipFile,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.AddUpdate.cs,AddOrUpdateDirectoryImpl,The length of the statement  "		StatusMessageTextWriter.WriteLine ("{0} {1}..."' (action == AddOrUpdateAction.AddOnly) ? "adding" : "Adding or updating"' directoryName); " is 137.
Long Statement,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The length of the statement  "	bool needZip64CentralDirectory = zip64 == Zip64Option.Always || countOfEntries >= 0xFFFF || SizeOfCentralDirectory > 0xFFFFFFFF || Start > 0xFFFFFFFF; " is 150.
Long Statement,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The length of the statement  "				throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property."); " is 133.
Long Statement,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The length of the statement  "				throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property."); " is 134.
Long Statement,PMDCP.Compression.Zip,ZipOutputStream,C:\repos\pmdcp_framework\Compression\Zip\ZipOutputStream.cs,_InitiateCurrentEntry,The length of the statement  "		_currentEntry.PrepOutputStream (_outputStream' finishing ? 0 : -1' out _outputCounter' out _encryptor' out _deflater' out _entryOutputStream); " is 142.
Long Statement,PMDCP.Compression.Zip,ZipOutputStream,C:\repos\pmdcp_framework\Compression\Zip\ZipOutputStream.cs,Dispose,The length of the statement  "			_directoryNeededZip64 = ZipOutput.WriteCentralDirectoryStructure (_outputStream' _entriesWritten.Values' 1' // _numberOfSegmentsForMostRecentSave' " is 146.
Long Statement,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,_NameForSegment,The length of the statement  "	return String.Format ("{0}.z{1:D2}"' Path.Combine (Path.GetDirectoryName (_baseName)' Path.GetFileNameWithoutExtension (_baseName))' diskNumber + 1); " is 149.
Long Statement,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,ToString,The length of the statement  "	return String.Format ("{0}[{1}][{2}]' pos=0x{3:X})"' "ZipSegmentedStream"' CurrentName' (rw == 1) ? "Read" : (rw == 2) ? "Write" : (rw == 3) ? "Update" : "???"' this.Position); " is 176.
Long Statement,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The length of the statement  "			if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) { " is 145.
Long Statement,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The length of the statement  "		if (window [match + best_len] != scan_end || window [match + best_len - 1] != scan_end1 || window [match] != window [scan] || window [++match] != window [scan + 1]) " is 164.
Long Statement,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The length of the statement  "		while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend); " is 334.
Long Statement,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The length of the statement  "	if (_codec.OutputBuffer == null || (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) || (status == FINISH_STATE && flush != FlushType.Finish)) { " is 155.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "			TraceOutput (TraceBits.Fill' "Fill     lock     wi({0}) stat({1}) iba({2}) nf({3})"' workitem.index' workitem.status' workitem.inputBytesAvailable' _nextToFill); " is 161.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "			if (workitem.status == (int)WorkItem.Status.None || workitem.status == (int)WorkItem.Status.Done || workitem.status == (int)WorkItem.Status.Filling) { " is 150.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "				int limit = ((workitem.buffer.Length - workitem.inputBytesAvailable) > count) ? count : (workitem.buffer.Length - workitem.inputBytesAvailable); " is 144.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "					TraceOutput (TraceBits.Fill' "Fill     QUWI     wi({0}) stat({1}) iba({2}) nf({3})"' workitem.index' workitem.status' workitem.inputBytesAvailable' _nextToFill); " is 161.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "				while (workitem.status != (int)WorkItem.Status.None && workitem.status != (int)WorkItem.Status.Done && workitem.status != (int)WorkItem.Status.Filling) { " is 153.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "					TraceOutput (TraceBits.Fill' "Fill     waiting  wi({0}) stat({1}) nf({2})"' workitem.index' workitem.status' _nextToFill); " is 122.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "					if (workitem.status == (int)WorkItem.Status.None || workitem.status == (int)WorkItem.Status.Done || workitem.status == (int)WorkItem.Status.Filling) " is 148.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,Write,The length of the statement  "						TraceOutput (TraceBits.Fill' "Fill     A-OK     wi({0}) stat({1}) iba({2}) cyc({3})"' workitem.index' workitem.status' workitem.inputBytesAvailable' wcycles); " is 158.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_Flush,The length of the statement  "			TraceOutput (TraceBits.Flush' "Flush    filled   wi({0})  iba({1}) nf({2}) nomore({3})"' workitem.index' workitem.inputBytesAvailable' _nextToFill' _noMoreInputForThisSegment); " is 176.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_Flush,The length of the statement  "			TraceOutput (TraceBits.Flush' "Flush    noaction wi({0}) stat({1}) nf({2})  nomore({3})"' workitem.index' workitem.status' _nextToFill' _noMoreInputForThisSegment); " is 164.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The length of the statement  "						TraceOutput (TraceBits.Write' "Write    drain    wi({0}) stat({1}) canuse({2})  cba({3})"' workitem.index' workitem.status' (workitem.status == (int)WorkItem.Status.Compressed)' workitem.compressedBytesAvailable); " is 213.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The length of the statement  "							TraceOutput (TraceBits.WriteBegin' "Write    begin    wi({0}) stat({1})              cba({2})"' workitem.index' workitem.status' workitem.compressedBytesAvailable); " is 164.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The length of the statement  "							TraceOutput (TraceBits.WriteDone' "Write    done     wi({0}) stat({1})              cba({2})"' workitem.index' workitem.status' workitem.compressedBytesAvailable); " is 163.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The length of the statement  "								TraceOutput (TraceBits.WriteWait' "Write    waiting  wi({0}) stat({1}) nw({2}) nf({3}) nomore({4})"' workitem.index' workitem.status' _nextToWrite' _nextToFill' _noMoreInputForThisSegment); " is 189.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The length of the statement  "									TraceOutput (TraceBits.WriteWait' "Write    A-OK     wi({0}) stat({1}) iba({2}) cba({3}) cyc({4})"' workitem.index' workitem.status' workitem.inputBytesAvailable' workitem.compressedBytesAvailable' wcycles); " is 207.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The length of the statement  "					TraceOutput (TraceBits.Write' "Write    nomore  nw({0}) nf({1}) break({2})"' _nextToWrite' _nextToFill' (_nextToWrite == _nextToFill)); " is 135.
Long Statement,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_DeflateOne,The length of the statement  "			TraceOutput (TraceBits.Compress' "Compress          wi({0}) stat({1}) len({2})"' workitem.index' workitem.status' workitem.compressedBytesAvailable); " is 149.
Long Statement,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The length of the statement  "						throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead)); " is 126.
Long Statement,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The length of the statement  "					throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected)); " is 135.
Long Statement,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The length of the statement  "					throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected)); " is 128.
Long Statement,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,Read,The length of the statement  "			throw new ZlibException (String.Format ("{0}flating:  rc={1}  msg={2}"' (_wantCompress ? "de" : "in")' rc' _z.Message)); " is 120.
Long Statement,PMDCP.Compression.Zlib,ZlibCodec,C:\repos\pmdcp_framework\Compression\Zlib\ZlibCodec.cs,flush_pending,The length of the statement  "	if (dstate.pending.Length <= dstate.nextPending || OutputBuffer.Length <= NextOut || dstate.pending.Length < (dstate.nextPending + len) || OutputBuffer.Length < (NextOut + len)) { " is 179.
Long Statement,PMDCP.Compression.Zlib,ZlibCodec,C:\repos\pmdcp_framework\Compression\Zlib\ZlibCodec.cs,flush_pending,The length of the statement  "		throw new ZlibException (String.Format ("Invalid State. (pending.Length={0}' pendingCount={1})"' dstate.pending.Length' dstate.pendingCount)); " is 142.
Complex Conditional,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The conditional expression  "(b < 8) || ((b > 13) && (b < 32)) || (b == 255)"  is complex.
Complex Conditional,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The conditional expression  "match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The conditional expression  "window [match + best_len] != scan_end || window [match + best_len - 1] != scan_end1 || window [match] != window [scan] || window [++match] != window [scan + 1]"  is complex.
Complex Conditional,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The conditional expression  "window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend"  is complex.
Complex Conditional,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The conditional expression  "_codec.OutputBuffer == null || (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) || (status == FINISH_STATE && flush != FlushType.Finish)"  is complex.
Complex Conditional,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The conditional expression  "_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != FlushType.None && status != FINISH_STATE)"  is complex.
Complex Conditional,PMDCP.Compression.Zlib,ZlibCodec,C:\repos\pmdcp_framework\Compression\Zlib\ZlibCodec.cs,flush_pending,The conditional expression  "dstate.pending.Length <= dstate.nextPending || OutputBuffer.Length <= NextOut || dstate.pending.Length < (dstate.nextPending + len) || OutputBuffer.Length < (NextOut + len)"  is complex.
Empty Catch Block,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,SelectFiles,The method has an empty catch block.
Empty Catch Block,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,SelectFiles,The method has an empty catch block.
Empty Catch Block,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadSignature,The method has an empty catch block.
Empty Catch Block,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The method has an empty catch block.
Empty Catch Block,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The method has an empty catch block.
Empty Catch Block,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The method has an empty catch block.
Magic Number,SevenZip,CRC,C:\repos\pmdcp_framework\Compression\SevenZip\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];  
Magic Number,SevenZip,CRC,C:\repos\pmdcp_framework\Compression\SevenZip\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	uint r = i;  	for (int j = 0; j < 8; j++)  		if ((r & 1) != 0)  			r = (r >> 1) ^ kPoly;  		else  			r >>= 1;  	Table [i] = r;  }  
Magic Number,SevenZip,CRC,C:\repos\pmdcp_framework\Compression\SevenZip\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	uint r = i;  	for (int j = 0; j < 8; j++)  		if ((r & 1) != 0)  			r = (r >> 1) ^ kPoly;  		else  			r >>= 1;  	Table [i] = r;  }  
Magic Number,SevenZip,CRC,C:\repos\pmdcp_framework\Compression\SevenZip\CRC.cs,CRC,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	if ((r & 1) != 0)  		r = (r >> 1) ^ kPoly;  	else  		r >>= 1;  
Magic Number,SevenZip,CRC,C:\repos\pmdcp_framework\Compression\SevenZip\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table [(((byte)(_value)) ^ b)] ^ (_value >> 8);  
Magic Number,SevenZip,CRC,C:\repos\pmdcp_framework\Compression\SevenZip\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  	_value = Table [(((byte)(_value)) ^ data [offset + i])] ^ (_value >> 8);  
Magic Number,SevenZip,CRC,C:\repos\pmdcp_framework\Compression\SevenZip\CRC.cs,Update,The following statement contains a magic number: _value = Table [(((byte)(_value)) ^ data [offset + i])] ^ (_value >> 8);  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	outputStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	outputStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Compress,The following statement contains a magic number: outputStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Decompress,The following statement contains a magic number: if (inputStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Decompress,The following statement contains a magic number: if (inputStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = inputStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = inputStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,SevenZip,SevenZipHelper,C:\repos\pmdcp_framework\Compression\SevenZip\SevenZipHelper.cs,Decompress,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize) {  	m_DictionarySize = dictionarySize;  	m_DictionarySizeCheck = Math.Max (m_DictionarySize' 1);  	uint blockSize = Math.Max (m_DictionarySizeCheck' (1 << 12));  	m_OutWindow.Create (blockSize);  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64) {  	// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  	// while(nowPos64 < next)  	{  		uint posState = (uint)nowPos64 & m_PosStateMask;  		if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			byte b;  			byte prevByte = m_OutWindow.GetByte (0);  			if (!state.IsCharState ())  				b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  			else  				b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  			m_OutWindow.PutByte (b);  			state.UpdateChar ();  			nowPos64++;  		}  		else {  			uint len;  			if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  				if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  					if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  						state.UpdateShortRep ();  						m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  						nowPos64++;  						continue;  					}  				}  				else {  					UInt32 distance;  					if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  						distance = rep1;  					}  					else {  						if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  							distance = rep2;  						else {  							distance = rep3;  							rep3 = rep2;  						}  						rep2 = rep1;  					}  					rep1 = rep0;  					rep0 = distance;  				}  				len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  				state.UpdateRep ();  			}  			else {  				rep3 = rep2;  				rep2 = rep1;  				rep1 = rep0;  				len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  				state.UpdateMatch ();  				uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  				if (posSlot >= Base.kStartPosModelIndex) {  					int numDirectBits = (int)((posSlot >> 1) - 1);  					rep0 = ((2 | (posSlot & 1)) << numDirectBits);  					if (posSlot < Base.kEndPosModelIndex)  						rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  					else {  						rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  						rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  					}  				}  				else  					rep0 = posSlot;  			}  			if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  				if (rep0 == 0xFFFFFFFF)  					break;  				throw new DataErrorException ();  			}  			m_OutWindow.CopyBlock (rep0' len);  			nowPos64 += len;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  	byte b;  	byte prevByte = m_OutWindow.GetByte (0);  	if (!state.IsCharState ())  		b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  	else  		b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  	m_OutWindow.PutByte (b);  	state.UpdateChar ();  	nowPos64++;  }  else {  	uint len;  	if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  		if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  				state.UpdateShortRep ();  				m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  				nowPos64++;  				continue;  			}  		}  		else {  			UInt32 distance;  			if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  				distance = rep1;  			}  			else {  				if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  					distance = rep2;  				else {  					distance = rep3;  					rep3 = rep2;  				}  				rep2 = rep1;  			}  			rep1 = rep0;  			rep0 = distance;  		}  		len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  		state.UpdateRep ();  	}  	else {  		rep3 = rep2;  		rep2 = rep1;  		rep1 = rep0;  		len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  		state.UpdateMatch ();  		uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  		if (posSlot >= Base.kStartPosModelIndex) {  			int numDirectBits = (int)((posSlot >> 1) - 1);  			rep0 = ((2 | (posSlot & 1)) << numDirectBits);  			if (posSlot < Base.kEndPosModelIndex)  				rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  			else {  				rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  				rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  			}  		}  		else  			rep0 = posSlot;  	}  	if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  		if (rep0 == 0xFFFFFFFF)  			break;  		throw new DataErrorException ();  	}  	m_OutWindow.CopyBlock (rep0' len);  	nowPos64 += len;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  	if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  		if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			state.UpdateShortRep ();  			m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  			nowPos64++;  			continue;  		}  	}  	else {  		UInt32 distance;  		if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			distance = rep1;  		}  		else {  			if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  				distance = rep2;  			else {  				distance = rep3;  				rep3 = rep2;  			}  			rep2 = rep1;  		}  		rep1 = rep0;  		rep0 = distance;  	}  	len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  	state.UpdateRep ();  }  else {  	rep3 = rep2;  	rep2 = rep1;  	rep1 = rep0;  	len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  	state.UpdateMatch ();  	uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  	if (posSlot >= Base.kStartPosModelIndex) {  		int numDirectBits = (int)((posSlot >> 1) - 1);  		rep0 = ((2 | (posSlot & 1)) << numDirectBits);  		if (posSlot < Base.kEndPosModelIndex)  			rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  		else {  			rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  			rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  		}  	}  	else  		rep0 = posSlot;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int numDirectBits = (int)((posSlot >> 1) - 1);  	rep0 = ((2 | (posSlot & 1)) << numDirectBits);  	if (posSlot < Base.kEndPosModelIndex)  		rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  	else {  		rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  		rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  	}  }  else  	rep0 = posSlot;  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: rep0 = ((2 | (posSlot & 1)) << numDirectBits);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++) {  	UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  	for (UInt32 j = 0; j < k; j++' c++)  		g_FastPos [c] = slotFast;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  	return g_FastPos [pos];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 20] + 40);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 20] + 40);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 26] + 52);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 26] + 52);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  	LZ.BinTree bt = new LZ.BinTree ();  	int numHashBytes = 4;  	if (_matchFinderType == EMatchFinderType.BT2)  		numHashBytes = 2;  	bt.SetType (numHashBytes);  	_matchFinder = bt;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  	LZ.BinTree bt = new LZ.BinTree ();  	int numHashBytes = 4;  	if (_matchFinderType == EMatchFinderType.BT2)  		numHashBytes = 2;  	bt.SetType (numHashBytes);  	_matchFinder = bt;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinderType == EMatchFinderType.BT2)  	numHashBytes = 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: numHashBytes = 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0) {  	lenRes = _matchDistances [numDistancePairs - 2];  	if (lenRes == _numFastBytes)  		lenRes += _matchFinder.GetMatchLen ((int)lenRes - 1' _matchDistances [numDistancePairs - 1]' Base.kMatchMaxLen - lenRes);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: lenRes = _matchDistances [numDistancePairs - 2];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0) {  	price = _isRepG0 [state.Index].GetPrice0 ();  	price += _isRep0Long [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  }  else {  	price = _isRepG0 [state.Index].GetPrice1 ();  	if (repIndex == 1)  		price += _isRepG1 [state.Index].GetPrice0 ();  	else {  		price += _isRepG1 [state.Index].GetPrice1 ();  		price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 1)  	price += _isRepG1 [state.Index].GetPrice0 ();  else {  	price += _isRepG1 [state.Index].GetPrice1 ();  	price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2) {  	backRes = 0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens [repMaxIndex] < 2) {  	backRes = (UInt32)0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens [repMaxIndex] < 2) {  	backRes = (UInt32)0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenEnd < 2) {  	backRes = _optimum [1].BackPrev;  	return 1;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [0].Backs2 = reps [2];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [0].Backs3 = reps [3];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  	_optimum [len--].Price = kIfinityPrice;  while (len >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (repLen < 2)  	continue;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  	Optimal optimum = _optimum [repLen];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = i;  		optimum.Prev1IsChar = false;  	}  }  while (--repLen >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  	Optimal optimum = _optimum [repLen];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = i;  		optimum.Prev1IsChar = false;  	}  }  while (--repLen >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens [0] >= 2) ? repLens [0] + 1 : 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens [0] >= 2) ? repLens [0] + 1 : 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  	UInt32 offs = 0;  	while (len > _matchDistances [offs])  		offs += 2;  	for (; ; len++) {  		UInt32 distance = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  		Optimal optimum = _optimum [len];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = distance + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (len == _matchDistances [offs]) {  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  	UInt32 offs = 0;  	while (len > _matchDistances [offs])  		offs += 2;  	for (; ; len++) {  		UInt32 distance = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  		Optimal optimum = _optimum [len];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = distance + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (len == _matchDistances [offs]) {  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (len > _matchDistances [offs])  	offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (; ; len++) {  	UInt32 distance = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  	Optimal optimum = _optimum [len];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = distance + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (len == _matchDistances [offs]) {  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len == _matchDistances [offs]) {  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [cur].Backs2 = reps [2];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [cur].Backs3 = reps [3];  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)  	continue;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (!nextIsChar && matchByte != currentByte) {  	// try Literal + rep0  	UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateChar ();  		UInt32 posStateNext = (position + 1) & _posStateMask;  		UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  		{  			UInt32 offset = cur + 1 + lenTest2;  			while (lenEnd < offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			Optimal optimum = _optimum [offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = false;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateChar ();  	UInt32 posStateNext = (position + 1) & _posStateMask;  	UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  	{  		UInt32 offset = cur + 1 + lenTest2;  		while (lenEnd < offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		Optimal optimum = _optimum [offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = false;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < 2)  	continue;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	while (lenEnd < cur + lenTest)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = repIndex;  		optimum.Prev1IsChar = false;  	}  }  while (--lenTest >= 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < numAvailableBytesFull) {  	UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateRep ();  		UInt32 posStateNext = (position + lenTest) & _posStateMask;  		UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  		state2.UpdateChar ();  		posStateNext = (position + lenTest + 1) & _posStateMask;  		UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  		UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  		// for(; lenTest2 >= 2; lenTest2--)  		{  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			Optimal optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = repIndex;  			}  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateRep ();  	UInt32 posStateNext = (position + lenTest) & _posStateMask;  	UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  	state2.UpdateChar ();  	posStateNext = (position + lenTest + 1) & _posStateMask;  	UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  	UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  	// for(; lenTest2 >= 2; lenTest2--)  	{  		UInt32 offset = lenTest + 1 + lenTest2;  		while (lenEnd < cur + offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		Optimal optimum = _optimum [cur + offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + lenTest + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = true;  			optimum.PosPrev2 = cur;  			optimum.BackPrev2 = repIndex;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen > numAvailableBytes) {  	newLen = numAvailableBytes;  	for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  		;  	_matchDistances [numDistancePairs] = newLen;  	numDistancePairs += 2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen > numAvailableBytes) {  	newLen = numAvailableBytes;  	for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  		;  	_matchDistances [numDistancePairs] = newLen;  	numDistancePairs += 2;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  	;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (startLen > _matchDistances [offs])  	offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 lenTest = startLen; ; lenTest++) {  	UInt32 curBack = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = curBack + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (lenTest == _matchDistances [offs]) {  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateMatch ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = curBack + Base.kNumRepDistances;  				}  			}  		}  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 lenTest = startLen; ; lenTest++) {  	UInt32 curBack = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = curBack + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (lenTest == _matchDistances [offs]) {  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateMatch ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = curBack + Base.kNumRepDistances;  				}  			}  		}  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest == _matchDistances [offs]) {  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateMatch ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = curBack + Base.kNumRepDistances;  			}  		}  	}  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest == _matchDistances [offs]) {  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateMatch ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = curBack + Base.kNumRepDistances;  			}  		}  	}  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < numAvailableBytesFull) {  	UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateMatch ();  		UInt32 posStateNext = (position + lenTest) & _posStateMask;  		UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  		state2.UpdateChar ();  		posStateNext = (position + lenTest + 1) & _posStateMask;  		UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  		UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  		UInt32 offset = lenTest + 1 + lenTest2;  		while (lenEnd < cur + offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		optimum = _optimum [cur + offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + lenTest + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = true;  			optimum.PosPrev2 = cur;  			optimum.BackPrev2 = curBack + Base.kNumRepDistances;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateMatch ();  	UInt32 posStateNext = (position + lenTest) & _posStateMask;  	UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  	state2.UpdateChar ();  	posStateNext = (position + lenTest + 1) & _posStateMask;  	UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  	UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  	UInt32 offset = lenTest + 1 + lenTest2;  	while (lenEnd < cur + offset)  		_optimum [++lenEnd].Price = kIfinityPrice;  	curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  	optimum = _optimum [cur + offset];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur + lenTest + 1;  		optimum.BackPrev = 0;  		optimum.Prev1IsChar = true;  		optimum.Prev2 = true;  		optimum.PosPrev2 = cur;  		optimum.BackPrev2 = curBack + Base.kNumRepDistances;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (len == 1 && pos == 0xFFFFFFFF) {  	_isMatch [complexState].Encode (_rangeEncoder' 0);  	Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  	LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  	if (!_state.IsCharState ()) {  		Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  		subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  	}  	else  		subCoder.Encode (_rangeEncoder' curByte);  	_previousByte = curByte;  	_state.UpdateChar ();  }  else {  	_isMatch [complexState].Encode (_rangeEncoder' 1);  	if (pos < Base.kNumRepDistances) {  		_isRep [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 0) {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  			if (len == 1)  				_isRep0Long [complexState].Encode (_rangeEncoder' 0);  			else  				_isRep0Long [complexState].Encode (_rangeEncoder' 1);  		}  		else {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 1)  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  			else {  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  				_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  			}  		}  		if (len == 1)  			_state.UpdateShortRep ();  		else {  			_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			_state.UpdateRep ();  		}  		UInt32 distance = _repDistances [pos];  		if (pos != 0) {  			for (UInt32 i = pos; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  		}  	}  	else {  		_isRep [_state.Index].Encode (_rangeEncoder' 0);  		_state.UpdateMatch ();  		_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		pos -= Base.kNumRepDistances;  		UInt32 posSlot = GetPosSlot (pos);  		UInt32 lenToPosState = Base.GetLenToPosState (len);  		_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  		if (posSlot >= Base.kStartPosModelIndex) {  			int footerBits = (int)((posSlot >> 1) - 1);  			UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  			UInt32 posReduced = pos - baseVal;  			if (posSlot < Base.kEndPosModelIndex)  				RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  			else {  				_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  				_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  				_alignPriceCount++;  			}  		}  		UInt32 distance = pos;  		for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  		_matchPriceCount++;  	}  	_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (len == 1 && pos == 0xFFFFFFFF) {  	_isMatch [complexState].Encode (_rangeEncoder' 0);  	Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  	LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  	if (!_state.IsCharState ()) {  		Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  		subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  	}  	else  		subCoder.Encode (_rangeEncoder' curByte);  	_previousByte = curByte;  	_state.UpdateChar ();  }  else {  	_isMatch [complexState].Encode (_rangeEncoder' 1);  	if (pos < Base.kNumRepDistances) {  		_isRep [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 0) {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  			if (len == 1)  				_isRep0Long [complexState].Encode (_rangeEncoder' 0);  			else  				_isRep0Long [complexState].Encode (_rangeEncoder' 1);  		}  		else {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 1)  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  			else {  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  				_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  			}  		}  		if (len == 1)  			_state.UpdateShortRep ();  		else {  			_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			_state.UpdateRep ();  		}  		UInt32 distance = _repDistances [pos];  		if (pos != 0) {  			for (UInt32 i = pos; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  		}  	}  	else {  		_isRep [_state.Index].Encode (_rangeEncoder' 0);  		_state.UpdateMatch ();  		_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		pos -= Base.kNumRepDistances;  		UInt32 posSlot = GetPosSlot (pos);  		UInt32 lenToPosState = Base.GetLenToPosState (len);  		_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  		if (posSlot >= Base.kStartPosModelIndex) {  			int footerBits = (int)((posSlot >> 1) - 1);  			UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  			UInt32 posReduced = pos - baseVal;  			if (posSlot < Base.kEndPosModelIndex)  				RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  			else {  				_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  				_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  				_alignPriceCount++;  			}  		}  		UInt32 distance = pos;  		for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  		_matchPriceCount++;  	}  	_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	_isRep [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 0) {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  		if (len == 1)  			_isRep0Long [complexState].Encode (_rangeEncoder' 0);  		else  			_isRep0Long [complexState].Encode (_rangeEncoder' 1);  	}  	else {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 1)  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  		else {  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  			_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  		}  	}  	if (len == 1)  		_state.UpdateShortRep ();  	else {  		_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		_state.UpdateRep ();  	}  	UInt32 distance = _repDistances [pos];  	if (pos != 0) {  		for (UInt32 i = pos; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  	}  }  else {  	_isRep [_state.Index].Encode (_rangeEncoder' 0);  	_state.UpdateMatch ();  	_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  	pos -= Base.kNumRepDistances;  	UInt32 posSlot = GetPosSlot (pos);  	UInt32 lenToPosState = Base.GetLenToPosState (len);  	_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  	if (posSlot >= Base.kStartPosModelIndex) {  		int footerBits = (int)((posSlot >> 1) - 1);  		UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  		UInt32 posReduced = pos - baseVal;  		if (posSlot < Base.kEndPosModelIndex)  			RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  		else {  			_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  			_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  			_alignPriceCount++;  		}  	}  	UInt32 distance = pos;  	for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  		_repDistances [i] = _repDistances [i - 1];  	_repDistances [0] = distance;  	_matchPriceCount++;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	_isRep [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 0) {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  		if (len == 1)  			_isRep0Long [complexState].Encode (_rangeEncoder' 0);  		else  			_isRep0Long [complexState].Encode (_rangeEncoder' 1);  	}  	else {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 1)  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  		else {  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  			_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  		}  	}  	if (len == 1)  		_state.UpdateShortRep ();  	else {  		_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		_state.UpdateRep ();  	}  	UInt32 distance = _repDistances [pos];  	if (pos != 0) {  		for (UInt32 i = pos; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  	}  }  else {  	_isRep [_state.Index].Encode (_rangeEncoder' 0);  	_state.UpdateMatch ();  	_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  	pos -= Base.kNumRepDistances;  	UInt32 posSlot = GetPosSlot (pos);  	UInt32 lenToPosState = Base.GetLenToPosState (len);  	_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  	if (posSlot >= Base.kStartPosModelIndex) {  		int footerBits = (int)((posSlot >> 1) - 1);  		UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  		UInt32 posReduced = pos - baseVal;  		if (posSlot < Base.kEndPosModelIndex)  			RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  		else {  			_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  			_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  			_alignPriceCount++;  		}  	}  	UInt32 distance = pos;  	for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  		_repDistances [i] = _repDistances [i - 1];  	_repDistances [0] = distance;  	_matchPriceCount++;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos == 0) {  	_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  	if (len == 1)  		_isRep0Long [complexState].Encode (_rangeEncoder' 0);  	else  		_isRep0Long [complexState].Encode (_rangeEncoder' 1);  }  else {  	_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 1)  		_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  	else {  		_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  		_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos == 1)  	_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  else {  	_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  	_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: _isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int footerBits = (int)((posSlot >> 1) - 1);  	UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  	UInt32 posReduced = pos - baseVal;  	if (posSlot < Base.kEndPosModelIndex)  		RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  	else {  		_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  		_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  		_alignPriceCount++;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_additionalOffset == 0) {  	// if (!_fastMode)  	if (_matchPriceCount >= (1 << 7))  		FillDistancesPrices ();  	if (_alignPriceCount >= Base.kAlignTableSize)  		FillAlignPrices ();  	inSize = nowPos64;  	outSize = _rangeEncoder.GetProcessedSizeAdd ();  	if (_matchFinder.GetNumAvailableBytes () == 0) {  		Flush ((UInt32)nowPos64);  		return;  	}  	if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  		_finished = false;  		finished = false;  		return;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_additionalOffset == 0) {  	// if (!_fastMode)  	if (_matchPriceCount >= (1 << 7))  		FillDistancesPrices ();  	if (_alignPriceCount >= Base.kAlignTableSize)  		FillAlignPrices ();  	inSize = nowPos64;  	outSize = _rangeEncoder.GetProcessedSizeAdd ();  	if (_matchFinder.GetNumAvailableBytes () == 0) {  		Flush ((UInt32)nowPos64);  		return;  	}  	if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  		_finished = false;  		finished = false;  		return;  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_matchPriceCount >= (1 << 7))  	FillDistancesPrices ();  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  	_finished = false;  	finished = false;  	return;  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++) {  	UInt32 posSlot = GetPosSlot (i);  	int footerBits = (int)((posSlot >> 1) - 1);  	UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  	tempPrices [i] = BitTreeEncoder.ReverseGetPrice (_posEncoders' baseVal - posSlot - 1' footerBits' i - baseVal);  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: _distTableSize = (UInt32)dicLogSize * 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 4;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kNumHashDirectBytes = 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 2 + 1;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  	throw new Exception ();  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  	_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 2);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 4);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (hs > (1 << 24))  	hs >>= 1;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch2 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  		distances [offset++] = maxLen = 2;  		distances [offset++] = _pos - curMatch2 - 1;  	}  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  	distances [offset++] = maxLen = 2;  	distances [offset++] = _pos - curMatch2 - 1;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances [offset++] = maxLen = 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  		if (curMatch3 == curMatch2)  			offset -= 2;  		distances [offset++] = maxLen = 3;  		distances [offset++] = _pos - curMatch3 - 1;  		curMatch2 = curMatch3;  	}  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  		if (curMatch3 == curMatch2)  			offset -= 2;  		distances [offset++] = maxLen = 3;  		distances [offset++] = _pos - curMatch3 - 1;  		curMatch2 = curMatch3;  	}  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  	if (curMatch3 == curMatch2)  		offset -= 2;  	distances [offset++] = maxLen = 3;  	distances [offset++] = _pos - curMatch3 - 1;  	curMatch2 = curMatch3;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  	if (curMatch3 == curMatch2)  		offset -= 2;  	distances [offset++] = maxLen = 3;  	distances [offset++] = _pos - curMatch3 - 1;  	curMatch2 = curMatch3;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 == curMatch2)  	offset -= 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances [offset++] = maxLen = 3;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (offset != 0 && curMatch2 == curMatch) {  	offset -= 2;  	maxLen = kStartMaxLen;  }  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks (_son' _cyclicBufferSize * 2' subValue);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	ShiftLow ();  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: do {  	Stream.WriteByte ((byte)(temp + (Low >> 32)));  	temp = 0xFF;  }  while (--_cacheSize != 0);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte ((byte)(temp + (Low >> 32)));  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--) {  	Range >>= 1;  	if (((v >> i) & 1) == 1)  		Low += Range;  	if (Range < kTopValue) {  		Range <<= 8;  		ShiftLow ();  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: if (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize + Stream.Position - StartPosition + 4;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue) {  	encoder.Range <<= 8;  	encoder.ShiftLow ();  }  
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\pmdcp_framework\Compression\SevenZip\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length < 3)  	throw new ArgumentException (s);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	switch (tokens [i].ToLower ()) {  	case "and":  	case "xor":  	case "or":  		state = stateStack.Peek ();  		if (state != ParseState.CriterionDone)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 3)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  		current = new CompoundCriterion {  			Left = current'  			Right = null'  			Conjunction = pendingConjunction  		};  		stateStack.Push (state);  		stateStack.Push (ParseState.ConjunctionPending);  		critStack.Push (current);  		break;  	case "(":  		state = stateStack.Peek ();  		if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		if (tokens.Length <= i + 4)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Push (ParseState.OpenParen);  		break;  	case ")":  		state = stateStack.Pop ();  		if (stateStack.Peek () != ParseState.OpenParen)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		stateStack.Pop ();  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "atime":  	case "ctime":  	case "mtime":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		DateTime t;  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  				}  				catch (FormatException) {  					try {  						t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  					}  					catch (FormatException) {  						t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  					}  				}  			}  		}  		t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  		current = new TimeCriterion {  			Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  			Time = t  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "length":  	case "size":  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		Int64 sz = 0;  		string v = tokens [i + 2];  		if (v.ToUpper ().EndsWith ("K"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  		else if (v.ToUpper ().EndsWith ("KB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  		else if (v.ToUpper ().EndsWith ("M"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("MB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("G"))  			sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  		else if (v.ToUpper ().EndsWith ("GB"))  			sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  		else  			sz = Int64.Parse (tokens [i + 2]);  		current = new SizeCriterion {  			Size = sz'  			Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  		break;  	case "filename":  	case "name":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			string m = tokens [i + 2];  			// handle single-quoted filespecs (used to include spaces in filename patterns)  			if (m.StartsWith ("'")) {  				int ix = i;  				if (!m.EndsWith ("'")) {  					do {  						i++;  						if (tokens.Length <= i + 2)  							throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  						m += " " + tokens [i + 2];  					}  					while (!tokens [i + 2].EndsWith ("'"));  				}  				// trim off leading and trailing single quotes  				m = m.Substring (1' m.Length - 2);  			}  			current = new NameCriterion {  				MatchingFileSpec = m'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "attrs":  	case "attributes":  		{  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  			if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  				throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  			current = new AttributesCriterion {  				AttributeString = tokens [i + 2]'  				Operator = c  			};  			i += 2;  			stateStack.Push (ParseState.CriterionDone);  		}  		break;  	case "":  		// NOP  		stateStack.Push (ParseState.Whitespace);  		break;  	default:  		throw new ArgumentException ("'" + tokens [i] + "'");  	}  	state = stateStack.Peek ();  	if (state == ParseState.CriterionDone) {  		stateStack.Pop ();  		if (stateStack.Peek () == ParseState.ConjunctionPending) {  			while (stateStack.Peek () == ParseState.ConjunctionPending) {  				var cc = critStack.Pop () as CompoundCriterion;  				cc.Right = current;  				current = cc;  				// mark the parent as current (walk up the tree)  				stateStack.Pop ();  				// the conjunction is no longer pending  				state = stateStack.Pop ();  				if (state != ParseState.CriterionDone)  					throw new ArgumentException ("??");  			}  		}  		else  			stateStack.Push (ParseState.CriterionDone);  		// not sure?  	}  	if (state == ParseState.Whitespace)  		stateStack.Pop ();  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tokens [i].ToLower ()) {  case "and":  case "xor":  case "or":  	state = stateStack.Peek ();  	if (state != ParseState.CriterionDone)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 3)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	pendingConjunction = (LogicalConjunction)Enum.Parse (typeof(LogicalConjunction)' tokens [i].ToUpper ());  	current = new CompoundCriterion {  		Left = current'  		Right = null'  		Conjunction = pendingConjunction  	};  	stateStack.Push (state);  	stateStack.Push (ParseState.ConjunctionPending);  	critStack.Push (current);  	break;  case "(":  	state = stateStack.Peek ();  	if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	if (tokens.Length <= i + 4)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Push (ParseState.OpenParen);  	break;  case ")":  	state = stateStack.Pop ();  	if (stateStack.Peek () != ParseState.OpenParen)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	stateStack.Pop ();  	stateStack.Push (ParseState.CriterionDone);  	break;  case "atime":  case "ctime":  case "mtime":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	DateTime t;  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  			}  			catch (FormatException) {  				try {  					t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  				}  				catch (FormatException) {  					t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  				}  			}  		}  	}  	t = DateTime.SpecifyKind (t' DateTimeKind.Local).ToUniversalTime ();  	current = new TimeCriterion {  		Which = (WhichTime)Enum.Parse (typeof(WhichTime)' tokens [i])'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])'  		Time = t  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "length":  case "size":  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  	Int64 sz = 0;  	string v = tokens [i + 2];  	if (v.ToUpper ().EndsWith ("K"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  	else if (v.ToUpper ().EndsWith ("KB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  	else if (v.ToUpper ().EndsWith ("M"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("MB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("G"))  		sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  	else if (v.ToUpper ().EndsWith ("GB"))  		sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  	else  		sz = Int64.Parse (tokens [i + 2]);  	current = new SizeCriterion {  		Size = sz'  		Operator = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1])  	};  	i += 2;  	stateStack.Push (ParseState.CriterionDone);  	break;  case "filename":  case "name":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		string m = tokens [i + 2];  		// handle single-quoted filespecs (used to include spaces in filename patterns)  		if (m.StartsWith ("'")) {  			int ix = i;  			if (!m.EndsWith ("'")) {  				do {  					i++;  					if (tokens.Length <= i + 2)  						throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  					m += " " + tokens [i + 2];  				}  				while (!tokens [i + 2].EndsWith ("'"));  			}  			// trim off leading and trailing single quotes  			m = m.Substring (1' m.Length - 2);  		}  		current = new NameCriterion {  			MatchingFileSpec = m'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "attrs":  case "attributes":  	{  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		ComparisonOperator c = (ComparisonOperator)EnumUtil.Parse (typeof(ComparisonOperator)' tokens [i + 1]);  		if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)  			throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  		current = new AttributesCriterion {  			AttributeString = tokens [i + 2]'  			Operator = c  		};  		i += 2;  		stateStack.Push (ParseState.CriterionDone);  	}  	break;  case "":  	// NOP  	stateStack.Push (ParseState.Whitespace);  	break;  default:  	throw new ArgumentException ("'" + tokens [i] + "'");  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length <= i + 3)  	throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length <= i + 4)  	throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length <= i + 2)  	throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  			}  			catch (FormatException) {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  			}  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  			}  			catch (FormatException) {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  			}  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  			}  			catch (FormatException) {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  			}  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  			}  			catch (FormatException) {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  			}  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  		}  		catch (FormatException) {  			try {  				t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  			}  			catch (FormatException) {  				t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  			}  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  		}  		catch (FormatException) {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  		}  		catch (FormatException) {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  		}  		catch (FormatException) {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  	}  	catch (FormatException) {  		try {  			t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  		}  		catch (FormatException) {  			t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  		}  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  	}  	catch (FormatException) {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  	}  	catch (FormatException) {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  }  catch (FormatException) {  	try {  		t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  	}  	catch (FormatException) {  		t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  	}  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: t = DateTime.ParseExact (tokens [i + 2]' "yyyy/MM/dd"' null);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  }  catch (FormatException) {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: try {  	t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  }  catch (FormatException) {  	t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: t = DateTime.ParseExact (tokens [i + 2]' "MM/dd/yyyy"' null);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: t = DateTime.ParseExact (tokens [i + 2]' "yyyy-MM-dd"' null);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: i += 2;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length <= i + 2)  	throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("K"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  else if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("KB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  else if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("M"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("MB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("G"))  	sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  else if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 1)) * 1024 * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (v.ToUpper ().EndsWith ("GB"))  	sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  else  	sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (v.Substring (0' v.Length - 2)) * 1024 * 1024 * 1024;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: sz = Int64.Parse (tokens [i + 2]);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: i += 2;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length <= i + 2)  	throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (m.StartsWith ("'")) {  	int ix = i;  	if (!m.EndsWith ("'")) {  		do {  			i++;  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  			m += " " + tokens [i + 2];  		}  		while (!tokens [i + 2].EndsWith ("'"));  	}  	// trim off leading and trailing single quotes  	m = m.Substring (1' m.Length - 2);  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (m.StartsWith ("'")) {  	int ix = i;  	if (!m.EndsWith ("'")) {  		do {  			i++;  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  			m += " " + tokens [i + 2];  		}  		while (!tokens [i + 2].EndsWith ("'"));  	}  	// trim off leading and trailing single quotes  	m = m.Substring (1' m.Length - 2);  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (m.StartsWith ("'")) {  	int ix = i;  	if (!m.EndsWith ("'")) {  		do {  			i++;  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  			m += " " + tokens [i + 2];  		}  		while (!tokens [i + 2].EndsWith ("'"));  	}  	// trim off leading and trailing single quotes  	m = m.Substring (1' m.Length - 2);  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (m.StartsWith ("'")) {  	int ix = i;  	if (!m.EndsWith ("'")) {  		do {  			i++;  			if (tokens.Length <= i + 2)  				throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  			m += " " + tokens [i + 2];  		}  		while (!tokens [i + 2].EndsWith ("'"));  	}  	// trim off leading and trailing single quotes  	m = m.Substring (1' m.Length - 2);  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (!m.EndsWith ("'")) {  	do {  		i++;  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  		m += " " + tokens [i + 2];  	}  	while (!tokens [i + 2].EndsWith ("'"));  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (!m.EndsWith ("'")) {  	do {  		i++;  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  		m += " " + tokens [i + 2];  	}  	while (!tokens [i + 2].EndsWith ("'"));  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (!m.EndsWith ("'")) {  	do {  		i++;  		if (tokens.Length <= i + 2)  			throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  		m += " " + tokens [i + 2];  	}  	while (!tokens [i + 2].EndsWith ("'"));  }  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: do {  	i++;  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  	m += " " + tokens [i + 2];  }  while (!tokens [i + 2].EndsWith ("'"));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: do {  	i++;  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  	m += " " + tokens [i + 2];  }  while (!tokens [i + 2].EndsWith ("'"));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: do {  	i++;  	if (tokens.Length <= i + 2)  		throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  	m += " " + tokens [i + 2];  }  while (!tokens [i + 2].EndsWith ("'"));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length <= i + 2)  	throw new ArgumentException (String.Join (" "' tokens' ix' tokens.Length - ix));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: m += " " + tokens [i + 2];  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: m = m.Substring (1' m.Length - 2);  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: i += 2;  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: if (tokens.Length <= i + 2)  	throw new ArgumentException (String.Join (" "' tokens' i' tokens.Length - i));  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: current = new AttributesCriterion {  	AttributeString = tokens [i + 2]'  	Operator = c  };  
Magic Number,PMDCP.Compression,FileSelector,C:\repos\pmdcp_framework\Compression\Zip\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: i += 2;  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  	EnsureDirectoryExists (destFile);  }  else {  	string parentDirectory = Path.GetDirectoryName (destFile);  	EnsureDirectoryExists (parentDirectory);  	bool process = true;  	FileInfo fileInfo = new FileInfo (destFile);  	if (fileInfo.Exists) {  		if (keepOldFiles) {  			OnProgressMessageEvent (entry' "Destination file already exists");  			process = false;  		}  		else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  			OnProgressMessageEvent (entry' "Destination file already exists' and is read-only");  			process = false;  		}  	}  	if (process) {  		bool asciiTrans = false;  		Stream outputStream = File.Create (destFile);  		if (this.asciiTranslate) {  			asciiTrans = !IsBinary (destFile);  		}  		StreamWriter outw = null;  		if (asciiTrans) {  			outw = new StreamWriter (outputStream);  		}  		byte[] rdbuf = new byte[32 * 1024];  		while (true) {  			int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  			if (numRead <= 0) {  				break;  			}  			if (asciiTrans) {  				for (int off = 0' b = 0; b < numRead; ++b) {  					if (rdbuf [b] == 10) {  						string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  						outw.WriteLine (s);  						off = b + 1;  					}  				}  			}  			else {  				outputStream.Write (rdbuf' 0' numRead);  			}  		}  		if (asciiTrans) {  			outw.Close ();  		}  		else {  			outputStream.Close ();  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  	EnsureDirectoryExists (destFile);  }  else {  	string parentDirectory = Path.GetDirectoryName (destFile);  	EnsureDirectoryExists (parentDirectory);  	bool process = true;  	FileInfo fileInfo = new FileInfo (destFile);  	if (fileInfo.Exists) {  		if (keepOldFiles) {  			OnProgressMessageEvent (entry' "Destination file already exists");  			process = false;  		}  		else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  			OnProgressMessageEvent (entry' "Destination file already exists' and is read-only");  			process = false;  		}  	}  	if (process) {  		bool asciiTrans = false;  		Stream outputStream = File.Create (destFile);  		if (this.asciiTranslate) {  			asciiTrans = !IsBinary (destFile);  		}  		StreamWriter outw = null;  		if (asciiTrans) {  			outw = new StreamWriter (outputStream);  		}  		byte[] rdbuf = new byte[32 * 1024];  		while (true) {  			int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  			if (numRead <= 0) {  				break;  			}  			if (asciiTrans) {  				for (int off = 0' b = 0; b < numRead; ++b) {  					if (rdbuf [b] == 10) {  						string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  						outw.WriteLine (s);  						off = b + 1;  					}  				}  			}  			else {  				outputStream.Write (rdbuf' 0' numRead);  			}  		}  		if (asciiTrans) {  			outw.Close ();  		}  		else {  			outputStream.Close ();  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  	EnsureDirectoryExists (destFile);  }  else {  	string parentDirectory = Path.GetDirectoryName (destFile);  	EnsureDirectoryExists (parentDirectory);  	bool process = true;  	FileInfo fileInfo = new FileInfo (destFile);  	if (fileInfo.Exists) {  		if (keepOldFiles) {  			OnProgressMessageEvent (entry' "Destination file already exists");  			process = false;  		}  		else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  			OnProgressMessageEvent (entry' "Destination file already exists' and is read-only");  			process = false;  		}  	}  	if (process) {  		bool asciiTrans = false;  		Stream outputStream = File.Create (destFile);  		if (this.asciiTranslate) {  			asciiTrans = !IsBinary (destFile);  		}  		StreamWriter outw = null;  		if (asciiTrans) {  			outw = new StreamWriter (outputStream);  		}  		byte[] rdbuf = new byte[32 * 1024];  		while (true) {  			int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  			if (numRead <= 0) {  				break;  			}  			if (asciiTrans) {  				for (int off = 0' b = 0; b < numRead; ++b) {  					if (rdbuf [b] == 10) {  						string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  						outw.WriteLine (s);  						off = b + 1;  					}  				}  			}  			else {  				outputStream.Write (rdbuf' 0' numRead);  			}  		}  		if (asciiTrans) {  			outw.Close ();  		}  		else {  			outputStream.Close ();  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (process) {  	bool asciiTrans = false;  	Stream outputStream = File.Create (destFile);  	if (this.asciiTranslate) {  		asciiTrans = !IsBinary (destFile);  	}  	StreamWriter outw = null;  	if (asciiTrans) {  		outw = new StreamWriter (outputStream);  	}  	byte[] rdbuf = new byte[32 * 1024];  	while (true) {  		int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  		if (numRead <= 0) {  			break;  		}  		if (asciiTrans) {  			for (int off = 0' b = 0; b < numRead; ++b) {  				if (rdbuf [b] == 10) {  					string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  					outw.WriteLine (s);  					off = b + 1;  				}  			}  		}  		else {  			outputStream.Write (rdbuf' 0' numRead);  		}  	}  	if (asciiTrans) {  		outw.Close ();  	}  	else {  		outputStream.Close ();  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (process) {  	bool asciiTrans = false;  	Stream outputStream = File.Create (destFile);  	if (this.asciiTranslate) {  		asciiTrans = !IsBinary (destFile);  	}  	StreamWriter outw = null;  	if (asciiTrans) {  		outw = new StreamWriter (outputStream);  	}  	byte[] rdbuf = new byte[32 * 1024];  	while (true) {  		int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  		if (numRead <= 0) {  			break;  		}  		if (asciiTrans) {  			for (int off = 0' b = 0; b < numRead; ++b) {  				if (rdbuf [b] == 10) {  					string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  					outw.WriteLine (s);  					off = b + 1;  				}  			}  		}  		else {  			outputStream.Write (rdbuf' 0' numRead);  		}  	}  	if (asciiTrans) {  		outw.Close ();  	}  	else {  		outputStream.Close ();  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (process) {  	bool asciiTrans = false;  	Stream outputStream = File.Create (destFile);  	if (this.asciiTranslate) {  		asciiTrans = !IsBinary (destFile);  	}  	StreamWriter outw = null;  	if (asciiTrans) {  		outw = new StreamWriter (outputStream);  	}  	byte[] rdbuf = new byte[32 * 1024];  	while (true) {  		int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  		if (numRead <= 0) {  			break;  		}  		if (asciiTrans) {  			for (int off = 0' b = 0; b < numRead; ++b) {  				if (rdbuf [b] == 10) {  					string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  					outw.WriteLine (s);  					off = b + 1;  				}  			}  		}  		else {  			outputStream.Write (rdbuf' 0' numRead);  		}  	}  	if (asciiTrans) {  		outw.Close ();  	}  	else {  		outputStream.Close ();  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: while (true) {  	int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  	if (numRead <= 0) {  		break;  	}  	if (asciiTrans) {  		for (int off = 0' b = 0; b < numRead; ++b) {  			if (rdbuf [b] == 10) {  				string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  				outw.WriteLine (s);  				off = b + 1;  			}  		}  	}  	else {  		outputStream.Write (rdbuf' 0' numRead);  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (asciiTrans) {  	for (int off = 0' b = 0; b < numRead; ++b) {  		if (rdbuf [b] == 10) {  			string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  			outw.WriteLine (s);  			off = b + 1;  		}  	}  }  else {  	outputStream.Write (rdbuf' 0' numRead);  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: for (int off = 0' b = 0; b < numRead; ++b) {  	if (rdbuf [b] == 10) {  		string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  		outw.WriteLine (s);  		off = b + 1;  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (rdbuf [b] == 10) {  	string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  	outw.WriteLine (s);  	off = b + 1;  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: if (entry.IsDirectory) {  	if (recurse) {  		TarEntry[] list = entry.GetDirectoryEntries ();  		for (int i = 0; i < list.Length; ++i) {  			WriteEntryCore (list [i]' recurse);  		}  	}  }  else {  	using (Stream inputStream = File.OpenRead (entryFilename)) {  		byte[] localBuffer = new byte[32 * 1024];  		while (true) {  			int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  			if (numRead <= 0) {  				break;  			}  			tarOut.Write (localBuffer' 0' numRead);  		}  	}  	if ((tempFileName != null) && (tempFileName.Length > 0)) {  		File.Delete (tempFileName);  	}  	tarOut.CloseEntry ();  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: if (entry.IsDirectory) {  	if (recurse) {  		TarEntry[] list = entry.GetDirectoryEntries ();  		for (int i = 0; i < list.Length; ++i) {  			WriteEntryCore (list [i]' recurse);  		}  	}  }  else {  	using (Stream inputStream = File.OpenRead (entryFilename)) {  		byte[] localBuffer = new byte[32 * 1024];  		while (true) {  			int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  			if (numRead <= 0) {  				break;  			}  			tarOut.Write (localBuffer' 0' numRead);  		}  	}  	if ((tempFileName != null) && (tempFileName.Length > 0)) {  		File.Delete (tempFileName);  	}  	tarOut.CloseEntry ();  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: using (Stream inputStream = File.OpenRead (entryFilename)) {  	byte[] localBuffer = new byte[32 * 1024];  	while (true) {  		int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  		if (numRead <= 0) {  			break;  		}  		tarOut.Write (localBuffer' 0' numRead);  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: using (Stream inputStream = File.OpenRead (entryFilename)) {  	byte[] localBuffer = new byte[32 * 1024];  	while (true) {  		int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  		if (numRead <= 0) {  			break;  		}  		tarOut.Write (localBuffer' 0' numRead);  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,PMDCP.Compression.Tar,TarArchive,C:\repos\pmdcp_framework\Compression\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,PMDCP.Compression.Tar,TarEntry,C:\repos\pmdcp_framework\Compression\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Directory.Exists (file)) {  	header.Mode = 1003;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_DIR;  	if ((header.Name.Length == 0) || header.Name [header.Name.Length - 1] != '/') {  		header.Name = header.Name + "/";  	}  	header.Size = 0;  }  else {  	header.Mode = 33216;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_NORMAL;  	header.Size = new FileInfo (file.Replace ('/'' Path.DirectorySeparatorChar)).Length;  }  
Magic Number,PMDCP.Compression.Tar,TarEntry,C:\repos\pmdcp_framework\Compression\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Directory.Exists (file)) {  	header.Mode = 1003;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_DIR;  	if ((header.Name.Length == 0) || header.Name [header.Name.Length - 1] != '/') {  		header.Name = header.Name + "/";  	}  	header.Size = 0;  }  else {  	header.Mode = 33216;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_NORMAL;  	header.Size = new FileInfo (file.Replace ('/'' Path.DirectorySeparatorChar)).Length;  }  
Magic Number,PMDCP.Compression.Tar,TarEntry,C:\repos\pmdcp_framework\Compression\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: header.Mode = 1003;  
Magic Number,PMDCP.Compression.Tar,TarEntry,C:\repos\pmdcp_framework\Compression\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: header.Mode = 33216;  
Magic Number,PMDCP.Compression.Tar,TarEntry,C:\repos\pmdcp_framework\Compression\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;  
Magic Number,PMDCP.Compression.Tar,TarEntry,C:\repos\pmdcp_framework\Compression\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,ParseOctal,The following statement contains a magic number: for (int i = offset; i < end; ++i) {  	if (header [i] == 0) {  		break;  	}  	if (header [i] == (byte)' ' || header [i] == '0') {  		if (stillPadding) {  			continue;  		}  		if (header [i] == (byte)' ') {  			break;  		}  	}  	stillPadding = false;  	result = (result << 3) + (header [i] - '0');  }  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,ParseOctal,The following statement contains a magic number: result = (result << 3) + (header [i] - '0');  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  	for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  		buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  		v >>= 3;  	}  }  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  	for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  		buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  		v >>= 3;  	}  }  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  	buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  	v >>= 3;  }  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  	buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  	v >>= 3;  }  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  
Magic Number,PMDCP.Compression.Tar,TarHeader,C:\repos\pmdcp_framework\Compression\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: v >>= 3;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,SimplifyFwdSlashPath,The following statement contains a magic number: if (path.StartsWith ("./"))  	path = path.Substring (2);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,SimplifyFwdSlashPath,The following statement contains a magic number: path = path.Substring (2);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: if ((pathName.Length >= 2) && ((pathName [1] == ':') && (pathName [2] == '\\')))  	pathName = pathName.Substring (3);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: if ((pathName.Length >= 2) && ((pathName [1] == ':') && (pathName [2] == '\\')))  	pathName = pathName.Substring (3);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: if ((pathName.Length >= 2) && ((pathName [1] == ':') && (pathName [2] == '\\')))  	pathName = pathName.Substring (3);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: pathName = pathName.Substring (3);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: try {  	x = _ReadFourBytes (s' "nul");  	if (x == ZipConstants.ZipEntryDataDescriptorSignature) {  		// advance past data descriptor - 12 bytes if not zip64  		s.Seek (12' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  		if (x != ZipConstants.ZipEntrySignature) {  			// Maybe zip64 was in use for the prior entry.  			// Therefore' skip another 8 bytes.  			s.Seek (8' SeekOrigin.Current);  			x = _ReadFourBytes (s' "nul");  			if (x != ZipConstants.ZipEntrySignature) {  				// seek back to the first spot  				s.Seek (-24' SeekOrigin.Current);  				x = _ReadFourBytes (s' "nul");  			}  		}  	}  }  catch (BadReadException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: try {  	x = _ReadFourBytes (s' "nul");  	if (x == ZipConstants.ZipEntryDataDescriptorSignature) {  		// advance past data descriptor - 12 bytes if not zip64  		s.Seek (12' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  		if (x != ZipConstants.ZipEntrySignature) {  			// Maybe zip64 was in use for the prior entry.  			// Therefore' skip another 8 bytes.  			s.Seek (8' SeekOrigin.Current);  			x = _ReadFourBytes (s' "nul");  			if (x != ZipConstants.ZipEntrySignature) {  				// seek back to the first spot  				s.Seek (-24' SeekOrigin.Current);  				x = _ReadFourBytes (s' "nul");  			}  		}  	}  }  catch (BadReadException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: try {  	x = _ReadFourBytes (s' "nul");  	if (x == ZipConstants.ZipEntryDataDescriptorSignature) {  		// advance past data descriptor - 12 bytes if not zip64  		s.Seek (12' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  		if (x != ZipConstants.ZipEntrySignature) {  			// Maybe zip64 was in use for the prior entry.  			// Therefore' skip another 8 bytes.  			s.Seek (8' SeekOrigin.Current);  			x = _ReadFourBytes (s' "nul");  			if (x != ZipConstants.ZipEntrySignature) {  				// seek back to the first spot  				s.Seek (-24' SeekOrigin.Current);  				x = _ReadFourBytes (s' "nul");  			}  		}  	}  }  catch (BadReadException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: if (x == ZipConstants.ZipEntryDataDescriptorSignature) {  	// advance past data descriptor - 12 bytes if not zip64  	s.Seek (12' SeekOrigin.Current);  	x = _ReadFourBytes (s' "nul");  	if (x != ZipConstants.ZipEntrySignature) {  		// Maybe zip64 was in use for the prior entry.  		// Therefore' skip another 8 bytes.  		s.Seek (8' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  		if (x != ZipConstants.ZipEntrySignature) {  			// seek back to the first spot  			s.Seek (-24' SeekOrigin.Current);  			x = _ReadFourBytes (s' "nul");  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: if (x == ZipConstants.ZipEntryDataDescriptorSignature) {  	// advance past data descriptor - 12 bytes if not zip64  	s.Seek (12' SeekOrigin.Current);  	x = _ReadFourBytes (s' "nul");  	if (x != ZipConstants.ZipEntrySignature) {  		// Maybe zip64 was in use for the prior entry.  		// Therefore' skip another 8 bytes.  		s.Seek (8' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  		if (x != ZipConstants.ZipEntrySignature) {  			// seek back to the first spot  			s.Seek (-24' SeekOrigin.Current);  			x = _ReadFourBytes (s' "nul");  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: if (x == ZipConstants.ZipEntryDataDescriptorSignature) {  	// advance past data descriptor - 12 bytes if not zip64  	s.Seek (12' SeekOrigin.Current);  	x = _ReadFourBytes (s' "nul");  	if (x != ZipConstants.ZipEntrySignature) {  		// Maybe zip64 was in use for the prior entry.  		// Therefore' skip another 8 bytes.  		s.Seek (8' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  		if (x != ZipConstants.ZipEntrySignature) {  			// seek back to the first spot  			s.Seek (-24' SeekOrigin.Current);  			x = _ReadFourBytes (s' "nul");  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek (12' SeekOrigin.Current);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: if (x != ZipConstants.ZipEntrySignature) {  	// Maybe zip64 was in use for the prior entry.  	// Therefore' skip another 8 bytes.  	s.Seek (8' SeekOrigin.Current);  	x = _ReadFourBytes (s' "nul");  	if (x != ZipConstants.ZipEntrySignature) {  		// seek back to the first spot  		s.Seek (-24' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: if (x != ZipConstants.ZipEntrySignature) {  	// Maybe zip64 was in use for the prior entry.  	// Therefore' skip another 8 bytes.  	s.Seek (8' SeekOrigin.Current);  	x = _ReadFourBytes (s' "nul");  	if (x != ZipConstants.ZipEntrySignature) {  		// seek back to the first spot  		s.Seek (-24' SeekOrigin.Current);  		x = _ReadFourBytes (s' "nul");  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek (8' SeekOrigin.Current);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: if (x != ZipConstants.ZipEntrySignature) {  	// seek back to the first spot  	s.Seek (-24' SeekOrigin.Current);  	x = _ReadFourBytes (s' "nul");  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek (-24' SeekOrigin.Current);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes [0] = (byte)(SignatureToFind >> 24);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes [1] = (byte)((SignatureToFind & 0x00FF0000) >> 16);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes [2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes [2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes [3] = (byte)(SignatureToFind & 0x000000FF);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: do {  	n = stream.Read (batch' 0' batch.Length);  	if (n != 0) {  		for (int i = 0; i < n; i++) {  			if (batch [i] == targetBytes [3]) {  				long curPosition = stream.Position;  				stream.Seek (i - n' System.IO.SeekOrigin.Current);  				// workitem 7711  				int sig = ReadSignature (stream);  				success = (sig == SignatureToFind);  				if (!success) {  					stream.Seek (curPosition' System.IO.SeekOrigin.Begin);  				}  				else  					break;  				// out of for loop  			}  		}  	}  	else  		break;  	if (success)  		break;  }  while (true);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: if (n != 0) {  	for (int i = 0; i < n; i++) {  		if (batch [i] == targetBytes [3]) {  			long curPosition = stream.Position;  			stream.Seek (i - n' System.IO.SeekOrigin.Current);  			// workitem 7711  			int sig = ReadSignature (stream);  			success = (sig == SignatureToFind);  			if (!success) {  				stream.Seek (curPosition' System.IO.SeekOrigin.Begin);  			}  			else  				break;  			// out of for loop  		}  	}  }  else  	break;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (batch [i] == targetBytes [3]) {  		long curPosition = stream.Position;  		stream.Seek (i - n' System.IO.SeekOrigin.Current);  		// workitem 7711  		int sig = ReadSignature (stream);  		success = (sig == SignatureToFind);  		if (!success) {  			stream.Seek (curPosition' System.IO.SeekOrigin.Begin);  		}  		else  			break;  		// out of for loop  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,FindSignature,The following statement contains a magic number: if (batch [i] == targetBytes [3]) {  	long curPosition = stream.Position;  	stream.Seek (i - n' System.IO.SeekOrigin.Current);  	// workitem 7711  	int sig = ReadSignature (stream);  	success = (sig == SignatureToFind);  	if (!success) {  		stream.Seek (curPosition' System.IO.SeekOrigin.Begin);  	}  	else  		break;  	// out of for loop  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (packedDateTime == 0xFFFF || packedDateTime == 0)  	return new System.DateTime (1995' 1' 1' 0' 0' 0' 0);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: return new System.DateTime (1995' 1' 1' 0' 0' 0' 0);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (second >= 60) {  	minute++;  	second = 0;  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (minute >= 60) {  	hour++;  	minute = 0;  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (hour >= 24) {  	day++;  	hour = 0;  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	if (year == 1980 && (month == 0 || day == 0)) {  		try {  			d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  			try {  				d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  				success = true;  			}  			catch (System.ArgumentOutOfRangeException) {  			}  		}  	}  	// workitem 8814  	// my god' I can't believe how many different ways applications  	// can mess up a simple date format.  	else {  		try {  			while (year < 1980)  				year++;  			while (year > 2030)  				year--;  			while (month < 1)  				month++;  			while (month > 12)  				month--;  			while (day < 1)  				day++;  			while (day > 28)  				day--;  			while (minute < 0)  				minute++;  			while (minute > 59)  				minute--;  			while (second < 0)  				second++;  			while (second > 59)  				second--;  			d = new System.DateTime (year' month' day' hour' minute' second' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (year == 1980 && (month == 0 || day == 0)) {  	try {  		d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  		try {  			d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  			success = true;  		}  		catch (System.ArgumentOutOfRangeException) {  		}  	}  }  // workitem 8814  // my god' I can't believe how many different ways applications  // can mess up a simple date format.  else {  	try {  		while (year < 1980)  			year++;  		while (year > 2030)  			year--;  		while (month < 1)  			month++;  		while (month > 12)  			month--;  		while (day < 1)  			day++;  		while (day > 28)  			day--;  		while (minute < 0)  			minute++;  		while (minute > 59)  			minute--;  		while (second < 0)  			second++;  		while (second > 59)  			second--;  		d = new System.DateTime (year' month' day' hour' minute' second' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	try {  		d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  	try {  		d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  		success = true;  	}  	catch (System.ArgumentOutOfRangeException) {  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: d = new System.DateTime (1980' 1' 1' hour' minute' second' 0);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: d = new System.DateTime (1980' 1' 1' 0' 0' 0' 0);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	while (year < 1980)  		year++;  	while (year > 2030)  		year--;  	while (month < 1)  		month++;  	while (month > 12)  		month--;  	while (day < 1)  		day++;  	while (day > 28)  		day--;  	while (minute < 0)  		minute++;  	while (minute > 59)  		minute--;  	while (second < 0)  		second++;  	while (second > 59)  		second--;  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	while (year < 1980)  		year++;  	while (year > 2030)  		year--;  	while (month < 1)  		month++;  	while (month > 12)  		month--;  	while (day < 1)  		day++;  	while (day > 28)  		day--;  	while (minute < 0)  		minute++;  	while (minute > 59)  		minute--;  	while (second < 0)  		second++;  	while (second > 59)  		second--;  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	while (year < 1980)  		year++;  	while (year > 2030)  		year--;  	while (month < 1)  		month++;  	while (month > 12)  		month--;  	while (day < 1)  		day++;  	while (day > 28)  		day--;  	while (minute < 0)  		minute++;  	while (minute > 59)  		minute--;  	while (second < 0)  		second++;  	while (second > 59)  		second--;  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	while (year < 1980)  		year++;  	while (year > 2030)  		year--;  	while (month < 1)  		month++;  	while (month > 12)  		month--;  	while (day < 1)  		day++;  	while (day > 28)  		day--;  	while (minute < 0)  		minute++;  	while (minute > 59)  		minute--;  	while (second < 0)  		second++;  	while (second > 59)  		second--;  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	while (year < 1980)  		year++;  	while (year > 2030)  		year--;  	while (month < 1)  		month++;  	while (month > 12)  		month--;  	while (day < 1)  		day++;  	while (day > 28)  		day--;  	while (minute < 0)  		minute++;  	while (minute > 59)  		minute--;  	while (second < 0)  		second++;  	while (second > 59)  		second--;  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: try {  	while (year < 1980)  		year++;  	while (year > 2030)  		year--;  	while (month < 1)  		month++;  	while (month > 12)  		month--;  	while (day < 1)  		day++;  	while (day > 28)  		day--;  	while (minute < 0)  		minute++;  	while (minute > 59)  		minute--;  	while (second < 0)  		second++;  	while (second > 59)  		second--;  	d = new System.DateTime (year' month' day' hour' minute' second' 0);  	success = true;  }  catch (System.ArgumentOutOfRangeException) {  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: while (year < 1980)  	year++;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: while (year > 2030)  	year--;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: while (month > 12)  	month--;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: while (day > 28)  	day--;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: while (minute > 59)  	minute--;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: while (second > 59)  	second--;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,CreateAndOpenUniqueTempFile,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	try {  		filename = Path.Combine (dir' InternalGetTempFileName ());  		fs = new FileStream (filename' FileMode.CreateNew);  		return;  	}  	catch (IOException) {  		if (i == 2)  			throw;  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,CreateAndOpenUniqueTempFile,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	try {  		filename = Path.Combine (dir' InternalGetTempFileName ());  		fs = new FileStream (filename' FileMode.CreateNew);  		return;  	}  	catch (IOException) {  		if (i == 2)  			throw;  	}  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,CreateAndOpenUniqueTempFile,The following statement contains a magic number: try {  	filename = Path.Combine (dir' InternalGetTempFileName ());  	fs = new FileStream (filename' FileMode.CreateNew);  	return;  }  catch (IOException) {  	if (i == 2)  		throw;  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,CreateAndOpenUniqueTempFile,The following statement contains a magic number: if (i == 2)  	throw;  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,InternalGetTempFileName,The following statement contains a magic number: return "DotNetZip-" + Path.GetRandomFileName ().Substring (0' 8) + ".tmp";  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: do {  	try {  		n = s.Read (buffer' offset' count);  		done = true;  	}  	catch (System.IO.IOException ioexc1) {  		#if !NETCF  		// Check if we can call GetHRForException'  		// which makes unmanaged code calls.  		var p = new SecurityPermission (SecurityPermissionFlag.UnmanagedCode);  		if (p.IsUnrestricted ()) {  			#endif  			uint hresult = _HRForException (ioexc1);  			if (hresult != 0x80070021)  				// ERROR_LOCK_VIOLATION  				throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  			retries++;  			if (retries > 10)  				throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  			// max time waited on last retry = 250 + 10*550 = 5.75s  			// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  			System.Threading.Thread.Sleep (250 + retries * 550);  			#if !NETCF  		}  		else {  			// The permission.Demand() failed. Therefore' we cannot call  			// GetHRForException' and cannot do the subtle handling of  			// ERROR_LOCK_VIOLATION.  Just bail.  			throw;  		}  		#endif  	}  }  while (!done);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: do {  	try {  		n = s.Read (buffer' offset' count);  		done = true;  	}  	catch (System.IO.IOException ioexc1) {  		#if !NETCF  		// Check if we can call GetHRForException'  		// which makes unmanaged code calls.  		var p = new SecurityPermission (SecurityPermissionFlag.UnmanagedCode);  		if (p.IsUnrestricted ()) {  			#endif  			uint hresult = _HRForException (ioexc1);  			if (hresult != 0x80070021)  				// ERROR_LOCK_VIOLATION  				throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  			retries++;  			if (retries > 10)  				throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  			// max time waited on last retry = 250 + 10*550 = 5.75s  			// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  			System.Threading.Thread.Sleep (250 + retries * 550);  			#if !NETCF  		}  		else {  			// The permission.Demand() failed. Therefore' we cannot call  			// GetHRForException' and cannot do the subtle handling of  			// ERROR_LOCK_VIOLATION.  Just bail.  			throw;  		}  		#endif  	}  }  while (!done);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: do {  	try {  		n = s.Read (buffer' offset' count);  		done = true;  	}  	catch (System.IO.IOException ioexc1) {  		#if !NETCF  		// Check if we can call GetHRForException'  		// which makes unmanaged code calls.  		var p = new SecurityPermission (SecurityPermissionFlag.UnmanagedCode);  		if (p.IsUnrestricted ()) {  			#endif  			uint hresult = _HRForException (ioexc1);  			if (hresult != 0x80070021)  				// ERROR_LOCK_VIOLATION  				throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  			retries++;  			if (retries > 10)  				throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  			// max time waited on last retry = 250 + 10*550 = 5.75s  			// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  			System.Threading.Thread.Sleep (250 + retries * 550);  			#if !NETCF  		}  		else {  			// The permission.Demand() failed. Therefore' we cannot call  			// GetHRForException' and cannot do the subtle handling of  			// ERROR_LOCK_VIOLATION.  Just bail.  			throw;  		}  		#endif  	}  }  while (!done);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: try {  	n = s.Read (buffer' offset' count);  	done = true;  }  catch (System.IO.IOException ioexc1) {  	#if !NETCF  	// Check if we can call GetHRForException'  	// which makes unmanaged code calls.  	var p = new SecurityPermission (SecurityPermissionFlag.UnmanagedCode);  	if (p.IsUnrestricted ()) {  		#endif  		uint hresult = _HRForException (ioexc1);  		if (hresult != 0x80070021)  			// ERROR_LOCK_VIOLATION  			throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  		retries++;  		if (retries > 10)  			throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  		// max time waited on last retry = 250 + 10*550 = 5.75s  		// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  		System.Threading.Thread.Sleep (250 + retries * 550);  		#if !NETCF  	}  	else {  		// The permission.Demand() failed. Therefore' we cannot call  		// GetHRForException' and cannot do the subtle handling of  		// ERROR_LOCK_VIOLATION.  Just bail.  		throw;  	}  	#endif  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: try {  	n = s.Read (buffer' offset' count);  	done = true;  }  catch (System.IO.IOException ioexc1) {  	#if !NETCF  	// Check if we can call GetHRForException'  	// which makes unmanaged code calls.  	var p = new SecurityPermission (SecurityPermissionFlag.UnmanagedCode);  	if (p.IsUnrestricted ()) {  		#endif  		uint hresult = _HRForException (ioexc1);  		if (hresult != 0x80070021)  			// ERROR_LOCK_VIOLATION  			throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  		retries++;  		if (retries > 10)  			throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  		// max time waited on last retry = 250 + 10*550 = 5.75s  		// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  		System.Threading.Thread.Sleep (250 + retries * 550);  		#if !NETCF  	}  	else {  		// The permission.Demand() failed. Therefore' we cannot call  		// GetHRForException' and cannot do the subtle handling of  		// ERROR_LOCK_VIOLATION.  Just bail.  		throw;  	}  	#endif  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: try {  	n = s.Read (buffer' offset' count);  	done = true;  }  catch (System.IO.IOException ioexc1) {  	#if !NETCF  	// Check if we can call GetHRForException'  	// which makes unmanaged code calls.  	var p = new SecurityPermission (SecurityPermissionFlag.UnmanagedCode);  	if (p.IsUnrestricted ()) {  		#endif  		uint hresult = _HRForException (ioexc1);  		if (hresult != 0x80070021)  			// ERROR_LOCK_VIOLATION  			throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  		retries++;  		if (retries > 10)  			throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  		// max time waited on last retry = 250 + 10*550 = 5.75s  		// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  		System.Threading.Thread.Sleep (250 + retries * 550);  		#if !NETCF  	}  	else {  		// The permission.Demand() failed. Therefore' we cannot call  		// GetHRForException' and cannot do the subtle handling of  		// ERROR_LOCK_VIOLATION.  Just bail.  		throw;  	}  	#endif  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: if (p.IsUnrestricted ()) {  	#endif  	uint hresult = _HRForException (ioexc1);  	if (hresult != 0x80070021)  		// ERROR_LOCK_VIOLATION  		throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  	retries++;  	if (retries > 10)  		throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  	// max time waited on last retry = 250 + 10*550 = 5.75s  	// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  	System.Threading.Thread.Sleep (250 + retries * 550);  	#if !NETCF  }  else {  	// The permission.Demand() failed. Therefore' we cannot call  	// GetHRForException' and cannot do the subtle handling of  	// ERROR_LOCK_VIOLATION.  Just bail.  	throw;  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: if (p.IsUnrestricted ()) {  	#endif  	uint hresult = _HRForException (ioexc1);  	if (hresult != 0x80070021)  		// ERROR_LOCK_VIOLATION  		throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  	retries++;  	if (retries > 10)  		throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  	// max time waited on last retry = 250 + 10*550 = 5.75s  	// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  	System.Threading.Thread.Sleep (250 + retries * 550);  	#if !NETCF  }  else {  	// The permission.Demand() failed. Therefore' we cannot call  	// GetHRForException' and cannot do the subtle handling of  	// ERROR_LOCK_VIOLATION.  Just bail.  	throw;  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: if (p.IsUnrestricted ()) {  	#endif  	uint hresult = _HRForException (ioexc1);  	if (hresult != 0x80070021)  		// ERROR_LOCK_VIOLATION  		throw new System.IO.IOException (String.Format ("Cannot read file {0}"' FileName)' ioexc1);  	retries++;  	if (retries > 10)  		throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  	// max time waited on last retry = 250 + 10*550 = 5.75s  	// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s  	System.Threading.Thread.Sleep (250 + retries * 550);  	#if !NETCF  }  else {  	// The permission.Demand() failed. Therefore' we cannot call  	// GetHRForException' and cannot do the subtle handling of  	// ERROR_LOCK_VIOLATION.  Just bail.  	throw;  }  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: if (retries > 10)  	throw new System.IO.IOException (String.Format ("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: System.Threading.Thread.Sleep (250 + retries * 550);  
Magic Number,PMDCP.Compression.Zip,SharedUtilities,C:\repos\pmdcp_framework\Compression\Zip\Shared.cs,ReadWithRetry,The following statement contains a magic number: System.Threading.Thread.Sleep (250 + retries * 550);  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: e._WeakEncryptionHeader = new byte[12];  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if (DecryptedHeader [11] != (byte)((e._Crc32 >> 24) & 0xff)) {  	// In the case that bit 3 of the general purpose bit flag is set to  	// indicate the presence of an 'Extended File Header' or a 'data  	// descriptor' (signature 0x08074b50)' the last byte of the decrypted  	// header is sometimes compared with the high-order byte of the  	// lastmodified time' rather than the high-order byte of the CRC' to  	// verify the password.  	//  	// This is not documented in the PKWare Appnote.txt.    	// This was discovered this by analysis of the Crypt.c source file in the InfoZip library  	// http://www.info-zip.org/pub/infozip/  	if ((e._BitField & 0x0008) != 0x0008) {  		throw new BadPasswordException ("The password did not match.");  	}  	else if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  		throw new BadPasswordException ("The password did not match.");  	}  	// We have a good password.   }  else {  	// A-OK  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if (DecryptedHeader [11] != (byte)((e._Crc32 >> 24) & 0xff)) {  	// In the case that bit 3 of the general purpose bit flag is set to  	// indicate the presence of an 'Extended File Header' or a 'data  	// descriptor' (signature 0x08074b50)' the last byte of the decrypted  	// header is sometimes compared with the high-order byte of the  	// lastmodified time' rather than the high-order byte of the CRC' to  	// verify the password.  	//  	// This is not documented in the PKWare Appnote.txt.    	// This was discovered this by analysis of the Crypt.c source file in the InfoZip library  	// http://www.info-zip.org/pub/infozip/  	if ((e._BitField & 0x0008) != 0x0008) {  		throw new BadPasswordException ("The password did not match.");  	}  	else if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  		throw new BadPasswordException ("The password did not match.");  	}  	// We have a good password.   }  else {  	// A-OK  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if (DecryptedHeader [11] != (byte)((e._Crc32 >> 24) & 0xff)) {  	// In the case that bit 3 of the general purpose bit flag is set to  	// indicate the presence of an 'Extended File Header' or a 'data  	// descriptor' (signature 0x08074b50)' the last byte of the decrypted  	// header is sometimes compared with the high-order byte of the  	// lastmodified time' rather than the high-order byte of the CRC' to  	// verify the password.  	//  	// This is not documented in the PKWare Appnote.txt.    	// This was discovered this by analysis of the Crypt.c source file in the InfoZip library  	// http://www.info-zip.org/pub/infozip/  	if ((e._BitField & 0x0008) != 0x0008) {  		throw new BadPasswordException ("The password did not match.");  	}  	else if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  		throw new BadPasswordException ("The password did not match.");  	}  	// We have a good password.   }  else {  	// A-OK  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if (DecryptedHeader [11] != (byte)((e._Crc32 >> 24) & 0xff)) {  	// In the case that bit 3 of the general purpose bit flag is set to  	// indicate the presence of an 'Extended File Header' or a 'data  	// descriptor' (signature 0x08074b50)' the last byte of the decrypted  	// header is sometimes compared with the high-order byte of the  	// lastmodified time' rather than the high-order byte of the CRC' to  	// verify the password.  	//  	// This is not documented in the PKWare Appnote.txt.    	// This was discovered this by analysis of the Crypt.c source file in the InfoZip library  	// http://www.info-zip.org/pub/infozip/  	if ((e._BitField & 0x0008) != 0x0008) {  		throw new BadPasswordException ("The password did not match.");  	}  	else if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  		throw new BadPasswordException ("The password did not match.");  	}  	// We have a good password.   }  else {  	// A-OK  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if ((e._BitField & 0x0008) != 0x0008) {  	throw new BadPasswordException ("The password did not match.");  }  else if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  	throw new BadPasswordException ("The password did not match.");  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if ((e._BitField & 0x0008) != 0x0008) {  	throw new BadPasswordException ("The password did not match.");  }  else if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  	throw new BadPasswordException ("The password did not match.");  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  	throw new BadPasswordException ("The password did not match.");  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,ForRead,The following statement contains a magic number: if (DecryptedHeader [11] != (byte)((e._TimeBlob >> 8) & 0xff)) {  	throw new BadPasswordException ("The password did not match.");  }  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys [2] = (UInt32)crc32.ComputeCrc32 ((int)_Keys [2]' (byte)(_Keys [1] >> 24));  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys [2] = (UInt32)crc32.ComputeCrc32 ((int)_Keys [2]' (byte)(_Keys [1] >> 24));  
Magic Number,PMDCP.Compression.Zip,ZipCrypto,C:\repos\pmdcp_framework\Compression\Zip\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys [2] = (UInt32)crc32.ComputeCrc32 ((int)_Keys [2]' (byte)(_Keys [1] >> 24));  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if (IsNotValidZipDirEntrySig (signature)) {  	s.Seek (-4' System.IO.SeekOrigin.Current);  	// Getting "not a ZipDirEntry signature" here is not always wrong or an  	// error.  This can happen when walking through a zipfile.  After the  	// last ZipDirEntry' we expect to read an  	// EndOfCentralDirectorySignature.  When we get this is how we know  	// we've reached the end of the central directory.  	if (signature != ZipConstants.EndOfCentralDirectorySignature && signature != ZipConstants.Zip64EndOfCentralDirectoryRecordSignature && signature != ZipConstants.ZipEntrySignature// workitem 8299  	) {  		throw new BadReadException (String.Format ("  ZipEntry::ReadDirEntry(): Bad signature (0x{0:X8}) at position 0x{1:X8}"' signature' s.Position));  	}  	return null;  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: s.Seek (-4' System.IO.SeekOrigin.Current);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: unchecked {  	zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  	zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  	zde._BitField = (short)(block [i++] + block [i++] * 256);  	zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  	zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._LastModified = PMDCP.Compression.Zip.SharedUtilities.PackedToDateTime (zde._TimeBlob);  	zde._timestamp |= ZipEntryTimestamp.DOS;  	zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  	zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  	zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionMadeBy = (short)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionNeeded = (short)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._BitField = (short)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressionMethod = (Int16)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._filenameLength = (short)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._extraFieldLength = (short)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._commentLength = (short)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._diskNumber = (UInt32)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._InternalFileAttrs = (short)(block [i++] + block [i++] * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block [i++] + block [i++] * 256 + block [i++] * 256 * 256 + block [i++] * 256 * 256 * 256);  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if (zde._Encryption == EncryptionAlgorithm.PkzipWeak) {  	// the "encryption header" of 12 bytes precedes the file data  	zde._CompressedFileDataSize -= 12;  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedFileDataSize -= 12;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if ((zde._BitField & 0x0008) == 0x0008) {  	// sig' CRC' Comp and Uncomp sizes  	if (zde._InputUsesZip64)  		zde._LengthOfTrailer += 24;  	else  		zde._LengthOfTrailer += 16;  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if ((zde._BitField & 0x0008) == 0x0008) {  	// sig' CRC' Comp and Uncomp sizes  	if (zde._InputUsesZip64)  		zde._LengthOfTrailer += 24;  	else  		zde._LengthOfTrailer += 16;  }  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if (zde._InputUsesZip64)  	zde._LengthOfTrailer += 24;  else  	zde._LengthOfTrailer += 16;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if (zde._InputUsesZip64)  	zde._LengthOfTrailer += 24;  else  	zde._LengthOfTrailer += 16;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._LengthOfTrailer += 24;  
Magic Number,PMDCP.Compression.Zip,ZipEntry,C:\repos\pmdcp_framework\Compression\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._LengthOfTrailer += 16;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (needZip64CentralDirectory) {  	if (zip64 == Zip64Option.Never) {  		#if NETCF  		                    throw new ZipException("The archive requires a ZIP64 Central Directory. Consider enabling ZIP64 extensions."); #else  		System.Diagnostics.StackFrame sf = new System.Diagnostics.StackFrame (1);  		if (sf.GetMethod ().DeclaringType == typeof(ZipFile))  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property.");  		else  			throw new ZipException ("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property.");  		#endif  	}  	a = GenZip64EndOfCentralDirectory (Start' Finish' countOfEntries' numSegments);  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  	if (startSegment != 0) {  		UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  		int i = 16;  		// number of this disk  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		// number of the disk with the start of the central directory  		//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i = 60;  		// offset 60  		// number of the disk with the start of the zip64 eocd  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  		i += 4;  		i += 8;  		// offset 72  		// total number of disks  		Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	}  	s.Write (a' 0' a.Length);  }  else  	a2 = GenCentralDirectoryFooter (Start' Finish' zip64' countOfEntries' comment' encoding);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	UInt32 thisSegment = zss.ComputeSegment (a.Length + a2.Length);  	int i = 16;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes(startSegment)' 0' a' i' 4);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i = 60;  	// offset 60  	// number of the disk with the start of the zip64 eocd  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  	i += 4;  	i += 8;  	// offset 72  	// total number of disks  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i = 60;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 8;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	// The assumption is the central directory is never split across  	// segment boundaries.  	UInt16 thisSegment = (UInt16)zss.ComputeSegment (a2.Length);  	int i = 4;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes((UInt16)startSegment)' 0' a2' i' 2);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	// The assumption is the central directory is never split across  	// segment boundaries.  	UInt16 thisSegment = (UInt16)zss.ComputeSegment (a2.Length);  	int i = 4;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes((UInt16)startSegment)' 0' a2' i' 2);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	// The assumption is the central directory is never split across  	// segment boundaries.  	UInt16 thisSegment = (UInt16)zss.ComputeSegment (a2.Length);  	int i = 4;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes((UInt16)startSegment)' 0' a2' i' 2);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	// The assumption is the central directory is never split across  	// segment boundaries.  	UInt16 thisSegment = (UInt16)zss.ComputeSegment (a2.Length);  	int i = 4;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes((UInt16)startSegment)' 0' a2' i' 2);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: if (startSegment != 0) {  	// The assumption is the central directory is never split across  	// segment boundaries.  	UInt16 thisSegment = (UInt16)zss.ComputeSegment (a2.Length);  	int i = 4;  	// number of this disk  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  	// number of the disk with the start of the central directory  	//Array.Copy(BitConverter.GetBytes((UInt16)startSegment)' 0' a2' i' 2);  	Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  	i += 2;  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 2;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (thisSegment)' 0' a2' i' 2);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 2;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: Array.Copy (sig' 0' bytes' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (entryCount >= 0xFFFF || zip64 == Zip64Option.Always) {  	// the ZIP64 version.  	for (j = 0; j < 4; j++)  		bytes [i++] = 0xFF;  }  else {  	// the standard version.  	// total number of entries in the central dir on this disk  	bytes [i++] = (byte)(entryCount & 0x00FF);  	bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  	// total number of entries in the central directory  	bytes [i++] = (byte)(entryCount & 0x00FF);  	bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (entryCount >= 0xFFFF || zip64 == Zip64Option.Always) {  	// the ZIP64 version.  	for (j = 0; j < 4; j++)  		bytes [i++] = 0xFF;  }  else {  	// the standard version.  	// total number of entries in the central dir on this disk  	bytes [i++] = (byte)(entryCount & 0x00FF);  	bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  	// total number of entries in the central directory  	bytes [i++] = (byte)(entryCount & 0x00FF);  	bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (entryCount >= 0xFFFF || zip64 == Zip64Option.Always) {  	// the ZIP64 version.  	for (j = 0; j < 4; j++)  		bytes [i++] = 0xFF;  }  else {  	// the standard version.  	// total number of entries in the central dir on this disk  	bytes [i++] = (byte)(entryCount & 0x00FF);  	bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  	// total number of entries in the central directory  	bytes [i++] = (byte)(entryCount & 0x00FF);  	bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: for (j = 0; j < 4; j++)  	bytes [i++] = 0xFF;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((entryCount & 0xFF00) >> 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (SizeOfCentralDirectory >= 0xFFFFFFFF || StartOfCentralDirectory >= 0xFFFFFFFF) {  	// The actual data is in the ZIP64 central directory structure  	for (j = 0; j < 8; j++)  		bytes [i++] = 0xFF;  }  else {  	// size of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(SizeOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  	// offset of the start of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(StartOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (SizeOfCentralDirectory >= 0xFFFFFFFF || StartOfCentralDirectory >= 0xFFFFFFFF) {  	// The actual data is in the ZIP64 central directory structure  	for (j = 0; j < 8; j++)  		bytes [i++] = 0xFF;  }  else {  	// size of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(SizeOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  	// offset of the start of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(StartOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (SizeOfCentralDirectory >= 0xFFFFFFFF || StartOfCentralDirectory >= 0xFFFFFFFF) {  	// The actual data is in the ZIP64 central directory structure  	for (j = 0; j < 8; j++)  		bytes [i++] = 0xFF;  }  else {  	// size of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(SizeOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  	// offset of the start of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(StartOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (SizeOfCentralDirectory >= 0xFFFFFFFF || StartOfCentralDirectory >= 0xFFFFFFFF) {  	// The actual data is in the ZIP64 central directory structure  	for (j = 0; j < 8; j++)  		bytes [i++] = 0xFF;  }  else {  	// size of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(SizeOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  	// offset of the start of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(StartOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (SizeOfCentralDirectory >= 0xFFFFFFFF || StartOfCentralDirectory >= 0xFFFFFFFF) {  	// The actual data is in the ZIP64 central directory structure  	for (j = 0; j < 8; j++)  		bytes [i++] = 0xFF;  }  else {  	// size of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(SizeOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  	// offset of the start of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(StartOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (SizeOfCentralDirectory >= 0xFFFFFFFF || StartOfCentralDirectory >= 0xFFFFFFFF) {  	// The actual data is in the ZIP64 central directory structure  	for (j = 0; j < 8; j++)  		bytes [i++] = 0xFF;  }  else {  	// size of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(SizeOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  	// offset of the start of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(StartOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (SizeOfCentralDirectory >= 0xFFFFFFFF || StartOfCentralDirectory >= 0xFFFFFFFF) {  	// The actual data is in the ZIP64 central directory structure  	for (j = 0; j < 8; j++)  		bytes [i++] = 0xFF;  }  else {  	// size of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(SizeOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  	// offset of the start of the central directory (we just get the low 4 bytes)  	bytes [i++] = (byte)(StartOfCentralDirectory & 0x000000FF);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  	bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: for (j = 0; j < 8; j++)  	bytes [i++] = 0xFF;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((SizeOfCentralDirectory & 0x0000FF00) >> 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((SizeOfCentralDirectory & 0x00FF0000) >> 16);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((SizeOfCentralDirectory & 0xFF000000) >> 24);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((StartOfCentralDirectory & 0x0000FF00) >> 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((StartOfCentralDirectory & 0x00FF0000) >> 16);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((StartOfCentralDirectory & 0xFF000000) >> 24);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if ((comment == null) || (comment.Length == 0)) {  	// no comment!  	bytes [i++] = (byte)0;  	bytes [i++] = (byte)0;  }  else {  	// the size of our buffer defines the max length of the comment we can write  	if (commentLength + i + 2 > bytes.Length)  		commentLength = (Int16)(bytes.Length - i - 2);  	bytes [i++] = (byte)(commentLength & 0x00FF);  	bytes [i++] = (byte)((commentLength & 0xFF00) >> 8);  	if (commentLength != 0) {  		// now actually write the comment itself into the byte buffer  		for (j = 0; (j < commentLength) && (i + j < bytes.Length); j++) {  			bytes [i + j] = block [j];  		}  		i += j;  	}  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if ((comment == null) || (comment.Length == 0)) {  	// no comment!  	bytes [i++] = (byte)0;  	bytes [i++] = (byte)0;  }  else {  	// the size of our buffer defines the max length of the comment we can write  	if (commentLength + i + 2 > bytes.Length)  		commentLength = (Int16)(bytes.Length - i - 2);  	bytes [i++] = (byte)(commentLength & 0x00FF);  	bytes [i++] = (byte)((commentLength & 0xFF00) >> 8);  	if (commentLength != 0) {  		// now actually write the comment itself into the byte buffer  		for (j = 0; (j < commentLength) && (i + j < bytes.Length); j++) {  			bytes [i + j] = block [j];  		}  		i += j;  	}  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if ((comment == null) || (comment.Length == 0)) {  	// no comment!  	bytes [i++] = (byte)0;  	bytes [i++] = (byte)0;  }  else {  	// the size of our buffer defines the max length of the comment we can write  	if (commentLength + i + 2 > bytes.Length)  		commentLength = (Int16)(bytes.Length - i - 2);  	bytes [i++] = (byte)(commentLength & 0x00FF);  	bytes [i++] = (byte)((commentLength & 0xFF00) >> 8);  	if (commentLength != 0) {  		// now actually write the comment itself into the byte buffer  		for (j = 0; (j < commentLength) && (i + j < bytes.Length); j++) {  			bytes [i + j] = block [j];  		}  		i += j;  	}  }  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (commentLength + i + 2 > bytes.Length)  	commentLength = (Int16)(bytes.Length - i - 2);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: if (commentLength + i + 2 > bytes.Length)  	commentLength = (Int16)(bytes.Length - i - 2);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: commentLength = (Int16)(bytes.Length - i - 2);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: bytes [i++] = (byte)((commentLength & 0xFF00) >> 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (sig' 0' bytes' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (DataSize)' 0' bytes' i' 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: bytes [i++] = 45;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: bytes [i++] = 45;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	bytes [i++] = 0x00;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (numberOfEntries)' 0' bytes' i' 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (numberOfEntries)' 0' bytes' i' 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (SizeofCentraldirectory)' 0' bytes' i' 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (StartOfCentralDirectory)' 0' bytes' i' 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (sig' 0' bytes' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (x2)' 0' bytes' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (EndOfCentralDirectory)' 0' bytes' i' 8);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (numSegments - 1)' 0' bytes' i' 4);  
Magic Number,PMDCP.Compression.Zip,ZipOutput,C:\repos\pmdcp_framework\Compression\Zip\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zip,ZipInputStream,C:\repos\pmdcp_framework\Compression\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if (_findRequired) {  	// find the next signature  	long d = SharedUtilities.FindSignature (_inputStream' ZipConstants.ZipEntrySignature);  	if (d == -1)  		return null;  	// back up 4 bytes: ReadEntry assumes the file pointer is positioned before the entry signature  	_inputStream.Seek (-4' SeekOrigin.Current);  }  
Magic Number,PMDCP.Compression.Zip,ZipInputStream,C:\repos\pmdcp_framework\Compression\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: _inputStream.Seek (-4' SeekOrigin.Current);  
Magic Number,PMDCP.Compression.Zip,ZipOutputStream,C:\repos\pmdcp_framework\Compression\Zip\ZipOutputStream.cs,_InitiateCurrentEntry,The following statement contains a magic number: if (_entryCount > 65534 && _zip64 == Zip64Option.Never) {  	_exceptionPending = true;  	throw new System.InvalidOperationException ("Too many entries. Consider setting ZipOutputStream.EnableZip64.");  }  
Magic Number,PMDCP.Compression.Zip,ZipOutputStream,C:\repos\pmdcp_framework\Compression\Zip\ZipOutputStream.cs,_InitiateCurrentEntry,The following statement contains a magic number: _currentEntry.WriteHeader (_outputStream' finishing ? 99 : 0);  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,ToString,The following statement contains a magic number: return String.Format ("{0}[{1}][{2}]' pos=0x{3:X})"' "ZipSegmentedStream"' CurrentName' (rw == 1) ? "Read" : (rw == 2) ? "Write" : (rw == 3) ? "Update" : "???"' this.Position);  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,ToString,The following statement contains a magic number: return String.Format ("{0}[{1}][{2}]' pos=0x{3:X})"' "ZipSegmentedStream"' CurrentName' (rw == 1) ? "Read" : (rw == 2) ? "Write" : (rw == 3) ? "Update" : "???"' this.Position);  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,_SetWriteStream,The following statement contains a magic number: if (CurrentSegment == 0)  	_innerStream.Write (BitConverter.GetBytes (ZipConstants.SplitArchiveSignature)' 0' 4);  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,_SetWriteStream,The following statement contains a magic number: _innerStream.Write (BitConverter.GetBytes (ZipConstants.SplitArchiveSignature)' 0' 4);  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,Write,The following statement contains a magic number: if (rw == 2) {  	if (ContiguousWrite) {  		// enough space for a contiguous write?  		if (_innerStream.Position + count > _maxSegmentSize) {  			//Console.WriteLine("Inc for Contiguous ({0}) p(0x{1:X}) c(0x{2:X}) sz(0x{3:X})"'  			//                  CurrentName' _innerStream.Position' count' _maxSegmentSize);  			_SetWriteStream (1);  		}  	}  	else {  		while (_innerStream.Position + count > _maxSegmentSize) {  			int c = unchecked(_maxSegmentSize - (int)_innerStream.Position);  			//Console.WriteLine("ZipSegmentedStream::Write[{0}] pos(0x{1:X}) off(0x{2:X}) c(0x{3:X})"'  			//        CurrentName' _innerStream.Position'  offset' c);  			_innerStream.Write (buffer' offset' c);  			//Console.WriteLine("All Full ({0}) p(0x{1:X}) c(0x{2:X}) sz(0x{3:X})"'  			//                  CurrentName' _innerStream.Position' count' _maxSegmentSize);  			_SetWriteStream (1);  			count -= c;  			offset += c;  		}  	}  	//Console.WriteLine("ZipSegmentedStream::Write[{0}] pos(0x{1:X}) off(0x{2:X}) c(0x{3:X})"'  	//                  CurrentName' _innerStream.Position' offset' count);  	_innerStream.Write (buffer' offset' count);  }  else if (rw == 3) {  	// updating a segment.  There is no possibility for rollover  	_innerStream.Write (buffer' offset' count);  }  else  	throw new ZipException ("Stream Error: Cannot Write.");  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,Write,The following statement contains a magic number: if (rw == 2) {  	if (ContiguousWrite) {  		// enough space for a contiguous write?  		if (_innerStream.Position + count > _maxSegmentSize) {  			//Console.WriteLine("Inc for Contiguous ({0}) p(0x{1:X}) c(0x{2:X}) sz(0x{3:X})"'  			//                  CurrentName' _innerStream.Position' count' _maxSegmentSize);  			_SetWriteStream (1);  		}  	}  	else {  		while (_innerStream.Position + count > _maxSegmentSize) {  			int c = unchecked(_maxSegmentSize - (int)_innerStream.Position);  			//Console.WriteLine("ZipSegmentedStream::Write[{0}] pos(0x{1:X}) off(0x{2:X}) c(0x{3:X})"'  			//        CurrentName' _innerStream.Position'  offset' c);  			_innerStream.Write (buffer' offset' c);  			//Console.WriteLine("All Full ({0}) p(0x{1:X}) c(0x{2:X}) sz(0x{3:X})"'  			//                  CurrentName' _innerStream.Position' count' _maxSegmentSize);  			_SetWriteStream (1);  			count -= c;  			offset += c;  		}  	}  	//Console.WriteLine("ZipSegmentedStream::Write[{0}] pos(0x{1:X}) off(0x{2:X}) c(0x{3:X})"'  	//                  CurrentName' _innerStream.Position' offset' count);  	_innerStream.Write (buffer' offset' count);  }  else if (rw == 3) {  	// updating a segment.  There is no possibility for rollover  	_innerStream.Write (buffer' offset' count);  }  else  	throw new ZipException ("Stream Error: Cannot Write.");  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,Write,The following statement contains a magic number: if (rw == 3) {  	// updating a segment.  There is no possibility for rollover  	_innerStream.Write (buffer' offset' count);  }  else  	throw new ZipException ("Stream Error: Cannot Write.");  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,TruncateBackward,The following statement contains a magic number: if (rw != 2)  	throw new ZipException ("bad state.");  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,TruncateBackward,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	try {  		_currentTempName = SharedUtilities.InternalGetTempFileName ();  		File.Move (CurrentName' _currentTempName);  		// move the .z0x file back to a temp name  	}  	catch (IOException) {  		if (i == 2)  			throw;  	}  }  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,TruncateBackward,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	try {  		_currentTempName = SharedUtilities.InternalGetTempFileName ();  		File.Move (CurrentName' _currentTempName);  		// move the .z0x file back to a temp name  	}  	catch (IOException) {  		if (i == 2)  			throw;  	}  }  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,TruncateBackward,The following statement contains a magic number: try {  	_currentTempName = SharedUtilities.InternalGetTempFileName ();  	File.Move (CurrentName' _currentTempName);  	// move the .z0x file back to a temp name  }  catch (IOException) {  	if (i == 2)  		throw;  }  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,TruncateBackward,The following statement contains a magic number: if (i == 2)  	throw;  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,SetLength,The following statement contains a magic number: if (rw != 2)  	throw new NotImplementedException ();  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,Close,The following statement contains a magic number: if (_innerStream != null) {  	_innerStream.Close ();  	_innerStream = null;  	if (rw == 2) {  		if (File.Exists (CurrentName))  			File.Delete (CurrentName);  		if (File.Exists (_currentTempName)) {  			File.Move (_currentTempName' CurrentName);  		}  	}  }  
Magic Number,PMDCP.Compression.Zip,ZipSegmentedStream,C:\repos\pmdcp_framework\Compression\Zip\ZipSegmentedStream.cs,Close,The following statement contains a magic number: if (rw == 2) {  	if (File.Exists (CurrentName))  		File.Delete (CurrentName);  	if (File.Exists (_currentTempName)) {  		File.Move (_currentTempName' CurrentName);  	}  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table [(W ^ B) & 0xFF] ^ (W >> 8));  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	int x = offset + i;  	_RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table [(block [x]) ^ ((_RunningCrc32Result) & 0x000000FF)];  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,SlurpBlock,The following statement contains a magic number: _RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table [(block [x]) ^ ((_RunningCrc32Result) & 0x000000FF)];  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: unchecked {  	// PKZip specifies CRC32 with a polynomial of 0xEDB88320;  	// This is also the CRC-32 polynomial used bby Ethernet' FDDI'  	// bzip2' gzip' and others.  	// Often the polynomial is shown reversed as 0x04C11DB7.  	// For more details' see http://en.wikipedia.org/wiki/Cyclic_redundancy_check  	UInt32 dwPolynomial = 0xEDB88320;  	UInt32 i' j;  	crc32Table = new UInt32[256];  	UInt32 dwCrc;  	for (i = 0; i < 256; i++) {  		dwCrc = i;  		for (j = 8; j > 0; j--) {  			if ((dwCrc & 1) == 1) {  				dwCrc = (dwCrc >> 1) ^ dwPolynomial;  			}  			else {  				dwCrc >>= 1;  			}  		}  		crc32Table [i] = dwCrc;  	}  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: unchecked {  	// PKZip specifies CRC32 with a polynomial of 0xEDB88320;  	// This is also the CRC-32 polynomial used bby Ethernet' FDDI'  	// bzip2' gzip' and others.  	// Often the polynomial is shown reversed as 0x04C11DB7.  	// For more details' see http://en.wikipedia.org/wiki/Cyclic_redundancy_check  	UInt32 dwPolynomial = 0xEDB88320;  	UInt32 i' j;  	crc32Table = new UInt32[256];  	UInt32 dwCrc;  	for (i = 0; i < 256; i++) {  		dwCrc = i;  		for (j = 8; j > 0; j--) {  			if ((dwCrc & 1) == 1) {  				dwCrc = (dwCrc >> 1) ^ dwPolynomial;  			}  			else {  				dwCrc >>= 1;  			}  		}  		crc32Table [i] = dwCrc;  	}  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: unchecked {  	// PKZip specifies CRC32 with a polynomial of 0xEDB88320;  	// This is also the CRC-32 polynomial used bby Ethernet' FDDI'  	// bzip2' gzip' and others.  	// Often the polynomial is shown reversed as 0x04C11DB7.  	// For more details' see http://en.wikipedia.org/wiki/Cyclic_redundancy_check  	UInt32 dwPolynomial = 0xEDB88320;  	UInt32 i' j;  	crc32Table = new UInt32[256];  	UInt32 dwCrc;  	for (i = 0; i < 256; i++) {  		dwCrc = i;  		for (j = 8; j > 0; j--) {  			if ((dwCrc & 1) == 1) {  				dwCrc = (dwCrc >> 1) ^ dwPolynomial;  			}  			else {  				dwCrc >>= 1;  			}  		}  		crc32Table [i] = dwCrc;  	}  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: crc32Table = new UInt32[256];  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: for (i = 0; i < 256; i++) {  	dwCrc = i;  	for (j = 8; j > 0; j--) {  		if ((dwCrc & 1) == 1) {  			dwCrc = (dwCrc >> 1) ^ dwPolynomial;  		}  		else {  			dwCrc >>= 1;  		}  	}  	crc32Table [i] = dwCrc;  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: for (i = 0; i < 256; i++) {  	dwCrc = i;  	for (j = 8; j > 0; j--) {  		if ((dwCrc & 1) == 1) {  			dwCrc = (dwCrc >> 1) ^ dwPolynomial;  		}  		else {  			dwCrc >>= 1;  		}  	}  	crc32Table [i] = dwCrc;  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: for (j = 8; j > 0; j--) {  	if ((dwCrc & 1) == 1) {  		dwCrc = (dwCrc >> 1) ^ dwPolynomial;  	}  	else {  		dwCrc >>= 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: j = 8
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,gf2_matrix_square,The following statement contains a magic number: for (int i = 0; i < 32; i++)  	square [i] = gf2_matrix_times (mat' mat [i]);  
Magic Number,PMDCP.Compression.Zlib,CRC32,C:\repos\pmdcp_framework\Compression\Zlib\Crc32.cs,Combine,The following statement contains a magic number: for (int i = 1; i < 32; i++) {  	odd [i] = row;  	row <<= 1;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeLazyMatch,The following statement contains a magic number: window_size = 2 * w_size;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeTreeData,The following statement contains a magic number: last_eob_len = 8;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.L_CODES; i++)  	dyn_ltree [i * 2] = 0;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree [i * 2] = 0;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.D_CODES; i++)  	dyn_dtree [i * 2] = 0;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_dtree [i * 2] = 0;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.BL_CODES; i++)  	bl_tree [i * 2] = 0;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: bl_tree [i * 2] = 0;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree [END_BLOCK * 2] = 1;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree [(max_code + 1) * 2 + 1] = (short)0x7fff;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = (int)tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [InternalConstants.REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [InternalConstants.REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [InternalConstants.REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = (int)tree [(n + 1) * 2 + 1];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [InternalConstants.REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != prevlen)  	bl_tree [curlen * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [curlen * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [InternalConstants.REP_3_6 * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	bl_tree [InternalConstants.REPZ_3_10 * 2]++;  }  else {  	bl_tree [InternalConstants.REPZ_11_138 * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [InternalConstants.REPZ_3_10 * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [InternalConstants.REPZ_11_138 * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = InternalConstants.BL_CODES - 1; max_blindex >= 3; max_blindex--) {  	if (bl_tree [Tree.bl_order [max_blindex] * 2 + 1] != 0)  		break;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = InternalConstants.BL_CODES - 1; max_blindex >= 3; max_blindex--) {  	if (bl_tree [Tree.bl_order [max_blindex] * 2 + 1] != 0)  		break;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: if (bl_tree [Tree.bl_order [max_blindex] * 2 + 1] != 0)  	break;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (lcodes - 257' 5);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (lcodes - 257' 5);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (dcodes - 1' 5);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (blcodes - 4' 4);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (blcodes - 4' 4);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++) {  	send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++) {  	send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (InternalConstants.REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (InternalConstants.REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (InternalConstants.REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree [(n + 1) * 2 + 1];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (InternalConstants.REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 2);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 2);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (InternalConstants.REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (InternalConstants.REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 11' 7);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 11' 7);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_bits,The following statement contains a magic number: unchecked {  	if (bi_valid > (int)Buf_size - len) {  		//int val = value;  		//      bi_buf |= (val << bi_valid);  		bi_buf |= (short)((value << bi_valid) & 0xffff);  		//put_short(bi_buf);  		pending [pendingCount++] = (byte)bi_buf;  		pending [pendingCount++] = (byte)(bi_buf >> 8);  		bi_buf = (short)((uint)value >> (Buf_size - bi_valid));  		bi_valid += len - Buf_size;  	}  	else {  		//      bi_buf |= (value) << bi_valid;  		bi_buf |= (short)((value << bi_valid) & 0xffff);  		bi_valid += len;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_bits,The following statement contains a magic number: if (bi_valid > (int)Buf_size - len) {  	//int val = value;  	//      bi_buf |= (val << bi_valid);  	bi_buf |= (short)((value << bi_valid) & 0xffff);  	//put_short(bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  	bi_buf = (short)((uint)value >> (Buf_size - bi_valid));  	bi_valid += len - Buf_size;  }  else {  	//      bi_buf |= (value) << bi_valid;  	bi_buf |= (short)((value << bi_valid) & 0xffff);  	bi_valid += len;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_bits,The following statement contains a magic number: pending [pendingCount++] = (byte)(bi_buf >> 8);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits (STATIC_TREES << 1' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9) {  	send_bits (STATIC_TREES << 1' 3);  	send_code (END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);  	bi_flush ();  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9) {  	send_bits (STATIC_TREES << 1' 3);  	send_code (END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);  	bi_flush ();  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9) {  	send_bits (STATIC_TREES << 1' 3);  	send_code (END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);  	bi_flush ();  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits (STATIC_TREES << 1' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending [_distanceOffset + last_lit * 2] = unchecked((byte)((uint)dist >> 8));  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending [_distanceOffset + last_lit * 2] = unchecked((byte)((uint)dist >> 8));  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending [_distanceOffset + last_lit * 2 + 1] = unchecked((byte)dist);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0) {  	// lc is the unmatched char  	dyn_ltree [lc * 2]++;  }  else {  	matches++;  	// Here' lc is the match length - MIN_MATCH  	dist--;  	// dist = match distance - 1  	dyn_ltree [(Tree.LengthCode [lc] + InternalConstants.LITERALS + 1) * 2]++;  	dyn_dtree [Tree.DistanceCode (dist) * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0) {  	// lc is the unmatched char  	dyn_ltree [lc * 2]++;  }  else {  	matches++;  	// Here' lc is the match length - MIN_MATCH  	dist--;  	// dist = match distance - 1  	dyn_ltree [(Tree.LengthCode [lc] + InternalConstants.LITERALS + 1) * 2]++;  	dyn_dtree [Tree.DistanceCode (dist) * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0) {  	// lc is the unmatched char  	dyn_ltree [lc * 2]++;  }  else {  	matches++;  	// Here' lc is the match length - MIN_MATCH  	dist--;  	// dist = match distance - 1  	dyn_ltree [(Tree.LengthCode [lc] + InternalConstants.LITERALS + 1) * 2]++;  	dyn_dtree [Tree.DistanceCode (dist) * 2]++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree [lc * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree [(Tree.LengthCode [lc] + InternalConstants.LITERALS + 1) * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_dtree [Tree.DistanceCode (dist) * 2]++;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2) {  	// Compute an upper bound for the compressed length  	int out_length = last_lit << 3;  	int in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  	}  	out_length >>= 3;  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2) {  	// Compute an upper bound for the compressed length  	int out_length = last_lit << 3;  	int in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  	}  	out_length >>= 3;  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2) {  	// Compute an upper bound for the compressed length  	int out_length = last_lit << 3;  	int in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  	}  	out_length >>= 3;  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2) {  	// Compute an upper bound for the compressed length  	int out_length = last_lit << 3;  	int in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  	}  	out_length >>= 3;  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2) {  	// Compute an upper bound for the compressed length  	int out_length = last_lit << 3;  	int in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  	}  	out_length >>= 3;  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2) {  	// Compute an upper bound for the compressed length  	int out_length = last_lit << 3;  	int in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  	}  	out_length >>= 3;  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++) {  	out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.ExtraDistanceBits [dcode]));  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length >>= 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((matches < (last_lit / 2)) && out_length < in_length / 2)  	return true;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((matches < (last_lit / 2)) && out_length < in_length / 2)  	return true;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: if (last_lit != 0) {  	do {  		int ix = _distanceOffset + lx * 2;  		distance = ((pending [ix] << 8) & 0xff00) | (pending [ix + 1] & 0xff);  		lc = (pending [_lengthOffset + lx]) & 0xff;  		lx++;  		if (distance == 0) {  			send_code (lc' ltree);  			// send a literal byte  		}  		else {  			// literal or match pair   			// Here' lc is the match length - MIN_MATCH  			code = Tree.LengthCode [lc];  			// send the length code  			send_code (code + InternalConstants.LITERALS + 1' ltree);  			extra = Tree.ExtraLengthBits [code];  			if (extra != 0) {  				// send the extra length bits  				lc -= Tree.LengthBase [code];  				send_bits (lc' extra);  			}  			distance--;  			// dist is now the match distance - 1  			code = Tree.DistanceCode (distance);  			// send the distance code  			send_code (code' dtree);  			extra = Tree.ExtraDistanceBits [code];  			if (extra != 0) {  				// send the extra distance bits  				distance -= Tree.DistanceBase [code];  				send_bits (distance' extra);  			}  		}  		// Check that the overlay between pending and d_buf+l_buf is ok:  	}  	while (lx < last_lit);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: if (last_lit != 0) {  	do {  		int ix = _distanceOffset + lx * 2;  		distance = ((pending [ix] << 8) & 0xff00) | (pending [ix + 1] & 0xff);  		lc = (pending [_lengthOffset + lx]) & 0xff;  		lx++;  		if (distance == 0) {  			send_code (lc' ltree);  			// send a literal byte  		}  		else {  			// literal or match pair   			// Here' lc is the match length - MIN_MATCH  			code = Tree.LengthCode [lc];  			// send the length code  			send_code (code + InternalConstants.LITERALS + 1' ltree);  			extra = Tree.ExtraLengthBits [code];  			if (extra != 0) {  				// send the extra length bits  				lc -= Tree.LengthBase [code];  				send_bits (lc' extra);  			}  			distance--;  			// dist is now the match distance - 1  			code = Tree.DistanceCode (distance);  			// send the distance code  			send_code (code' dtree);  			extra = Tree.ExtraDistanceBits [code];  			if (extra != 0) {  				// send the extra distance bits  				distance -= Tree.DistanceBase [code];  				send_bits (distance' extra);  			}  		}  		// Check that the overlay between pending and d_buf+l_buf is ok:  	}  	while (lx < last_lit);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: do {  	int ix = _distanceOffset + lx * 2;  	distance = ((pending [ix] << 8) & 0xff00) | (pending [ix + 1] & 0xff);  	lc = (pending [_lengthOffset + lx]) & 0xff;  	lx++;  	if (distance == 0) {  		send_code (lc' ltree);  		// send a literal byte  	}  	else {  		// literal or match pair   		// Here' lc is the match length - MIN_MATCH  		code = Tree.LengthCode [lc];  		// send the length code  		send_code (code + InternalConstants.LITERALS + 1' ltree);  		extra = Tree.ExtraLengthBits [code];  		if (extra != 0) {  			// send the extra length bits  			lc -= Tree.LengthBase [code];  			send_bits (lc' extra);  		}  		distance--;  		// dist is now the match distance - 1  		code = Tree.DistanceCode (distance);  		// send the distance code  		send_code (code' dtree);  		extra = Tree.ExtraDistanceBits [code];  		if (extra != 0) {  			// send the extra distance bits  			distance -= Tree.DistanceBase [code];  			send_bits (distance' extra);  		}  	}  	// Check that the overlay between pending and d_buf+l_buf is ok:  }  while (lx < last_lit);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: do {  	int ix = _distanceOffset + lx * 2;  	distance = ((pending [ix] << 8) & 0xff00) | (pending [ix + 1] & 0xff);  	lc = (pending [_lengthOffset + lx]) & 0xff;  	lx++;  	if (distance == 0) {  		send_code (lc' ltree);  		// send a literal byte  	}  	else {  		// literal or match pair   		// Here' lc is the match length - MIN_MATCH  		code = Tree.LengthCode [lc];  		// send the length code  		send_code (code + InternalConstants.LITERALS + 1' ltree);  		extra = Tree.ExtraLengthBits [code];  		if (extra != 0) {  			// send the extra length bits  			lc -= Tree.LengthBase [code];  			send_bits (lc' extra);  		}  		distance--;  		// dist is now the match distance - 1  		code = Tree.DistanceCode (distance);  		// send the distance code  		send_code (code' dtree);  		extra = Tree.ExtraDistanceBits [code];  		if (extra != 0) {  			// send the extra distance bits  			distance -= Tree.DistanceBase [code];  			send_bits (distance' extra);  		}  	}  	// Check that the overlay between pending and d_buf+l_buf is ok:  }  while (lx < last_lit);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: distance = ((pending [ix] << 8) & 0xff00) | (pending [ix + 1] & 0xff);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: last_eob_len = ltree [END_BLOCK * 2 + 1];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7) {  	bin_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7) {  	bin_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree [n * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128) {  	ascii_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128) {  	ascii_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree [n * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < InternalConstants.LITERALS) {  	bin_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree [n * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (sbyte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: pending [pendingCount++] = (byte)(bi_buf >> 8);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid >= 8) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  	bi_buf >>= 8;  	bi_valid -= 8;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_buf >>= 8;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid -= 8;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8) {  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  }  else if (bi_valid > 0) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8) {  	pending [pendingCount++] = (byte)bi_buf;  	pending [pendingCount++] = (byte)(bi_buf >> 8);  }  else if (bi_valid > 0) {  	//put_byte((byte)bi_buf);  	pending [pendingCount++] = (byte)bi_buf;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: pending [pendingCount++] = (byte)(bi_buf >> 8);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: if (header)  	unchecked {  		//put_short((short)len);  		pending [pendingCount++] = (byte)len;  		pending [pendingCount++] = (byte)(len >> 8);  		//put_short((short)~len);  		pending [pendingCount++] = (byte)~len;  		pending [pendingCount++] = (byte)(~len >> 8);  	}  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: if (header)  	unchecked {  		//put_short((short)len);  		pending [pendingCount++] = (byte)len;  		pending [pendingCount++] = (byte)(len >> 8);  		//put_short((short)~len);  		pending [pendingCount++] = (byte)~len;  		pending [pendingCount++] = (byte)(~len >> 8);  	}  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: unchecked {  	//put_short((short)len);  	pending [pendingCount++] = (byte)len;  	pending [pendingCount++] = (byte)(len >> 8);  	//put_short((short)~len);  	pending [pendingCount++] = (byte)~len;  	pending [pendingCount++] = (byte)(~len >> 8);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: unchecked {  	//put_short((short)len);  	pending [pendingCount++] = (byte)len;  	pending [pendingCount++] = (byte)(len >> 8);  	//put_short((short)~len);  	pending [pendingCount++] = (byte)~len;  	pending [pendingCount++] = (byte)(~len >> 8);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: pending [pendingCount++] = (byte)(len >> 8);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: pending [pendingCount++] = (byte)(~len >> 8);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateNone,The following statement contains a magic number: if (max_block_size > pending.Length - 5) {  	max_block_size = pending.Length - 5;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateNone,The following statement contains a magic number: if (max_block_size > pending.Length - 5) {  	max_block_size = pending.Length - 5;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateNone,The following statement contains a magic number: max_block_size = pending.Length - 5;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits ((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	treeLiterals.build_tree (this);  	treeDistances.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = (opt_len + 3 + 7) >> 3;  	static_lenb = (static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	treeLiterals.build_tree (this);  	treeDistances.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = (opt_len + 3 + 7) >> 3;  	static_lenb = (static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	treeLiterals.build_tree (this);  	treeDistances.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = (opt_len + 3 + 7) >> 3;  	static_lenb = (static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	treeLiterals.build_tree (this);  	treeDistances.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = (opt_len + 3 + 7) >> 3;  	static_lenb = (static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	treeLiterals.build_tree (this);  	treeDistances.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = (opt_len + 3 + 7) >> 3;  	static_lenb = (static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	treeLiterals.build_tree (this);  	treeDistances.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = (opt_len + 3 + 7) >> 3;  	static_lenb = (static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	treeLiterals.build_tree (this);  	treeDistances.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = (opt_len + 3 + 7) >> 3;  	static_lenb = (static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = static_lenb = stored_len + 5;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1) {  	// 4: two words for the lengths  	// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  	// Otherwise we can't have processed more than WSIZE input bytes since  	// the last block flush' because compression would have been  	// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  	// transform a block into a stored block.  	_tr_stored_block (buf' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	send_compressed_block (StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);  	send_compressed_block (dyn_ltree' dyn_dtree);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1) {  	// 4: two words for the lengths  	// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  	// Otherwise we can't have processed more than WSIZE input bytes since  	// the last block flush' because compression would have been  	// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  	// transform a block into a stored block.  	_tr_stored_block (buf' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	send_compressed_block (StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);  	send_compressed_block (dyn_ltree' dyn_dtree);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1) {  	// 4: two words for the lengths  	// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  	// Otherwise we can't have processed more than WSIZE input bytes since  	// the last block flush' because compression would have been  	// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  	// transform a block into a stored block.  	_tr_stored_block (buf' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	send_compressed_block (StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);  	send_compressed_block (dyn_ltree' dyn_dtree);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	send_compressed_block (StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);  	send_compressed_block (dyn_ltree' dyn_dtree);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	send_compressed_block (StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);  	send_compressed_block (dyn_ltree' dyn_dtree);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true) {  	// Make sure that we always have enough lookahead' except  	// at the end of the input file. We need MAX_MATCH bytes  	// for the next match' plus MIN_MATCH bytes to insert the  	// string following the next match.  	if (lookahead < MIN_LOOKAHEAD) {  		_fillWindow ();  		if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)  			return BlockState.NeedMore;  		if (lookahead == 0)  			break;  		// flush the current block  	}  	// Insert the string window[strstart .. strstart+2] in the  	// dictionary' and set hash_head to the head of the hash chain:  	if (lookahead >= MIN_MATCH) {  		ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  		//  prev[strstart&w_mask]=hash_head=head[ins_h];  		hash_head = (head [ins_h] & 0xffff);  		prev [strstart & w_mask] = head [ins_h];  		head [ins_h] = unchecked((short)strstart);  	}  	// Find the longest match' discarding those <= prev_length.  	prev_length = match_length;  	prev_match = match_start;  	match_length = MIN_MATCH - 1;  	if (hash_head != 0 && prev_length < config.MaxLazy && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  		// To simplify the code' we prevent matches with the string  		// of window index 0 (in particular we have to avoid a match  		// of the string with itself at the start of the input file).  		if (compressionStrategy != CompressionStrategy.HuffmanOnly) {  			match_length = longest_match (hash_head);  		}  		// longest_match() sets match_start  		if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  			// If prev_match is also MIN_MATCH' match_start is garbage  			// but we will ignore the current match anyway.  			match_length = MIN_MATCH - 1;  		}  	}  	// If there was a match at the previous step and the current  	// match is not better' output the previous match:  	if (prev_length >= MIN_MATCH && match_length <= prev_length) {  		int max_insert = strstart + lookahead - MIN_MATCH;  		// Do not insert strings in hash table beyond this.  		//          check_match(strstart-1' prev_match' prev_length);  		bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  		// Insert in hash table all strings up to the end of the match.  		// strstart-1 and strstart are already inserted. If there is not  		// enough lookahead' the last two strings are not inserted in  		// the hash table.  		lookahead -= (prev_length - 1);  		prev_length -= 2;  		do {  			if (++strstart <= max_insert) {  				ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  				//prev[strstart&w_mask]=hash_head=head[ins_h];  				hash_head = (head [ins_h] & 0xffff);  				prev [strstart & w_mask] = head [ins_h];  				head [ins_h] = unchecked((short)strstart);  			}  		}  		while (--prev_length != 0);  		match_available = 0;  		match_length = MIN_MATCH - 1;  		strstart++;  		if (bflush) {  			flush_block_only (false);  			if (_codec.AvailableBytesOut == 0)  				return BlockState.NeedMore;  		}  	}  	else if (match_available != 0) {  		// If there was no match at the previous position' output a  		// single literal. If there was a match but the current match  		// is longer' truncate the previous match to a single literal.  		bflush = _tr_tally (0' window [strstart - 1] & 0xff);  		if (bflush) {  			flush_block_only (false);  		}  		strstart++;  		lookahead--;  		if (_codec.AvailableBytesOut == 0)  			return BlockState.NeedMore;  	}  	else {  		// There is no previous match to compare with' wait for  		// the next step to decide.  		match_available = 1;  		strstart++;  		lookahead--;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true) {  	// Make sure that we always have enough lookahead' except  	// at the end of the input file. We need MAX_MATCH bytes  	// for the next match' plus MIN_MATCH bytes to insert the  	// string following the next match.  	if (lookahead < MIN_LOOKAHEAD) {  		_fillWindow ();  		if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)  			return BlockState.NeedMore;  		if (lookahead == 0)  			break;  		// flush the current block  	}  	// Insert the string window[strstart .. strstart+2] in the  	// dictionary' and set hash_head to the head of the hash chain:  	if (lookahead >= MIN_MATCH) {  		ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  		//  prev[strstart&w_mask]=hash_head=head[ins_h];  		hash_head = (head [ins_h] & 0xffff);  		prev [strstart & w_mask] = head [ins_h];  		head [ins_h] = unchecked((short)strstart);  	}  	// Find the longest match' discarding those <= prev_length.  	prev_length = match_length;  	prev_match = match_start;  	match_length = MIN_MATCH - 1;  	if (hash_head != 0 && prev_length < config.MaxLazy && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  		// To simplify the code' we prevent matches with the string  		// of window index 0 (in particular we have to avoid a match  		// of the string with itself at the start of the input file).  		if (compressionStrategy != CompressionStrategy.HuffmanOnly) {  			match_length = longest_match (hash_head);  		}  		// longest_match() sets match_start  		if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  			// If prev_match is also MIN_MATCH' match_start is garbage  			// but we will ignore the current match anyway.  			match_length = MIN_MATCH - 1;  		}  	}  	// If there was a match at the previous step and the current  	// match is not better' output the previous match:  	if (prev_length >= MIN_MATCH && match_length <= prev_length) {  		int max_insert = strstart + lookahead - MIN_MATCH;  		// Do not insert strings in hash table beyond this.  		//          check_match(strstart-1' prev_match' prev_length);  		bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  		// Insert in hash table all strings up to the end of the match.  		// strstart-1 and strstart are already inserted. If there is not  		// enough lookahead' the last two strings are not inserted in  		// the hash table.  		lookahead -= (prev_length - 1);  		prev_length -= 2;  		do {  			if (++strstart <= max_insert) {  				ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  				//prev[strstart&w_mask]=hash_head=head[ins_h];  				hash_head = (head [ins_h] & 0xffff);  				prev [strstart & w_mask] = head [ins_h];  				head [ins_h] = unchecked((short)strstart);  			}  		}  		while (--prev_length != 0);  		match_available = 0;  		match_length = MIN_MATCH - 1;  		strstart++;  		if (bflush) {  			flush_block_only (false);  			if (_codec.AvailableBytesOut == 0)  				return BlockState.NeedMore;  		}  	}  	else if (match_available != 0) {  		// If there was no match at the previous position' output a  		// single literal. If there was a match but the current match  		// is longer' truncate the previous match to a single literal.  		bflush = _tr_tally (0' window [strstart - 1] & 0xff);  		if (bflush) {  			flush_block_only (false);  		}  		strstart++;  		lookahead--;  		if (_codec.AvailableBytesOut == 0)  			return BlockState.NeedMore;  	}  	else {  		// There is no previous match to compare with' wait for  		// the next step to decide.  		match_available = 1;  		strstart++;  		lookahead--;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true) {  	// Make sure that we always have enough lookahead' except  	// at the end of the input file. We need MAX_MATCH bytes  	// for the next match' plus MIN_MATCH bytes to insert the  	// string following the next match.  	if (lookahead < MIN_LOOKAHEAD) {  		_fillWindow ();  		if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)  			return BlockState.NeedMore;  		if (lookahead == 0)  			break;  		// flush the current block  	}  	// Insert the string window[strstart .. strstart+2] in the  	// dictionary' and set hash_head to the head of the hash chain:  	if (lookahead >= MIN_MATCH) {  		ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  		//  prev[strstart&w_mask]=hash_head=head[ins_h];  		hash_head = (head [ins_h] & 0xffff);  		prev [strstart & w_mask] = head [ins_h];  		head [ins_h] = unchecked((short)strstart);  	}  	// Find the longest match' discarding those <= prev_length.  	prev_length = match_length;  	prev_match = match_start;  	match_length = MIN_MATCH - 1;  	if (hash_head != 0 && prev_length < config.MaxLazy && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  		// To simplify the code' we prevent matches with the string  		// of window index 0 (in particular we have to avoid a match  		// of the string with itself at the start of the input file).  		if (compressionStrategy != CompressionStrategy.HuffmanOnly) {  			match_length = longest_match (hash_head);  		}  		// longest_match() sets match_start  		if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  			// If prev_match is also MIN_MATCH' match_start is garbage  			// but we will ignore the current match anyway.  			match_length = MIN_MATCH - 1;  		}  	}  	// If there was a match at the previous step and the current  	// match is not better' output the previous match:  	if (prev_length >= MIN_MATCH && match_length <= prev_length) {  		int max_insert = strstart + lookahead - MIN_MATCH;  		// Do not insert strings in hash table beyond this.  		//          check_match(strstart-1' prev_match' prev_length);  		bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  		// Insert in hash table all strings up to the end of the match.  		// strstart-1 and strstart are already inserted. If there is not  		// enough lookahead' the last two strings are not inserted in  		// the hash table.  		lookahead -= (prev_length - 1);  		prev_length -= 2;  		do {  			if (++strstart <= max_insert) {  				ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  				//prev[strstart&w_mask]=hash_head=head[ins_h];  				hash_head = (head [ins_h] & 0xffff);  				prev [strstart & w_mask] = head [ins_h];  				head [ins_h] = unchecked((short)strstart);  			}  		}  		while (--prev_length != 0);  		match_available = 0;  		match_length = MIN_MATCH - 1;  		strstart++;  		if (bflush) {  			flush_block_only (false);  			if (_codec.AvailableBytesOut == 0)  				return BlockState.NeedMore;  		}  	}  	else if (match_available != 0) {  		// If there was no match at the previous position' output a  		// single literal. If there was a match but the current match  		// is longer' truncate the previous match to a single literal.  		bflush = _tr_tally (0' window [strstart - 1] & 0xff);  		if (bflush) {  			flush_block_only (false);  		}  		strstart++;  		lookahead--;  		if (_codec.AvailableBytesOut == 0)  			return BlockState.NeedMore;  	}  	else {  		// There is no previous match to compare with' wait for  		// the next step to decide.  		match_available = 1;  		strstart++;  		lookahead--;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: if (hash_head != 0 && prev_length < config.MaxLazy && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  	// To simplify the code' we prevent matches with the string  	// of window index 0 (in particular we have to avoid a match  	// of the string with itself at the start of the input file).  	if (compressionStrategy != CompressionStrategy.HuffmanOnly) {  		match_length = longest_match (hash_head);  	}  	// longest_match() sets match_start  	if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  		// If prev_match is also MIN_MATCH' match_start is garbage  		// but we will ignore the current match anyway.  		match_length = MIN_MATCH - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: if (hash_head != 0 && prev_length < config.MaxLazy && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  	// To simplify the code' we prevent matches with the string  	// of window index 0 (in particular we have to avoid a match  	// of the string with itself at the start of the input file).  	if (compressionStrategy != CompressionStrategy.HuffmanOnly) {  		match_length = longest_match (hash_head);  	}  	// longest_match() sets match_start  	if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  		// If prev_match is also MIN_MATCH' match_start is garbage  		// but we will ignore the current match anyway.  		match_length = MIN_MATCH - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  	// If prev_match is also MIN_MATCH' match_start is garbage  	// but we will ignore the current match anyway.  	match_length = MIN_MATCH - 1;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  	// If prev_match is also MIN_MATCH' match_start is garbage  	// but we will ignore the current match anyway.  	match_length = MIN_MATCH - 1;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: if (prev_length >= MIN_MATCH && match_length <= prev_length) {  	int max_insert = strstart + lookahead - MIN_MATCH;  	// Do not insert strings in hash table beyond this.  	//          check_match(strstart-1' prev_match' prev_length);  	bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  	// Insert in hash table all strings up to the end of the match.  	// strstart-1 and strstart are already inserted. If there is not  	// enough lookahead' the last two strings are not inserted in  	// the hash table.  	lookahead -= (prev_length - 1);  	prev_length -= 2;  	do {  		if (++strstart <= max_insert) {  			ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  			//prev[strstart&w_mask]=hash_head=head[ins_h];  			hash_head = (head [ins_h] & 0xffff);  			prev [strstart & w_mask] = head [ins_h];  			head [ins_h] = unchecked((short)strstart);  		}  	}  	while (--prev_length != 0);  	match_available = 0;  	match_length = MIN_MATCH - 1;  	strstart++;  	if (bflush) {  		flush_block_only (false);  		if (_codec.AvailableBytesOut == 0)  			return BlockState.NeedMore;  	}  }  else if (match_available != 0) {  	// If there was no match at the previous position' output a  	// single literal. If there was a match but the current match  	// is longer' truncate the previous match to a single literal.  	bflush = _tr_tally (0' window [strstart - 1] & 0xff);  	if (bflush) {  		flush_block_only (false);  	}  	strstart++;  	lookahead--;  	if (_codec.AvailableBytesOut == 0)  		return BlockState.NeedMore;  }  else {  	// There is no previous match to compare with' wait for  	// the next step to decide.  	match_available = 1;  	strstart++;  	lookahead--;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: prev_length -= 2;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= config.GoodLength) {  	chain_length >>= 2;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: do {  	match = cur_match;  	// Skip to next match if the match length cannot increase  	// or if the match length is less than 2:  	if (window [match + best_len] != scan_end || window [match + best_len - 1] != scan_end1 || window [match] != window [scan] || window [++match] != window [scan + 1])  		continue;  	// The check at best_len-1 can be removed because it will be made  	// again later. (This heuristic is not always a win.)  	// It is not necessary to compare scan[2] and match[2] since they  	// are always equal when the other bytes match' given that  	// the hash keys are equal and that HASH_BITS >= 8.  	scan += 2;  	match++;  	// We check for insufficient lookahead only every 8th comparison;  	// the 256th check will be made at strstart+258.  	do {  	}  	while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend);  	len = MAX_MATCH - (int)(strend - scan);  	scan = strend - MAX_MATCH;  	if (len > best_len) {  		match_start = cur_match;  		best_len = len;  		if (len >= niceLength)  			break;  		scan_end1 = window [scan + best_len - 1];  		scan_end = window [scan + best_len];  	}  }  while ((cur_match = (prev [cur_match & wmask] & 0xffff)) > limit && --chain_length != 0);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: if (windowBits < 9 || windowBits > 15)  	throw new ZlibException ("windowBits must be in the range 9..15.");  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: if (windowBits < 9 || windowBits > 15)  	throw new ZlibException ("windowBits must be in the range 9..15.");  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: hash_bits = memLevel + 7;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: window = new byte[w_size * 2];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: pending = new byte[lit_bufsize * 4];  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: _lengthOffset = (1 + 2) * lit_bufsize;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	//putShortMSB(header);  	unchecked {  		pending [pendingCount++] = (byte)(header >> 8);  		pending [pendingCount++] = (byte)header;  	}  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  		//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  		//putShortMSB((int)(_codec._Adler32 & 0xffff));  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  		pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  		pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  	}  	_codec._Adler32 = Adler.Adler32 (0' null' 0' 0);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: header |= (level_flags << 6);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: unchecked {  	pending [pendingCount++] = (byte)(header >> 8);  	pending [pendingCount++] = (byte)header;  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending [pendingCount++] = (byte)(header >> 8);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (strstart != 0) {  	////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  	//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  	//putShortMSB((int)(_codec._Adler32 & 0xffff));  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  	pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (strstart != 0) {  	////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  	//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  	//putShortMSB((int)(_codec._Adler32 & 0xffff));  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  	pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (strstart != 0) {  	////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));  	//putShortMSB((int)((UInt64)_codec._Adler32 >> 16));  	//putShortMSB((int)(_codec._Adler32 & 0xffff));  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  	pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  	pending [pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);  }  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending [pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending [pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);  
Magic Number,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending [pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);  
Magic Number,PMDCP.Compression.Zlib,GZipStream,C:\repos\pmdcp_framework\Compression\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: header [i++] = 8;  
Magic Number,PMDCP.Compression.Zlib,GZipStream,C:\repos\pmdcp_framework\Compression\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (timet)' 0' header' i' 4);  
Magic Number,PMDCP.Compression.Zlib,GZipStream,C:\repos\pmdcp_framework\Compression\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: i += 4;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateBlockMode.TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch ((uint)t >> 1) {  		case 0:  			// stored  			b >>= 3;  			k -= (3);  			t = k & 7;  			// go to byte boundary  			b >>= t;  			k -= t;  			mode = InflateBlockMode.LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			int[] bl = new int[1];  			int[] bd = new int[1];  			int[][] tl = new int[1][];  			int[][] td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  			codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.CODES;  			break;  		case 2:  			// dynamic  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.TABLE;  			break;  		case 3:  			// illegal  			b >>= 3;  			k -= 3;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid block type";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		break;  	case InflateBlockMode.LENS:  		while (k < (32)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			;  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid stored block lengths";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  		break;  	case InflateBlockMode.STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		if (m == 0) {  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				writeAt = q;  				r = Flush (r);  				q = writeAt;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  				if (q == end && readAt != 0) {  					q = 0;  					m = (int)(q < readAt ? readAt - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (_codec.InputBuffer' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  		break;  	case InflateBlockMode.TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = InflateBlockMode.BAD;  			_codec.Message = "too many length or distance symbols";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		if (blens == null || blens.Length < t) {  			blens = new int[t];  		}  		else {  			Array.Clear (blens' 0' t);  			// for (int i = 0; i < t; i++)  			// {  			//     blens[i] = 0;  			// }  		}  		b >>= 14;  		k -= 14;  		index = 0;  		mode = InflateBlockMode.BTREE;  		goto case InflateBlockMode.BTREE;  	case InflateBlockMode.BTREE:  		while (index < 4 + (table >> 10)) {  			while (k < (3)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			b >>= 3;  			k -= 3;  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			r = t;  			if (r == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		index = 0;  		mode = InflateBlockMode.DTREE;  		goto case InflateBlockMode.DTREE;  	case InflateBlockMode.DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < t) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  			if (c < 16) {  				b >>= t;  				k -= t;  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = ZlibConstants.Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						_codec.AvailableBytesIn = n;  						_codec.TotalBytesIn += p - _codec.NextIn;  						_codec.NextIn = p;  						writeAt = q;  						return Flush (r);  					}  					n--;  					b |= (_codec.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				b >>= t;  				k -= t;  				j += (b & InternalInflateConstants.InflateMask [i]);  				b >>= i;  				k -= i;  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = InflateBlockMode.BAD;  					_codec.Message = "invalid bit length repeat";  					r = ZlibConstants.Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				c = (c == 16) ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			int[] bl = new int[] {  				9  			};  			// must be <= 9 for lookahead assumptions  			int[] bd = new int[] {  				6  			};  			// must be <= 9 for lookahead assumptions  			int[] tl = new int[1];  			int[] td = new int[1];  			t = table;  			t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  			if (t != ZlibConstants.Z_OK) {  				if (t == ZlibConstants.Z_DATA_ERROR) {  					blens = null;  					mode = InflateBlockMode.BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  		}  		mode = InflateBlockMode.CODES;  		goto case InflateBlockMode.CODES;  	case InflateBlockMode.CODES:  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		r = codes.Process (this' r);  		if (r != ZlibConstants.Z_STREAM_END) {  			return Flush (r);  		}  		r = ZlibConstants.Z_OK;  		p = _codec.NextIn;  		n = _codec.AvailableBytesIn;  		b = bitb;  		k = bitk;  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (last == 0) {  			mode = InflateBlockMode.TYPE;  			break;  		}  		mode = InflateBlockMode.DRY;  		goto case InflateBlockMode.DRY;  	case InflateBlockMode.DRY:  		writeAt = q;  		r = Flush (r);  		q = writeAt;  		m = (int)(q < readAt ? readAt - q - 1 : end - q);  		if (readAt != writeAt) {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		mode = InflateBlockMode.DONE;  		goto case InflateBlockMode.DONE;  	case InflateBlockMode.DONE:  		r = ZlibConstants.Z_STREAM_END;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	case InflateBlockMode.BAD:  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  case InflateBlockMode.TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch ((uint)t >> 1) {  	case 0:  		// stored  		b >>= 3;  		k -= (3);  		t = k & 7;  		// go to byte boundary  		b >>= t;  		k -= t;  		mode = InflateBlockMode.LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		int[] bl = new int[1];  		int[] bd = new int[1];  		int[][] tl = new int[1][];  		int[][] td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  		codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.CODES;  		break;  	case 2:  		// dynamic  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.TABLE;  		break;  	case 3:  		// illegal  		b >>= 3;  		k -= 3;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid block type";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	break;  case InflateBlockMode.LENS:  	while (k < (32)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		;  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid stored block lengths";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);  	break;  case InflateBlockMode.STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	if (m == 0) {  		if (q == end && readAt != 0) {  			q = 0;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  		}  		if (m == 0) {  			writeAt = q;  			r = Flush (r);  			q = writeAt;  			m = (int)(q < readAt ? readAt - q - 1 : end - q);  			if (q == end && readAt != 0) {  				q = 0;  				m = (int)(q < readAt ? readAt - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (_codec.InputBuffer' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;  	break;  case InflateBlockMode.TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = InflateBlockMode.BAD;  		_codec.Message = "too many length or distance symbols";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	if (blens == null || blens.Length < t) {  		blens = new int[t];  	}  	else {  		Array.Clear (blens' 0' t);  		// for (int i = 0; i < t; i++)  		// {  		//     blens[i] = 0;  		// }  	}  	b >>= 14;  	k -= 14;  	index = 0;  	mode = InflateBlockMode.BTREE;  	goto case InflateBlockMode.BTREE;  case InflateBlockMode.BTREE:  	while (index < 4 + (table >> 10)) {  		while (k < (3)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		b >>= 3;  		k -= 3;  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = inftree.inflate_trees_bits (blens' bb' tb' hufts' _codec);  	if (t != ZlibConstants.Z_OK) {  		r = t;  		if (r == ZlibConstants.Z_DATA_ERROR) {  			blens = null;  			mode = InflateBlockMode.BAD;  		}  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	index = 0;  	mode = InflateBlockMode.DTREE;  	goto case InflateBlockMode.DTREE;  case InflateBlockMode.DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < t) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  		if (c < 16) {  			b >>= t;  			k -= t;  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = ZlibConstants.Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					_codec.AvailableBytesIn = n;  					_codec.TotalBytesIn += p - _codec.NextIn;  					_codec.NextIn = p;  					writeAt = q;  					return Flush (r);  				}  				n--;  				b |= (_codec.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			b >>= t;  			k -= t;  			j += (b & InternalInflateConstants.InflateMask [i]);  			b >>= i;  			k -= i;  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = InflateBlockMode.BAD;  				_codec.Message = "invalid bit length repeat";  				r = ZlibConstants.Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			c = (c == 16) ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		int[] bl = new int[] {  			9  		};  		// must be <= 9 for lookahead assumptions  		int[] bd = new int[] {  			6  		};  		// must be <= 9 for lookahead assumptions  		int[] tl = new int[1];  		int[] td = new int[1];  		t = table;  		t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  		if (t != ZlibConstants.Z_OK) {  			if (t == ZlibConstants.Z_DATA_ERROR) {  				blens = null;  				mode = InflateBlockMode.BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		codes.Init (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]);  	}  	mode = InflateBlockMode.CODES;  	goto case InflateBlockMode.CODES;  case InflateBlockMode.CODES:  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	r = codes.Process (this' r);  	if (r != ZlibConstants.Z_STREAM_END) {  		return Flush (r);  	}  	r = ZlibConstants.Z_OK;  	p = _codec.NextIn;  	n = _codec.AvailableBytesIn;  	b = bitb;  	k = bitk;  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (last == 0) {  		mode = InflateBlockMode.TYPE;  		break;  	}  	mode = InflateBlockMode.DRY;  	goto case InflateBlockMode.DRY;  case InflateBlockMode.DRY:  	writeAt = q;  	r = Flush (r);  	q = writeAt;  	m = (int)(q < readAt ? readAt - q - 1 : end - q);  	if (readAt != writeAt) {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	mode = InflateBlockMode.DONE;  	goto case InflateBlockMode.DONE;  case InflateBlockMode.DONE:  	r = ZlibConstants.Z_STREAM_END;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  case InflateBlockMode.BAD:  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: t = (int)(b & 7);  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: b >>= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k -= (3);  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: t = k & 7;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: b >>= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k -= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: b >>= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k -= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: b >>= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k -= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (32)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	;  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (32)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	;  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid stored block lengths";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (14)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (14)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = InflateBlockMode.BAD;  	_codec.Message = "too many length or distance symbols";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = InflateBlockMode.BAD;  	_codec.Message = "too many length or distance symbols";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = InflateBlockMode.BAD;  	_codec.Message = "too many length or distance symbols";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: b >>= 14;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k -= 14;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 4 + (table >> 10)) {  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	b >>= 3;  	k -= 3;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 4 + (table >> 10)) {  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	b >>= 3;  	k -= 3;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 4 + (table >> 10)) {  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	b >>= 3;  	k -= 3;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 4 + (table >> 10)) {  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	b >>= 3;  	k -= 3;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 4 + (table >> 10)) {  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	b >>= 3;  	k -= 3;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 4 + (table >> 10)) {  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	b >>= 3;  	k -= 3;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 4 + (table >> 10)) {  	while (k < (3)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	b >>= 3;  	k -= 3;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: blens [border [index++]] = b & 7;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: b >>= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k -= 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (index < 19) {  	blens [border [index++]] = 0;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: bb [0] = 7;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < t) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  	if (c < 16) {  		b >>= t;  		k -= t;  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = ZlibConstants.Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				_codec.AvailableBytesIn = n;  				_codec.TotalBytesIn += p - _codec.NextIn;  				_codec.NextIn = p;  				writeAt = q;  				return Flush (r);  			}  			n--;  			b |= (_codec.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		b >>= t;  		k -= t;  		j += (b & InternalInflateConstants.InflateMask [i]);  		b >>= i;  		k -= i;  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = InflateBlockMode.BAD;  			_codec.Message = "invalid bit length repeat";  			r = ZlibConstants.Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		c = (c == 16) ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < t) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: t = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 1];  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: c = hufts [(tb [0] + (b & InternalInflateConstants.InflateMask [t])) * 3 + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (c < 16) {  	b >>= t;  	k -= t;  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = ZlibConstants.Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			_codec.AvailableBytesIn = n;  			_codec.TotalBytesIn += p - _codec.NextIn;  			_codec.NextIn = p;  			writeAt = q;  			return Flush (r);  		}  		n--;  		b |= (_codec.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	b >>= t;  	k -= t;  	j += (b & InternalInflateConstants.InflateMask [i]);  	b >>= i;  	k -= i;  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = InflateBlockMode.BAD;  		_codec.Message = "invalid bit length repeat";  		r = ZlibConstants.Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	c = (c == 16) ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < (t + i)) {  	if (n != 0) {  		r = ZlibConstants.Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		_codec.AvailableBytesIn = n;  		_codec.TotalBytesIn += p - _codec.NextIn;  		_codec.NextIn = p;  		writeAt = q;  		return Flush (r);  	}  	n--;  	b |= (_codec.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid bit length repeat";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid bit length repeat";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid bit length repeat";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: c = (c == 16) ? blens [i - 1] : 0;  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: t = inftree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);  
Magic Number,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Flush,The following statement contains a magic number: for (int pass = 0; pass < 2; pass++) {  	if (pass == 0) {  		// compute number of bytes to copy as far as end of window  		nBytes = (int)((readAt <= writeAt ? writeAt : end) - readAt);  	}  	else {  		// compute bytes to copy  		nBytes = writeAt - readAt;  	}  	// workitem 8870  	if (nBytes == 0) {  		if (r == ZlibConstants.Z_BUF_ERROR)  			r = ZlibConstants.Z_OK;  		return r;  	}  	if (nBytes > _codec.AvailableBytesOut)  		nBytes = _codec.AvailableBytesOut;  	if (nBytes != 0 && r == ZlibConstants.Z_BUF_ERROR)  		r = ZlibConstants.Z_OK;  	// update counters  	_codec.AvailableBytesOut -= nBytes;  	_codec.TotalBytesOut += nBytes;  	// update check information  	if (checkfn != null)  		_codec._Adler32 = check = Adler.Adler32 (check' window' readAt' nBytes);  	// copy as far as end of window  	Array.Copy (window' readAt' _codec.OutputBuffer' _codec.NextOut' nBytes);  	_codec.NextOut += nBytes;  	readAt += nBytes;  	// see if more to copy at beginning of window  	if (readAt == end && pass == 0) {  		// wrap pointers  		readAt = 0;  		if (writeAt == end)  			writeAt = 0;  	}  	else  		pass++;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  			p = z.NextIn;  			n = z.AvailableBytesIn;  			b = blocks.bitb;  			k = blocks.bitk;  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (r != ZlibConstants.Z_OK) {  				mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= (tree [tindex + 1]);  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			bitsToGet = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid literal/length code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case LENEXT:  		// i: getting length extra (have base)  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 0x10) != 0) {  			// distance  			bitsToGet = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.Message = "invalid distance code";  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case DISTEXT:  		// i: getting distance extra  		j = bitsToGet;  		while (k < j) {  			if (n != 0)  				r = ZlibConstants.Z_OK;  			else {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & InternalInflateConstants.InflateMask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += blocks.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.writeAt = q;  					r = blocks.Flush (r);  					q = blocks.writeAt;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					if (q == blocks.end && blocks.readAt != 0) {  						q = 0;  						m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  					}  					if (m == 0) {  						blocks.bitb = b;  						blocks.bitk = k;  						z.AvailableBytesIn = n;  						z.TotalBytesIn += p - z.NextIn;  						z.NextIn = p;  						blocks.writeAt = q;  						return blocks.Flush (r);  					}  				}  			}  			blocks.window [q++] = blocks.window [f++];  			m--;  			if (f == blocks.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		r = ZlibConstants.Z_OK;  		blocks.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		blocks.writeAt = q;  		r = blocks.Flush (r);  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (blocks.readAt != blocks.writeAt) {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		mode = END;  		goto case END;  	case END:  		r = ZlibConstants.Z_STREAM_END;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	case BADCODE:  		// x: got error  		r = ZlibConstants.Z_DATA_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	default:  		r = ZlibConstants.Z_STREAM_ERROR;  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  		p = z.NextIn;  		n = z.AvailableBytesIn;  		b = blocks.bitb;  		k = blocks.bitk;  		q = blocks.writeAt;  		m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		if (r != ZlibConstants.Z_OK) {  			mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= (tree [tindex + 1]);  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		bitsToGet = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid literal/length code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case LENEXT:  	// i: getting length extra (have base)  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 0x10) != 0) {  		// distance  		bitsToGet = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.Message = "invalid distance code";  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case DISTEXT:  	// i: getting distance extra  	j = bitsToGet;  	while (k < j) {  		if (n != 0)  			r = ZlibConstants.Z_OK;  		else {  			blocks.bitb = b;  			blocks.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			blocks.writeAt = q;  			return blocks.Flush (r);  		}  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & InternalInflateConstants.InflateMask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += blocks.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.writeAt = q;  				r = blocks.Flush (r);  				q = blocks.writeAt;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				if (q == blocks.end && blocks.readAt != 0) {  					q = 0;  					m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  				}  				if (m == 0) {  					blocks.bitb = b;  					blocks.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					blocks.writeAt = q;  					return blocks.Flush (r);  				}  			}  		}  		blocks.window [q++] = blocks.window [f++];  		m--;  		if (f == blocks.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == blocks.end && blocks.readAt != 0) {  			q = 0;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  		}  		if (m == 0) {  			blocks.writeAt = q;  			r = blocks.Flush (r);  			q = blocks.writeAt;  			m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			if (q == blocks.end && blocks.readAt != 0) {  				q = 0;  				m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  			}  			if (m == 0) {  				blocks.bitb = b;  				blocks.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				blocks.writeAt = q;  				return blocks.Flush (r);  			}  		}  	}  	r = ZlibConstants.Z_OK;  	blocks.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	blocks.writeAt = q;  	r = blocks.Flush (r);  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (blocks.readAt != blocks.writeAt) {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	mode = END;  	goto case END;  case END:  	r = ZlibConstants.Z_STREAM_END;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  case BADCODE:  	// x: got error  	r = ZlibConstants.Z_DATA_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  default:  	r = ZlibConstants.Z_STREAM_ERROR;  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	return blocks.Flush (r);  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (m >= 258 && n >= 10) {  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  	p = z.NextIn;  	n = z.AvailableBytesIn;  	b = blocks.bitb;  	k = blocks.bitk;  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (r != ZlibConstants.Z_OK) {  		mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  		break;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (m >= 258 && n >= 10) {  	blocks.bitb = b;  	blocks.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	blocks.writeAt = q;  	r = InflateFast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);  	p = z.NextIn;  	n = z.AvailableBytesIn;  	b = blocks.bitb;  	k = blocks.bitk;  	q = blocks.writeAt;  	m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;  	if (r != ZlibConstants.Z_OK) {  		mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;  		break;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < j) {  	if (n != 0)  		r = ZlibConstants.Z_OK;  	else {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (e == 0) {  	// literal  	lit = tree [tindex + 2];  	mode = LIT;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: lit = tree [tindex + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	bitsToGet = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	bitsToGet = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	bitsToGet = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: bitsToGet = e & 15;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: len = tree [tindex + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 32) != 0) {  	// end of block  	mode = WASH;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < j) {  	if (n != 0)  		r = ZlibConstants.Z_OK;  	else {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < j) {  	if (n != 0)  		r = ZlibConstants.Z_OK;  	else {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: tindex = (tree_index + (b & InternalInflateConstants.InflateMask [j])) * 3;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 0x10) != 0) {  	// distance  	bitsToGet = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 0x10) != 0) {  	// distance  	bitsToGet = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: bitsToGet = e & 15;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: dist = tree [tindex + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (k < j) {  	if (n != 0)  		r = ZlibConstants.Z_OK;  	else {  		blocks.bitb = b;  		blocks.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		blocks.writeAt = q;  		return blocks.Flush (r);  	}  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (k > 7) {  	// return unused byte' if any  	k -= 8;  	n++;  	p--;  	// can always return one  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: if (k > 7) {  	// return unused byte' if any  	k -= 8;  	n++;  	p--;  	// can always return one  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following statement contains a magic number: k -= 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < 15) {  				// max bits for distance code  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  			do {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < e) {  						// get extra bits (up to 13)  						n--;  						b |= (z.InputBuffer [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  					b >>= e;  					k -= e;  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							// minimum count is three'  							s.window [q++] = s.window [r++];  							// so unroll loop a little  							c -= 2;  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_index_t_3 + 2];  					t += (b & InternalInflateConstants.InflateMask [e]);  					tp_index_t_3 = (tp_index + t) * 3;  					e = tp [tp_index_t_3];  				}  				else {  					z.Message = "invalid distance code";  					c = z.AvailableBytesIn - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.AvailableBytesIn = n;  					z.TotalBytesIn += p - z.NextIn;  					z.NextIn = p;  					s.writeAt = q;  					return ZlibConstants.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			if ((e = tp [tp_index_t_3]) == 0) {  				b >>= (tp [tp_index_t_3 + 1]);  				k -= (tp [tp_index_t_3 + 1]);  				s.window [q++] = (byte)tp [tp_index_t_3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_STREAM_END;  		}  		else {  			z.Message = "invalid literal/length code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: while (k < (20)) {  	// max bits for literal/length code  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: while (k < (20)) {  	// max bits for literal/length code  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e = tp [tp_index_t_3]) == 0) {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	s.window [q++] = (byte)tp [tp_index_t_3 + 2];  	m--;  	continue;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: s.window [q++] = (byte)tp [tp_index_t_3 + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < 15) {  			// max bits for distance code  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  		do {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < e) {  					// get extra bits (up to 13)  					n--;  					b |= (z.InputBuffer [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  				b >>= e;  				k -= e;  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						// minimum count is three'  						s.window [q++] = s.window [r++];  						// so unroll loop a little  						c -= 2;  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_index_t_3 + 2];  				t += (b & InternalInflateConstants.InflateMask [e]);  				tp_index_t_3 = (tp_index + t) * 3;  				e = tp [tp_index_t_3];  			}  			else {  				z.Message = "invalid distance code";  				c = z.AvailableBytesIn - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.AvailableBytesIn = n;  				z.TotalBytesIn += p - z.NextIn;  				z.NextIn = p;  				s.writeAt = q;  				return ZlibConstants.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		if ((e = tp [tp_index_t_3]) == 0) {  			b >>= (tp [tp_index_t_3 + 1]);  			k -= (tp [tp_index_t_3 + 1]);  			s.window [q++] = (byte)tp [tp_index_t_3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_STREAM_END;  	}  	else {  		z.Message = "invalid literal/length code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < 15) {  		// max bits for distance code  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  	do {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < e) {  				// get extra bits (up to 13)  				n--;  				b |= (z.InputBuffer [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  			b >>= e;  			k -= e;  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					// minimum count is three'  					s.window [q++] = s.window [r++];  					// so unroll loop a little  					c -= 2;  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_index_t_3 + 2];  			t += (b & InternalInflateConstants.InflateMask [e]);  			tp_index_t_3 = (tp_index + t) * 3;  			e = tp [tp_index_t_3];  		}  		else {  			z.Message = "invalid distance code";  			c = z.AvailableBytesIn - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.AvailableBytesIn = n;  			z.TotalBytesIn += p - z.NextIn;  			z.NextIn = p;  			s.writeAt = q;  			return ZlibConstants.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = tp [tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask [e]);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: while (k < 15) {  	// max bits for distance code  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: while (k < 15) {  	// max bits for distance code  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < e) {  			// get extra bits (up to 13)  			n--;  			b |= (z.InputBuffer [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  		b >>= e;  		k -= e;  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				// minimum count is three'  				s.window [q++] = s.window [r++];  				// so unroll loop a little  				c -= 2;  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_index_t_3 + 2];  		t += (b & InternalInflateConstants.InflateMask [e]);  		tp_index_t_3 = (tp_index + t) * 3;  		e = tp [tp_index_t_3];  	}  	else {  		z.Message = "invalid distance code";  		c = z.AvailableBytesIn - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.AvailableBytesIn = n;  		z.TotalBytesIn += p - z.NextIn;  		z.NextIn = p;  		s.writeAt = q;  		return ZlibConstants.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < e) {  		// get extra bits (up to 13)  		n--;  		b |= (z.InputBuffer [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  	b >>= e;  	k -= e;  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			// minimum count is three'  			s.window [q++] = s.window [r++];  			// so unroll loop a little  			c -= 2;  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: while (k < e) {  	// get extra bits (up to 13)  	n--;  	b |= (z.InputBuffer [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: d = tp [tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask [e]);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		// minimum count is three'  		s.window [q++] = s.window [r++];  		// so unroll loop a little  		c -= 2;  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		// minimum count is three'  		s.window [q++] = s.window [r++];  		// so unroll loop a little  		c -= 2;  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		// minimum count is three'  		s.window [q++] = s.window [r++];  		// so unroll loop a little  		c -= 2;  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		// minimum count is three'  		s.window [q++] = s.window [r++];  		// so unroll loop a little  		c -= 2;  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		// minimum count is three'  		s.window [q++] = s.window [r++];  		// so unroll loop a little  		c -= 2;  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		// minimum count is three'  		s.window [q++] = s.window [r++];  		// so unroll loop a little  		c -= 2;  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	// minimum count is three'  	s.window [q++] = s.window [r++];  	// so unroll loop a little  	c -= 2;  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	// minimum count is three'  	s.window [q++] = s.window [r++];  	// so unroll loop a little  	c -= 2;  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	// minimum count is three'  	s.window [q++] = s.window [r++];  	// so unroll loop a little  	c -= 2;  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	// minimum count is three'  	s.window [q++] = s.window [r++];  	// so unroll loop a little  	c -= 2;  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	// minimum count is three'  	s.window [q++] = s.window [r++];  	// so unroll loop a little  	c -= 2;  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	// minimum count is three'  	s.window [q++] = s.window [r++];  	// so unroll loop a little  	c -= 2;  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c -= 2;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: Array.Copy (s.window' r' s.window' q' 2);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: q += 2;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: r += 2;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c -= 2;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	e = tp [tp_index_t_3];  }  else {  	z.Message = "invalid distance code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: t += tp [tp_index_t_3 + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_index_t_3 + 2];  	t += (b & InternalInflateConstants.InflateMask [e]);  	tp_index_t_3 = (tp_index + t) * 3;  	if ((e = tp [tp_index_t_3]) == 0) {  		b >>= (tp [tp_index_t_3 + 1]);  		k -= (tp [tp_index_t_3 + 1]);  		s.window [q++] = (byte)tp [tp_index_t_3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: t += tp [tp_index_t_3 + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e = tp [tp_index_t_3]) == 0) {  	b >>= (tp [tp_index_t_3 + 1]);  	k -= (tp [tp_index_t_3 + 1]);  	s.window [q++] = (byte)tp [tp_index_t_3 + 2];  	m--;  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: s.window [q++] = (byte)tp [tp_index_t_3 + 2];  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_STREAM_END;  }  else {  	z.Message = "invalid literal/length code";  	c = z.AvailableBytesIn - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.AvailableBytesIn = n;  	z.TotalBytesIn += p - z.NextIn;  	z.NextIn = p;  	s.writeAt = q;  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15) {  	End ();  	throw new ZlibException ("Bad window size.");  	//return ZlibConstants.Z_STREAM_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15) {  	End ();  	throw new ZlibException ("Bad window size.");  	//return ZlibConstants.Z_STREAM_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true) {  	switch (mode) {  	case InflateManagerMode.METHOD:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  			marker = 5;  			// can't try inflateSync  			break;  		}  		if ((method >> 4) + 8 > wbits) {  			mode = InflateManagerMode.BAD;  			_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.FLAG;  		break;  	case InflateManagerMode.FLAG:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  		if ((((method << 8) + b) % 31) != 0) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect header check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  		break;  	case InflateManagerMode.DICT4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.DICT3;  		break;  	case InflateManagerMode.DICT3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.DICT2;  		break;  	case InflateManagerMode.DICT2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.DICT1;  		break;  	case InflateManagerMode.DICT1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		_codec._Adler32 = expectedCheck;  		mode = InflateManagerMode.DICT0;  		return ZlibConstants.Z_NEED_DICT;  	case InflateManagerMode.DICT0:  		mode = InflateManagerMode.BAD;  		_codec.Message = "need dictionary";  		marker = 0;  		// can try inflateSync  		return ZlibConstants.Z_STREAM_ERROR;  	case InflateManagerMode.BLOCKS:  		r = blocks.Process (r);  		if (r == ZlibConstants.Z_DATA_ERROR) {  			mode = InflateManagerMode.BAD;  			marker = 0;  			// can try inflateSync  			break;  		}  		if (r == ZlibConstants.Z_OK)  			r = f;  		if (r != ZlibConstants.Z_STREAM_END)  			return r;  		r = f;  		computedCheck = blocks.Reset ();  		if (!HandleRfc1950HeaderBytes) {  			mode = InflateManagerMode.DONE;  			return ZlibConstants.Z_STREAM_END;  		}  		mode = InflateManagerMode.CHECK4;  		break;  	case InflateManagerMode.CHECK4:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  		mode = InflateManagerMode.CHECK3;  		break;  	case InflateManagerMode.CHECK3:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  		mode = InflateManagerMode.CHECK2;  		break;  	case InflateManagerMode.CHECK2:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  		mode = InflateManagerMode.CHECK1;  		break;  	case InflateManagerMode.CHECK1:  		if (_codec.AvailableBytesIn == 0)  			return r;  		r = f;  		_codec.AvailableBytesIn--;  		_codec.TotalBytesIn++;  		expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  		if (computedCheck != expectedCheck) {  			mode = InflateManagerMode.BAD;  			_codec.Message = "incorrect data check";  			marker = 5;  			// can't try inflateSync  			break;  		}  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.DONE:  		return ZlibConstants.Z_STREAM_END;  	case InflateManagerMode.BAD:  		throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  	default:  		throw new ZlibException ("Stream error.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode) {  case InflateManagerMode.METHOD:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  		marker = 5;  		// can't try inflateSync  		break;  	}  	if ((method >> 4) + 8 > wbits) {  		mode = InflateManagerMode.BAD;  		_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.FLAG;  	break;  case InflateManagerMode.FLAG:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	b = (_codec.InputBuffer [_codec.NextIn++]) & 0xff;  	if ((((method << 8) + b) % 31) != 0) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect header check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = ((b & PRESET_DICT) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4;  	break;  case InflateManagerMode.DICT4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.DICT3;  	break;  case InflateManagerMode.DICT3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.DICT2;  	break;  case InflateManagerMode.DICT2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.DICT1;  	break;  case InflateManagerMode.DICT1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	_codec._Adler32 = expectedCheck;  	mode = InflateManagerMode.DICT0;  	return ZlibConstants.Z_NEED_DICT;  case InflateManagerMode.DICT0:  	mode = InflateManagerMode.BAD;  	_codec.Message = "need dictionary";  	marker = 0;  	// can try inflateSync  	return ZlibConstants.Z_STREAM_ERROR;  case InflateManagerMode.BLOCKS:  	r = blocks.Process (r);  	if (r == ZlibConstants.Z_DATA_ERROR) {  		mode = InflateManagerMode.BAD;  		marker = 0;  		// can try inflateSync  		break;  	}  	if (r == ZlibConstants.Z_OK)  		r = f;  	if (r != ZlibConstants.Z_STREAM_END)  		return r;  	r = f;  	computedCheck = blocks.Reset ();  	if (!HandleRfc1950HeaderBytes) {  		mode = InflateManagerMode.DONE;  		return ZlibConstants.Z_STREAM_END;  	}  	mode = InflateManagerMode.CHECK4;  	break;  case InflateManagerMode.CHECK4:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  	mode = InflateManagerMode.CHECK3;  	break;  case InflateManagerMode.CHECK3:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  	mode = InflateManagerMode.CHECK2;  	break;  case InflateManagerMode.CHECK2:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  	mode = InflateManagerMode.CHECK1;  	break;  case InflateManagerMode.CHECK1:  	if (_codec.AvailableBytesIn == 0)  		return r;  	r = f;  	_codec.AvailableBytesIn--;  	_codec.TotalBytesIn++;  	expectedCheck += (uint)(_codec.InputBuffer [_codec.NextIn++] & 0x000000ff);  	if (computedCheck != expectedCheck) {  		mode = InflateManagerMode.BAD;  		_codec.Message = "incorrect data check";  		marker = 5;  		// can't try inflateSync  		break;  	}  	mode = InflateManagerMode.DONE;  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.DONE:  	return ZlibConstants.Z_STREAM_END;  case InflateManagerMode.BAD:  	throw new ZlibException (String.Format ("Bad state ({0})"' _codec.Message));  default:  	throw new ZlibException ("Stream error.");  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if (((method = _codec.InputBuffer [_codec.NextIn++]) & 0xf) != Z_DEFLATED) {  	mode = InflateManagerMode.BAD;  	_codec.Message = String.Format ("unknown compression method (0x{0:X2})"' method);  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: marker = 5;  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((method >> 4) + 8 > wbits) {  	mode = InflateManagerMode.BAD;  	_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((method >> 4) + 8 > wbits) {  	mode = InflateManagerMode.BAD;  	_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((method >> 4) + 8 > wbits) {  	mode = InflateManagerMode.BAD;  	_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((method >> 4) + 8 > wbits) {  	mode = InflateManagerMode.BAD;  	_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((method >> 4) + 8 > wbits) {  	mode = InflateManagerMode.BAD;  	_codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: _codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: _codec.Message = String.Format ("invalid window size ({0})"' (method >> 4) + 8);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: marker = 5;  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((((method << 8) + b) % 31) != 0) {  	mode = InflateManagerMode.BAD;  	_codec.Message = "incorrect header check";  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((((method << 8) + b) % 31) != 0) {  	mode = InflateManagerMode.BAD;  	_codec.Message = "incorrect header check";  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if ((((method << 8) + b) % 31) != 0) {  	mode = InflateManagerMode.BAD;  	_codec.Message = "incorrect header check";  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: marker = 5;  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: expectedCheck = (uint)((_codec.InputBuffer [_codec.NextIn++] << 24) & 0xff000000);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 16) & 0x00ff0000);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: expectedCheck += (uint)((_codec.InputBuffer [_codec.NextIn++] << 8) & 0x0000ff00);  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: if (computedCheck != expectedCheck) {  	mode = InflateManagerMode.BAD;  	_codec.Message = "incorrect data check";  	marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: marker = 5;  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4) {  	if (_codec.InputBuffer [p] == mark [m]) {  		m++;  	}  	else if (_codec.InputBuffer [p] != 0) {  		m = 0;  	}  	else {  		m = 4 - m;  	}  	p++;  	n--;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4) {  	if (_codec.InputBuffer [p] == mark [m]) {  		m++;  	}  	else if (_codec.InputBuffer [p] != 0) {  		m = 0;  	}  	else {  		m = 4 - m;  	}  	p++;  	n--;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Sync,The following statement contains a magic number: if (_codec.InputBuffer [p] == mark [m]) {  	m++;  }  else if (_codec.InputBuffer [p] != 0) {  	m = 0;  }  else {  	m = 4 - m;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Sync,The following statement contains a magic number: if (_codec.InputBuffer [p] != 0) {  	m = 0;  }  else {  	m = 4 - m;  }  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Sync,The following statement contains a magic number: m = 4 - m;  
Magic Number,PMDCP.Compression.Zlib,InflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Sync,The following statement contains a magic number: if (m != 4) {  	return ZlibConstants.Z_DATA_ERROR;  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY) {  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  				// overflow of MANY  			}  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (sbyte)j;  				// bits in this table  				r [1] = (sbyte)l;  				// bits to dump before this table  				j = SharedUtils.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (sbyte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SharedUtils.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY) {  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  			// overflow of MANY  		}  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (sbyte)j;  			// bits in this table  			r [1] = (sbyte)l;  			// bits to dump before this table  			j = SharedUtils.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (sbyte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SharedUtils.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY) {  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  		// overflow of MANY  	}  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (sbyte)j;  		// bits in this table  		r [1] = (sbyte)l;  		// bits to dump before this table  		j = SharedUtils.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY) {  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  		// overflow of MANY  	}  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (sbyte)j;  		// bits in this table  		r [1] = (sbyte)l;  		// bits to dump before this table  		j = SharedUtils.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY) {  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  		// overflow of MANY  	}  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (sbyte)j;  		// bits in this table  		r [1] = (sbyte)l;  		// bits to dump before this table  		j = SharedUtils.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (sbyte)j;  	// bits in this table  	r [1] = (sbyte)l;  	// bits to dump before this table  	j = SharedUtils.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (sbyte)j;  	// bits in this table  	r [1] = (sbyte)l;  	// bits to dump before this table  	j = SharedUtils.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (sbyte)j;  	// bits in this table  	r [1] = (sbyte)l;  	// bits to dump before this table  	j = SharedUtils.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = (int)(q - u [h - 1] - j);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = 128 + 64;  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = 128 + 64;  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (sbyte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = v [p++];  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (sbyte)(e [v [p] - s] + 16 + 64);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = d [v [p++] - s];  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (j = SharedUtils.URShift (i' w); j < z; j += f) {  	Array.Copy (r' 0' hp' (q + j) * 3' 3);  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (j = SharedUtils.URShift (i' w); j < z; j += f) {  	Array.Copy (r' 0' hp' (q + j) * 3' 3);  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (q + j) * 3' 3);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (q + j) * 3' 3);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea (19);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build (c' 0' 19' 19' null' null' tb' bb' hp' hn' v);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build (c' 0' 19' 19' null' null' tb' bb' hp' hn' v);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea (288);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build (c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea (288);  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (result != Z_OK || (bd [0] == 0 && nl > 257)) {  	if (result == Z_DATA_ERROR) {  		z.Message = "oversubscribed distance tree";  	}  	else if (result == Z_BUF_ERROR) {  		z.Message = "incomplete distance tree";  		result = Z_DATA_ERROR;  	}  	else if (result != Z_MEM_ERROR) {  		z.Message = "empty distance tree with lengths";  		result = Z_DATA_ERROR;  	}  	return result;  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,initWorkArea,The following statement contains a magic number: if (hn == null) {  	hn = new int[1];  	v = new int[vsize];  	c = new int[BMAX + 1];  	r = new int[3];  	u = new int[BMAX];  	x = new int[BMAX + 1];  }  else {  	if (v.Length < vsize) {  		v = new int[vsize];  	}  	Array.Clear (v' 0' vsize);  	Array.Clear (c' 0' BMAX + 1);  	r [0] = 0;  	r [1] = 0;  	r [2] = 0;  	//  for(int i=0; i<BMAX; i++){u[i]=0;}  	//Array.Copy(c' 0' u' 0' BMAX);  	Array.Clear (u' 0' BMAX);  	//  for(int i=0; i<BMAX+1; i++){x[i]=0;}  	//Array.Copy(c' 0' x' 0' BMAX + 1);  	Array.Clear (x' 0' BMAX + 1);  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,initWorkArea,The following statement contains a magic number: if (hn == null) {  	hn = new int[1];  	v = new int[vsize];  	c = new int[BMAX + 1];  	r = new int[3];  	u = new int[BMAX];  	x = new int[BMAX + 1];  }  else {  	if (v.Length < vsize) {  		v = new int[vsize];  	}  	Array.Clear (v' 0' vsize);  	Array.Clear (c' 0' BMAX + 1);  	r [0] = 0;  	r [1] = 0;  	r [2] = 0;  	//  for(int i=0; i<BMAX; i++){u[i]=0;}  	//Array.Copy(c' 0' u' 0' BMAX);  	Array.Clear (u' 0' BMAX);  	//  for(int i=0; i<BMAX+1; i++){x[i]=0;}  	//Array.Copy(c' 0' x' 0' BMAX + 1);  	Array.Clear (x' 0' BMAX + 1);  }  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,initWorkArea,The following statement contains a magic number: r = new int[3];  
Magic Number,PMDCP.Compression.Zlib,InfTree,C:\repos\pmdcp_framework\Compression\Zlib\InfTree.cs,initWorkArea,The following statement contains a magic number: r [2] = 0;  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,ParallelDeflateOutputStream,The following statement contains a magic number: BuffersPerCore = 4;  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The following statement contains a magic number: try {  	do {  		// wait for the next session  		TraceOutput (TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.WaitOne(begin) PWM");  		_sessionReset.WaitOne ();  		TraceOutput (TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.WaitOne(done)  PWM");  		if (_isDisposed)  			break;  		TraceOutput (TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.Reset()        PWM");  		_sessionReset.Reset ();  		// repeatedly write buffers as they become ready  		WorkItem workitem = null;  		PMDCP.Compression.Zlib.CRC32 c = new PMDCP.Compression.Zlib.CRC32 ();  		do {  			workitem = _pool [_nextToWrite % _pc];  			lock (workitem) {  				if (_noMoreInputForThisSegment)  					TraceOutput (TraceBits.Write' "Write    drain    wi({0}) stat({1}) canuse({2})  cba({3})"' workitem.index' workitem.status' (workitem.status == (int)WorkItem.Status.Compressed)' workitem.compressedBytesAvailable);  				do {  					if (workitem.status == (int)WorkItem.Status.Compressed) {  						TraceOutput (TraceBits.WriteBegin' "Write    begin    wi({0}) stat({1})              cba({2})"' workitem.index' workitem.status' workitem.compressedBytesAvailable);  						workitem.status = (int)WorkItem.Status.Writing;  						_outStream.Write (workitem.compressed' 0' workitem.compressedBytesAvailable);  						c.Combine (workitem.crc' workitem.inputBytesAvailable);  						_totalBytesProcessed += workitem.inputBytesAvailable;  						_nextToWrite++;  						workitem.inputBytesAvailable = 0;  						workitem.status = (int)WorkItem.Status.Done;  						TraceOutput (TraceBits.WriteDone' "Write    done     wi({0}) stat({1})              cba({2})"' workitem.index' workitem.status' workitem.compressedBytesAvailable);  						Monitor.Pulse (workitem);  						break;  					}  					else {  						int wcycles = 0;  						// I've locked a workitem I cannot use.  						// Therefore' wake someone else up' and then release the lock.  						while (workitem.status != (int)WorkItem.Status.Compressed) {  							TraceOutput (TraceBits.WriteWait' "Write    waiting  wi({0}) stat({1}) nw({2}) nf({3}) nomore({4})"' workitem.index' workitem.status' _nextToWrite' _nextToFill' _noMoreInputForThisSegment);  							if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)  								break;  							wcycles++;  							// wake up someone else  							Monitor.Pulse (workitem);  							// release and wait  							Monitor.Wait (workitem);  							if (workitem.status == (int)WorkItem.Status.Compressed)  								TraceOutput (TraceBits.WriteWait' "Write    A-OK     wi({0}) stat({1}) iba({2}) cba({3}) cyc({4})"' workitem.index' workitem.status' workitem.inputBytesAvailable' workitem.compressedBytesAvailable' wcycles);  						}  						if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)  							break;  					}  				}  				while (true);  			}  			if (_noMoreInputForThisSegment)  				TraceOutput (TraceBits.Write' "Write    nomore  nw({0}) nf({1}) break({2})"' _nextToWrite' _nextToFill' (_nextToWrite == _nextToFill));  			if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)  				break;  		}  		while (true);  		// Finish:  		// After writing a series of buffers' closing each one with  		// Flush.Sync' we now write the final one as Flush.Finish' and  		// then stop.  		byte[] buffer = new byte[128];  		ZlibCodec compressor = new ZlibCodec ();  		int rc = compressor.InitializeDeflate (_compressLevel' false);  		compressor.InputBuffer = null;  		compressor.NextIn = 0;  		compressor.AvailableBytesIn = 0;  		compressor.OutputBuffer = buffer;  		compressor.NextOut = 0;  		compressor.AvailableBytesOut = buffer.Length;  		rc = compressor.Deflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)  			throw new Exception ("deflating: " + compressor.Message);  		if (buffer.Length - compressor.AvailableBytesOut > 0) {  			TraceOutput (TraceBits.WriteBegin' "Write    begin    flush bytes({0})"' buffer.Length - compressor.AvailableBytesOut);  			_outStream.Write (buffer' 0' buffer.Length - compressor.AvailableBytesOut);  			TraceOutput (TraceBits.WriteBegin' "Write    done     flush");  		}  		compressor.EndDeflate ();  		_Crc32 = c.Crc32Result;  		// signal that writing is complete:  		TraceOutput (TraceBits.Synch' "Synch    _writingDone.Set()           PWM");  		_writingDone.Set ();  	}  	while (true);  }  catch (System.Exception exc1) {  	lock (_eLock) {  		// expose the exception to the main thread  		if (_pendingException != null)  			_pendingException = exc1;  	}  }  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The following statement contains a magic number: do {  	// wait for the next session  	TraceOutput (TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.WaitOne(begin) PWM");  	_sessionReset.WaitOne ();  	TraceOutput (TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.WaitOne(done)  PWM");  	if (_isDisposed)  		break;  	TraceOutput (TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.Reset()        PWM");  	_sessionReset.Reset ();  	// repeatedly write buffers as they become ready  	WorkItem workitem = null;  	PMDCP.Compression.Zlib.CRC32 c = new PMDCP.Compression.Zlib.CRC32 ();  	do {  		workitem = _pool [_nextToWrite % _pc];  		lock (workitem) {  			if (_noMoreInputForThisSegment)  				TraceOutput (TraceBits.Write' "Write    drain    wi({0}) stat({1}) canuse({2})  cba({3})"' workitem.index' workitem.status' (workitem.status == (int)WorkItem.Status.Compressed)' workitem.compressedBytesAvailable);  			do {  				if (workitem.status == (int)WorkItem.Status.Compressed) {  					TraceOutput (TraceBits.WriteBegin' "Write    begin    wi({0}) stat({1})              cba({2})"' workitem.index' workitem.status' workitem.compressedBytesAvailable);  					workitem.status = (int)WorkItem.Status.Writing;  					_outStream.Write (workitem.compressed' 0' workitem.compressedBytesAvailable);  					c.Combine (workitem.crc' workitem.inputBytesAvailable);  					_totalBytesProcessed += workitem.inputBytesAvailable;  					_nextToWrite++;  					workitem.inputBytesAvailable = 0;  					workitem.status = (int)WorkItem.Status.Done;  					TraceOutput (TraceBits.WriteDone' "Write    done     wi({0}) stat({1})              cba({2})"' workitem.index' workitem.status' workitem.compressedBytesAvailable);  					Monitor.Pulse (workitem);  					break;  				}  				else {  					int wcycles = 0;  					// I've locked a workitem I cannot use.  					// Therefore' wake someone else up' and then release the lock.  					while (workitem.status != (int)WorkItem.Status.Compressed) {  						TraceOutput (TraceBits.WriteWait' "Write    waiting  wi({0}) stat({1}) nw({2}) nf({3}) nomore({4})"' workitem.index' workitem.status' _nextToWrite' _nextToFill' _noMoreInputForThisSegment);  						if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)  							break;  						wcycles++;  						// wake up someone else  						Monitor.Pulse (workitem);  						// release and wait  						Monitor.Wait (workitem);  						if (workitem.status == (int)WorkItem.Status.Compressed)  							TraceOutput (TraceBits.WriteWait' "Write    A-OK     wi({0}) stat({1}) iba({2}) cba({3}) cyc({4})"' workitem.index' workitem.status' workitem.inputBytesAvailable' workitem.compressedBytesAvailable' wcycles);  					}  					if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)  						break;  				}  			}  			while (true);  		}  		if (_noMoreInputForThisSegment)  			TraceOutput (TraceBits.Write' "Write    nomore  nw({0}) nf({1}) break({2})"' _nextToWrite' _nextToFill' (_nextToWrite == _nextToFill));  		if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)  			break;  	}  	while (true);  	// Finish:  	// After writing a series of buffers' closing each one with  	// Flush.Sync' we now write the final one as Flush.Finish' and  	// then stop.  	byte[] buffer = new byte[128];  	ZlibCodec compressor = new ZlibCodec ();  	int rc = compressor.InitializeDeflate (_compressLevel' false);  	compressor.InputBuffer = null;  	compressor.NextIn = 0;  	compressor.AvailableBytesIn = 0;  	compressor.OutputBuffer = buffer;  	compressor.NextOut = 0;  	compressor.AvailableBytesOut = buffer.Length;  	rc = compressor.Deflate (FlushType.Finish);  	if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)  		throw new Exception ("deflating: " + compressor.Message);  	if (buffer.Length - compressor.AvailableBytesOut > 0) {  		TraceOutput (TraceBits.WriteBegin' "Write    begin    flush bytes({0})"' buffer.Length - compressor.AvailableBytesOut);  		_outStream.Write (buffer' 0' buffer.Length - compressor.AvailableBytesOut);  		TraceOutput (TraceBits.WriteBegin' "Write    done     flush");  	}  	compressor.EndDeflate ();  	_Crc32 = c.Crc32Result;  	// signal that writing is complete:  	TraceOutput (TraceBits.Synch' "Synch    _writingDone.Set()           PWM");  	_writingDone.Set ();  }  while (true);  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & _DesiredTrace) != 0) {  	lock (_outputLock) {  		int tid = Thread.CurrentThread.GetHashCode ();  		Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);  		Console.Write ("{0:000} PDOS "' tid);  		Console.WriteLine (format' varParams);  		Console.ResetColor ();  	}  }  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & _DesiredTrace) != 0) {  	lock (_outputLock) {  		int tid = Thread.CurrentThread.GetHashCode ();  		Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);  		Console.Write ("{0:000} PDOS "' tid);  		Console.WriteLine (format' varParams);  		Console.ResetColor ();  	}  }  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: lock (_outputLock) {  	int tid = Thread.CurrentThread.GetHashCode ();  	Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);  	Console.Write ("{0:000} PDOS "' tid);  	Console.WriteLine (format' varParams);  	Console.ResetColor ();  }  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: lock (_outputLock) {  	int tid = Thread.CurrentThread.GetHashCode ();  	Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);  	Console.Write ("{0:000} PDOS "' tid);  	Console.WriteLine (format' varParams);  	Console.ResetColor ();  }  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);  
Magic Number,PMDCP.Compression.Zlib,ParallelDeflateOutputStream,C:\repos\pmdcp_framework\Compression\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256) ? _dist_code [dist] : _dist_code [256 + SharedUtils.URShift (dist' 7)];  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256) ? _dist_code [dist] : _dist_code [256 + SharedUtils.URShift (dist' 7)];  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256) ? _dist_code [dist] : _dist_code [256 + SharedUtils.URShift (dist' 7)];  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree [s.heap [s.heap_max] * 2 + 1] = 0;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree [n * 2 + 1] = (short)bits;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree [n * 2];  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (stree != null)  	s.static_len += f * (stree [n * 2 + 1] + xbits);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree [n * 2 + 1] + xbits);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	// move one leaf down the tree  	s.bl_count [bits + 1] = (short)(s.bl_count [bits + 1] + 2);  	// move one overflow item as its brother  	s.bl_count [max_length]--;  	// The brother of the overflow item also moves one step up'  	// but this does not affect bl_count[max_length]  	overflow -= 2;  }  while (overflow > 0);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	// move one leaf down the tree  	s.bl_count [bits + 1] = (short)(s.bl_count [bits + 1] + 2);  	// move one overflow item as its brother  	s.bl_count [max_length]--;  	// The brother of the overflow item also moves one step up'  	// but this does not affect bl_count[max_length]  	overflow -= 2;  }  while (overflow > 0);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count [bits + 1] = (short)(s.bl_count [bits + 1] + 2);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree [m * 2 + 1] = (short)bits;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++) {  	if (tree [n * 2] != 0) {  		s.heap [++s.heap_len] = max_code = n;  		s.depth [n] = 0;  	}  	else {  		tree [n * 2 + 1] = 0;  	}  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++) {  	if (tree [n * 2] != 0) {  		s.heap [++s.heap_len] = max_code = n;  		s.depth [n] = 0;  	}  	else {  		tree [n * 2 + 1] = 0;  	}  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: if (tree [n * 2] != 0) {  	s.heap [++s.heap_len] = max_code = n;  	s.depth [n] = 0;  }  else {  	tree [n * 2 + 1] = 0;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: if (tree [n * 2] != 0) {  	s.heap [++s.heap_len] = max_code = n;  	s.depth [n] = 0;  }  else {  	tree [n * 2 + 1] = 0;  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [n * 2 + 1] = 0;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = 1;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: if (stree != null)  	s.static_len -= stree [node * 2 + 1];  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree [node * 2 + 1];  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)  	s.pqdownheap (tree' n);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: n = s.heap_len / 2
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  	s.depth [node] = (sbyte)(System.Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  	s.depth [node] = (sbyte)(System.Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  	s.depth [node] = (sbyte)(System.Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  	s.depth [node] = (sbyte)(System.Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  	s.depth [node] = (sbyte)(System.Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  	s.depth [node] = (sbyte)(System.Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = unchecked((short)(tree [n * 2] + tree [m * 2]));  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	int len = tree [n * 2 + 1];  	if (len == 0)  		continue;  	// Now reverse the bits  	tree [n * 2] = unchecked((short)(bi_reverse (next_code [len]++' len)));  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	int len = tree [n * 2 + 1];  	if (len == 0)  		continue;  	// Now reverse the bits  	tree [n * 2] = unchecked((short)(bi_reverse (next_code [len]++' len)));  }  
Magic Number,PMDCP.Compression.Zlib,Tree,C:\repos\pmdcp_framework\Compression\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: tree [n * 2] = unchecked((short)(bi_reverse (next_code [len]++' len)));  
Magic Number,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0) {  	int k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		//s1 += (buf[index++] & 0xff); s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [index++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0) {  	int k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		//s1 += (buf[index++] & 0xff); s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		s1 += buf [index++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [index++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: while (k >= 16) {  	//s1 += (buf[index++] & 0xff); s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	k -= 16;  }  
Magic Number,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: while (k >= 16) {  	//s1 += (buf[index++] & 0xff); s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	s1 += buf [index++];  	s2 += s1;  	k -= 16;  }  
Magic Number,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: k -= 16;  
Magic Number,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: return (uint)((s2 << 16) | s1);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,Write,The following statement contains a magic number: do {  	_z.OutputBuffer = workingBuffer;  	_z.NextOut = 0;  	_z.AvailableBytesOut = _workingBuffer.Length;  	int rc = (_wantCompress) ? _z.Deflate (_flushMode) : _z.Inflate (_flushMode);  	if (rc != ZlibConstants.Z_OK && rc != ZlibConstants.Z_STREAM_END)  		throw new ZlibException ((_wantCompress ? "de" : "in") + "flating: " + _z.Message);  	//if (_workingBuffer.Length - _z.AvailableBytesOut > 0)  	_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  	done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  	// If GZIP and de-compress' we're done when 8 bytes remain.  	if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  		done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  }  while (!done);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,Write,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  	done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,Write,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer) {  	bool done = false;  	do {  		_z.OutputBuffer = workingBuffer;  		_z.NextOut = 0;  		_z.AvailableBytesOut = _workingBuffer.Length;  		int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  			string verb = (_wantCompress ? "de" : "in") + "flating";  			if (_z.Message == null)  				throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  			else  				throw new ZlibException (verb + ": " + _z.Message);  		}  		if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  			_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  		}  		done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  		// If GZIP and de-compress' we're done when 8 bytes remain.  		if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  			done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  	}  	while (!done);  	Flush ();  	// workitem 7159  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (_wantCompress) {  			// Emit the GZIP trailer: CRC32 and  size mod 2^32  			int c1 = crc.Crc32Result;  			_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  			int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  			_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  		}  		else {  			throw new ZlibException ("Writing with decompression is not supported.");  		}  	}  }  // workitem 7159  else if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer) {  	bool done = false;  	do {  		_z.OutputBuffer = workingBuffer;  		_z.NextOut = 0;  		_z.AvailableBytesOut = _workingBuffer.Length;  		int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  			string verb = (_wantCompress ? "de" : "in") + "flating";  			if (_z.Message == null)  				throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  			else  				throw new ZlibException (verb + ": " + _z.Message);  		}  		if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  			_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  		}  		done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  		// If GZIP and de-compress' we're done when 8 bytes remain.  		if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  			done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  	}  	while (!done);  	Flush ();  	// workitem 7159  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (_wantCompress) {  			// Emit the GZIP trailer: CRC32 and  size mod 2^32  			int c1 = crc.Crc32Result;  			_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  			int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  			_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  		}  		else {  			throw new ZlibException ("Writing with decompression is not supported.");  		}  	}  }  // workitem 7159  else if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer) {  	bool done = false;  	do {  		_z.OutputBuffer = workingBuffer;  		_z.NextOut = 0;  		_z.AvailableBytesOut = _workingBuffer.Length;  		int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  			string verb = (_wantCompress ? "de" : "in") + "flating";  			if (_z.Message == null)  				throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  			else  				throw new ZlibException (verb + ": " + _z.Message);  		}  		if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  			_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  		}  		done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  		// If GZIP and de-compress' we're done when 8 bytes remain.  		if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  			done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  	}  	while (!done);  	Flush ();  	// workitem 7159  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (_wantCompress) {  			// Emit the GZIP trailer: CRC32 and  size mod 2^32  			int c1 = crc.Crc32Result;  			_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  			int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  			_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  		}  		else {  			throw new ZlibException ("Writing with decompression is not supported.");  		}  	}  }  // workitem 7159  else if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer) {  	bool done = false;  	do {  		_z.OutputBuffer = workingBuffer;  		_z.NextOut = 0;  		_z.AvailableBytesOut = _workingBuffer.Length;  		int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  			string verb = (_wantCompress ? "de" : "in") + "flating";  			if (_z.Message == null)  				throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  			else  				throw new ZlibException (verb + ": " + _z.Message);  		}  		if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  			_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  		}  		done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  		// If GZIP and de-compress' we're done when 8 bytes remain.  		if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  			done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  	}  	while (!done);  	Flush ();  	// workitem 7159  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (_wantCompress) {  			// Emit the GZIP trailer: CRC32 and  size mod 2^32  			int c1 = crc.Crc32Result;  			_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  			int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  			_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  		}  		else {  			throw new ZlibException ("Writing with decompression is not supported.");  		}  	}  }  // workitem 7159  else if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer) {  	bool done = false;  	do {  		_z.OutputBuffer = workingBuffer;  		_z.NextOut = 0;  		_z.AvailableBytesOut = _workingBuffer.Length;  		int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  			string verb = (_wantCompress ? "de" : "in") + "flating";  			if (_z.Message == null)  				throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  			else  				throw new ZlibException (verb + ": " + _z.Message);  		}  		if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  			_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  		}  		done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  		// If GZIP and de-compress' we're done when 8 bytes remain.  		if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  			done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  	}  	while (!done);  	Flush ();  	// workitem 7159  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (_wantCompress) {  			// Emit the GZIP trailer: CRC32 and  size mod 2^32  			int c1 = crc.Crc32Result;  			_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  			int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  			_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  		}  		else {  			throw new ZlibException ("Writing with decompression is not supported.");  		}  	}  }  // workitem 7159  else if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer) {  	bool done = false;  	do {  		_z.OutputBuffer = workingBuffer;  		_z.NextOut = 0;  		_z.AvailableBytesOut = _workingBuffer.Length;  		int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  			string verb = (_wantCompress ? "de" : "in") + "flating";  			if (_z.Message == null)  				throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  			else  				throw new ZlibException (verb + ": " + _z.Message);  		}  		if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  			_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  		}  		done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  		// If GZIP and de-compress' we're done when 8 bytes remain.  		if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  			done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  	}  	while (!done);  	Flush ();  	// workitem 7159  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (_wantCompress) {  			// Emit the GZIP trailer: CRC32 and  size mod 2^32  			int c1 = crc.Crc32Result;  			_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  			int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  			_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  		}  		else {  			throw new ZlibException ("Writing with decompression is not supported.");  		}  	}  }  // workitem 7159  else if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer) {  	bool done = false;  	do {  		_z.OutputBuffer = workingBuffer;  		_z.NextOut = 0;  		_z.AvailableBytesOut = _workingBuffer.Length;  		int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  		if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  			string verb = (_wantCompress ? "de" : "in") + "flating";  			if (_z.Message == null)  				throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  			else  				throw new ZlibException (verb + ": " + _z.Message);  		}  		if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  			_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  		}  		done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  		// If GZIP and de-compress' we're done when 8 bytes remain.  		if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  			done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  	}  	while (!done);  	Flush ();  	// workitem 7159  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (_wantCompress) {  			// Emit the GZIP trailer: CRC32 and  size mod 2^32  			int c1 = crc.Crc32Result;  			_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  			int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  			_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  		}  		else {  			throw new ZlibException ("Writing with decompression is not supported.");  		}  	}  }  // workitem 7159  else if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: do {  	_z.OutputBuffer = workingBuffer;  	_z.NextOut = 0;  	_z.AvailableBytesOut = _workingBuffer.Length;  	int rc = (_wantCompress) ? _z.Deflate (FlushType.Finish) : _z.Inflate (FlushType.Finish);  	if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK) {  		string verb = (_wantCompress ? "de" : "in") + "flating";  		if (_z.Message == null)  			throw new ZlibException (String.Format ("{0}: (rc = {1})"' verb' rc));  		else  			throw new ZlibException (verb + ": " + _z.Message);  	}  	if (_workingBuffer.Length - _z.AvailableBytesOut > 0) {  		_stream.Write (_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);  	}  	done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;  	// If GZIP and de-compress' we're done when 8 bytes remain.  	if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  		done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  }  while (!done);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)  	done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP) {  	if (_wantCompress) {  		// Emit the GZIP trailer: CRC32 and  size mod 2^32  		int c1 = crc.Crc32Result;  		_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  		int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  		_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  	}  	else {  		throw new ZlibException ("Writing with decompression is not supported.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP) {  	if (_wantCompress) {  		// Emit the GZIP trailer: CRC32 and  size mod 2^32  		int c1 = crc.Crc32Result;  		_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  		int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  		_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  	}  	else {  		throw new ZlibException ("Writing with decompression is not supported.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_wantCompress) {  	// Emit the GZIP trailer: CRC32 and  size mod 2^32  	int c1 = crc.Crc32Result;  	_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  	int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  	_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  }  else {  	throw new ZlibException ("Writing with decompression is not supported.");  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_wantCompress) {  	// Emit the GZIP trailer: CRC32 and  size mod 2^32  	int c1 = crc.Crc32Result;  	_stream.Write (BitConverter.GetBytes (c1)' 0' 4);  	int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);  	_stream.Write (BitConverter.GetBytes (c2)' 0' 4);  }  else {  	throw new ZlibException ("Writing with decompression is not supported.");  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write (BitConverter.GetBytes (c1)' 0' 4);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write (BitConverter.GetBytes (c2)' 0' 4);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Reader) {  	if (_flavor == ZlibStreamFlavor.GZIP) {  		if (!_wantCompress) {  			// workitem 8501: handle edge case (decompress empty stream)  			if (_z.TotalBytesOut == 0L)  				return;  			// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  			byte[] trailer = new byte[8];  			// workitem 8679  			if (_z.AvailableBytesIn != 8) {  				// Make sure we have read to the end of the stream  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  				int bytesNeeded = 8 - _z.AvailableBytesIn;  				int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  				if (bytesNeeded != bytesRead) {  					throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  				}  			}  			else {  				Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  			}  			Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  			Int32 crc32_actual = crc.Crc32Result;  			Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  			Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  			if (crc32_actual != crc32_expected)  				throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  			if (isize_actual != isize_expected)  				throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  		}  		else {  			throw new ZlibException ("Reading with compression is not supported.");  		}  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP) {  	if (!_wantCompress) {  		// workitem 8501: handle edge case (decompress empty stream)  		if (_z.TotalBytesOut == 0L)  			return;  		// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  		byte[] trailer = new byte[8];  		// workitem 8679  		if (_z.AvailableBytesIn != 8) {  			// Make sure we have read to the end of the stream  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  			int bytesNeeded = 8 - _z.AvailableBytesIn;  			int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  			if (bytesNeeded != bytesRead) {  				throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  			}  		}  		else {  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  		}  		Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  		Int32 crc32_actual = crc.Crc32Result;  		Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  		Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  		if (crc32_actual != crc32_expected)  			throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  		if (isize_actual != isize_expected)  			throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  	}  	else {  		throw new ZlibException ("Reading with compression is not supported.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP) {  	if (!_wantCompress) {  		// workitem 8501: handle edge case (decompress empty stream)  		if (_z.TotalBytesOut == 0L)  			return;  		// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  		byte[] trailer = new byte[8];  		// workitem 8679  		if (_z.AvailableBytesIn != 8) {  			// Make sure we have read to the end of the stream  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  			int bytesNeeded = 8 - _z.AvailableBytesIn;  			int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  			if (bytesNeeded != bytesRead) {  				throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  			}  		}  		else {  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  		}  		Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  		Int32 crc32_actual = crc.Crc32Result;  		Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  		Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  		if (crc32_actual != crc32_expected)  			throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  		if (isize_actual != isize_expected)  			throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  	}  	else {  		throw new ZlibException ("Reading with compression is not supported.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP) {  	if (!_wantCompress) {  		// workitem 8501: handle edge case (decompress empty stream)  		if (_z.TotalBytesOut == 0L)  			return;  		// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  		byte[] trailer = new byte[8];  		// workitem 8679  		if (_z.AvailableBytesIn != 8) {  			// Make sure we have read to the end of the stream  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  			int bytesNeeded = 8 - _z.AvailableBytesIn;  			int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  			if (bytesNeeded != bytesRead) {  				throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  			}  		}  		else {  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  		}  		Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  		Int32 crc32_actual = crc.Crc32Result;  		Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  		Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  		if (crc32_actual != crc32_expected)  			throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  		if (isize_actual != isize_expected)  			throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  	}  	else {  		throw new ZlibException ("Reading with compression is not supported.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_flavor == ZlibStreamFlavor.GZIP) {  	if (!_wantCompress) {  		// workitem 8501: handle edge case (decompress empty stream)  		if (_z.TotalBytesOut == 0L)  			return;  		// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  		byte[] trailer = new byte[8];  		// workitem 8679  		if (_z.AvailableBytesIn != 8) {  			// Make sure we have read to the end of the stream  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  			int bytesNeeded = 8 - _z.AvailableBytesIn;  			int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  			if (bytesNeeded != bytesRead) {  				throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  			}  		}  		else {  			Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  		}  		Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  		Int32 crc32_actual = crc.Crc32Result;  		Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  		Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  		if (crc32_actual != crc32_expected)  			throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  		if (isize_actual != isize_expected)  			throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  	}  	else {  		throw new ZlibException ("Reading with compression is not supported.");  	}  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (!_wantCompress) {  	// workitem 8501: handle edge case (decompress empty stream)  	if (_z.TotalBytesOut == 0L)  		return;  	// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  	byte[] trailer = new byte[8];  	// workitem 8679  	if (_z.AvailableBytesIn != 8) {  		// Make sure we have read to the end of the stream  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  		int bytesNeeded = 8 - _z.AvailableBytesIn;  		int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  		if (bytesNeeded != bytesRead) {  			throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  		}  	}  	else {  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  	}  	Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  	Int32 crc32_actual = crc.Crc32Result;  	Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  	Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  	if (crc32_actual != crc32_expected)  		throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  	if (isize_actual != isize_expected)  		throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  }  else {  	throw new ZlibException ("Reading with compression is not supported.");  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (!_wantCompress) {  	// workitem 8501: handle edge case (decompress empty stream)  	if (_z.TotalBytesOut == 0L)  		return;  	// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  	byte[] trailer = new byte[8];  	// workitem 8679  	if (_z.AvailableBytesIn != 8) {  		// Make sure we have read to the end of the stream  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  		int bytesNeeded = 8 - _z.AvailableBytesIn;  		int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  		if (bytesNeeded != bytesRead) {  			throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  		}  	}  	else {  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  	}  	Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  	Int32 crc32_actual = crc.Crc32Result;  	Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  	Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  	if (crc32_actual != crc32_expected)  		throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  	if (isize_actual != isize_expected)  		throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  }  else {  	throw new ZlibException ("Reading with compression is not supported.");  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (!_wantCompress) {  	// workitem 8501: handle edge case (decompress empty stream)  	if (_z.TotalBytesOut == 0L)  		return;  	// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  	byte[] trailer = new byte[8];  	// workitem 8679  	if (_z.AvailableBytesIn != 8) {  		// Make sure we have read to the end of the stream  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  		int bytesNeeded = 8 - _z.AvailableBytesIn;  		int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  		if (bytesNeeded != bytesRead) {  			throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  		}  	}  	else {  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  	}  	Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  	Int32 crc32_actual = crc.Crc32Result;  	Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  	Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  	if (crc32_actual != crc32_expected)  		throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  	if (isize_actual != isize_expected)  		throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  }  else {  	throw new ZlibException ("Reading with compression is not supported.");  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (!_wantCompress) {  	// workitem 8501: handle edge case (decompress empty stream)  	if (_z.TotalBytesOut == 0L)  		return;  	// Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32  	byte[] trailer = new byte[8];  	// workitem 8679  	if (_z.AvailableBytesIn != 8) {  		// Make sure we have read to the end of the stream  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  		int bytesNeeded = 8 - _z.AvailableBytesIn;  		int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  		if (bytesNeeded != bytesRead) {  			throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  		}  	}  	else {  		Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  	}  	Int32 crc32_expected = BitConverter.ToInt32 (trailer' 0);  	Int32 crc32_actual = crc.Crc32Result;  	Int32 isize_expected = BitConverter.ToInt32 (trailer' 4);  	Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);  	if (crc32_actual != crc32_expected)  		throw new ZlibException (String.Format ("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));  	if (isize_actual != isize_expected)  		throw new ZlibException (String.Format ("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));  }  else {  	throw new ZlibException ("Reading with compression is not supported.");  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_z.AvailableBytesIn != 8) {  	// Make sure we have read to the end of the stream  	Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  	int bytesNeeded = 8 - _z.AvailableBytesIn;  	int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  	if (bytesNeeded != bytesRead) {  		throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  	}  }  else {  	Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_z.AvailableBytesIn != 8) {  	// Make sure we have read to the end of the stream  	Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);  	int bytesNeeded = 8 - _z.AvailableBytesIn;  	int bytesRead = _stream.Read (trailer' _z.AvailableBytesIn' bytesNeeded);  	if (bytesNeeded != bytesRead) {  		throw new ZlibException (String.Format ("Protocol error. AvailableBytesIn={0}' expected 8"' _z.AvailableBytesIn + bytesRead));  	}  }  else {  	Array.Copy (_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (n != 10)  	throw new ZlibException ("Not a valid GZIP stream.");  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (header [0] != 0x1F || header [1] != 0x8B || header [2] != 8)  	throw new ZlibException ("Bad GZIP header.");  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (header [0] != 0x1F || header [1] != 0x8B || header [2] != 8)  	throw new ZlibException ("Bad GZIP header.");  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header [3] & 0x04) == 0x04) {  	// read and discard extra field  	n = _stream.Read (header' 0' 2);  	// 2-byte length field  	totalBytesRead += n;  	Int16 extraLength = (Int16)(header [0] + header [1] * 256);  	byte[] extra = new byte[extraLength];  	n = _stream.Read (extra' 0' extra.Length);  	if (n != extraLength)  		throw new ZlibException ("Unexpected end-of-file reading GZIP header.");  	totalBytesRead += n;  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header [3] & 0x04) == 0x04) {  	// read and discard extra field  	n = _stream.Read (header' 0' 2);  	// 2-byte length field  	totalBytesRead += n;  	Int16 extraLength = (Int16)(header [0] + header [1] * 256);  	byte[] extra = new byte[extraLength];  	n = _stream.Read (extra' 0' extra.Length);  	if (n != extraLength)  		throw new ZlibException ("Unexpected end-of-file reading GZIP header.");  	totalBytesRead += n;  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header [3] & 0x04) == 0x04) {  	// read and discard extra field  	n = _stream.Read (header' 0' 2);  	// 2-byte length field  	totalBytesRead += n;  	Int16 extraLength = (Int16)(header [0] + header [1] * 256);  	byte[] extra = new byte[extraLength];  	n = _stream.Read (extra' 0' extra.Length);  	if (n != extraLength)  		throw new ZlibException ("Unexpected end-of-file reading GZIP header.");  	totalBytesRead += n;  }  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: n = _stream.Read (header' 0' 2);  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header [3] & 0x08) == 0x08)  	_GzipFileName = ReadZeroTerminatedString ();  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header [3] & 0x10) == 0x010)  	_GzipComment = ReadZeroTerminatedString ();  
Magic Number,PMDCP.Compression.Zlib,ZlibBaseStream,C:\repos\pmdcp_framework\Compression\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header [3] & 0x02) == 0x02)  	Read (_buf1' 0' 1);  
Duplicate Code,PMDCP.Compression.Zlib,InflateCodes,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((225' 249)' (260' 284))
Duplicate Code,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 30)' (13' 32)' (15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42))
Duplicate Code,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 39)' (13' 41))
Duplicate Code,PMDCP.Compression.Zlib,Adler,C:\repos\pmdcp_framework\Compression\Zlib\Zlib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 30)' (15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42))
Missing Default,SevenZip.CommandLineParser,Parser,C:\repos\pmdcp_framework\Compression\SevenZip\CommandLineParser\CommandLineParser.cs,ParseString,The following switch statement is missing a default case: switch (type) {  case SwitchType.PostMinus: {  	if (tailSize == 0)  		matchedSwitch.WithMinus = false;  	else {  		matchedSwitch.WithMinus = (srcString [pos] == kSwitchMinus);  		if (matchedSwitch.WithMinus)  			pos++;  	}  	break;  }  case SwitchType.PostChar: {  	if (tailSize < switchForm.MinLen)  		throw new Exception ("switch is not full");  	string charSet = switchForm.PostCharSet;  	const int kEmptyCharValue = -1;  	if (tailSize == 0)  		matchedSwitch.PostCharIndex = kEmptyCharValue;  	else {  		int index = charSet.IndexOf (srcString [pos]);  		if (index < 0)  			matchedSwitch.PostCharIndex = kEmptyCharValue;  		else {  			matchedSwitch.PostCharIndex = index;  			pos++;  		}  	}  	break;  }  case SwitchType.LimitedPostString:  case SwitchType.UnLimitedPostString: {  	int minLen = switchForm.MinLen;  	if (tailSize < minLen)  		throw new Exception ("switch is not full");  	if (type == SwitchType.UnLimitedPostString) {  		matchedSwitch.PostStrings.Add (srcString.Substring (pos));  		return true;  	}  	String stringSwitch = srcString.Substring (pos' minLen);  	pos += minLen;  	for (int i = minLen; i < switchForm.MaxLen && pos < len; i++' pos++) {  		char c = srcString [pos];  		if (IsItSwitchChar (c))  			break;  		stringSwitch += c;  	}  	matchedSwitch.PostStrings.Add (stringSwitch);  	break;  }  }  
Missing Default,PMDCP.Compression.Zlib,DeflateManager,C:\repos\pmdcp_framework\Compression\Zlib\Deflate.cs,SetDeflater,The following switch statement is missing a default case: switch (config.Flavor) {  case DeflateFlavor.Store:  	DeflateFunction = DeflateNone;  	break;  case DeflateFlavor.Fast:  	DeflateFunction = DeflateFast;  	break;  case DeflateFlavor.Slow:  	DeflateFunction = DeflateSlow;  	break;  }  
Missing Default,PMDCP.Compression.Zlib,InflateBlocks,C:\repos\pmdcp_framework\Compression\Zlib\Inflate.cs,Process,The following switch statement is missing a default case: switch ((uint)t >> 1) {  case 0:  	// stored  	b >>= 3;  	k -= (3);  	t = k & 7;  	// go to byte boundary  	b >>= t;  	k -= t;  	mode = InflateBlockMode.LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	int[] bl = new int[1];  	int[] bd = new int[1];  	int[][] tl = new int[1][];  	int[][] td = new int[1][];  	InfTree.inflate_trees_fixed (bl' bd' tl' td' _codec);  	codes.Init (bl [0]' bd [0]' tl [0]' 0' td [0]' 0);  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.CODES;  	break;  case 2:  	// dynamic  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.TABLE;  	break;  case 3:  	// illegal  	b >>= 3;  	k -= 3;  	mode = InflateBlockMode.BAD;  	_codec.Message = "invalid block type";  	r = ZlibConstants.Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	_codec.AvailableBytesIn = n;  	_codec.TotalBytesIn += p - _codec.NextIn;  	_codec.NextIn = p;  	writeAt = q;  	return Flush (r);  }  
