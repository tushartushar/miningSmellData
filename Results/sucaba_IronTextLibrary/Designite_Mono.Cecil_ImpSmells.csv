Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The method has 73 lines of code.
Long Method,Mono.Cecil.Cil,OpCodeNames,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCodeNames,The method has 1801 lines of code.
Long Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The method has 249 lines of code.
Long Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The method has 195 lines of code.
Long Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The method has 131 lines of code.
Long Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteTypeSignature,The method has 65 lines of code.
Long Method,Mono.Cecil,MetadataSystem,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\MetadataSystem.cs,InitializePrimitives,The method has 76 lines of code.
Long Method,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The method has 64 lines of code.
Long Method,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The method has 253 lines of code.
Long Method,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method has 135 lines of code.
Long Method,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The method has 116 lines of code.
Long Method,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The method has 84 lines of code.
Complex Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,Cyclomatic complexity of the method is 51
Complex Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeExceptionHandlerStackSize,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,CopyBranchStackSize,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeStackDelta,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,Cyclomatic complexity of the method is 26
Complex Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteExceptionHandlerSpecific,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadOperand,Cyclomatic complexity of the method is 27
Complex Method,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ResolveBranches,Cyclomatic complexity of the method is 13
Complex Method,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadExceptionHandlerSpecific,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawMethodBody,Cyclomatic complexity of the method is 13
Complex Method,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,Cyclomatic complexity of the method is 43
Complex Method,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawExceptionHandlers,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,Cyclomatic complexity of the method is 19
Complex Method,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,Cyclomatic complexity of the method is 41
Complex Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,Cyclomatic complexity of the method is 41
Complex Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,Cyclomatic complexity of the method is 55
Complex Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,IsPrimitive,Cyclomatic complexity of the method is 15
Complex Method,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,IsTypeSpecification,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,HashPublicKey,Cyclomatic complexity of the method is 7
Complex Method,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,Cyclomatic complexity of the method is 20
Complex Method,Mono.Cecil,ImmediateModuleReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadModule,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,ImmediateModuleReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadType,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,ImmediateModuleReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadMethods,Cyclomatic complexity of the method is 7
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,IsNested,Cyclomatic complexity of the method is 7
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetTypeReferenceScope,Cyclomatic complexity of the method is 7
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,Cyclomatic complexity of the method is 31
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadMethodSemantics,Cyclomatic complexity of the method is 20
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,LookupToken,Cyclomatic complexity of the method is 22
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadMemberReference,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadExportedTypes,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetExportedTypeScope,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetGenericParameter,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadArrayTypeSignature,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadTypeSignature,Cyclomatic complexity of the method is 24
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadMethodSignature,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadCustomAttributeNamedArgument,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadPrimitiveValue,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetPrimitiveType,Cyclomatic complexity of the method is 15
Complex Method,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadMarshalInfo,Cyclomatic complexity of the method is 19
Complex Method,Mono.Cecil,ModuleWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteModuleTo,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,BuildModule,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddResources,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,GetExportedTypeScope,Cyclomatic complexity of the method is 7
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddType,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantType,Cyclomatic complexity of the method is 29
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantType,Cyclomatic complexity of the method is 15
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantSignature,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,LookupToken,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteMethodSignature,Cyclomatic complexity of the method is 7
Complex Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteTypeSignature,Cyclomatic complexity of the method is 26
Complex Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteArrayTypeSignature,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteCustomAttributeValue,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WritePrimitiveValue,Cyclomatic complexity of the method is 39
Complex Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteCustomAttributeFieldOrPropType,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteMarshalInfo,Cyclomatic complexity of the method is 23
Complex Method,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,Cyclomatic complexity of the method is 17
Complex Method,Mono.Cecil,TypeParser,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeParser.cs,ParseSpecs,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil,TypeParser,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeParser.cs,CreateSpecs,Cyclomatic complexity of the method is 18
Complex Method,Mono.Cecil,TypeParser,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeParser.cs,AppendTypeSpecification,Cyclomatic complexity of the method is 27
Complex Method,Mono.Cecil,MetadataImporter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\Import.cs,ImportTypeSpecification,Cyclomatic complexity of the method is 36
Complex Method,Mono.Cecil,MetadataResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\MetadataResolver.cs,Resolve,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil,MetadataResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\MetadataResolver.cs,GetMethod,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,MetadataSystem,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\MetadataSystem.cs,Clear,Cyclomatic complexity of the method is 18
Complex Method,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadataStream,Cyclomatic complexity of the method is 16
Complex Method,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,Cyclomatic complexity of the method is 137
Complex Method,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,Cyclomatic complexity of the method is 8
Long Parameter List,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeStackSize,The method has 4 parameters.
Long Parameter List,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawFatMethod,The method has 4 parameters.
Long Parameter List,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawExceptionHandlers,The method has 4 parameters.
Long Parameter List,Mono.Cecil.Metadata,Row,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Row.cs,Row,The method has 4 parameters.
Long Parameter List,Mono.Cecil.Metadata,Row,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Row.cs,Row,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Metadata,Row,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Row.cs,Row,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Metadata,Row,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Row.cs,Row,The method has 9 parameters.
Long Parameter List,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,SetMaskedAttributes,The method has 4 parameters.
Long Parameter List,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,SetMaskedAttributes,The method has 4 parameters.
Long Parameter List,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadPointers,The method has 5 parameters.
Long Parameter List,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,MetadataBuilder,The method has 4 parameters.
Long Parameter List,Mono.Cecil,TypeParser,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeParser.cs,AppendType,The method has 4 parameters.
Long Parameter List,Mono.Cecil,ExportedType,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\ExportedType.cs,ExportedType,The method has 4 parameters.
Long Parameter List,Mono.Cecil,EmbeddedResource,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\EmbeddedResource.cs,EmbeddedResource,The method has 4 parameters.
Long Parameter List,Mono.Cecil,ModuleDefinition,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\ModuleDefinition.cs,GetFileStream,The method has 4 parameters.
Long Parameter List,Mono.Cecil,TypeDefinition,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeDefinition.cs,TypeDefinition,The method has 4 parameters.
Long Parameter List,Mono.Cecil,TypeReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeReference.cs,TypeReference,The method has 4 parameters.
Long Parameter List,Mono.Cecil,TypeReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeReference.cs,TypeReference,The method has 5 parameters.
Long Parameter List,Mono.Cecil,CryptoService,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoService.cs,CopyStreamChunk,The method has 4 parameters.
Long Identifier,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddGenericParameters,The length of the parameter generic_param_constraint_table is 30.
Long Statement,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,RequiresFatHeader,The length of the statement  "	return body.CodeSize >= 64 || body.InitLocals || body.HasVariables || body.HasExceptionHandlers || body.MaxStackSize > 8; " is 121.
Long Statement,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The length of the statement  "			buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ()); " is 122.
Long Statement,Mono.Cecil.Metadata,UserStringHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,WriteString,The length of the statement  "			if (@char > 0x7e || (@char >= 0x01 && @char <= 0x08) || (@char >= 0x0e && @char <= 0x1f) || @char == 0x27 || @char == 0x2d) { " is 125.
Long Statement,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSecurityDeclarations,The length of the statement  "	return module.HasImage () ? module.Read (self' (provider' reader) => reader.ReadSecurityDeclarations (provider)) : new Collection<SecurityDeclaration> (); " is 154.
Long Statement,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ResolveConstant,The length of the statement  "	constant = module.HasImage () ? module.Read (self' (provider' reader) => reader.ReadConstant (provider)) : Mixin.NoValue; " is 121.
Long Statement,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetCustomAttributes,The length of the statement  "	return module.HasImage () ? module.Read (self' (provider' reader) => reader.ReadCustomAttributes (provider)) : new Collection<CustomAttribute> (); " is 146.
Long Statement,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetGenericParameters,The length of the statement  "	return module.HasImage () ? module.Read (self' (provider' reader) => reader.ReadGenericParameters (provider)) : new GenericParameterCollection (self); " is 150.
Long Statement,Mono.Cecil,ModuleReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadSymbols,The length of the statement  "		var reader = parameters.SymbolStream != null ? symbol_reader_provider.GetSymbolReader (module' parameters.SymbolStream) : symbol_reader_provider.GetSymbolReader (module' module.FullyQualifiedName); " is 197.
Long Statement,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetManagedResourceStream,The length of the statement  "	var length = buffer [position] | (buffer [position + 1] << 8) | (buffer [position + 2] << 16) | (buffer [position + 3] << 24); " is 126.
Long Statement,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,AddGenericConstraintMapping,The length of the statement  "	metadata.SetGenericConstraintMapping (generic_parameter' AddMapping (metadata.GenericConstraints' generic_parameter' constraint)); " is 130.
Long Statement,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadXmlSecurityDeclaration,The length of the statement  "	var attribute = new SecurityAttribute (module.TypeSystem.LookupType ("System.Security.Permissions"' "PermissionSetAttribute")); " is 127.
Long Statement,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadXmlSecurityDeclaration,The length of the statement  "	attribute.properties.Add (new CustomAttributeNamedArgument ("XML"' new CustomAttributeArgument (module.TypeSystem.String' Encoding.Unicode.GetString (blob' 0' blob.Length)))); " is 175.
Long Statement,Mono.Cecil,SignatureReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadCustomAttributeElement,The length of the statement  "	return new CustomAttributeArgument (type' type.etype == ElementType.Object ? ReadCustomAttributeElement (ReadCustomAttributeFieldOrPropType ()) : ReadCustomAttributeElementValue (type)); " is 186.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,BuildAssembly,The length of the statement  "	table.row = new AssemblyRow (name.HashAlgorithm' (ushort)name.Version.Major' (ushort)name.Version.Minor' (ushort)name.Version.Build' (ushort)name.Version.Revision' name.Attributes' GetBlobIndex (name.PublicKey)' GetStringIndex (name.Name)' GetStringIndex (name.Culture)); " is 271.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddAssemblyReferences,The length of the statement  "		var rid = table.AddRow (new AssemblyRefRow ((ushort)version.Major' (ushort)version.Minor' (ushort)version.Build' (ushort)version.Revision' reference.Attributes' GetBlobIndex (key_or_token)' GetStringIndex (reference.Name)' GetStringIndex (reference.Culture)' GetBlobIndex (reference.Hash))); " is 291.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddResources,The length of the statement  "			row.Col4 = CodedIndex.Implementation.CompressMetadataToken (new MetadataToken (TokenType.File' AddLinkedResource ((LinkedResource)resource))); " is 142.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddLinkedResource,The length of the statement  "	return (uint)table.AddRow (new FileRow (FileAttributes.ContainsNoMetaData' GetStringIndex (resource.File)' GetBlobIndex (hash))); " is 129.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddExportedTypes,The length of the statement  "		var rid = table.AddRow (new ExportedTypeRow (exported_type.Attributes' (uint)exported_type.Identifier' GetStringIndex (exported_type.Name)' GetStringIndex (exported_type.Namespace)' MakeCodedRID (GetExportedTypeScope (exported_type)' CodedIndex.Implementation))); " is 263.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,CreateTypeRefRow,The length of the statement  "	return new TypeRefRow (MakeCodedRID (scope_token' CodedIndex.ResolutionScope)' GetStringIndex (type.Name)' GetStringIndex (type.Namespace)); " is 140.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddType,The length of the statement  "	type_def_table.AddRow (new TypeDefRow (type.Attributes' GetStringIndex (type.Name)' GetStringIndex (type.Namespace)' MakeCodedRID (GetTypeToken (type.BaseType)' CodedIndex.TypeDefOrRef)' type.fields_range.Start' type.methods_range.Start)); " is 239.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddGenericParameters,The length of the statement  "		var rid = generic_param_table.AddRow (new GenericParamRow ((ushort)generic_parameter.Position' generic_parameter.Attributes' MakeCodedRID (generic_parameter.Owner' CodedIndex.TypeOrMethodDef)' GetStringIndex (generic_parameter.Name))); " is 235.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddConstraints,The length of the statement  "		table.AddRow (new GenericParamConstraintRow (rid' MakeCodedRID (GetTypeToken (constraints [i])' CodedIndex.TypeDefOrRef))); " is 123.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddInterfaces,The length of the statement  "		iface_impl_table.AddRow (new InterfaceImplRow (type_rid' MakeCodedRID (GetTypeToken (interfaces [i])' CodedIndex.TypeDefOrRef))); " is 129.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddField,The length of the statement  "	field_table.AddRow (new FieldRow (field.Attributes' GetStringIndex (field.Name)' GetBlobIndex (GetFieldSignature (field)))); " is 124.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddMethod,The length of the statement  "	method_table.AddRow (new MethodRow (method.HasBody ? code.WriteMethodBody (method) : 0' method.ImplAttributes' method.Attributes' GetStringIndex (method.Name)' GetBlobIndex (GetMethodSignature (method))' param_rid)); " is 216.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddPInvokeInfo,The length of the statement  "	table.AddRow (new ImplMapRow (pinvoke.Attributes' MakeCodedRID (method' CodedIndex.MemberForwarded)' GetStringIndex (pinvoke.EntryPoint)' pinvoke.Module.MetadataToken.RID)); " is 173.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddOverrides,The length of the statement  "		table.AddRow (new MethodImplRow (method.DeclaringType.token.RID' MakeCodedRID (method' CodedIndex.MethodDefOrRef)' MakeCodedRID (LookupToken (overrides [i])' CodedIndex.MethodDefOrRef))); " is 187.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,RequiresParameterRow,The length of the statement  "	return !string.IsNullOrEmpty (parameter.Name) || parameter.Attributes != ParameterAttributes.None || parameter.HasMarshalInfo || parameter.HasConstant || parameter.HasCustomAttributes; " is 184.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddMarshalInfo,The length of the statement  "	table.AddRow (new FieldMarshalRow (MakeCodedRID (owner' CodedIndex.HasFieldMarshal)' GetBlobIndex (GetMarshalInfoSignature (owner)))); " is 134.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddProperty,The length of the statement  "	property_table.AddRow (new PropertyRow (property.Attributes' GetStringIndex (property.Name)' GetBlobIndex (GetPropertySignature (property)))); " is 142.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddEvent,The length of the statement  "	event_table.AddRow (new EventRow (@event.Attributes' GetStringIndex (@event.Name)' MakeCodedRID (GetTypeToken (@event.EventType)' CodedIndex.TypeDefOrRef))); " is 157.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddConstant,The length of the statement  "	constant_table.AddRow (new ConstantRow (etype' MakeCodedRID (owner.MetadataToken' CodedIndex.HasConstant)' GetBlobIndex (GetConstantSignature (etype' constant)))); " is 163.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddCustomAttributes,The length of the statement  "		custom_attribute_table.AddRow (new CustomAttributeRow (MakeCodedRID (owner' CodedIndex.HasCustomAttribute)' MakeCodedRID (LookupToken (attribute.Constructor)' CodedIndex.CustomAttributeType)' GetBlobIndex (GetCustomAttributeSignature (attribute)))); " is 249.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,AddSecurityDeclarations,The length of the statement  "		declsec_table.AddRow (new DeclSecurityRow (declaration.Action' MakeCodedRID (owner' CodedIndex.HasDeclSecurity)' GetBlobIndex (GetSecurityDeclarationSignature (declaration)))); " is 176.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,CreateMemberRefRow,The length of the statement  "	return new MemberRefRow (MakeCodedRID (GetTypeToken (member.DeclaringType)' CodedIndex.MemberRefParent)' GetStringIndex (member.Name)' GetBlobIndex (GetMemberRefSignature (member))); " is 182.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,CreateMethodSpecRow,The length of the statement  "	return new MethodSpecRow (MakeCodedRID (LookupToken (method_spec.ElementMethod)' CodedIndex.MethodDefOrRef)' GetBlobIndex (GetMethodSpecSignature (method_spec))); " is 162.
Long Statement,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,CreateForeignMemberException,The length of the statement  "	return new ArgumentException (string.Format ("Member '{0}' is declared in another module and needs to be imported"' member)); " is 125.
Long Statement,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteMethodSignature,The length of the statement  "	var generic_arity = generic_provider != null && generic_provider.HasGenericParameters ? generic_provider.GenericParameters.Count : 0; " is 133.
Long Statement,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCurrentMonoGac,The length of the statement  "	return Path.Combine (Directory.GetParent (Path.GetDirectoryName (typeof(object).Module.FullyQualifiedName)).FullName' "gac"); " is 125.
Long Statement,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetAssemblyFile,The length of the statement  "	return Path.Combine (Path.Combine (Path.Combine (gac' reference.Name)' gac_folder.ToString ())' reference.Name + ".dll"); " is 121.
Long Statement,Mono.Cecil,MetadataImporter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\Import.cs,ImportMethod,The length of the statement  "		reference.ReturnType = method_info != null ? ImportType (method_info.ReturnType' context) : ImportType (typeof(void)' default(ImportGenericContext)); " is 149.
Long Statement,Mono.Cecil,ModuleDefinition,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\ModuleDefinition.cs,Import,The length of the statement  "	return MetadataImporter.ImportType (type' GenericContextFor (context)' context != null ? ImportGenericKind.Open : ImportGenericKind.Definition); " is 144.
Long Statement,Mono.Cecil,ModuleDefinition,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\ModuleDefinition.cs,Import,The length of the statement  "	return MetadataImporter.ImportMethod (method' GenericContextFor (context)' context != null ? ImportGenericKind.Open : ImportGenericKind.Definition); " is 148.
Long Statement,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt32,The length of the statement  "	uint value = (uint)(buffer [position] | (buffer [position + 1] << 8) | (buffer [position + 2] << 16) | (buffer [position + 3] << 24)); " is 134.
Long Statement,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,CreateSection,The length of the statement  "		VirtualAddress = previous != null ? previous.VirtualAddress + Align (previous.VirtualSize' section_alignment) : text_rva' " is 121.
Long Statement,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,CreateSection,The length of the statement  "		PointerToRawData = previous != null ? previous.PointerToRawData + previous.SizeOfRawData : Align (GetHeaderSize ()' file_alignment)' " is 132.
Long Statement,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetRuntimeMain,The length of the statement  "	return module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule ? GetSimpleString ("_CorDllMain") : GetSimpleString ("_CorExeMain"); " is 144.
Long Statement,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The length of the statement  "	startup_stub_rva = module.Architecture == TargetArchitecture.IA64 ? (startup_stub_rva + 15u) & ~15u : 2 + ((startup_stub_rva + 3u) & ~3u); " is 138.
Complex Conditional,Mono.Cecil.Metadata,UserStringHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,WriteString,The conditional expression  "@char > 0x7e || (@char >= 0x01 && @char <= 0x08) || (@char >= 0x0e && @char <= 0x1f) || @char == 0x27 || @char == 0x2d"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The conditional expression  "(blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The conditional expression  "(blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352)"  is complex.
Empty Catch Block,Mono.Cecil.Cil,SymbolProvider,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Symbols.cs,GetPlatformType,The method has an empty catch block.
Empty Catch Block,Mono.Cecil.Cil,SymbolProvider,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Symbols.cs,GetPlatformType,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,Add,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,Add,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,IndexOf,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,IndexOf,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,Insert,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,Insert,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,Remove,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,Remove,The method has an empty catch block.
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteMethodBody,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,GetLocalVarToken,The following statement contains a magic number: buffer.position = 8;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteResolvedMethodBody,The following statement contains a magic number: if (RequiresFatHeader ())  	WriteFatHeader ();  else  	WriteByte ((byte)(0x2 | (body.CodeSize << 2)));  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteResolvedMethodBody,The following statement contains a magic number: WriteByte ((byte)(0x2 | (body.CodeSize << 2)));  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The following statement contains a magic number: switch (operand_type) {  case OperandType.InlineSwitch: {  	var targets = (Instruction[])operand;  	WriteInt32 (targets.Length);  	var diff = instruction.Offset + opcode.Size + (4 * (targets.Length + 1));  	for (int i = 0; i < targets.Length; i++)  		WriteInt32 (GetTargetOffset (targets [i]) - diff);  	break;  }  case OperandType.ShortInlineBrTarget: {  	var target = (Instruction)operand;  	WriteSByte ((sbyte)(GetTargetOffset (target) - (instruction.Offset + opcode.Size + 1)));  	break;  }  case OperandType.InlineBrTarget: {  	var target = (Instruction)operand;  	WriteInt32 (GetTargetOffset (target) - (instruction.Offset + opcode.Size + 4));  	break;  }  case OperandType.ShortInlineVar:  	WriteByte ((byte)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.ShortInlineArg:  	WriteByte ((byte)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineVar:  	WriteInt16 ((short)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.InlineArg:  	WriteInt16 ((short)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineSig:  	WriteMetadataToken (GetStandAloneSignature ((CallSite)operand));  	break;  case OperandType.ShortInlineI:  	if (opcode == OpCodes.Ldc_I4_S)  		WriteSByte ((sbyte)operand);  	else  		WriteByte ((byte)operand);  	break;  case OperandType.InlineI:  	WriteInt32 ((int)operand);  	break;  case OperandType.InlineI8:  	WriteInt64 ((long)operand);  	break;  case OperandType.ShortInlineR:  	WriteSingle ((float)operand);  	break;  case OperandType.InlineR:  	WriteDouble ((double)operand);  	break;  case OperandType.InlineString:  	WriteMetadataToken (new MetadataToken (TokenType.String' GetUserStringIndex ((string)operand)));  	break;  case OperandType.InlineType:  case OperandType.InlineField:  case OperandType.InlineMethod:  case OperandType.InlineTok:  	WriteMetadataToken (metadata.LookupToken ((IMetadataTokenProvider)operand));  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The following statement contains a magic number: switch (operand_type) {  case OperandType.InlineSwitch: {  	var targets = (Instruction[])operand;  	WriteInt32 (targets.Length);  	var diff = instruction.Offset + opcode.Size + (4 * (targets.Length + 1));  	for (int i = 0; i < targets.Length; i++)  		WriteInt32 (GetTargetOffset (targets [i]) - diff);  	break;  }  case OperandType.ShortInlineBrTarget: {  	var target = (Instruction)operand;  	WriteSByte ((sbyte)(GetTargetOffset (target) - (instruction.Offset + opcode.Size + 1)));  	break;  }  case OperandType.InlineBrTarget: {  	var target = (Instruction)operand;  	WriteInt32 (GetTargetOffset (target) - (instruction.Offset + opcode.Size + 4));  	break;  }  case OperandType.ShortInlineVar:  	WriteByte ((byte)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.ShortInlineArg:  	WriteByte ((byte)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineVar:  	WriteInt16 ((short)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.InlineArg:  	WriteInt16 ((short)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineSig:  	WriteMetadataToken (GetStandAloneSignature ((CallSite)operand));  	break;  case OperandType.ShortInlineI:  	if (opcode == OpCodes.Ldc_I4_S)  		WriteSByte ((sbyte)operand);  	else  		WriteByte ((byte)operand);  	break;  case OperandType.InlineI:  	WriteInt32 ((int)operand);  	break;  case OperandType.InlineI8:  	WriteInt64 ((long)operand);  	break;  case OperandType.ShortInlineR:  	WriteSingle ((float)operand);  	break;  case OperandType.InlineR:  	WriteDouble ((double)operand);  	break;  case OperandType.InlineString:  	WriteMetadataToken (new MetadataToken (TokenType.String' GetUserStringIndex ((string)operand)));  	break;  case OperandType.InlineType:  case OperandType.InlineField:  case OperandType.InlineMethod:  case OperandType.InlineTok:  	WriteMetadataToken (metadata.LookupToken ((IMetadataTokenProvider)operand));  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The following statement contains a magic number: WriteInt32 (GetTargetOffset (target) - (instruction.Offset + opcode.Size + 4));  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,RequiresFatHeader,The following statement contains a magic number: return body.CodeSize >= 64 || body.InitLocals || body.HasVariables || body.HasExceptionHandlers || body.MaxStackSize > 8;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,RequiresFatHeader,The following statement contains a magic number: return body.CodeSize >= 64 || body.InitLocals || body.HasVariables || body.HasExceptionHandlers || body.MaxStackSize > 8;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: switch (pop_behavior) {  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	stack_size--;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	stack_size -= 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	stack_size -= 3;  	break;  case StackBehaviour.PopAll:  	stack_size = 0;  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: switch (pop_behavior) {  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	stack_size--;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	stack_size -= 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	stack_size -= 3;  	break;  case StackBehaviour.PopAll:  	stack_size = 0;  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: stack_size -= 2;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: stack_size -= 3;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,The following statement contains a magic number: switch (push_behaviour) {  case StackBehaviour.Push1:  case StackBehaviour.Pushi:  case StackBehaviour.Pushi8:  case StackBehaviour.Pushr4:  case StackBehaviour.Pushr8:  case StackBehaviour.Pushref:  	stack_size++;  	break;  case StackBehaviour.Push1_push1:  	stack_size += 2;  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,The following statement contains a magic number: stack_size += 2;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteExceptionHandlers,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,IsFatRange,The following statement contains a magic number: return end.Offset - start.Offset > 255 || start.Offset > 65535;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,IsFatRange,The following statement contains a magic number: return end.Offset - start.Offset > 255 || start.Offset > 65535;  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteSmallSection,The following statement contains a magic number: WriteByte ((byte)(handlers.Count * 12 + 4));  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteSmallSection,The following statement contains a magic number: WriteByte ((byte)(handlers.Count * 12 + 4));  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteSmallSection,The following statement contains a magic number: WriteBytes (2);  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteFatSection,The following statement contains a magic number: WriteByte ((byte)((size >> 8) & 0xff));  
Magic Number,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteFatSection,The following statement contains a magic number: WriteByte ((byte)((size >> 16) & 0xff));  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  case 0x2:  	// tiny  	body.code_size = flags >> 2;  	body.MaxStackSize = 8;  	ReadCode ();  	break;  case 0x3:  	// fat  	base.position--;  	ReadFatMethod ();  	break;  default:  	throw new InvalidOperationException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  case 0x2:  	// tiny  	body.code_size = flags >> 2;  	body.MaxStackSize = 8;  	ReadCode ();  	break;  case 0x3:  	// fat  	base.position--;  	ReadFatMethod ();  	break;  default:  	throw new InvalidOperationException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: body.code_size = flags >> 2;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: body.MaxStackSize = 8;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadOperand,The following statement contains a magic number: switch (instruction.opcode.OperandType) {  case OperandType.InlineSwitch:  	var length = ReadInt32 ();  	var base_offset = Offset + (4 * length);  	var branches = new int[length];  	for (int i = 0; i < length; i++)  		branches [i] = base_offset + ReadInt32 ();  	return branches;  case OperandType.ShortInlineBrTarget:  	return ReadSByte () + Offset;  case OperandType.InlineBrTarget:  	return ReadInt32 () + Offset;  case OperandType.ShortInlineI:  	if (instruction.opcode == OpCodes.Ldc_I4_S)  		return ReadSByte ();  	return ReadByte ();  case OperandType.InlineI:  	return ReadInt32 ();  case OperandType.ShortInlineR:  	return ReadSingle ();  case OperandType.InlineR:  	return ReadDouble ();  case OperandType.InlineI8:  	return ReadInt64 ();  case OperandType.ShortInlineVar:  	return GetVariable (ReadByte ());  case OperandType.InlineVar:  	return GetVariable (ReadUInt16 ());  case OperandType.ShortInlineArg:  	return GetParameter (ReadByte ());  case OperandType.InlineArg:  	return GetParameter (ReadUInt16 ());  case OperandType.InlineSig:  	return GetCallSite (ReadToken ());  case OperandType.InlineString:  	return GetString (ReadToken ());  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	return reader.LookupToken (ReadToken ());  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,GetInstruction,The following statement contains a magic number: while (min <= max) {  	int mid = min + ((max - min) / 2);  	var instruction = items [mid];  	var instruction_offset = instruction.offset;  	if (offset == instruction_offset)  		return instruction;  	if (offset < instruction_offset)  		max = mid - 1;  	else  		min = mid + 1;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadSection,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadSmallSection,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadExceptionHandlerSpecific,The following statement contains a magic number: switch (handler.HandlerType) {  case ExceptionHandlerType.Catch:  	handler.CatchType = (TypeReference)reader.LookupToken (ReadToken ());  	break;  case ExceptionHandlerType.Filter:  	handler.FilterStart = GetInstruction (ReadInt32 ());  	break;  default:  	Advance (4);  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ReadExceptionHandlerSpecific,The following statement contains a magic number: Advance (4);  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  case 0x2:  	// tiny  	buffer.WriteByte (flags);  	local_var_token = MetadataToken.Zero;  	symbols.code_size = flags >> 2;  	PatchRawCode (buffer' symbols.code_size' writer);  	break;  case 0x3:  	// fat  	base.position--;  	PatchRawFatMethod (buffer' symbols' writer' out local_var_token);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawMethodBody,The following statement contains a magic number: symbols.code_size = flags >> 2;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += 2;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += 8;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += length * 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position -= 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position -= 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position -= 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawSection,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawSmallSection,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + (1 + ((Instruction[])operand).Length) * 4;  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + 8;  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + 4;  
Magic Number,Mono.Cecil.Cil,Instruction,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + 2;  
Magic Number,Mono.Cecil.Cil,OpCode,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.op2 = (byte)((x >> 8) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.code = (byte)((x >> 16) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.flow_control = (byte)((x >> 24) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.operand_type = (byte)((y >> 8) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.stack_behavior_pop = (byte)((y >> 16) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.stack_behavior_push = (byte)((y >> 24) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCodeNames,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\OpCode.cs,OpCodeNames,The following statement contains a magic number: names = new string[219];  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,WriteBySize,The following statement contains a magic number: if (size == 4)  	WriteUInt32 (value);  else  	WriteUInt16 ((ushort)value);  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,WriteTableHeap,The following statement contains a magic number: WriteByte (10);  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,GetTableHeapVersion,The following statement contains a magic number: switch (module.Runtime) {  case TargetRuntime.Net_1_0:  case TargetRuntime.Net_1_1:  	return 1;  default:  	return 2;  }  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,GetTableHeapVersion,The following statement contains a magic number: return 2;  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,FixupData,The following statement contains a magic number: for (int i = 0; i < table.length; i++) {  	var rva = ReadUInt32 ();  	base.position -= 4;  	WriteUInt32 (rva + data_rva);  	base.position += field_idx_size;  }  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,FixupData,The following statement contains a magic number: base.position -= 4;  
Magic Number,Mono.Cecil.Metadata,UserStringHeapBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Buffers.cs,WriteString,The following statement contains a magic number: WriteCompressedUInt32 ((uint)@string.Length * 2 + 1);  
Magic Number,Mono.Cecil.Metadata,UserStringHeap,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: for (int i = start' j = 0; i < start + length; i += 2)  	chars [j++] = (char)(data [i] | (data [i + 1] << 8));  
Magic Number,Mono.Cecil.Metadata,UserStringHeap,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: for (int i = start' j = 0; i < start + length; i += 2)  	chars [j++] = (char)(data [i] | (data [i + 1] << 8));  
Magic Number,Mono.Cecil.Metadata,UserStringHeap,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: i += 2
Magic Number,Mono.Cecil.Metadata,UserStringHeap,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: chars [j++] = (char)(data [i] | (data [i + 1] << 8));  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: integer = (uint)(data [position] & ~0x80) << 8;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: position += 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: integer = (uint)(data [position] & ~0xc0) << 24;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 1] << 16;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 2] << 8;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 2] << 8;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 3];  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ReadCompressedUInt32,The following statement contains a magic number: position += 4;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Field;  	goto ret;  case 1:  	token_type = TokenType.Param;  	goto ret;  case 2:  	token_type = TokenType.Property;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Field;  	goto ret;  case 1:  	token_type = TokenType.Param;  	goto ret;  case 2:  	token_type = TokenType.Property;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 5;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.Method;  	goto ret;  case 2:  	token_type = TokenType.Assembly;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.Method;  	goto ret;  case 2:  	token_type = TokenType.Assembly;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.File;  	goto ret;  case 1:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 2:  	token_type = TokenType.ExportedType;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.File;  	goto ret;  case 1:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 2:  	token_type = TokenType.ExportedType;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 2:  	token_type = TokenType.Method;  	goto ret;  case 3:  	token_type = TokenType.MemberRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 2:  	token_type = TokenType.Method;  	goto ret;  case 3:  	token_type = TokenType.MemberRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 2:  	token_type = TokenType.Method;  	goto ret;  case 3:  	token_type = TokenType.MemberRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Module;  	goto ret;  case 1:  	token_type = TokenType.ModuleRef;  	goto ret;  case 2:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 3:  	token_type = TokenType.TypeRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Module;  	goto ret;  case 1:  	token_type = TokenType.ModuleRef;  	goto ret;  case 2:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 3:  	token_type = TokenType.TypeRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Module;  	goto ret;  case 1:  	token_type = TokenType.ModuleRef;  	goto ret;  case 2:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 3:  	token_type = TokenType.TypeRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.TypeSpec:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Field:  	return ret | 0;  case TokenType.Param:  	return ret | 1;  case TokenType.Property:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 5;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 4;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 5;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 6;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 7;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 8;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 9;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 10;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 11;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 12;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 13;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 14;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 15;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 16;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 17;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 18;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 19;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.Method:  	return ret | 1;  case TokenType.Assembly:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.ModuleRef:  	return ret | 2;  case TokenType.Method:  	return ret | 3;  case TokenType.TypeSpec:  	return ret | 4;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.ModuleRef:  	return ret | 2;  case TokenType.Method:  	return ret | 3;  case TokenType.TypeSpec:  	return ret | 4;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.ModuleRef:  	return ret | 2;  case TokenType.Method:  	return ret | 3;  case TokenType.TypeSpec:  	return ret | 4;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 4;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.File:  	return ret | 0;  case TokenType.AssemblyRef:  	return ret | 1;  case TokenType.ExportedType:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 2;  case TokenType.MemberRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 2;  case TokenType.MemberRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Module:  	return ret | 0;  case TokenType.ModuleRef:  	return ret | 1;  case TokenType.AssemblyRef:  	return ret | 2;  case TokenType.TypeRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Module:  	return ret | 0;  case TokenType.ModuleRef:  	return ret | 1;  case TokenType.AssemblyRef:  	return ret | 2;  case TokenType.TypeRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 5;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 3;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ParseRuntime,The following statement contains a magic number: switch (self [1]) {  case '1':  	return self [3] == '0' ? TargetRuntime.Net_1_0 : TargetRuntime.Net_1_1;  case '2':  	return TargetRuntime.Net_2_0;  case '4':  default:  	return TargetRuntime.Net_4_0;  }  
Magic Number,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,ParseRuntime,The following statement contains a magic number: return self [3] == '0' ? TargetRuntime.Net_1_0 : TargetRuntime.Net_1_1;  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: if (parts.Length != 2)  	throw new ArgumentException ("Malformed name");  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: name.PublicKeyToken = new byte[pk_token.Length / 2];  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int j = 0; j < name.PublicKeyToken.Length; j++)  	name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int j = 0; j < name.PublicKeyToken.Length; j++)  	name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadByIndexSize,The following statement contains a magic number: if (size == 4)  	return ReadUInt32 ();  else  	return ReadUInt16 ();  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadBlob,The following statement contains a magic number: if (blob_heap == null) {  	position += 2;  	return Empty<byte>.Array;  }  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadBlob,The following statement contains a magic number: position += 2;  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadBlobIndex,The following statement contains a magic number: return ReadByIndexSize (blob_heap != null ? blob_heap.IndexSize : 2);  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,Populate,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetManagedResourceStream,The following statement contains a magic number: return new MemoryStream (buffer' (int)position + 4' length);  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  case ElementType.Boolean:  case ElementType.U1:  case ElementType.I1:  	size = 1;  	break;  case ElementType.U2:  case ElementType.I2:  case ElementType.Char:  	size = 2;  	break;  case ElementType.U4:  case ElementType.I4:  case ElementType.R4:  	size = 4;  	break;  case ElementType.U8:  case ElementType.I8:  case ElementType.R8:  	size = 8;  	break;  case ElementType.Ptr:  case ElementType.FnPtr:  	size = IntPtr.Size;  	break;  case ElementType.CModOpt:  case ElementType.CModReqD:  	return GetFieldTypeSize (((IModifierType)type).ElementType);  default:  	var field_type = type.CheckedResolve ();  	if (field_type.HasLayoutInfo)  		size = field_type.ClassSize;  	break;  }  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  case ElementType.Boolean:  case ElementType.U1:  case ElementType.I1:  	size = 1;  	break;  case ElementType.U2:  case ElementType.I2:  case ElementType.Char:  	size = 2;  	break;  case ElementType.U4:  case ElementType.I4:  case ElementType.R4:  	size = 4;  	break;  case ElementType.U8:  case ElementType.I8:  case ElementType.R8:  	size = 8;  	break;  case ElementType.Ptr:  case ElementType.FnPtr:  	size = IntPtr.Size;  	break;  case ElementType.CModOpt:  case ElementType.CModReqD:  	return GetFieldTypeSize (((IModifierType)type).ElementType);  default:  	var field_type = type.CheckedResolve ();  	if (field_type.HasLayoutInfo)  		size = field_type.ClassSize;  	break;  }  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  case ElementType.Boolean:  case ElementType.U1:  case ElementType.I1:  	size = 1;  	break;  case ElementType.U2:  case ElementType.I2:  case ElementType.Char:  	size = 2;  	break;  case ElementType.U4:  case ElementType.I4:  case ElementType.R4:  	size = 4;  	break;  case ElementType.U8:  case ElementType.I8:  case ElementType.R8:  	size = 8;  	break;  case ElementType.Ptr:  case ElementType.FnPtr:  	size = IntPtr.Size;  	break;  case ElementType.CModOpt:  case ElementType.CModReqD:  	return GetFieldTypeSize (((IModifierType)type).ElementType);  default:  	var field_type = type.CheckedResolve ();  	if (field_type.HasLayoutInfo)  		size = field_type.ClassSize;  	break;  }  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: size = 2;  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: size = 4;  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: size = 8;  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,InitializeGenericParameters,The following statement contains a magic number: metadata.GenericParameters = InitializeRanges (Table.GenericParam' () => {  	Advance (4);  	var next = ReadMetadataToken (CodedIndex.TypeOrMethodDef);  	ReadStringIndex ();  	return next;  });  
Magic Number,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,InitializeGenericParameters,The following statement contains a magic number: Advance (4);  
Magic Number,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,CreateTextMap,The following statement contains a magic number: map.AddMap (TextSegment.ImportAddressTable' module.Architecture == TargetArchitecture.I386 ? 8 : 0);  
Magic Number,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,CreateTextMap,The following statement contains a magic number: map.AddMap (TextSegment.CLIHeader' 0x48' 8);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,BaseAssemblyResolver,The following statement contains a magic number: directories = new Collection<string> (2) {  	"."'  	"bin"  };  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 1)  	path = Path.Combine (path' "1.0");  else if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 1)  	path = Path.Combine (path' "1.0");  else if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 1)  	path = Path.Combine (path' "1.0");  else if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.MajorRevision == 5)  	path = Path.Combine (path' "2.1");  else  	path = Path.Combine (path' "2.0");  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: switch (version.Major) {  case 1:  	if (version.MajorRevision == 3300)  		path = Path.Combine (path' "v1.0.3705");  	else  		path = Path.Combine (path' "v1.0.5000.0");  	break;  case 2:  	path = Path.Combine (path' "v2.0.50727");  	break;  case 4:  	path = Path.Combine (path' "v4.0.30319");  	break;  default:  	throw new NotSupportedException ("Version not supported: " + version);  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: switch (version.Major) {  case 1:  	if (version.MajorRevision == 3300)  		path = Path.Combine (path' "v1.0.3705");  	else  		path = Path.Combine (path' "v1.0.5000.0");  	break;  case 2:  	path = Path.Combine (path' "v2.0.50727");  	break;  case 4:  	path = Path.Combine (path' "v4.0.30319");  	break;  default:  	throw new NotSupportedException ("Version not supported: " + version);  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: switch (version.Major) {  case 1:  	if (version.MajorRevision == 3300)  		path = Path.Combine (path' "v1.0.3705");  	else  		path = Path.Combine (path' "v1.0.5000.0");  	break;  case 2:  	path = Path.Combine (path' "v2.0.50727");  	break;  case 4:  	path = Path.Combine (path' "v4.0.30319");  	break;  default:  	throw new NotSupportedException ("Version not supported: " + version);  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.MajorRevision == 3300)  	path = Path.Combine (path' "v1.0.3705");  else  	path = Path.Combine (path' "v1.0.5000.0");  
Magic Number,Mono.Cecil,BaseAssemblyResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetAssemblyInNetGac,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	for (int j = 0; j < gacs.Length; j++) {  		var gac = Path.Combine (gac_paths [i]' gacs [j]);  		var file = GetAssemblyFile (reference' prefixes [i]' gac);  		if (Directory.Exists (gac) && File.Exists (file))  			return GetAssembly (file' parameters);  	}  }  
Magic Number,Mono.Cecil,MetadataSystem,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\MetadataSystem.cs,InitializePrimitives,The following statement contains a magic number: primitive_value_types = new Dictionary<string' Row<ElementType' bool>> (18' StringComparer.Ordinal) {  	{  		"Void"'  		new Row<ElementType' bool> (ElementType.Void' false)  	}'  	{  		"Boolean"'  		new Row<ElementType' bool> (ElementType.Boolean' true)  	}'  	{  		"Char"'  		new Row<ElementType' bool> (ElementType.Char' true)  	}'  	{  		"SByte"'  		new Row<ElementType' bool> (ElementType.I1' true)  	}'  	{  		"Byte"'  		new Row<ElementType' bool> (ElementType.U1' true)  	}'  	{  		"Int16"'  		new Row<ElementType' bool> (ElementType.I2' true)  	}'  	{  		"UInt16"'  		new Row<ElementType' bool> (ElementType.U2' true)  	}'  	{  		"Int32"'  		new Row<ElementType' bool> (ElementType.I4' true)  	}'  	{  		"UInt32"'  		new Row<ElementType' bool> (ElementType.U4' true)  	}'  	{  		"Int64"'  		new Row<ElementType' bool> (ElementType.I8' true)  	}'  	{  		"UInt64"'  		new Row<ElementType' bool> (ElementType.U8' true)  	}'  	{  		"Single"'  		new Row<ElementType' bool> (ElementType.R4' true)  	}'  	{  		"Double"'  		new Row<ElementType' bool> (ElementType.R8' true)  	}'  	{  		"String"'  		new Row<ElementType' bool> (ElementType.String' false)  	}'  	{  		"TypedReference"'  		new Row<ElementType' bool> (ElementType.TypedByRef' false)  	}'  	{  		"IntPtr"'  		new Row<ElementType' bool> (ElementType.I' true)  	}'  	{  		"UIntPtr"'  		new Row<ElementType' bool> (ElementType.U' true)  	}'  	{  		"Object"'  		new Row<ElementType' bool> (ElementType.Object' false)  	}'  };  
Magic Number,Mono.Cecil,MetadataSystem,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\MetadataSystem.cs,BinaryRangeSearch,The following statement contains a magic number: while (min <= max) {  	int mid = min + ((max - min) / 2);  	var type = types [mid];  	var range = field ? type.fields_range : type.methods_range;  	if (rid < range.Start)  		max = mid - 1;  	else if (rid >= range.Start + range.Length)  		min = mid + 1;  	else  		return type;  }  
Magic Number,Mono.Cecil,ModuleDefinition,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\ModuleDefinition.cs,CreateAssemblyName,The following statement contains a magic number: if (name.EndsWith (".dll") || name.EndsWith (".exe"))  	name = name.Substring (0' name.Length - 4);  
Magic Number,Mono.Cecil,ModuleDefinition,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\ModuleDefinition.cs,CreateAssemblyName,The following statement contains a magic number: name = name.Substring (0' name.Length - 4);  
Magic Number,Mono.Cecil.PE,ByteBufferEqualityComparer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBufferEqualityComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < buffer.length; i++)  	hash = (hash * 37) ^ bytes [i];  
Magic Number,Mono.Cecil.PE,ByteBufferEqualityComparer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBufferEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash * 37) ^ bytes [i];  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt16,The following statement contains a magic number: position += 2;  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: position += 4;  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt64,The following statement contains a magic number: return (((ulong)high) << 32) | low;  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((first & 0x40) == 0)  	return ((uint)(first & ~0x80) << 8) | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0x80) << 8) | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0xc0) << 24) | (uint)ReadByte () << 16 | (uint)ReadByte () << 8 | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0xc0) << 24) | (uint)ReadByte () << 16 | (uint)ReadByte () << 8 | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0xc0) << 24) | (uint)ReadByte () << 16 | (uint)ReadByte () << 8 | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {  	var bytes = ReadBytes (4);  	Array.Reverse (bytes);  	return BitConverter.ToSingle (bytes' 0);  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: position += 4;  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {  	var bytes = ReadBytes (8);  	Array.Reverse (bytes);  	return BitConverter.ToDouble (bytes' 0);  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: position += 8;  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: if (position + 2 > buffer.Length)  	Grow (2);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: if (position + 2 > buffer.Length)  	Grow (2);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: Grow (2);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: buffer [position++] = (byte)(value >> 8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: if (position + 4 > buffer.Length)  	Grow (4);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: if (position + 4 > buffer.Length)  	Grow (4);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: Grow (4);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: buffer [position++] = (byte)(value >> 8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: buffer [position++] = (byte)(value >> 16);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: buffer [position++] = (byte)(value >> 24);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: if (position + 8 > buffer.Length)  	Grow (8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: if (position + 8 > buffer.Length)  	Grow (8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: Grow (8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 16);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 24);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 32);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 40);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 48);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 56);  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)(0x80 | (value >> 8)));  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 24) | 0xc0));  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 16) & 0xff));  
Magic Number,Mono.Cecil.PE,ByteBuffer,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,Mono.Cecil.PE,Image,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;  
Magic Number,Mono.Cecil.PE,Image,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;  
Magic Number,Mono.Cecil.PE,Image,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadImage,The following statement contains a magic number: if (BaseStream.Length < 128)  	throw new BadImageFormatException ();  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadImage,The following statement contains a magic number: Advance (58);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadImage,The following statement contains a magic number: Advance (14);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (66);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (pe64 ? 88 : 72);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (pe64 ? 88 : 72);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (56);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (8);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadAlignedString,The following statement contains a magic number: Advance (-1 + ((read + 4) & ~3) - read);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadAlignedString,The following statement contains a magic number: Advance (-1 + ((read + 4) & ~3) - read);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var section = new Section ();  	// Name  	section.Name = ReadZeroTerminatedString (8);  	// VirtualSize		4  	Advance (4);  	// VirtualAddress	4  	section.VirtualAddress = ReadUInt32 ();  	// SizeOfRawData	4  	section.SizeOfRawData = ReadUInt32 ();  	// PointerToRawData	4  	section.PointerToRawData = ReadUInt32 ();  	// PointerToRelocations		4  	// PointerToLineNumbers		4  	// NumberOfRelocations		2  	// NumberOfLineNumbers		2  	// Characteristics			4  	Advance (16);  	sections [i] = section;  	ReadSectionData (section);  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var section = new Section ();  	// Name  	section.Name = ReadZeroTerminatedString (8);  	// VirtualSize		4  	Advance (4);  	// VirtualAddress	4  	section.VirtualAddress = ReadUInt32 ();  	// SizeOfRawData	4  	section.SizeOfRawData = ReadUInt32 ();  	// PointerToRawData	4  	section.PointerToRawData = ReadUInt32 ();  	// PointerToRelocations		4  	// PointerToLineNumbers		4  	// NumberOfRelocations		2  	// NumberOfLineNumbers		2  	// Characteristics			4  	Advance (16);  	sections [i] = section;  	ReadSectionData (section);  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var section = new Section ();  	// Name  	section.Name = ReadZeroTerminatedString (8);  	// VirtualSize		4  	Advance (4);  	// VirtualAddress	4  	section.VirtualAddress = ReadUInt32 ();  	// SizeOfRawData	4  	section.SizeOfRawData = ReadUInt32 ();  	// PointerToRawData	4  	section.PointerToRawData = ReadUInt32 ();  	// PointerToRelocations		4  	// PointerToLineNumbers		4  	// NumberOfRelocations		2  	// NumberOfLineNumbers		2  	// Characteristics			4  	Advance (16);  	sections [i] = section;  	ReadSectionData (section);  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: section.Name = ReadZeroTerminatedString (8);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: Advance (4);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: Advance (16);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadCLIHeader,The following statement contains a magic number: Advance (8);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadata,The following statement contains a magic number: Advance (8);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadata,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadTableHeap,The following statement contains a magic number: Advance (6);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,SetIndexSize,The following statement contains a magic number: heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,SetIndexSize,The following statement contains a magic number: heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (image.GuidHeap.IndexSize * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (image.GuidHeap.IndexSize * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Generation  + stridx_size // Name  + (image.GuidHeap.IndexSize * 3);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Generation  + stridx_size // Name  + (image.GuidHeap.IndexSize * 3);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  + GetTableIndexSize (Table.Field) // FieldList  + GetTableIndexSize (Table.Method);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  + GetTableIndexSize (Table.Field) // FieldList  + GetTableIndexSize (Table.Method);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Flags  + stridx_size // Name  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Rva 4' ImplFlags 2' Flags 2  + stridx_size // Name  + blobidx_size // Signature  + GetTableIndexSize (Table.Param);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags 2' Sequence 2  + stridx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Type  + GetCodedIndexSize (CodedIndex.HasConstant) // Parent  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Action  + GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 6 // PackingSize 2' ClassSize 4  + GetTableIndexSize (Table.TypeDef);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Offset  + GetTableIndexSize (Table.Field);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Flags  + stridx_size // Name  + GetCodedIndexSize (CodedIndex.TypeDefOrRef);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Flags  + stridx_size // Name  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Semantics  + GetTableIndexSize (Table.Method) // Method  + GetCodedIndexSize (CodedIndex.HasSemantics);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // MappingFlags  + GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  + stridx_size // ImportName  + GetTableIndexSize (Table.ModuleRef);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // RVA  + GetTableIndexSize (Table.Field);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  + blobidx_size // PublicKey  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  + blobidx_size // PublicKey  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Version 2 * 4 + Flags 4  + (blobidx_size * 2) // PublicKeyOrToken' HashValue  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Version 2 * 4 + Flags 4  + (blobidx_size * 2) // PublicKeyOrToken' HashValue  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Version 2 * 4 + Flags 4  + (blobidx_size * 2) // PublicKeyOrToken' HashValue  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Processor  + GetTableIndexSize (Table.AssemblyRef);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Platform 4' Version 2 * 4  + GetTableIndexSize (Table.AssemblyRef);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags  + stridx_size // Name  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Flags 4' TypeDefId 4  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.Implementation);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Flags 4' TypeDefId 4  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.Implementation);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Offset' Flags  + stridx_size // Name  + GetCodedIndexSize (CodedIndex.Implementation);  
Magic Number,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Number' Flags  + GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  + stridx_size;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,ImageWriter,The following statement contains a magic number: this.sections = (ushort)(has_reloc ? 2 : 1);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,ImageWriter,The following statement contains a magic number: this.time_stamp = (uint)DateTime.UtcNow.Subtract (new DateTime (1970' 1' 1)).TotalSeconds;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteByte (8);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteUInt16 (4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteUInt16 (4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteUInt32 (16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteText,The following statement contains a magic number: WriteUInt16 (2);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteText,The following statement contains a magic number: WriteUInt16 ((ushort)((module.Runtime <= TargetRuntime.Net_1_1) ? 0 : 5));  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetZeroTerminatedString,The following statement contains a magic number: return GetString (@string' (@string.Length + 1 + 3) & ~3);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetZeroTerminatedString,The following statement contains a magic number: return GetString (@string' (@string.Length + 1 + 3) & ~3);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDebugDirectory,The following statement contains a magic number: WriteInt32 ((int)BaseStream.Position + 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteImportDirectory,The following statement contains a magic number: WriteUInt32 (text_map.GetRVA (TextSegment.ImportDirectory) + 40);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteImportDirectory,The following statement contains a magic number: WriteUInt32 (text_map.GetRVA (TextSegment.ImportHintNameTable) + 14);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteImportDirectory,The following statement contains a magic number: Advance (20);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteReloc,The following statement contains a magic number: reloc_rva += module.Architecture == TargetArchitecture.IA64 ? 0x20u : 2;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Code' metadata.code.length' !pe64 ? 4 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Code' metadata.code.length' !pe64 ? 4 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Resources' metadata.resources.length' 8);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Data' metadata.data.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.StrongNameSignature' GetStrongNameLength ()' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.TableHeap' metadata.table_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.StringHeap' metadata.string_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.UserStringHeap' metadata.user_string_heap.IsEmpty ? 0 : metadata.user_string_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.GuidHeap' 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.BlobHeap' metadata.blob_heap.IsEmpty ? 0 : metadata.blob_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: if (!debug_data.IsNullOrEmpty ()) {  	const int debug_dir_header_len = 28;  	debug_directory.AddressOfRawData = (int)map.GetNextRVA (TextSegment.BlobHeap) + debug_dir_header_len;  	debug_dir_len = debug_data.Length + debug_dir_header_len;  }  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.DebugDirectory' debug_dir_len' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: startup_stub_rva = module.Architecture == TargetArchitecture.IA64 ? (startup_stub_rva + 15u) & ~15u : 2 + ((startup_stub_rva + 3u) & ~3u);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetStartupStubLength,The following statement contains a magic number: switch (module.Architecture) {  case TargetArchitecture.I386:  	return 6;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetStartupStubLength,The following statement contains a magic number: return 6;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  40 // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  40 // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  40 // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  40 // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  40 // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  40 // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: if (size > 32)  	return size - 32;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: if (size > 32)  	return size - 32;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: return size - 32;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: return 128;  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,PatchResourceDirectoryTable,The following statement contains a magic number: resources.Advance (12);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,PatchResourceDirectoryEntry,The following statement contains a magic number: resources.Advance (4);  
Magic Number,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,PatchResourceDataEntry,The following statement contains a magic number: resources.position -= 4;  
Magic Number,Mono.Collections.Generic,Collection,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Collections.Generic\Collection.cs,Grow,The following statement contains a magic number: new_size = System.Math.Max (System.Math.Max (items.Length * 2' default_capacity)' new_size);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent = new byte[3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [0] = blob [offset + 18];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [1] = blob [offset + 17];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: return FromCapiPublicKeyBlob (blob' offset + 12);  
Duplicate Code,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 48)' (30' 49)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (36' 55)' (37' 56)' (38' 57)' (39' 58)' (40' 59)' (41' 60)' (42' 61)' (43' 62)' (44' 63))
Duplicate Code,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 62)' (30' 63))
Duplicate Code,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 48)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (36' 55)' (37' 56)' (38' 57)' (39' 58)' (40' 59)' (41' 60)' (42' 61)' (43' 62)' (44' 63))
Missing Default,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeExceptionHandlerStackSize,The following switch statement is missing a default case: switch (exception_handler.HandlerType) {  case ExceptionHandlerType.Catch:  	AddExceptionStackSize (exception_handler.HandlerStart' ref stack_sizes);  	break;  case ExceptionHandlerType.Filter:  	AddExceptionStackSize (exception_handler.FilterStart' ref stack_sizes);  	AddExceptionStackSize (exception_handler.HandlerStart' ref stack_sizes);  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,CopyBranchStackSize,The following switch statement is missing a default case: switch (instruction.opcode.OperandType) {  case OperandType.ShortInlineBrTarget:  case OperandType.InlineBrTarget:  	CopyBranchStackSize (ref stack_sizes' (Instruction)instruction.operand' stack_size);  	break;  case OperandType.InlineSwitch:  	var targets = (Instruction[])instruction.operand;  	for (int i = 0; i < targets.Length; i++)  		CopyBranchStackSize (ref stack_sizes' targets [i]' stack_size);  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeStackSize,The following switch statement is missing a default case: switch (instruction.opcode.FlowControl) {  case FlowControl.Branch:  case FlowControl.Break:  case FlowControl.Throw:  case FlowControl.Return:  	stack_size = 0;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following switch statement is missing a default case: switch (pop_behavior) {  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	stack_size--;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	stack_size -= 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	stack_size -= 3;  	break;  case StackBehaviour.PopAll:  	stack_size = 0;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,The following switch statement is missing a default case: switch (push_behaviour) {  case StackBehaviour.Push1:  case StackBehaviour.Pushi:  case StackBehaviour.Pushi8:  case StackBehaviour.Pushr4:  case StackBehaviour.Pushr8:  case StackBehaviour.Pushref:  	stack_size++;  	break;  case StackBehaviour.Push1_push1:  	stack_size += 2;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,ResolveBranches,The following switch statement is missing a default case: switch (instruction.opcode.OperandType) {  case OperandType.ShortInlineBrTarget:  case OperandType.InlineBrTarget:  	instruction.operand = GetInstruction ((int)instruction.operand);  	break;  case OperandType.InlineSwitch:  	var offsets = (int[])instruction.operand;  	var branches = new Instruction[offsets.Length];  	for (int j = 0; j < offsets.Length; j++)  		branches [j] = GetInstruction (offsets [j]);  	instruction.operand = branches;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following switch statement is missing a default case: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Missing Default,Mono.Cecil,Mixin,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.Metadata\Utilities.cs,IsTypeSpecification,The following switch statement is missing a default case: switch (type.etype) {  case ElementType.Array:  case ElementType.ByRef:  case ElementType.CModOpt:  case ElementType.CModReqD:  case ElementType.FnPtr:  case ElementType.GenericInst:  case ElementType.MVar:  case ElementType.Pinned:  case ElementType.Ptr:  case ElementType.SzArray:  case ElementType.Sentinel:  case ElementType.Var:  	return true;  }  
Missing Default,Mono.Cecil,AssemblyNameReference,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following switch statement is missing a default case: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Missing Default,Mono.Cecil,MetadataReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyReader.cs,ReadExportedTypes,The following switch statement is missing a default case: switch (implementation.TokenType) {  case TokenType.AssemblyRef:  case TokenType.File:  	scope = GetExportedTypeScope (implementation);  	break;  case TokenType.ExportedType:  	// FIXME: if the table is not properly sorted  	declaring_type = exported_types [(int)implementation.RID - 1];  	break;  }  
Missing Default,Mono.Cecil,MetadataBuilder,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,GetExportedTypeScope,The following switch statement is missing a default case: switch (scope.MetadataToken.TokenType) {  case TokenType.AssemblyRef:  	return scope.MetadataToken;  case TokenType.ModuleRef:  	var file_table = GetTable<FileTable> (Table.File);  	for (int i = 0; i < file_table.length; i++)  		if (file_table.rows [i].Col2 == GetStringIndex (scope.Name))  			return new MetadataToken (TokenType.File' i + 1);  	break;  }  
Missing Default,Mono.Cecil,SignatureWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\AssemblyWriter.cs,WriteMarshalInfo,The following switch statement is missing a default case: switch (marshal_info.native) {  case NativeType.Array: {  	var array = (ArrayMarshalInfo)marshal_info;  	if (array.element_type != NativeType.None)  		WriteNativeType (array.element_type);  	if (array.size_parameter_index > -1)  		WriteCompressedUInt32 ((uint)array.size_parameter_index);  	if (array.size > -1)  		WriteCompressedUInt32 ((uint)array.size);  	if (array.size_parameter_multiplier > -1)  		WriteCompressedUInt32 ((uint)array.size_parameter_multiplier);  	return;  }  case NativeType.SafeArray: {  	var array = (SafeArrayMarshalInfo)marshal_info;  	if (array.element_type != VariantType.None)  		WriteVariantType (array.element_type);  	return;  }  case NativeType.FixedArray: {  	var array = (FixedArrayMarshalInfo)marshal_info;  	if (array.size > -1)  		WriteCompressedUInt32 ((uint)array.size);  	if (array.element_type != NativeType.None)  		WriteNativeType (array.element_type);  	return;  }  case NativeType.FixedSysString:  	var sys_string = (FixedSysStringMarshalInfo)marshal_info;  	if (sys_string.size > -1)  		WriteCompressedUInt32 ((uint)sys_string.size);  	return;  case NativeType.CustomMarshaler:  	var marshaler = (CustomMarshalInfo)marshal_info;  	WriteUTF8String (marshaler.guid != Guid.Empty ? marshaler.guid.ToString () : string.Empty);  	WriteUTF8String (marshaler.unmanaged_type);  	WriteTypeReference (marshaler.managed_type);  	WriteUTF8String (marshaler.cookie);  	return;  }  
Missing Default,Mono.Cecil,TypeParser,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\TypeParser.cs,GetScopeFullName,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  case MetadataScopeType.AssemblyNameReference:  	return ((AssemblyNameReference)scope).FullName;  case MetadataScopeType.ModuleDefinition:  	return ((ModuleDefinition)scope).Assembly.Name.FullName;  }  
Missing Default,Mono.Cecil,MetadataImporter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\Import.cs,ImportScope,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  case MetadataScopeType.AssemblyNameReference:  	return ImportAssemblyName ((AssemblyNameReference)scope);  case MetadataScopeType.ModuleDefinition:  	return ImportAssemblyName (((ModuleDefinition)scope).Assembly.Name);  case MetadataScopeType.ModuleReference:  	throw new NotImplementedException ();  }  
Missing Default,Mono.Cecil,MetadataImporter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\Import.cs,ImportTypeSpecification,The following switch statement is missing a default case: switch (type.etype) {  case ElementType.SzArray:  	var vector = (ArrayType)type;  	return new ArrayType (ImportType (vector.ElementType' context));  case ElementType.Ptr:  	var pointer = (PointerType)type;  	return new PointerType (ImportType (pointer.ElementType' context));  case ElementType.ByRef:  	var byref = (ByReferenceType)type;  	return new ByReferenceType (ImportType (byref.ElementType' context));  case ElementType.Pinned:  	var pinned = (PinnedType)type;  	return new PinnedType (ImportType (pinned.ElementType' context));  case ElementType.Sentinel:  	var sentinel = (SentinelType)type;  	return new SentinelType (ImportType (sentinel.ElementType' context));  case ElementType.CModOpt:  	var modopt = (OptionalModifierType)type;  	return new OptionalModifierType (ImportType (modopt.ModifierType' context)' ImportType (modopt.ElementType' context));  case ElementType.CModReqD:  	var modreq = (RequiredModifierType)type;  	return new RequiredModifierType (ImportType (modreq.ModifierType' context)' ImportType (modreq.ElementType' context));  case ElementType.Array:  	var array = (ArrayType)type;  	var imported_array = new ArrayType (ImportType (array.ElementType' context));  	if (array.IsVector)  		return imported_array;  	var dimensions = array.Dimensions;  	var imported_dimensions = imported_array.Dimensions;  	imported_dimensions.Clear ();  	for (int i = 0; i < dimensions.Count; i++) {  		var dimension = dimensions [i];  		imported_dimensions.Add (new ArrayDimension (dimension.LowerBound' dimension.UpperBound));  	}  	return imported_array;  case ElementType.GenericInst:  	var instance = (GenericInstanceType)type;  	var element_type = ImportType (instance.ElementType' context);  	var imported_instance = new GenericInstanceType (element_type);  	var arguments = instance.GenericArguments;  	var imported_arguments = imported_instance.GenericArguments;  	for (int i = 0; i < arguments.Count; i++)  		imported_arguments.Add (ImportType (arguments [i]' context));  	return imported_instance;  case ElementType.Var:  	var var_parameter = (GenericParameter)type;  	return context.TypeParameter (type.DeclaringType.FullName' var_parameter.Position);  case ElementType.MVar:  	var mvar_parameter = (GenericParameter)type;  	return context.MethodParameter (mvar_parameter.DeclaringMethod.Name' mvar_parameter.Position);  }  
Missing Default,Mono.Cecil,GenericParameter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\GenericParameter.cs,ConvertGenericParameterType,The following switch statement is missing a default case: switch (type) {  case GenericParameterType.Type:  	return ElementType.Var;  case GenericParameterType.Method:  	return ElementType.MVar;  }  
Missing Default,Mono.Cecil,MetadataResolver,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil\MetadataResolver.cs,Resolve,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  case MetadataScopeType.AssemblyNameReference:  	var assembly = assembly_resolver.Resolve ((AssemblyNameReference)scope);  	if (assembly == null)  		return null;  	return GetType (assembly.MainModule' type);  case MetadataScopeType.ModuleDefinition:  	return GetType ((ModuleDefinition)scope' type);  case MetadataScopeType.ModuleReference:  	var modules = type.Module.Assembly.Modules;  	var module_ref = (ModuleReference)scope;  	for (int i = 0; i < modules.Count; i++) {  		var netmodule = modules [i];  		if (netmodule.Name == module_ref.Name)  			return GetType (netmodule' type);  	}  	break;  }  
Missing Default,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadArchitecture,The following switch statement is missing a default case: switch (machine) {  case 0x014c:  	return TargetArchitecture.I386;  case 0x8664:  	return TargetArchitecture.AMD64;  case 0x0200:  	return TargetArchitecture.IA64;  case 0x01c4:  	return TargetArchitecture.ARMv7;  }  
Missing Default,Mono.Cecil.PE,ImageReader,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadataStream,The following switch statement is missing a default case: switch (name) {  case "#~":  case "#-":  	image.TableHeap = new TableHeap (section' start' size);  	break;  case "#Strings":  	image.StringHeap = new StringHeap (section' start' size);  	break;  case "#Blob":  	image.BlobHeap = new BlobHeap (section' start' size);  	break;  case "#GUID":  	image.GuidHeap = new GuidHeap (section' start' size);  	break;  case "#US":  	image.UserStringHeap = new UserStringHeap (section' start' size);  	break;  }  
Missing Default,Mono.Cecil.PE,ImageWriter,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Cecil.PE\ImageWriter.cs,GetMachine,The following switch statement is missing a default case: switch (module.Architecture) {  case TargetArchitecture.I386:  	return 0x014c;  case TargetArchitecture.AMD64:  	return 0x8664;  case TargetArchitecture.IA64:  	return 0x0200;  case TargetArchitecture.ARMv7:  	return 0x01c4;  }  
Missing Default,Mono.Security.Cryptography,CryptoConvert,D:\newReposJune17\sucaba_IronTextLibrary\Deps\cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following switch statement is missing a default case: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
